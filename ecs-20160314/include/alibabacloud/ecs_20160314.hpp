// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ECS20160314_H_
#define ALIBABACLOUD_ECS20160314_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ecs20160314 {
class AddMigratableInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessMigrationType{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<long> networkMigrationType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  AddMigratableInstancesRequest() {}

  explicit AddMigratableInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessMigrationType) {
      res["BusinessMigrationType"] = boost::any(*businessMigrationType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkMigrationType) {
      res["NetworkMigrationType"] = boost::any(*networkMigrationType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessMigrationType") != m.end() && !m["BusinessMigrationType"].empty()) {
      businessMigrationType = make_shared<long>(boost::any_cast<long>(m["BusinessMigrationType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkMigrationType") != m.end() && !m["NetworkMigrationType"].empty()) {
      networkMigrationType = make_shared<long>(boost::any_cast<long>(m["NetworkMigrationType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AddMigratableInstancesRequest() = default;
};
class AddMigratableInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddMigratableInstancesResponseBody() {}

  explicit AddMigratableInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMigratableInstancesResponseBody() = default;
};
class AddMigratableInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMigratableInstancesResponseBody> body{};

  AddMigratableInstancesResponse() {}

  explicit AddMigratableInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMigratableInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMigratableInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~AddMigratableInstancesResponse() = default;
};
class AllocateDedicatedHostsRequestNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<long> slbUdpTimeout{};
  shared_ptr<long> udpTimeout{};

  AllocateDedicatedHostsRequestNetworkAttributes() {}

  explicit AllocateDedicatedHostsRequestNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbUdpTimeout) {
      res["SlbUdpTimeout"] = boost::any(*slbUdpTimeout);
    }
    if (udpTimeout) {
      res["UdpTimeout"] = boost::any(*udpTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbUdpTimeout") != m.end() && !m["SlbUdpTimeout"].empty()) {
      slbUdpTimeout = make_shared<long>(boost::any_cast<long>(m["SlbUdpTimeout"]));
    }
    if (m.find("UdpTimeout") != m.end() && !m["UdpTimeout"].empty()) {
      udpTimeout = make_shared<long>(boost::any_cast<long>(m["UdpTimeout"]));
    }
  }


  virtual ~AllocateDedicatedHostsRequestNetworkAttributes() = default;
};
class AllocateDedicatedHostsRequestSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> managedPrivateSpaceId{};

  AllocateDedicatedHostsRequestSchedulerOptions() {}

  explicit AllocateDedicatedHostsRequestSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedPrivateSpaceId) {
      res["ManagedPrivateSpaceId"] = boost::any(*managedPrivateSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedPrivateSpaceId") != m.end() && !m["ManagedPrivateSpaceId"].empty()) {
      managedPrivateSpaceId = make_shared<string>(boost::any_cast<string>(m["ManagedPrivateSpaceId"]));
    }
  }


  virtual ~AllocateDedicatedHostsRequestSchedulerOptions() = default;
};
class AllocateDedicatedHostsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AllocateDedicatedHostsRequestTag() {}

  explicit AllocateDedicatedHostsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AllocateDedicatedHostsRequestTag() = default;
};
class AllocateDedicatedHostsRequest : public Darabonba::Model {
public:
  shared_ptr<AllocateDedicatedHostsRequestNetworkAttributes> networkAttributes{};
  shared_ptr<AllocateDedicatedHostsRequestSchedulerOptions> schedulerOptions{};
  shared_ptr<string> actionOnMaintenance{};
  shared_ptr<string> autoPlacement{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> businessInfo{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<double> cpuOverCommitRatio{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> description{};
  shared_ptr<string> fromApp{};
  shared_ptr<long> minQuantity{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> quantity{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<AllocateDedicatedHostsRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  AllocateDedicatedHostsRequest() {}

  explicit AllocateDedicatedHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = boost::any(*actionOnMaintenance);
    }
    if (autoPlacement) {
      res["AutoPlacement"] = boost::any(*autoPlacement);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (cpuOverCommitRatio) {
      res["CpuOverCommitRatio"] = boost::any(*cpuOverCommitRatio);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (minQuantity) {
      res["MinQuantity"] = boost::any(*minQuantity);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        AllocateDedicatedHostsRequestNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<AllocateDedicatedHostsRequestNetworkAttributes>(model1);
      }
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        AllocateDedicatedHostsRequestSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<AllocateDedicatedHostsRequestSchedulerOptions>(model1);
      }
    }
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      actionOnMaintenance = make_shared<string>(boost::any_cast<string>(m["ActionOnMaintenance"]));
    }
    if (m.find("AutoPlacement") != m.end() && !m["AutoPlacement"].empty()) {
      autoPlacement = make_shared<string>(boost::any_cast<string>(m["AutoPlacement"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CpuOverCommitRatio") != m.end() && !m["CpuOverCommitRatio"].empty()) {
      cpuOverCommitRatio = make_shared<double>(boost::any_cast<double>(m["CpuOverCommitRatio"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("MinQuantity") != m.end() && !m["MinQuantity"].empty()) {
      minQuantity = make_shared<long>(boost::any_cast<long>(m["MinQuantity"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AllocateDedicatedHostsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AllocateDedicatedHostsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AllocateDedicatedHostsRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~AllocateDedicatedHostsRequest() = default;
};
class AllocateDedicatedHostsResponseBodyDedicatedHostIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dedicatedHostId{};

  AllocateDedicatedHostsResponseBodyDedicatedHostIdSets() {}

  explicit AllocateDedicatedHostsResponseBodyDedicatedHostIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DedicatedHostId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DedicatedHostId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dedicatedHostId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AllocateDedicatedHostsResponseBodyDedicatedHostIdSets() = default;
};
class AllocateDedicatedHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<AllocateDedicatedHostsResponseBodyDedicatedHostIdSets> dedicatedHostIdSets{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  AllocateDedicatedHostsResponseBody() {}

  explicit AllocateDedicatedHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostIdSets) {
      res["DedicatedHostIdSets"] = dedicatedHostIdSets ? boost::any(dedicatedHostIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostIdSets") != m.end() && !m["DedicatedHostIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostIdSets"].type()) {
        AllocateDedicatedHostsResponseBodyDedicatedHostIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostIdSets"]));
        dedicatedHostIdSets = make_shared<AllocateDedicatedHostsResponseBodyDedicatedHostIdSets>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AllocateDedicatedHostsResponseBody() = default;
};
class AllocateDedicatedHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllocateDedicatedHostsResponseBody> body{};

  AllocateDedicatedHostsResponse() {}

  explicit AllocateDedicatedHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateDedicatedHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateDedicatedHostsResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateDedicatedHostsResponse() = default;
};
class CancelMigrationInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> networkMigrationType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CancelMigrationInstancesRequest() {}

  explicit CancelMigrationInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkMigrationType) {
      res["NetworkMigrationType"] = boost::any(*networkMigrationType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkMigrationType") != m.end() && !m["NetworkMigrationType"].empty()) {
      networkMigrationType = make_shared<string>(boost::any_cast<string>(m["NetworkMigrationType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CancelMigrationInstancesRequest() = default;
};
class CancelMigrationInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelMigrationInstancesResponseBody() {}

  explicit CancelMigrationInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelMigrationInstancesResponseBody() = default;
};
class CancelMigrationInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelMigrationInstancesResponseBody> body{};

  CancelMigrationInstancesResponse() {}

  explicit CancelMigrationInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelMigrationInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelMigrationInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~CancelMigrationInstancesResponse() = default;
};
class CancelMigrationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> migrationPlanId{};
  shared_ptr<bool> onlyCancelPlan{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CancelMigrationPlanRequest() {}

  explicit CancelMigrationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationPlanId) {
      res["MigrationPlanId"] = boost::any(*migrationPlanId);
    }
    if (onlyCancelPlan) {
      res["OnlyCancelPlan"] = boost::any(*onlyCancelPlan);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationPlanId") != m.end() && !m["MigrationPlanId"].empty()) {
      migrationPlanId = make_shared<string>(boost::any_cast<string>(m["MigrationPlanId"]));
    }
    if (m.find("OnlyCancelPlan") != m.end() && !m["OnlyCancelPlan"].empty()) {
      onlyCancelPlan = make_shared<bool>(boost::any_cast<bool>(m["OnlyCancelPlan"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CancelMigrationPlanRequest() = default;
};
class CancelMigrationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelMigrationPlanResponseBody() {}

  explicit CancelMigrationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelMigrationPlanResponseBody() = default;
};
class CancelMigrationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelMigrationPlanResponseBody> body{};

  CancelMigrationPlanResponse() {}

  explicit CancelMigrationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelMigrationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelMigrationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~CancelMigrationPlanResponse() = default;
};
class ConfigureSecurityGroupPermissionsRequestAuthorizePermission : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> destGroupId{};
  shared_ptr<string> destPrefixListId{};
  shared_ptr<string> direction{};
  shared_ptr<string> gressFlow{};
  shared_ptr<string> groupOwnerAccount{};
  shared_ptr<long> groupOwnerId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> nicType{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourceGroupId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> sourcePrefixListId{};

  ConfigureSecurityGroupPermissionsRequestAuthorizePermission() {}

  explicit ConfigureSecurityGroupPermissionsRequestAuthorizePermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (destGroupId) {
      res["DestGroupId"] = boost::any(*destGroupId);
    }
    if (destPrefixListId) {
      res["DestPrefixListId"] = boost::any(*destPrefixListId);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (gressFlow) {
      res["GressFlow"] = boost::any(*gressFlow);
    }
    if (groupOwnerAccount) {
      res["GroupOwnerAccount"] = boost::any(*groupOwnerAccount);
    }
    if (groupOwnerId) {
      res["GroupOwnerId"] = boost::any(*groupOwnerId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourceGroupId) {
      res["SourceGroupId"] = boost::any(*sourceGroupId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (sourcePrefixListId) {
      res["SourcePrefixListId"] = boost::any(*sourcePrefixListId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("DestGroupId") != m.end() && !m["DestGroupId"].empty()) {
      destGroupId = make_shared<string>(boost::any_cast<string>(m["DestGroupId"]));
    }
    if (m.find("DestPrefixListId") != m.end() && !m["DestPrefixListId"].empty()) {
      destPrefixListId = make_shared<string>(boost::any_cast<string>(m["DestPrefixListId"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("GressFlow") != m.end() && !m["GressFlow"].empty()) {
      gressFlow = make_shared<string>(boost::any_cast<string>(m["GressFlow"]));
    }
    if (m.find("GroupOwnerAccount") != m.end() && !m["GroupOwnerAccount"].empty()) {
      groupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["GroupOwnerAccount"]));
    }
    if (m.find("GroupOwnerId") != m.end() && !m["GroupOwnerId"].empty()) {
      groupOwnerId = make_shared<long>(boost::any_cast<long>(m["GroupOwnerId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourceGroupId") != m.end() && !m["SourceGroupId"].empty()) {
      sourceGroupId = make_shared<string>(boost::any_cast<string>(m["SourceGroupId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("SourcePrefixListId") != m.end() && !m["SourcePrefixListId"].empty()) {
      sourcePrefixListId = make_shared<string>(boost::any_cast<string>(m["SourcePrefixListId"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsRequestAuthorizePermission() = default;
};
class ConfigureSecurityGroupPermissionsRequestRevokePermission : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> destGroupId{};
  shared_ptr<string> destPrefixListId{};
  shared_ptr<string> direction{};
  shared_ptr<string> gressFlow{};
  shared_ptr<string> groupOwnerAccount{};
  shared_ptr<long> groupOwnerId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> nicType{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourceGroupId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> sourcePrefixListId{};

  ConfigureSecurityGroupPermissionsRequestRevokePermission() {}

  explicit ConfigureSecurityGroupPermissionsRequestRevokePermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (destGroupId) {
      res["DestGroupId"] = boost::any(*destGroupId);
    }
    if (destPrefixListId) {
      res["DestPrefixListId"] = boost::any(*destPrefixListId);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (gressFlow) {
      res["GressFlow"] = boost::any(*gressFlow);
    }
    if (groupOwnerAccount) {
      res["GroupOwnerAccount"] = boost::any(*groupOwnerAccount);
    }
    if (groupOwnerId) {
      res["GroupOwnerId"] = boost::any(*groupOwnerId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourceGroupId) {
      res["SourceGroupId"] = boost::any(*sourceGroupId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (sourcePrefixListId) {
      res["SourcePrefixListId"] = boost::any(*sourcePrefixListId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("DestGroupId") != m.end() && !m["DestGroupId"].empty()) {
      destGroupId = make_shared<string>(boost::any_cast<string>(m["DestGroupId"]));
    }
    if (m.find("DestPrefixListId") != m.end() && !m["DestPrefixListId"].empty()) {
      destPrefixListId = make_shared<string>(boost::any_cast<string>(m["DestPrefixListId"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("GressFlow") != m.end() && !m["GressFlow"].empty()) {
      gressFlow = make_shared<string>(boost::any_cast<string>(m["GressFlow"]));
    }
    if (m.find("GroupOwnerAccount") != m.end() && !m["GroupOwnerAccount"].empty()) {
      groupOwnerAccount = make_shared<string>(boost::any_cast<string>(m["GroupOwnerAccount"]));
    }
    if (m.find("GroupOwnerId") != m.end() && !m["GroupOwnerId"].empty()) {
      groupOwnerId = make_shared<long>(boost::any_cast<long>(m["GroupOwnerId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourceGroupId") != m.end() && !m["SourceGroupId"].empty()) {
      sourceGroupId = make_shared<string>(boost::any_cast<string>(m["SourceGroupId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("SourcePrefixListId") != m.end() && !m["SourcePrefixListId"].empty()) {
      sourcePrefixListId = make_shared<string>(boost::any_cast<string>(m["SourcePrefixListId"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsRequestRevokePermission() = default;
};
class ConfigureSecurityGroupPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ConfigureSecurityGroupPermissionsRequestAuthorizePermission>> authorizePermission{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ConfigureSecurityGroupPermissionsRequestRevokePermission>> revokePermission{};
  shared_ptr<string> securityGroupId{};

  ConfigureSecurityGroupPermissionsRequest() {}

  explicit ConfigureSecurityGroupPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizePermission) {
      vector<boost::any> temp1;
      for(auto item1:*authorizePermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizePermission"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (revokePermission) {
      vector<boost::any> temp1;
      for(auto item1:*revokePermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RevokePermission"] = boost::any(temp1);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizePermission") != m.end() && !m["AuthorizePermission"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizePermission"].type()) {
        vector<ConfigureSecurityGroupPermissionsRequestAuthorizePermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizePermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ConfigureSecurityGroupPermissionsRequestAuthorizePermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizePermission = make_shared<vector<ConfigureSecurityGroupPermissionsRequestAuthorizePermission>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RevokePermission") != m.end() && !m["RevokePermission"].empty()) {
      if (typeid(vector<boost::any>) == m["RevokePermission"].type()) {
        vector<ConfigureSecurityGroupPermissionsRequestRevokePermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RevokePermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ConfigureSecurityGroupPermissionsRequestRevokePermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        revokePermission = make_shared<vector<ConfigureSecurityGroupPermissionsRequestRevokePermission>>(expect1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsRequest() = default;
};
class ConfigureSecurityGroupPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigureSecurityGroupPermissionsResponseBody() {}

  explicit ConfigureSecurityGroupPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsResponseBody() = default;
};
class ConfigureSecurityGroupPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureSecurityGroupPermissionsResponseBody> body{};

  ConfigureSecurityGroupPermissionsResponse() {}

  explicit ConfigureSecurityGroupPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureSecurityGroupPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureSecurityGroupPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsResponse() = default;
};
class ConfirmReservationDemandRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ConfirmReservationDemandRequestTag() {}

  explicit ConfirmReservationDemandRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ConfirmReservationDemandRequestTag() = default;
};
class ConfirmReservationDemandRequest : public Darabonba::Model {
public:
  shared_ptr<string> demandId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ConfirmReservationDemandRequestTag>> tag{};

  ConfirmReservationDemandRequest() {}

  explicit ConfirmReservationDemandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ConfirmReservationDemandRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ConfirmReservationDemandRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ConfirmReservationDemandRequestTag>>(expect1);
      }
    }
  }


  virtual ~ConfirmReservationDemandRequest() = default;
};
class ConfirmReservationDemandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfirmReservationDemandResponseBody() {}

  explicit ConfirmReservationDemandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfirmReservationDemandResponseBody() = default;
};
class ConfirmReservationDemandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmReservationDemandResponseBody> body{};

  ConfirmReservationDemandResponse() {}

  explicit ConfirmReservationDemandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmReservationDemandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmReservationDemandResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmReservationDemandResponse() = default;
};
class CreateCapacityReservationRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateCapacityReservationRequestTag() {}

  explicit CreateCapacityReservationRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateCapacityReservationRequestTag() = default;
};
class CreateCapacityReservationRequest : public Darabonba::Model {
public:
  shared_ptr<string> capacityReservationName{};
  shared_ptr<string> description{};
  shared_ptr<string> endDateType{};
  shared_ptr<string> instanceCount{};
  shared_ptr<string> instanceMatchCriteria{};
  shared_ptr<string> instancePlatform{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateCapacityReservationRequestTag>> tag{};
  shared_ptr<string> timeSlot{};
  shared_ptr<string> zoneId{};

  CreateCapacityReservationRequest() {}

  explicit CreateCapacityReservationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservationName) {
      res["CapacityReservationName"] = boost::any(*capacityReservationName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endDateType) {
      res["EndDateType"] = boost::any(*endDateType);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceMatchCriteria) {
      res["InstanceMatchCriteria"] = boost::any(*instanceMatchCriteria);
    }
    if (instancePlatform) {
      res["InstancePlatform"] = boost::any(*instancePlatform);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (timeSlot) {
      res["TimeSlot"] = boost::any(*timeSlot);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservationName") != m.end() && !m["CapacityReservationName"].empty()) {
      capacityReservationName = make_shared<string>(boost::any_cast<string>(m["CapacityReservationName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndDateType") != m.end() && !m["EndDateType"].empty()) {
      endDateType = make_shared<string>(boost::any_cast<string>(m["EndDateType"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("InstanceMatchCriteria") != m.end() && !m["InstanceMatchCriteria"].empty()) {
      instanceMatchCriteria = make_shared<string>(boost::any_cast<string>(m["InstanceMatchCriteria"]));
    }
    if (m.find("InstancePlatform") != m.end() && !m["InstancePlatform"].empty()) {
      instancePlatform = make_shared<string>(boost::any_cast<string>(m["InstancePlatform"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateCapacityReservationRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCapacityReservationRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateCapacityReservationRequestTag>>(expect1);
      }
    }
    if (m.find("TimeSlot") != m.end() && !m["TimeSlot"].empty()) {
      timeSlot = make_shared<string>(boost::any_cast<string>(m["TimeSlot"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateCapacityReservationRequest() = default;
};
class CreateCapacityReservationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> capacityReservationId{};
  shared_ptr<string> requestId{};

  CreateCapacityReservationResponseBody() {}

  explicit CreateCapacityReservationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservationId) {
      res["CapacityReservationId"] = boost::any(*capacityReservationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservationId") != m.end() && !m["CapacityReservationId"].empty()) {
      capacityReservationId = make_shared<string>(boost::any_cast<string>(m["CapacityReservationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCapacityReservationResponseBody() = default;
};
class CreateCapacityReservationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCapacityReservationResponseBody> body{};

  CreateCapacityReservationResponse() {}

  explicit CreateCapacityReservationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCapacityReservationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCapacityReservationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCapacityReservationResponse() = default;
};
class CreateDedicatedBlockStorageClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> capacity{};
  shared_ptr<string> category{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> dedicatedBlockStorageClusterName{};
  shared_ptr<string> description{};
  shared_ptr<string> fromApp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> type{};
  shared_ptr<string> zoneId{};

  CreateDedicatedBlockStorageClusterRequest() {}

  explicit CreateDedicatedBlockStorageClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dedicatedBlockStorageClusterName) {
      res["DedicatedBlockStorageClusterName"] = boost::any(*dedicatedBlockStorageClusterName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DedicatedBlockStorageClusterName") != m.end() && !m["DedicatedBlockStorageClusterName"].empty()) {
      dedicatedBlockStorageClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateDedicatedBlockStorageClusterRequest() = default;
};
class CreateDedicatedBlockStorageClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedBlockStorageClusterId{};
  shared_ptr<string> dedicatedBlockStorageClusterOrderId{};
  shared_ptr<string> requestId{};

  CreateDedicatedBlockStorageClusterResponseBody() {}

  explicit CreateDedicatedBlockStorageClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedBlockStorageClusterId) {
      res["DedicatedBlockStorageClusterId"] = boost::any(*dedicatedBlockStorageClusterId);
    }
    if (dedicatedBlockStorageClusterOrderId) {
      res["DedicatedBlockStorageClusterOrderId"] = boost::any(*dedicatedBlockStorageClusterOrderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedBlockStorageClusterId") != m.end() && !m["DedicatedBlockStorageClusterId"].empty()) {
      dedicatedBlockStorageClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterId"]));
    }
    if (m.find("DedicatedBlockStorageClusterOrderId") != m.end() && !m["DedicatedBlockStorageClusterOrderId"].empty()) {
      dedicatedBlockStorageClusterOrderId = make_shared<string>(boost::any_cast<string>(m["DedicatedBlockStorageClusterOrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDedicatedBlockStorageClusterResponseBody() = default;
};
class CreateDedicatedBlockStorageClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDedicatedBlockStorageClusterResponseBody> body{};

  CreateDedicatedBlockStorageClusterResponse() {}

  explicit CreateDedicatedBlockStorageClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedBlockStorageClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedBlockStorageClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedBlockStorageClusterResponse() = default;
};
class CreateDedicatedHostClusterRequestSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> managedPrivateSpaceId{};

  CreateDedicatedHostClusterRequestSchedulerOptions() {}

  explicit CreateDedicatedHostClusterRequestSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedPrivateSpaceId) {
      res["ManagedPrivateSpaceId"] = boost::any(*managedPrivateSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedPrivateSpaceId") != m.end() && !m["ManagedPrivateSpaceId"].empty()) {
      managedPrivateSpaceId = make_shared<string>(boost::any_cast<string>(m["ManagedPrivateSpaceId"]));
    }
  }


  virtual ~CreateDedicatedHostClusterRequestSchedulerOptions() = default;
};
class CreateDedicatedHostClusterRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDedicatedHostClusterRequestTag() {}

  explicit CreateDedicatedHostClusterRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDedicatedHostClusterRequestTag() = default;
};
class CreateDedicatedHostClusterRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDedicatedHostClusterRequestSchedulerOptions> schedulerOptions{};
  shared_ptr<string> dedicatedHostClusterName{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateDedicatedHostClusterRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  CreateDedicatedHostClusterRequest() {}

  explicit CreateDedicatedHostClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostClusterName) {
      res["DedicatedHostClusterName"] = boost::any(*dedicatedHostClusterName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        CreateDedicatedHostClusterRequestSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<CreateDedicatedHostClusterRequestSchedulerOptions>(model1);
      }
    }
    if (m.find("DedicatedHostClusterName") != m.end() && !m["DedicatedHostClusterName"].empty()) {
      dedicatedHostClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDedicatedHostClusterRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDedicatedHostClusterRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDedicatedHostClusterRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateDedicatedHostClusterRequest() = default;
};
class CreateDedicatedHostClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> requestId{};

  CreateDedicatedHostClusterResponseBody() {}

  explicit CreateDedicatedHostClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDedicatedHostClusterResponseBody() = default;
};
class CreateDedicatedHostClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDedicatedHostClusterResponseBody> body{};

  CreateDedicatedHostClusterResponse() {}

  explicit CreateDedicatedHostClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedHostClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedHostClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedHostClusterResponse() = default;
};
class CreateDefaultAutoSnapshotPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateDefaultAutoSnapshotPolicyRequest() {}

  explicit CreateDefaultAutoSnapshotPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateDefaultAutoSnapshotPolicyRequest() = default;
};
class CreateDefaultAutoSnapshotPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> autoSnapshotPolicyName{};
  shared_ptr<string> repeatWeekdays{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retentionDays{};
  shared_ptr<string> timePoints{};

  CreateDefaultAutoSnapshotPolicyResponseBody() {}

  explicit CreateDefaultAutoSnapshotPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (autoSnapshotPolicyName) {
      res["AutoSnapshotPolicyName"] = boost::any(*autoSnapshotPolicyName);
    }
    if (repeatWeekdays) {
      res["RepeatWeekdays"] = boost::any(*repeatWeekdays);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retentionDays) {
      res["RetentionDays"] = boost::any(*retentionDays);
    }
    if (timePoints) {
      res["TimePoints"] = boost::any(*timePoints);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("AutoSnapshotPolicyName") != m.end() && !m["AutoSnapshotPolicyName"].empty()) {
      autoSnapshotPolicyName = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyName"]));
    }
    if (m.find("RepeatWeekdays") != m.end() && !m["RepeatWeekdays"].empty()) {
      repeatWeekdays = make_shared<string>(boost::any_cast<string>(m["RepeatWeekdays"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetentionDays") != m.end() && !m["RetentionDays"].empty()) {
      retentionDays = make_shared<long>(boost::any_cast<long>(m["RetentionDays"]));
    }
    if (m.find("TimePoints") != m.end() && !m["TimePoints"].empty()) {
      timePoints = make_shared<string>(boost::any_cast<string>(m["TimePoints"]));
    }
  }


  virtual ~CreateDefaultAutoSnapshotPolicyResponseBody() = default;
};
class CreateDefaultAutoSnapshotPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDefaultAutoSnapshotPolicyResponseBody> body{};

  CreateDefaultAutoSnapshotPolicyResponse() {}

  explicit CreateDefaultAutoSnapshotPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDefaultAutoSnapshotPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDefaultAutoSnapshotPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDefaultAutoSnapshotPolicyResponse() = default;
};
class CreateDiagnoseRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDiagnoseRequestTag() {}

  explicit CreateDiagnoseRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDiagnoseRequestTag() = default;
};
class CreateDiagnoseRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> diagnoseAction{};
  shared_ptr<string> diagnoseErrorCode{};
  shared_ptr<string> diagnoseProduct{};
  shared_ptr<string> diagnoseRequestId{};
  shared_ptr<string> diagnoseRequestParams{};
  shared_ptr<string> diagnoseResponse{};
  shared_ptr<string> diskCategory{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceTypeName{};
  shared_ptr<string> izNo{};
  shared_ptr<string> mark{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateDiagnoseRequestTag>> tag{};
  shared_ptr<long> type{};

  CreateDiagnoseRequest() {}

  explicit CreateDiagnoseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (diagnoseAction) {
      res["DiagnoseAction"] = boost::any(*diagnoseAction);
    }
    if (diagnoseErrorCode) {
      res["DiagnoseErrorCode"] = boost::any(*diagnoseErrorCode);
    }
    if (diagnoseProduct) {
      res["DiagnoseProduct"] = boost::any(*diagnoseProduct);
    }
    if (diagnoseRequestId) {
      res["DiagnoseRequestId"] = boost::any(*diagnoseRequestId);
    }
    if (diagnoseRequestParams) {
      res["DiagnoseRequestParams"] = boost::any(*diagnoseRequestParams);
    }
    if (diagnoseResponse) {
      res["DiagnoseResponse"] = boost::any(*diagnoseResponse);
    }
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceTypeName) {
      res["InstanceTypeName"] = boost::any(*instanceTypeName);
    }
    if (izNo) {
      res["IzNo"] = boost::any(*izNo);
    }
    if (mark) {
      res["Mark"] = boost::any(*mark);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("DiagnoseAction") != m.end() && !m["DiagnoseAction"].empty()) {
      diagnoseAction = make_shared<string>(boost::any_cast<string>(m["DiagnoseAction"]));
    }
    if (m.find("DiagnoseErrorCode") != m.end() && !m["DiagnoseErrorCode"].empty()) {
      diagnoseErrorCode = make_shared<string>(boost::any_cast<string>(m["DiagnoseErrorCode"]));
    }
    if (m.find("DiagnoseProduct") != m.end() && !m["DiagnoseProduct"].empty()) {
      diagnoseProduct = make_shared<string>(boost::any_cast<string>(m["DiagnoseProduct"]));
    }
    if (m.find("DiagnoseRequestId") != m.end() && !m["DiagnoseRequestId"].empty()) {
      diagnoseRequestId = make_shared<string>(boost::any_cast<string>(m["DiagnoseRequestId"]));
    }
    if (m.find("DiagnoseRequestParams") != m.end() && !m["DiagnoseRequestParams"].empty()) {
      diagnoseRequestParams = make_shared<string>(boost::any_cast<string>(m["DiagnoseRequestParams"]));
    }
    if (m.find("DiagnoseResponse") != m.end() && !m["DiagnoseResponse"].empty()) {
      diagnoseResponse = make_shared<string>(boost::any_cast<string>(m["DiagnoseResponse"]));
    }
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceTypeName") != m.end() && !m["InstanceTypeName"].empty()) {
      instanceTypeName = make_shared<string>(boost::any_cast<string>(m["InstanceTypeName"]));
    }
    if (m.find("IzNo") != m.end() && !m["IzNo"].empty()) {
      izNo = make_shared<string>(boost::any_cast<string>(m["IzNo"]));
    }
    if (m.find("Mark") != m.end() && !m["Mark"].empty()) {
      mark = make_shared<string>(boost::any_cast<string>(m["Mark"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDiagnoseRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDiagnoseRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDiagnoseRequestTag>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateDiagnoseRequest() = default;
};
class CreateDiagnoseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> diagnoseId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  CreateDiagnoseResponseBody() {}

  explicit CreateDiagnoseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateDiagnoseResponseBody() = default;
};
class CreateDiagnoseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDiagnoseResponseBody> body{};

  CreateDiagnoseResponse() {}

  explicit CreateDiagnoseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiagnoseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiagnoseResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiagnoseResponse() = default;
};
class CreateDiagnosisOperateRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> newInstanceType{};
  shared_ptr<string> newZoneId{};
  shared_ptr<string> operateRecordType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  CreateDiagnosisOperateRecordsRequest() {}

  explicit CreateDiagnosisOperateRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (newInstanceType) {
      res["NewInstanceType"] = boost::any(*newInstanceType);
    }
    if (newZoneId) {
      res["NewZoneId"] = boost::any(*newZoneId);
    }
    if (operateRecordType) {
      res["OperateRecordType"] = boost::any(*operateRecordType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NewInstanceType") != m.end() && !m["NewInstanceType"].empty()) {
      newInstanceType = make_shared<string>(boost::any_cast<string>(m["NewInstanceType"]));
    }
    if (m.find("NewZoneId") != m.end() && !m["NewZoneId"].empty()) {
      newZoneId = make_shared<string>(boost::any_cast<string>(m["NewZoneId"]));
    }
    if (m.find("OperateRecordType") != m.end() && !m["OperateRecordType"].empty()) {
      operateRecordType = make_shared<string>(boost::any_cast<string>(m["OperateRecordType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateDiagnosisOperateRecordsRequest() = default;
};
class CreateDiagnosisOperateRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDiagnosisOperateRecordsResponseBody() {}

  explicit CreateDiagnosisOperateRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDiagnosisOperateRecordsResponseBody() = default;
};
class CreateDiagnosisOperateRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDiagnosisOperateRecordsResponseBody> body{};

  CreateDiagnosisOperateRecordsResponse() {}

  explicit CreateDiagnosisOperateRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiagnosisOperateRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiagnosisOperateRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiagnosisOperateRecordsResponse() = default;
};
class CreateDiagnosticReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> commandName{};
  shared_ptr<string> commandType{};
  shared_ptr<string> diagnosticCategory{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pluginVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> sourceSystem{};
  shared_ptr<string> startTime{};

  CreateDiagnosticReportRequest() {}

  explicit CreateDiagnosticReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (commandName) {
      res["CommandName"] = boost::any(*commandName);
    }
    if (commandType) {
      res["CommandType"] = boost::any(*commandType);
    }
    if (diagnosticCategory) {
      res["DiagnosticCategory"] = boost::any(*diagnosticCategory);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pluginVersion) {
      res["PluginVersion"] = boost::any(*pluginVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (sourceSystem) {
      res["SourceSystem"] = boost::any(*sourceSystem);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CommandName") != m.end() && !m["CommandName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CommandName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CommandName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commandName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CommandType") != m.end() && !m["CommandType"].empty()) {
      commandType = make_shared<string>(boost::any_cast<string>(m["CommandType"]));
    }
    if (m.find("DiagnosticCategory") != m.end() && !m["DiagnosticCategory"].empty()) {
      diagnosticCategory = make_shared<string>(boost::any_cast<string>(m["DiagnosticCategory"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PluginVersion") != m.end() && !m["PluginVersion"].empty()) {
      pluginVersion = make_shared<string>(boost::any_cast<string>(m["PluginVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SourceSystem") != m.end() && !m["SourceSystem"].empty()) {
      sourceSystem = make_shared<string>(boost::any_cast<string>(m["SourceSystem"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CreateDiagnosticReportRequest() = default;
};
class CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult : public Darabonba::Model {
public:
  shared_ptr<string> commandName{};
  shared_ptr<string> dataFileDir{};
  shared_ptr<string> invokeResult{};

  CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult() {}

  explicit CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandName) {
      res["CommandName"] = boost::any(*commandName);
    }
    if (dataFileDir) {
      res["DataFileDir"] = boost::any(*dataFileDir);
    }
    if (invokeResult) {
      res["InvokeResult"] = boost::any(*invokeResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandName") != m.end() && !m["CommandName"].empty()) {
      commandName = make_shared<string>(boost::any_cast<string>(m["CommandName"]));
    }
    if (m.find("DataFileDir") != m.end() && !m["DataFileDir"].empty()) {
      dataFileDir = make_shared<string>(boost::any_cast<string>(m["DataFileDir"]));
    }
    if (m.find("InvokeResult") != m.end() && !m["InvokeResult"].empty()) {
      invokeResult = make_shared<string>(boost::any_cast<string>(m["InvokeResult"]));
    }
  }


  virtual ~CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult() = default;
};
class CreateDiagnosticReportResponseBodyCommandInvokeResults : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult>> invokeResult{};

  CreateDiagnosticReportResponseBodyCommandInvokeResults() {}

  explicit CreateDiagnosticReportResponseBodyCommandInvokeResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invokeResult) {
      vector<boost::any> temp1;
      for(auto item1:*invokeResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvokeResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvokeResult") != m.end() && !m["InvokeResult"].empty()) {
      if (typeid(vector<boost::any>) == m["InvokeResult"].type()) {
        vector<CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvokeResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invokeResult = make_shared<vector<CreateDiagnosticReportResponseBodyCommandInvokeResultsInvokeResult>>(expect1);
      }
    }
  }


  virtual ~CreateDiagnosticReportResponseBodyCommandInvokeResults() = default;
};
class CreateDiagnosticReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateDiagnosticReportResponseBodyCommandInvokeResults> commandInvokeResults{};
  shared_ptr<string> createTime{};
  shared_ptr<string> reportId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  CreateDiagnosticReportResponseBody() {}

  explicit CreateDiagnosticReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandInvokeResults) {
      res["CommandInvokeResults"] = commandInvokeResults ? boost::any(commandInvokeResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandInvokeResults") != m.end() && !m["CommandInvokeResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommandInvokeResults"].type()) {
        CreateDiagnosticReportResponseBodyCommandInvokeResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommandInvokeResults"]));
        commandInvokeResults = make_shared<CreateDiagnosticReportResponseBodyCommandInvokeResults>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateDiagnosticReportResponseBody() = default;
};
class CreateDiagnosticReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDiagnosticReportResponseBody> body{};

  CreateDiagnosticReportResponse() {}

  explicit CreateDiagnosticReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiagnosticReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiagnosticReportResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiagnosticReportResponse() = default;
};
class CreateDisksRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDisksRequestTag() {}

  explicit CreateDisksRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDisksRequestTag() = default;
};
class CreateDisksRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<string> category{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> multiAttach{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> storageClusterId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<vector<CreateDisksRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  CreateDisksRequest() {}

  explicit CreateDisksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (multiAttach) {
      res["MultiAttach"] = boost::any(*multiAttach);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (storageClusterId) {
      res["StorageClusterId"] = boost::any(*storageClusterId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("MultiAttach") != m.end() && !m["MultiAttach"].empty()) {
      multiAttach = make_shared<string>(boost::any_cast<string>(m["MultiAttach"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("StorageClusterId") != m.end() && !m["StorageClusterId"].empty()) {
      storageClusterId = make_shared<string>(boost::any_cast<string>(m["StorageClusterId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDisksRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDisksRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDisksRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateDisksRequest() = default;
};
class CreateDisksResponseBodyDiskId : public Darabonba::Model {
public:
  shared_ptr<vector<string>> diskIds{};

  CreateDisksResponseBodyDiskId() {}

  explicit CreateDisksResponseBodyDiskId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDisksResponseBodyDiskId() = default;
};
class CreateDisksResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateDisksResponseBodyDiskId> diskId{};
  shared_ptr<string> requestId{};

  CreateDisksResponseBody() {}

  explicit CreateDisksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = diskId ? boost::any(diskId->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskId"].type()) {
        CreateDisksResponseBodyDiskId model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskId"]));
        diskId = make_shared<CreateDisksResponseBodyDiskId>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDisksResponseBody() = default;
};
class CreateDisksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDisksResponseBody> body{};

  CreateDisksResponse() {}

  explicit CreateDisksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDisksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDisksResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDisksResponse() = default;
};
class CreateElasticityAssuranceRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> name{};

  CreateElasticityAssuranceRequestPrivatePoolOptions() {}

  explicit CreateElasticityAssuranceRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateElasticityAssuranceRequestPrivatePoolOptions() = default;
};
class CreateElasticityAssuranceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateElasticityAssuranceRequestTag() {}

  explicit CreateElasticityAssuranceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateElasticityAssuranceRequestTag() = default;
};
class CreateElasticityAssuranceRequest : public Darabonba::Model {
public:
  shared_ptr<CreateElasticityAssuranceRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<string> assuranceTimes{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<long> instanceCpuCoreCount{};
  shared_ptr<vector<string>> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<CreateElasticityAssuranceRequestTag>> tag{};
  shared_ptr<vector<string>> zoneId{};

  CreateElasticityAssuranceRequest() {}

  explicit CreateElasticityAssuranceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (assuranceTimes) {
      res["AssuranceTimes"] = boost::any(*assuranceTimes);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceCpuCoreCount) {
      res["InstanceCpuCoreCount"] = boost::any(*instanceCpuCoreCount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        CreateElasticityAssuranceRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<CreateElasticityAssuranceRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("AssuranceTimes") != m.end() && !m["AssuranceTimes"].empty()) {
      assuranceTimes = make_shared<string>(boost::any_cast<string>(m["AssuranceTimes"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceCpuCoreCount") != m.end() && !m["InstanceCpuCoreCount"].empty()) {
      instanceCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["InstanceCpuCoreCount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateElasticityAssuranceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateElasticityAssuranceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateElasticityAssuranceRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateElasticityAssuranceRequest() = default;
};
class CreateElasticityAssuranceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> requestId{};

  CreateElasticityAssuranceResponseBody() {}

  explicit CreateElasticityAssuranceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateElasticityAssuranceResponseBody() = default;
};
class CreateElasticityAssuranceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateElasticityAssuranceResponseBody> body{};

  CreateElasticityAssuranceResponse() {}

  explicit CreateElasticityAssuranceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateElasticityAssuranceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateElasticityAssuranceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateElasticityAssuranceResponse() = default;
};
class CreateEniQosGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosGroupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> rx{};
  shared_ptr<long> rxPps{};
  shared_ptr<long> tx{};
  shared_ptr<long> txPps{};

  CreateEniQosGroupRequest() {}

  explicit CreateEniQosGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosGroupName) {
      res["QosGroupName"] = boost::any(*qosGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (rx) {
      res["Rx"] = boost::any(*rx);
    }
    if (rxPps) {
      res["RxPps"] = boost::any(*rxPps);
    }
    if (tx) {
      res["Tx"] = boost::any(*tx);
    }
    if (txPps) {
      res["TxPps"] = boost::any(*txPps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosGroupName") != m.end() && !m["QosGroupName"].empty()) {
      qosGroupName = make_shared<string>(boost::any_cast<string>(m["QosGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Rx") != m.end() && !m["Rx"].empty()) {
      rx = make_shared<long>(boost::any_cast<long>(m["Rx"]));
    }
    if (m.find("RxPps") != m.end() && !m["RxPps"].empty()) {
      rxPps = make_shared<long>(boost::any_cast<long>(m["RxPps"]));
    }
    if (m.find("Tx") != m.end() && !m["Tx"].empty()) {
      tx = make_shared<long>(boost::any_cast<long>(m["Tx"]));
    }
    if (m.find("TxPps") != m.end() && !m["TxPps"].empty()) {
      txPps = make_shared<long>(boost::any_cast<long>(m["TxPps"]));
    }
  }


  virtual ~CreateEniQosGroupRequest() = default;
};
class CreateEniQosGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> qosGroupName{};
  shared_ptr<string> requestId{};

  CreateEniQosGroupResponseBody() {}

  explicit CreateEniQosGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosGroupName) {
      res["QosGroupName"] = boost::any(*qosGroupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosGroupName") != m.end() && !m["QosGroupName"].empty()) {
      qosGroupName = make_shared<string>(boost::any_cast<string>(m["QosGroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEniQosGroupResponseBody() = default;
};
class CreateEniQosGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEniQosGroupResponseBody> body{};

  CreateEniQosGroupResponse() {}

  explicit CreateEniQosGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEniQosGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEniQosGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEniQosGroupResponse() = default;
};
class CreateFunctionFeedbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> feedback{};
  shared_ptr<string> functionName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> suggestion{};

  CreateFunctionFeedbackRequest() {}

  explicit CreateFunctionFeedbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~CreateFunctionFeedbackRequest() = default;
};
class CreateFunctionFeedbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateFunctionFeedbackResponseBody() {}

  explicit CreateFunctionFeedbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFunctionFeedbackResponseBody() = default;
};
class CreateFunctionFeedbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFunctionFeedbackResponseBody> body{};

  CreateFunctionFeedbackResponse() {}

  explicit CreateFunctionFeedbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFunctionFeedbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFunctionFeedbackResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFunctionFeedbackResponse() = default;
};
class CreateImageCacheRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> imageId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  CreateImageCacheRequest() {}

  explicit CreateImageCacheRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateImageCacheRequest() = default;
};
class CreateImageCacheResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateImageCacheResponseBody() {}

  explicit CreateImageCacheResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateImageCacheResponseBody() = default;
};
class CreateImageCacheResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateImageCacheResponseBody> body{};

  CreateImageCacheResponse() {}

  explicit CreateImageCacheResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageCacheResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageCacheResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageCacheResponse() = default;
};
class CreateIssueCategoryReportRelationRequestRelationModelList : public Darabonba::Model {
public:
  shared_ptr<string> customerInputContent{};
  shared_ptr<long> issueCategoryId{};
  shared_ptr<string> issueCategoryName{};
  shared_ptr<string> mappingTools{};
  shared_ptr<string> reportId{};

  CreateIssueCategoryReportRelationRequestRelationModelList() {}

  explicit CreateIssueCategoryReportRelationRequestRelationModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerInputContent) {
      res["CustomerInputContent"] = boost::any(*customerInputContent);
    }
    if (issueCategoryId) {
      res["IssueCategoryId"] = boost::any(*issueCategoryId);
    }
    if (issueCategoryName) {
      res["IssueCategoryName"] = boost::any(*issueCategoryName);
    }
    if (mappingTools) {
      res["MappingTools"] = boost::any(*mappingTools);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerInputContent") != m.end() && !m["CustomerInputContent"].empty()) {
      customerInputContent = make_shared<string>(boost::any_cast<string>(m["CustomerInputContent"]));
    }
    if (m.find("IssueCategoryId") != m.end() && !m["IssueCategoryId"].empty()) {
      issueCategoryId = make_shared<long>(boost::any_cast<long>(m["IssueCategoryId"]));
    }
    if (m.find("IssueCategoryName") != m.end() && !m["IssueCategoryName"].empty()) {
      issueCategoryName = make_shared<string>(boost::any_cast<string>(m["IssueCategoryName"]));
    }
    if (m.find("MappingTools") != m.end() && !m["MappingTools"].empty()) {
      mappingTools = make_shared<string>(boost::any_cast<string>(m["MappingTools"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
  }


  virtual ~CreateIssueCategoryReportRelationRequestRelationModelList() = default;
};
class CreateIssueCategoryReportRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateIssueCategoryReportRelationRequestRelationModelList>> relationModelList{};

  CreateIssueCategoryReportRelationRequest() {}

  explicit CreateIssueCategoryReportRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (relationModelList) {
      vector<boost::any> temp1;
      for(auto item1:*relationModelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelationModelList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RelationModelList") != m.end() && !m["RelationModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["RelationModelList"].type()) {
        vector<CreateIssueCategoryReportRelationRequestRelationModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelationModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIssueCategoryReportRelationRequestRelationModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relationModelList = make_shared<vector<CreateIssueCategoryReportRelationRequestRelationModelList>>(expect1);
      }
    }
  }


  virtual ~CreateIssueCategoryReportRelationRequest() = default;
};
class CreateIssueCategoryReportRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  CreateIssueCategoryReportRelationResponseBody() {}

  explicit CreateIssueCategoryReportRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateIssueCategoryReportRelationResponseBody() = default;
};
class CreateIssueCategoryReportRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIssueCategoryReportRelationResponseBody> body{};

  CreateIssueCategoryReportRelationResponse() {}

  explicit CreateIssueCategoryReportRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIssueCategoryReportRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIssueCategoryReportRelationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIssueCategoryReportRelationResponse() = default;
};
class CreateMigrationPlanRequestCustomMigrationTimes : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> migrationTime{};

  CreateMigrationPlanRequestCustomMigrationTimes() {}

  explicit CreateMigrationPlanRequestCustomMigrationTimes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (migrationTime) {
      res["MigrationTime"] = boost::any(*migrationTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MigrationTime") != m.end() && !m["MigrationTime"].empty()) {
      migrationTime = make_shared<string>(boost::any_cast<string>(m["MigrationTime"]));
    }
  }


  virtual ~CreateMigrationPlanRequestCustomMigrationTimes() = default;
};
class CreateMigrationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMigrationPlanRequestCustomMigrationTimes>> customMigrationTimes{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> enableAutoCreateVSwitch{};
  shared_ptr<bool> ensureNetworkConnectivity{};
  shared_ptr<string> globalMigrationTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> remainPrivateIp{};
  shared_ptr<bool> remainPublicMacAsPriority{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> targetSecurityGroupIds{};
  shared_ptr<string> targetVSwitchId{};
  shared_ptr<string> targetVpcId{};
  shared_ptr<string> targetZoneId{};
  shared_ptr<string> type{};

  CreateMigrationPlanRequest() {}

  explicit CreateMigrationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customMigrationTimes) {
      vector<boost::any> temp1;
      for(auto item1:*customMigrationTimes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomMigrationTimes"] = boost::any(temp1);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (enableAutoCreateVSwitch) {
      res["EnableAutoCreateVSwitch"] = boost::any(*enableAutoCreateVSwitch);
    }
    if (ensureNetworkConnectivity) {
      res["EnsureNetworkConnectivity"] = boost::any(*ensureNetworkConnectivity);
    }
    if (globalMigrationTime) {
      res["GlobalMigrationTime"] = boost::any(*globalMigrationTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remainPrivateIp) {
      res["RemainPrivateIp"] = boost::any(*remainPrivateIp);
    }
    if (remainPublicMacAsPriority) {
      res["RemainPublicMacAsPriority"] = boost::any(*remainPublicMacAsPriority);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (targetSecurityGroupIds) {
      res["TargetSecurityGroupIds"] = boost::any(*targetSecurityGroupIds);
    }
    if (targetVSwitchId) {
      res["TargetVSwitchId"] = boost::any(*targetVSwitchId);
    }
    if (targetVpcId) {
      res["TargetVpcId"] = boost::any(*targetVpcId);
    }
    if (targetZoneId) {
      res["TargetZoneId"] = boost::any(*targetZoneId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomMigrationTimes") != m.end() && !m["CustomMigrationTimes"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomMigrationTimes"].type()) {
        vector<CreateMigrationPlanRequestCustomMigrationTimes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomMigrationTimes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMigrationPlanRequestCustomMigrationTimes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customMigrationTimes = make_shared<vector<CreateMigrationPlanRequestCustomMigrationTimes>>(expect1);
      }
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnableAutoCreateVSwitch") != m.end() && !m["EnableAutoCreateVSwitch"].empty()) {
      enableAutoCreateVSwitch = make_shared<bool>(boost::any_cast<bool>(m["EnableAutoCreateVSwitch"]));
    }
    if (m.find("EnsureNetworkConnectivity") != m.end() && !m["EnsureNetworkConnectivity"].empty()) {
      ensureNetworkConnectivity = make_shared<bool>(boost::any_cast<bool>(m["EnsureNetworkConnectivity"]));
    }
    if (m.find("GlobalMigrationTime") != m.end() && !m["GlobalMigrationTime"].empty()) {
      globalMigrationTime = make_shared<string>(boost::any_cast<string>(m["GlobalMigrationTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemainPrivateIp") != m.end() && !m["RemainPrivateIp"].empty()) {
      remainPrivateIp = make_shared<bool>(boost::any_cast<bool>(m["RemainPrivateIp"]));
    }
    if (m.find("RemainPublicMacAsPriority") != m.end() && !m["RemainPublicMacAsPriority"].empty()) {
      remainPublicMacAsPriority = make_shared<bool>(boost::any_cast<bool>(m["RemainPublicMacAsPriority"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TargetSecurityGroupIds") != m.end() && !m["TargetSecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetSecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetSecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetSecurityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetVSwitchId") != m.end() && !m["TargetVSwitchId"].empty()) {
      targetVSwitchId = make_shared<string>(boost::any_cast<string>(m["TargetVSwitchId"]));
    }
    if (m.find("TargetVpcId") != m.end() && !m["TargetVpcId"].empty()) {
      targetVpcId = make_shared<string>(boost::any_cast<string>(m["TargetVpcId"]));
    }
    if (m.find("TargetZoneId") != m.end() && !m["TargetZoneId"].empty()) {
      targetZoneId = make_shared<string>(boost::any_cast<string>(m["TargetZoneId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMigrationPlanRequest() = default;
};
class CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};

  CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel() {}

  explicit CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel() = default;
};
class CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel>> failModel{};

  CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels() {}

  explicit CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failModel) {
      vector<boost::any> temp1;
      for(auto item1:*failModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailModel") != m.end() && !m["FailModel"].empty()) {
      if (typeid(vector<boost::any>) == m["FailModel"].type()) {
        vector<CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failModel = make_shared<vector<CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel>>(expect1);
      }
    }
  }


  virtual ~CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels() = default;
};
class CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel : public Darabonba::Model {
public:
  shared_ptr<CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels> failModels{};
  shared_ptr<string> instanceId{};

  CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel() {}

  explicit CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failModels) {
      res["FailModels"] = failModels ? boost::any(failModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailModels") != m.end() && !m["FailModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailModels"].type()) {
        CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailModels"]));
        failModels = make_shared<CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModelFailModels>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel() = default;
};
class CreateMigrationPlanResponseBodyInstancesFailModels : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel>> instancesFailModel{};

  CreateMigrationPlanResponseBodyInstancesFailModels() {}

  explicit CreateMigrationPlanResponseBodyInstancesFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancesFailModel) {
      vector<boost::any> temp1;
      for(auto item1:*instancesFailModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstancesFailModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstancesFailModel") != m.end() && !m["InstancesFailModel"].empty()) {
      if (typeid(vector<boost::any>) == m["InstancesFailModel"].type()) {
        vector<CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstancesFailModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancesFailModel = make_shared<vector<CreateMigrationPlanResponseBodyInstancesFailModelsInstancesFailModel>>(expect1);
      }
    }
  }


  virtual ~CreateMigrationPlanResponseBodyInstancesFailModels() = default;
};
class CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};

  CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel() {}

  explicit CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel() = default;
};
class CreateMigrationPlanResponseBodyPlanFailModels : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel>> planFailModel{};

  CreateMigrationPlanResponseBodyPlanFailModels() {}

  explicit CreateMigrationPlanResponseBodyPlanFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (planFailModel) {
      vector<boost::any> temp1;
      for(auto item1:*planFailModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlanFailModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlanFailModel") != m.end() && !m["PlanFailModel"].empty()) {
      if (typeid(vector<boost::any>) == m["PlanFailModel"].type()) {
        vector<CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlanFailModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        planFailModel = make_shared<vector<CreateMigrationPlanResponseBodyPlanFailModelsPlanFailModel>>(expect1);
      }
    }
  }


  virtual ~CreateMigrationPlanResponseBodyPlanFailModels() = default;
};
class CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};

  CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel() {}

  explicit CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel() = default;
};
class CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel>> failModel{};

  CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels() {}

  explicit CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failModel) {
      vector<boost::any> temp1;
      for(auto item1:*failModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailModel") != m.end() && !m["FailModel"].empty()) {
      if (typeid(vector<boost::any>) == m["FailModel"].type()) {
        vector<CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failModel = make_shared<vector<CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModelsFailModel>>(expect1);
      }
    }
  }


  virtual ~CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels() = default;
};
class CreateMigrationPlanResponseBodySgFailModelsSgFailModel : public Darabonba::Model {
public:
  shared_ptr<CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels> failModels{};
  shared_ptr<string> groupNo{};

  CreateMigrationPlanResponseBodySgFailModelsSgFailModel() {}

  explicit CreateMigrationPlanResponseBodySgFailModelsSgFailModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failModels) {
      res["FailModels"] = failModels ? boost::any(failModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupNo) {
      res["GroupNo"] = boost::any(*groupNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailModels") != m.end() && !m["FailModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailModels"].type()) {
        CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailModels"]));
        failModels = make_shared<CreateMigrationPlanResponseBodySgFailModelsSgFailModelFailModels>(model1);
      }
    }
    if (m.find("GroupNo") != m.end() && !m["GroupNo"].empty()) {
      groupNo = make_shared<string>(boost::any_cast<string>(m["GroupNo"]));
    }
  }


  virtual ~CreateMigrationPlanResponseBodySgFailModelsSgFailModel() = default;
};
class CreateMigrationPlanResponseBodySgFailModels : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMigrationPlanResponseBodySgFailModelsSgFailModel>> sgFailModel{};

  CreateMigrationPlanResponseBodySgFailModels() {}

  explicit CreateMigrationPlanResponseBodySgFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sgFailModel) {
      vector<boost::any> temp1;
      for(auto item1:*sgFailModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SgFailModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SgFailModel") != m.end() && !m["SgFailModel"].empty()) {
      if (typeid(vector<boost::any>) == m["SgFailModel"].type()) {
        vector<CreateMigrationPlanResponseBodySgFailModelsSgFailModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SgFailModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMigrationPlanResponseBodySgFailModelsSgFailModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sgFailModel = make_shared<vector<CreateMigrationPlanResponseBodySgFailModelsSgFailModel>>(expect1);
      }
    }
  }


  virtual ~CreateMigrationPlanResponseBodySgFailModels() = default;
};
class CreateMigrationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMigrationPlanResponseBodyInstancesFailModels> instancesFailModels{};
  shared_ptr<string> migrationPlanId{};
  shared_ptr<CreateMigrationPlanResponseBodyPlanFailModels> planFailModels{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateMigrationPlanResponseBodySgFailModels> sgFailModels{};

  CreateMigrationPlanResponseBody() {}

  explicit CreateMigrationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancesFailModels) {
      res["InstancesFailModels"] = instancesFailModels ? boost::any(instancesFailModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (migrationPlanId) {
      res["MigrationPlanId"] = boost::any(*migrationPlanId);
    }
    if (planFailModels) {
      res["PlanFailModels"] = planFailModels ? boost::any(planFailModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sgFailModels) {
      res["SgFailModels"] = sgFailModels ? boost::any(sgFailModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstancesFailModels") != m.end() && !m["InstancesFailModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstancesFailModels"].type()) {
        CreateMigrationPlanResponseBodyInstancesFailModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstancesFailModels"]));
        instancesFailModels = make_shared<CreateMigrationPlanResponseBodyInstancesFailModels>(model1);
      }
    }
    if (m.find("MigrationPlanId") != m.end() && !m["MigrationPlanId"].empty()) {
      migrationPlanId = make_shared<string>(boost::any_cast<string>(m["MigrationPlanId"]));
    }
    if (m.find("PlanFailModels") != m.end() && !m["PlanFailModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlanFailModels"].type()) {
        CreateMigrationPlanResponseBodyPlanFailModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlanFailModels"]));
        planFailModels = make_shared<CreateMigrationPlanResponseBodyPlanFailModels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SgFailModels") != m.end() && !m["SgFailModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SgFailModels"].type()) {
        CreateMigrationPlanResponseBodySgFailModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SgFailModels"]));
        sgFailModels = make_shared<CreateMigrationPlanResponseBodySgFailModels>(model1);
      }
    }
  }


  virtual ~CreateMigrationPlanResponseBody() = default;
};
class CreateMigrationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMigrationPlanResponseBody> body{};

  CreateMigrationPlanResponse() {}

  explicit CreateMigrationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMigrationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMigrationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMigrationPlanResponse() = default;
};
class CreateNetworkInsightsPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> destination{};
  shared_ptr<string> destinationPort{};
  shared_ptr<string> destinationType{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> needDiagnoseGuest{};
  shared_ptr<string> networkInsightsPathName{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceType{};

  CreateNetworkInsightsPathRequest() {}

  explicit CreateNetworkInsightsPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (destinationPort) {
      res["DestinationPort"] = boost::any(*destinationPort);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (needDiagnoseGuest) {
      res["NeedDiagnoseGuest"] = boost::any(*needDiagnoseGuest);
    }
    if (networkInsightsPathName) {
      res["NetworkInsightsPathName"] = boost::any(*networkInsightsPathName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("DestinationPort") != m.end() && !m["DestinationPort"].empty()) {
      destinationPort = make_shared<string>(boost::any_cast<string>(m["DestinationPort"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NeedDiagnoseGuest") != m.end() && !m["NeedDiagnoseGuest"].empty()) {
      needDiagnoseGuest = make_shared<bool>(boost::any_cast<bool>(m["NeedDiagnoseGuest"]));
    }
    if (m.find("NetworkInsightsPathName") != m.end() && !m["NetworkInsightsPathName"].empty()) {
      networkInsightsPathName = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsPathName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~CreateNetworkInsightsPathRequest() = default;
};
class CreateNetworkInsightsPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkInsightsPathId{};
  shared_ptr<string> requestId{};

  CreateNetworkInsightsPathResponseBody() {}

  explicit CreateNetworkInsightsPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInsightsPathId) {
      res["NetworkInsightsPathId"] = boost::any(*networkInsightsPathId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInsightsPathId") != m.end() && !m["NetworkInsightsPathId"].empty()) {
      networkInsightsPathId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsPathId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkInsightsPathResponseBody() = default;
};
class CreateNetworkInsightsPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkInsightsPathResponseBody> body{};

  CreateNetworkInsightsPathResponse() {}

  explicit CreateNetworkInsightsPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkInsightsPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkInsightsPathResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkInsightsPathResponse() = default;
};
class CreateOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> affinity{};
  shared_ptr<bool> asyncPattern{};
  shared_ptr<string> businessInfo{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> commodity{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> fromApp{};
  shared_ptr<string> orderType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tenancy{};

  CreateOrderRequest() {}

  explicit CreateOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (asyncPattern) {
      res["AsyncPattern"] = boost::any(*asyncPattern);
    }
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (commodity) {
      res["Commodity"] = boost::any(*commodity);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("AsyncPattern") != m.end() && !m["AsyncPattern"].empty()) {
      asyncPattern = make_shared<bool>(boost::any_cast<bool>(m["AsyncPattern"]));
    }
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Commodity") != m.end() && !m["Commodity"].empty()) {
      commodity = make_shared<string>(boost::any_cast<string>(m["Commodity"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
  }


  virtual ~CreateOrderRequest() = default;
};
class CreateOrderResponseBodyOrderParams : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderParam{};

  CreateOrderResponseBodyOrderParams() {}

  explicit CreateOrderResponseBodyOrderParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderParam) {
      res["OrderParam"] = boost::any(*orderParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderParam") != m.end() && !m["OrderParam"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderParam"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderParam"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderParam = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrderResponseBodyOrderParams() = default;
};
class CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet() {}

  explicit CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet() = default;
};
class CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> relatedOrderId{};

  CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds() {}

  explicit CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relatedOrderId) {
      res["RelatedOrderId"] = boost::any(*relatedOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelatedOrderId") != m.end() && !m["RelatedOrderId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedOrderId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedOrderId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatedOrderId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds() = default;
};
class CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet : public Darabonba::Model {
public:
  shared_ptr<CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet> instanceIdSet{};
  shared_ptr<CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds> relatedOrderIds{};

  CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet() {}

  explicit CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdSet) {
      res["InstanceIdSet"] = instanceIdSet ? boost::any(instanceIdSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedOrderIds) {
      res["RelatedOrderIds"] = relatedOrderIds ? boost::any(relatedOrderIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIdSet") != m.end() && !m["InstanceIdSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIdSet"].type()) {
        CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIdSet"]));
        instanceIdSet = make_shared<CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetInstanceIdSet>(model1);
      }
    }
    if (m.find("RelatedOrderIds") != m.end() && !m["RelatedOrderIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelatedOrderIds"].type()) {
        CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelatedOrderIds"]));
        relatedOrderIds = make_shared<CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSetRelatedOrderIds>(model1);
      }
    }
  }


  virtual ~CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet() = default;
};
class CreateOrderResponseBodyRelatedOrderItemSets : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet>> relatedOrderItemSet{};

  CreateOrderResponseBodyRelatedOrderItemSets() {}

  explicit CreateOrderResponseBodyRelatedOrderItemSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relatedOrderItemSet) {
      vector<boost::any> temp1;
      for(auto item1:*relatedOrderItemSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedOrderItemSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelatedOrderItemSet") != m.end() && !m["RelatedOrderItemSet"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedOrderItemSet"].type()) {
        vector<CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedOrderItemSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedOrderItemSet = make_shared<vector<CreateOrderResponseBodyRelatedOrderItemSetsRelatedOrderItemSet>>(expect1);
      }
    }
  }


  virtual ~CreateOrderResponseBodyRelatedOrderItemSets() = default;
};
class CreateOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<CreateOrderResponseBodyOrderParams> orderParams{};
  shared_ptr<CreateOrderResponseBodyRelatedOrderItemSets> relatedOrderItemSets{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<double> tradePrice{};

  CreateOrderResponseBody() {}

  explicit CreateOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderParams) {
      res["OrderParams"] = orderParams ? boost::any(orderParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedOrderItemSets) {
      res["RelatedOrderItemSets"] = relatedOrderItemSets ? boost::any(relatedOrderItemSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderParams") != m.end() && !m["OrderParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderParams"].type()) {
        CreateOrderResponseBodyOrderParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderParams"]));
        orderParams = make_shared<CreateOrderResponseBodyOrderParams>(model1);
      }
    }
    if (m.find("RelatedOrderItemSets") != m.end() && !m["RelatedOrderItemSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelatedOrderItemSets"].type()) {
        CreateOrderResponseBodyRelatedOrderItemSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelatedOrderItemSets"]));
        relatedOrderItemSets = make_shared<CreateOrderResponseBodyRelatedOrderItemSets>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~CreateOrderResponseBody() = default;
};
class CreateOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrderResponseBody> body{};

  CreateOrderResponse() {}

  explicit CreateOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrderResponse() = default;
};
class CreateReservationDemandRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> zoneId{};

  CreateReservationDemandRequestPrivatePoolOptions() {}

  explicit CreateReservationDemandRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateReservationDemandRequestPrivatePoolOptions() = default;
};
class CreateReservationDemandRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateReservationDemandRequestTag() {}

  explicit CreateReservationDemandRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateReservationDemandRequestTag() = default;
};
class CreateReservationDemandRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> confirmType{};
  shared_ptr<bool> couponAuto{};
  shared_ptr<string> couponType{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> instanceCpuCoreCount{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> instanceTypes{};
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> name{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> platform{};
  shared_ptr<vector<CreateReservationDemandRequestPrivatePoolOptions>> privatePoolOptions{};
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservedInstanceDescription{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> reservedInstanceOfferingType{};
  shared_ptr<string> reservedInstanceScope{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceSupplyType{};
  shared_ptr<string> savingPlanDescription{};
  shared_ptr<double> savingPlanHourFee{};
  shared_ptr<string> savingPlanId{};
  shared_ptr<string> savingPlanInstanceTypeFamilyGroup{};
  shared_ptr<string> savingPlanName{};
  shared_ptr<string> savingPlanPayMode{};
  shared_ptr<string> savingPlanSavingType{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<CreateReservationDemandRequestTag>> tag{};
  shared_ptr<string> zoneIds{};

  CreateReservationDemandRequest() {}

  explicit CreateReservationDemandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (confirmType) {
      res["ConfirmType"] = boost::any(*confirmType);
    }
    if (couponAuto) {
      res["CouponAuto"] = boost::any(*couponAuto);
    }
    if (couponType) {
      res["CouponType"] = boost::any(*couponType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceCpuCoreCount) {
      res["InstanceCpuCoreCount"] = boost::any(*instanceCpuCoreCount);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (privatePoolOptions) {
      vector<boost::any> temp1;
      for(auto item1:*privatePoolOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivatePoolOptions"] = boost::any(temp1);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceDescription) {
      res["ReservedInstanceDescription"] = boost::any(*reservedInstanceDescription);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (reservedInstanceOfferingType) {
      res["ReservedInstanceOfferingType"] = boost::any(*reservedInstanceOfferingType);
    }
    if (reservedInstanceScope) {
      res["ReservedInstanceScope"] = boost::any(*reservedInstanceScope);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceSupplyType) {
      res["ResourceSupplyType"] = boost::any(*resourceSupplyType);
    }
    if (savingPlanDescription) {
      res["SavingPlanDescription"] = boost::any(*savingPlanDescription);
    }
    if (savingPlanHourFee) {
      res["SavingPlanHourFee"] = boost::any(*savingPlanHourFee);
    }
    if (savingPlanId) {
      res["SavingPlanId"] = boost::any(*savingPlanId);
    }
    if (savingPlanInstanceTypeFamilyGroup) {
      res["SavingPlanInstanceTypeFamilyGroup"] = boost::any(*savingPlanInstanceTypeFamilyGroup);
    }
    if (savingPlanName) {
      res["SavingPlanName"] = boost::any(*savingPlanName);
    }
    if (savingPlanPayMode) {
      res["SavingPlanPayMode"] = boost::any(*savingPlanPayMode);
    }
    if (savingPlanSavingType) {
      res["SavingPlanSavingType"] = boost::any(*savingPlanSavingType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneIds) {
      res["ZoneIds"] = boost::any(*zoneIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfirmType") != m.end() && !m["ConfirmType"].empty()) {
      confirmType = make_shared<string>(boost::any_cast<string>(m["ConfirmType"]));
    }
    if (m.find("CouponAuto") != m.end() && !m["CouponAuto"].empty()) {
      couponAuto = make_shared<bool>(boost::any_cast<bool>(m["CouponAuto"]));
    }
    if (m.find("CouponType") != m.end() && !m["CouponType"].empty()) {
      couponType = make_shared<string>(boost::any_cast<string>(m["CouponType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceCpuCoreCount") != m.end() && !m["InstanceCpuCoreCount"].empty()) {
      instanceCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["InstanceCpuCoreCount"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      instanceTypes = make_shared<string>(boost::any_cast<string>(m["InstanceTypes"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivatePoolOptions"].type()) {
        vector<CreateReservationDemandRequestPrivatePoolOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivatePoolOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateReservationDemandRequestPrivatePoolOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privatePoolOptions = make_shared<vector<CreateReservationDemandRequestPrivatePoolOptions>>(expect1);
      }
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceDescription") != m.end() && !m["ReservedInstanceDescription"].empty()) {
      reservedInstanceDescription = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceDescription"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ReservedInstanceOfferingType") != m.end() && !m["ReservedInstanceOfferingType"].empty()) {
      reservedInstanceOfferingType = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceOfferingType"]));
    }
    if (m.find("ReservedInstanceScope") != m.end() && !m["ReservedInstanceScope"].empty()) {
      reservedInstanceScope = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceScope"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceSupplyType") != m.end() && !m["ResourceSupplyType"].empty()) {
      resourceSupplyType = make_shared<string>(boost::any_cast<string>(m["ResourceSupplyType"]));
    }
    if (m.find("SavingPlanDescription") != m.end() && !m["SavingPlanDescription"].empty()) {
      savingPlanDescription = make_shared<string>(boost::any_cast<string>(m["SavingPlanDescription"]));
    }
    if (m.find("SavingPlanHourFee") != m.end() && !m["SavingPlanHourFee"].empty()) {
      savingPlanHourFee = make_shared<double>(boost::any_cast<double>(m["SavingPlanHourFee"]));
    }
    if (m.find("SavingPlanId") != m.end() && !m["SavingPlanId"].empty()) {
      savingPlanId = make_shared<string>(boost::any_cast<string>(m["SavingPlanId"]));
    }
    if (m.find("SavingPlanInstanceTypeFamilyGroup") != m.end() && !m["SavingPlanInstanceTypeFamilyGroup"].empty()) {
      savingPlanInstanceTypeFamilyGroup = make_shared<string>(boost::any_cast<string>(m["SavingPlanInstanceTypeFamilyGroup"]));
    }
    if (m.find("SavingPlanName") != m.end() && !m["SavingPlanName"].empty()) {
      savingPlanName = make_shared<string>(boost::any_cast<string>(m["SavingPlanName"]));
    }
    if (m.find("SavingPlanPayMode") != m.end() && !m["SavingPlanPayMode"].empty()) {
      savingPlanPayMode = make_shared<string>(boost::any_cast<string>(m["SavingPlanPayMode"]));
    }
    if (m.find("SavingPlanSavingType") != m.end() && !m["SavingPlanSavingType"].empty()) {
      savingPlanSavingType = make_shared<string>(boost::any_cast<string>(m["SavingPlanSavingType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateReservationDemandRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateReservationDemandRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateReservationDemandRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneIds") != m.end() && !m["ZoneIds"].empty()) {
      zoneIds = make_shared<string>(boost::any_cast<string>(m["ZoneIds"]));
    }
  }


  virtual ~CreateReservationDemandRequest() = default;
};
class CreateReservationDemandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> demandId{};
  shared_ptr<string> requestId{};

  CreateReservationDemandResponseBody() {}

  explicit CreateReservationDemandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateReservationDemandResponseBody() = default;
};
class CreateReservationDemandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateReservationDemandResponseBody> body{};

  CreateReservationDemandResponse() {}

  explicit CreateReservationDemandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateReservationDemandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateReservationDemandResponseBody>(model1);
      }
    }
  }


  virtual ~CreateReservationDemandResponse() = default;
};
class CreateStorageSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> maxPartitionNumber{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> storageSetName{};
  shared_ptr<string> zoneId{};

  CreateStorageSetRequest() {}

  explicit CreateStorageSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (maxPartitionNumber) {
      res["MaxPartitionNumber"] = boost::any(*maxPartitionNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (storageSetName) {
      res["StorageSetName"] = boost::any(*storageSetName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MaxPartitionNumber") != m.end() && !m["MaxPartitionNumber"].empty()) {
      maxPartitionNumber = make_shared<long>(boost::any_cast<long>(m["MaxPartitionNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StorageSetName") != m.end() && !m["StorageSetName"].empty()) {
      storageSetName = make_shared<string>(boost::any_cast<string>(m["StorageSetName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateStorageSetRequest() = default;
};
class CreateStorageSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> storageSetId{};

  CreateStorageSetResponseBody() {}

  explicit CreateStorageSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
  }


  virtual ~CreateStorageSetResponseBody() = default;
};
class CreateStorageSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStorageSetResponseBody> body{};

  CreateStorageSetResponse() {}

  explicit CreateStorageSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStorageSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStorageSetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStorageSetResponse() = default;
};
class CreateUserQuotaApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> quotaType{};
  shared_ptr<long> quotaValue{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  CreateUserQuotaApplicationRequest() {}

  explicit CreateUserQuotaApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (quotaType) {
      res["QuotaType"] = boost::any(*quotaType);
    }
    if (quotaValue) {
      res["QuotaValue"] = boost::any(*quotaValue);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QuotaType") != m.end() && !m["QuotaType"].empty()) {
      quotaType = make_shared<string>(boost::any_cast<string>(m["QuotaType"]));
    }
    if (m.find("QuotaValue") != m.end() && !m["QuotaValue"].empty()) {
      quotaValue = make_shared<long>(boost::any_cast<long>(m["QuotaValue"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateUserQuotaApplicationRequest() = default;
};
class CreateUserQuotaApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> requestId{};

  CreateUserQuotaApplicationResponseBody() {}

  explicit CreateUserQuotaApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateUserQuotaApplicationResponseBody() = default;
};
class CreateUserQuotaApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserQuotaApplicationResponseBody> body{};

  CreateUserQuotaApplicationResponse() {}

  explicit CreateUserQuotaApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserQuotaApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserQuotaApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserQuotaApplicationResponse() = default;
};
class CreateVolumesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVolumesRequestTag() {}

  explicit CreateVolumesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVolumesRequestTag() = default;
};
class CreateVolumesRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<vector<CreateVolumesRequestTag>> tag{};
  shared_ptr<string> volumeCategory{};
  shared_ptr<bool> volumeEncrypted{};
  shared_ptr<string> volumeName{};
  shared_ptr<string> zoneId{};

  CreateVolumesRequest() {}

  explicit CreateVolumesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (volumeCategory) {
      res["VolumeCategory"] = boost::any(*volumeCategory);
    }
    if (volumeEncrypted) {
      res["VolumeEncrypted"] = boost::any(*volumeEncrypted);
    }
    if (volumeName) {
      res["VolumeName"] = boost::any(*volumeName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateVolumesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVolumesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateVolumesRequestTag>>(expect1);
      }
    }
    if (m.find("VolumeCategory") != m.end() && !m["VolumeCategory"].empty()) {
      volumeCategory = make_shared<string>(boost::any_cast<string>(m["VolumeCategory"]));
    }
    if (m.find("VolumeEncrypted") != m.end() && !m["VolumeEncrypted"].empty()) {
      volumeEncrypted = make_shared<bool>(boost::any_cast<bool>(m["VolumeEncrypted"]));
    }
    if (m.find("VolumeName") != m.end() && !m["VolumeName"].empty()) {
      volumeName = make_shared<string>(boost::any_cast<string>(m["VolumeName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateVolumesRequest() = default;
};
class CreateVolumesResponseBodyVolumeIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> volumeId{};

  CreateVolumesResponseBodyVolumeIds() {}

  explicit CreateVolumesResponseBodyVolumeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (volumeId) {
      res["VolumeId"] = boost::any(*volumeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VolumeId") != m.end() && !m["VolumeId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VolumeId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VolumeId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      volumeId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateVolumesResponseBodyVolumeIds() = default;
};
class CreateVolumesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateVolumesResponseBodyVolumeIds> volumeIds{};

  CreateVolumesResponseBody() {}

  explicit CreateVolumesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (volumeIds) {
      res["VolumeIds"] = volumeIds ? boost::any(volumeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VolumeIds") != m.end() && !m["VolumeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VolumeIds"].type()) {
        CreateVolumesResponseBodyVolumeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VolumeIds"]));
        volumeIds = make_shared<CreateVolumesResponseBodyVolumeIds>(model1);
      }
    }
  }


  virtual ~CreateVolumesResponseBody() = default;
};
class CreateVolumesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVolumesResponseBody> body{};

  CreateVolumesResponse() {}

  explicit CreateVolumesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVolumesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVolumesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVolumesResponse() = default;
};
class CreateWaitingOrderRequestCpuOptions : public Darabonba::Model {
public:
  shared_ptr<long> core{};
  shared_ptr<string> numa{};
  shared_ptr<long> threadsPerCore{};

  CreateWaitingOrderRequestCpuOptions() {}

  explicit CreateWaitingOrderRequestCpuOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (core) {
      res["Core"] = boost::any(*core);
    }
    if (numa) {
      res["Numa"] = boost::any(*numa);
    }
    if (threadsPerCore) {
      res["ThreadsPerCore"] = boost::any(*threadsPerCore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Core") != m.end() && !m["Core"].empty()) {
      core = make_shared<long>(boost::any_cast<long>(m["Core"]));
    }
    if (m.find("Numa") != m.end() && !m["Numa"].empty()) {
      numa = make_shared<string>(boost::any_cast<string>(m["Numa"]));
    }
    if (m.find("ThreadsPerCore") != m.end() && !m["ThreadsPerCore"].empty()) {
      threadsPerCore = make_shared<long>(boost::any_cast<long>(m["ThreadsPerCore"]));
    }
  }


  virtual ~CreateWaitingOrderRequestCpuOptions() = default;
};
class CreateWaitingOrderRequestHibernationOptions : public Darabonba::Model {
public:
  shared_ptr<bool> configured{};

  CreateWaitingOrderRequestHibernationOptions() {}

  explicit CreateWaitingOrderRequestHibernationOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configured) {
      res["Configured"] = boost::any(*configured);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configured") != m.end() && !m["Configured"].empty()) {
      configured = make_shared<bool>(boost::any_cast<bool>(m["Configured"]));
    }
  }


  virtual ~CreateWaitingOrderRequestHibernationOptions() = default;
};
class CreateWaitingOrderRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  CreateWaitingOrderRequestPrivatePoolOptions() {}

  explicit CreateWaitingOrderRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~CreateWaitingOrderRequestPrivatePoolOptions() = default;
};
class CreateWaitingOrderRequestSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostClusterId{};

  CreateWaitingOrderRequestSchedulerOptions() {}

  explicit CreateWaitingOrderRequestSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
  }


  virtual ~CreateWaitingOrderRequestSchedulerOptions() = default;
};
class CreateWaitingOrderRequestSecurityOptions : public Darabonba::Model {
public:
  shared_ptr<string> confidentialComputingMode{};
  shared_ptr<string> trustedSystemMode{};

  CreateWaitingOrderRequestSecurityOptions() {}

  explicit CreateWaitingOrderRequestSecurityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confidentialComputingMode) {
      res["ConfidentialComputingMode"] = boost::any(*confidentialComputingMode);
    }
    if (trustedSystemMode) {
      res["TrustedSystemMode"] = boost::any(*trustedSystemMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfidentialComputingMode") != m.end() && !m["ConfidentialComputingMode"].empty()) {
      confidentialComputingMode = make_shared<string>(boost::any_cast<string>(m["ConfidentialComputingMode"]));
    }
    if (m.find("TrustedSystemMode") != m.end() && !m["TrustedSystemMode"].empty()) {
      trustedSystemMode = make_shared<string>(boost::any_cast<string>(m["TrustedSystemMode"]));
    }
  }


  virtual ~CreateWaitingOrderRequestSecurityOptions() = default;
};
class CreateWaitingOrderRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> diskName{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> size{};
  shared_ptr<string> storageClusterId{};

  CreateWaitingOrderRequestSystemDisk() {}

  explicit CreateWaitingOrderRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (storageClusterId) {
      res["StorageClusterId"] = boost::any(*storageClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StorageClusterId") != m.end() && !m["StorageClusterId"].empty()) {
      storageClusterId = make_shared<string>(boost::any_cast<string>(m["StorageClusterId"]));
    }
  }


  virtual ~CreateWaitingOrderRequestSystemDisk() = default;
};
class CreateWaitingOrderRequestArn : public Darabonba::Model {
public:
  shared_ptr<long> assumeRoleFor{};
  shared_ptr<string> roleType{};
  shared_ptr<string> rolearn{};

  CreateWaitingOrderRequestArn() {}

  explicit CreateWaitingOrderRequestArn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assumeRoleFor) {
      res["AssumeRoleFor"] = boost::any(*assumeRoleFor);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    if (rolearn) {
      res["Rolearn"] = boost::any(*rolearn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssumeRoleFor") != m.end() && !m["AssumeRoleFor"].empty()) {
      assumeRoleFor = make_shared<long>(boost::any_cast<long>(m["AssumeRoleFor"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
    if (m.find("Rolearn") != m.end() && !m["Rolearn"].empty()) {
      rolearn = make_shared<string>(boost::any_cast<string>(m["Rolearn"]));
    }
  }


  virtual ~CreateWaitingOrderRequestArn() = default;
};
class CreateWaitingOrderRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> storageClusterId{};

  CreateWaitingOrderRequestDataDisk() {}

  explicit CreateWaitingOrderRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (storageClusterId) {
      res["StorageClusterId"] = boost::any(*storageClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("StorageClusterId") != m.end() && !m["StorageClusterId"].empty()) {
      storageClusterId = make_shared<string>(boost::any_cast<string>(m["StorageClusterId"]));
    }
  }


  virtual ~CreateWaitingOrderRequestDataDisk() = default;
};
class CreateWaitingOrderRequestNetworkInterface : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<long> queueNumber{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> vSwitchId{};

  CreateWaitingOrderRequestNetworkInterface() {}

  explicit CreateWaitingOrderRequestNetworkInterface(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (queueNumber) {
      res["QueueNumber"] = boost::any(*queueNumber);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("QueueNumber") != m.end() && !m["QueueNumber"].empty()) {
      queueNumber = make_shared<long>(boost::any_cast<long>(m["QueueNumber"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateWaitingOrderRequestNetworkInterface() = default;
};
class CreateWaitingOrderRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateWaitingOrderRequestTag() {}

  explicit CreateWaitingOrderRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateWaitingOrderRequestTag() = default;
};
class CreateWaitingOrderRequest : public Darabonba::Model {
public:
  shared_ptr<CreateWaitingOrderRequestCpuOptions> cpuOptions{};
  shared_ptr<CreateWaitingOrderRequestHibernationOptions> hibernationOptions{};
  shared_ptr<CreateWaitingOrderRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<CreateWaitingOrderRequestSchedulerOptions> schedulerOptions{};
  shared_ptr<CreateWaitingOrderRequestSecurityOptions> securityOptions{};
  shared_ptr<CreateWaitingOrderRequestSystemDisk> systemDisk{};
  shared_ptr<string> affinity{};
  shared_ptr<vector<CreateWaitingOrderRequestArn>> arn{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<vector<CreateWaitingOrderRequestDataDisk>> dataDisk{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<long> deploymentSetGroupNo{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> hostName{};
  shared_ptr<vector<string>> hostNames{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<long> httpPutResponseHopLimit{};
  shared_ptr<string> httpTokens{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<vector<string>> ipv6Address{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> isp{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> launchTemplateId{};
  shared_ptr<string> launchTemplateName{};
  shared_ptr<long> launchTemplateVersion{};
  shared_ptr<long> maxAmount{};
  shared_ptr<long> minAmount{};
  shared_ptr<vector<CreateWaitingOrderRequestNetworkInterface>> networkInterface{};
  shared_ptr<long> networkInterfaceQueueNumber{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<vector<CreateWaitingOrderRequestTag>> tag{};
  shared_ptr<string> tenancy{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};

  CreateWaitingOrderRequest() {}

  explicit CreateWaitingOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuOptions) {
      res["CpuOptions"] = cpuOptions ? boost::any(cpuOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hibernationOptions) {
      res["HibernationOptions"] = hibernationOptions ? boost::any(hibernationOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityOptions) {
      res["SecurityOptions"] = securityOptions ? boost::any(securityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (arn) {
      vector<boost::any> temp1;
      for(auto item1:*arn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Arn"] = boost::any(temp1);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (deploymentSetGroupNo) {
      res["DeploymentSetGroupNo"] = boost::any(*deploymentSetGroupNo);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostNames) {
      res["HostNames"] = boost::any(*hostNames);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpPutResponseHopLimit) {
      res["HttpPutResponseHopLimit"] = boost::any(*httpPutResponseHopLimit);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (launchTemplateId) {
      res["LaunchTemplateId"] = boost::any(*launchTemplateId);
    }
    if (launchTemplateName) {
      res["LaunchTemplateName"] = boost::any(*launchTemplateName);
    }
    if (launchTemplateVersion) {
      res["LaunchTemplateVersion"] = boost::any(*launchTemplateVersion);
    }
    if (maxAmount) {
      res["MaxAmount"] = boost::any(*maxAmount);
    }
    if (minAmount) {
      res["MinAmount"] = boost::any(*minAmount);
    }
    if (networkInterface) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterface){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterface"] = boost::any(temp1);
    }
    if (networkInterfaceQueueNumber) {
      res["NetworkInterfaceQueueNumber"] = boost::any(*networkInterfaceQueueNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuOptions") != m.end() && !m["CpuOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["CpuOptions"].type()) {
        CreateWaitingOrderRequestCpuOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CpuOptions"]));
        cpuOptions = make_shared<CreateWaitingOrderRequestCpuOptions>(model1);
      }
    }
    if (m.find("HibernationOptions") != m.end() && !m["HibernationOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["HibernationOptions"].type()) {
        CreateWaitingOrderRequestHibernationOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HibernationOptions"]));
        hibernationOptions = make_shared<CreateWaitingOrderRequestHibernationOptions>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        CreateWaitingOrderRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<CreateWaitingOrderRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        CreateWaitingOrderRequestSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<CreateWaitingOrderRequestSchedulerOptions>(model1);
      }
    }
    if (m.find("SecurityOptions") != m.end() && !m["SecurityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityOptions"].type()) {
        CreateWaitingOrderRequestSecurityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityOptions"]));
        securityOptions = make_shared<CreateWaitingOrderRequestSecurityOptions>(model1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        CreateWaitingOrderRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<CreateWaitingOrderRequestSystemDisk>(model1);
      }
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      if (typeid(vector<boost::any>) == m["Arn"].type()) {
        vector<CreateWaitingOrderRequestArn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Arn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWaitingOrderRequestArn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        arn = make_shared<vector<CreateWaitingOrderRequestArn>>(expect1);
      }
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<CreateWaitingOrderRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWaitingOrderRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<CreateWaitingOrderRequestDataDisk>>(expect1);
      }
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("DeploymentSetGroupNo") != m.end() && !m["DeploymentSetGroupNo"].empty()) {
      deploymentSetGroupNo = make_shared<long>(boost::any_cast<long>(m["DeploymentSetGroupNo"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostNames") != m.end() && !m["HostNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpPutResponseHopLimit") != m.end() && !m["HttpPutResponseHopLimit"].empty()) {
      httpPutResponseHopLimit = make_shared<long>(boost::any_cast<long>(m["HttpPutResponseHopLimit"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LaunchTemplateId") != m.end() && !m["LaunchTemplateId"].empty()) {
      launchTemplateId = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateId"]));
    }
    if (m.find("LaunchTemplateName") != m.end() && !m["LaunchTemplateName"].empty()) {
      launchTemplateName = make_shared<string>(boost::any_cast<string>(m["LaunchTemplateName"]));
    }
    if (m.find("LaunchTemplateVersion") != m.end() && !m["LaunchTemplateVersion"].empty()) {
      launchTemplateVersion = make_shared<long>(boost::any_cast<long>(m["LaunchTemplateVersion"]));
    }
    if (m.find("MaxAmount") != m.end() && !m["MaxAmount"].empty()) {
      maxAmount = make_shared<long>(boost::any_cast<long>(m["MaxAmount"]));
    }
    if (m.find("MinAmount") != m.end() && !m["MinAmount"].empty()) {
      minAmount = make_shared<long>(boost::any_cast<long>(m["MinAmount"]));
    }
    if (m.find("NetworkInterface") != m.end() && !m["NetworkInterface"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterface"].type()) {
        vector<CreateWaitingOrderRequestNetworkInterface> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterface"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWaitingOrderRequestNetworkInterface model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterface = make_shared<vector<CreateWaitingOrderRequestNetworkInterface>>(expect1);
      }
    }
    if (m.find("NetworkInterfaceQueueNumber") != m.end() && !m["NetworkInterfaceQueueNumber"].empty()) {
      networkInterfaceQueueNumber = make_shared<long>(boost::any_cast<long>(m["NetworkInterfaceQueueNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateWaitingOrderRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWaitingOrderRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateWaitingOrderRequestTag>>(expect1);
      }
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateWaitingOrderRequest() = default;
};
class CreateWaitingOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dryRunResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> waitTimeCycle{};
  shared_ptr<long> waitTimeValue{};
  shared_ptr<string> waitingOrderId{};

  CreateWaitingOrderResponseBody() {}

  explicit CreateWaitingOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRunResult) {
      res["DryRunResult"] = boost::any(*dryRunResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waitTimeCycle) {
      res["WaitTimeCycle"] = boost::any(*waitTimeCycle);
    }
    if (waitTimeValue) {
      res["WaitTimeValue"] = boost::any(*waitTimeValue);
    }
    if (waitingOrderId) {
      res["WaitingOrderId"] = boost::any(*waitingOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRunResult") != m.end() && !m["DryRunResult"].empty()) {
      dryRunResult = make_shared<string>(boost::any_cast<string>(m["DryRunResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaitTimeCycle") != m.end() && !m["WaitTimeCycle"].empty()) {
      waitTimeCycle = make_shared<string>(boost::any_cast<string>(m["WaitTimeCycle"]));
    }
    if (m.find("WaitTimeValue") != m.end() && !m["WaitTimeValue"].empty()) {
      waitTimeValue = make_shared<long>(boost::any_cast<long>(m["WaitTimeValue"]));
    }
    if (m.find("WaitingOrderId") != m.end() && !m["WaitingOrderId"].empty()) {
      waitingOrderId = make_shared<string>(boost::any_cast<string>(m["WaitingOrderId"]));
    }
  }


  virtual ~CreateWaitingOrderResponseBody() = default;
};
class CreateWaitingOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWaitingOrderResponseBody> body{};

  CreateWaitingOrderResponse() {}

  explicit CreateWaitingOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWaitingOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWaitingOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWaitingOrderResponse() = default;
};
class DeleteDedicatedHostClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteDedicatedHostClusterRequest() {}

  explicit DeleteDedicatedHostClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteDedicatedHostClusterRequest() = default;
};
class DeleteDedicatedHostClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDedicatedHostClusterResponseBody() {}

  explicit DeleteDedicatedHostClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDedicatedHostClusterResponseBody() = default;
};
class DeleteDedicatedHostClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDedicatedHostClusterResponseBody> body{};

  DeleteDedicatedHostClusterResponse() {}

  explicit DeleteDedicatedHostClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDedicatedHostClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDedicatedHostClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDedicatedHostClusterResponse() = default;
};
class DeleteEniQosGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosGroupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteEniQosGroupRequest() {}

  explicit DeleteEniQosGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosGroupName) {
      res["QosGroupName"] = boost::any(*qosGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosGroupName") != m.end() && !m["QosGroupName"].empty()) {
      qosGroupName = make_shared<string>(boost::any_cast<string>(m["QosGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteEniQosGroupRequest() = default;
};
class DeleteEniQosGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEniQosGroupResponseBody() {}

  explicit DeleteEniQosGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEniQosGroupResponseBody() = default;
};
class DeleteEniQosGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEniQosGroupResponseBody> body{};

  DeleteEniQosGroupResponse() {}

  explicit DeleteEniQosGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEniQosGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEniQosGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEniQosGroupResponse() = default;
};
class DeleteImageCacheRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> imageId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  DeleteImageCacheRequest() {}

  explicit DeleteImageCacheRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DeleteImageCacheRequest() = default;
};
class DeleteImageCacheResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteImageCacheResponseBody() {}

  explicit DeleteImageCacheResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteImageCacheResponseBody() = default;
};
class DeleteImageCacheResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteImageCacheResponseBody> body{};

  DeleteImageCacheResponse() {}

  explicit DeleteImageCacheResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteImageCacheResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteImageCacheResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteImageCacheResponse() = default;
};
class DeleteMigratableInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteMigratableInstancesRequest() {}

  explicit DeleteMigratableInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteMigratableInstancesRequest() = default;
};
class DeleteMigratableInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMigratableInstancesResponseBody() {}

  explicit DeleteMigratableInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMigratableInstancesResponseBody() = default;
};
class DeleteMigratableInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMigratableInstancesResponseBody> body{};

  DeleteMigratableInstancesResponse() {}

  explicit DeleteMigratableInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMigratableInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMigratableInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMigratableInstancesResponse() = default;
};
class DeleteNetworkInsightsAnalysisRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<string>> networkInsightsAnalysisId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  DeleteNetworkInsightsAnalysisRequest() {}

  explicit DeleteNetworkInsightsAnalysisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkInsightsAnalysisId) {
      res["NetworkInsightsAnalysisId"] = boost::any(*networkInsightsAnalysisId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkInsightsAnalysisId") != m.end() && !m["NetworkInsightsAnalysisId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInsightsAnalysisId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInsightsAnalysisId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInsightsAnalysisId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteNetworkInsightsAnalysisRequest() = default;
};
class DeleteNetworkInsightsAnalysisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkInsightsAnalysisResponseBody() {}

  explicit DeleteNetworkInsightsAnalysisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkInsightsAnalysisResponseBody() = default;
};
class DeleteNetworkInsightsAnalysisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkInsightsAnalysisResponseBody> body{};

  DeleteNetworkInsightsAnalysisResponse() {}

  explicit DeleteNetworkInsightsAnalysisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkInsightsAnalysisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkInsightsAnalysisResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkInsightsAnalysisResponse() = default;
};
class DeleteNetworkInsightsPathRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<string>> networkInsightsPathId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  DeleteNetworkInsightsPathRequest() {}

  explicit DeleteNetworkInsightsPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkInsightsPathId) {
      res["NetworkInsightsPathId"] = boost::any(*networkInsightsPathId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkInsightsPathId") != m.end() && !m["NetworkInsightsPathId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInsightsPathId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInsightsPathId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInsightsPathId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteNetworkInsightsPathRequest() = default;
};
class DeleteNetworkInsightsPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkInsightsPathResponseBody() {}

  explicit DeleteNetworkInsightsPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkInsightsPathResponseBody() = default;
};
class DeleteNetworkInsightsPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkInsightsPathResponseBody> body{};

  DeleteNetworkInsightsPathResponse() {}

  explicit DeleteNetworkInsightsPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkInsightsPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkInsightsPathResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkInsightsPathResponse() = default;
};
class DeleteReservationDemandRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteReservationDemandRequestTag() {}

  explicit DeleteReservationDemandRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteReservationDemandRequestTag() = default;
};
class DeleteReservationDemandRequest : public Darabonba::Model {
public:
  shared_ptr<string> demandId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DeleteReservationDemandRequestTag>> tag{};

  DeleteReservationDemandRequest() {}

  explicit DeleteReservationDemandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeleteReservationDemandRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteReservationDemandRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeleteReservationDemandRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeleteReservationDemandRequest() = default;
};
class DeleteReservationDemandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteReservationDemandResponseBody() {}

  explicit DeleteReservationDemandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteReservationDemandResponseBody() = default;
};
class DeleteReservationDemandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteReservationDemandResponseBody> body{};

  DeleteReservationDemandResponse() {}

  explicit DeleteReservationDemandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteReservationDemandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteReservationDemandResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteReservationDemandResponse() = default;
};
class DeleteStorageSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> storageSetId{};

  DeleteStorageSetRequest() {}

  explicit DeleteStorageSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
  }


  virtual ~DeleteStorageSetRequest() = default;
};
class DeleteStorageSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStorageSetResponseBody() {}

  explicit DeleteStorageSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStorageSetResponseBody() = default;
};
class DeleteStorageSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStorageSetResponseBody> body{};

  DeleteStorageSetResponse() {}

  explicit DeleteStorageSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStorageSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStorageSetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStorageSetResponse() = default;
};
class DeleteUserQuotaApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteUserQuotaApplicationRequest() {}

  explicit DeleteUserQuotaApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteUserQuotaApplicationRequest() = default;
};
class DeleteUserQuotaApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserQuotaApplicationResponseBody() {}

  explicit DeleteUserQuotaApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserQuotaApplicationResponseBody() = default;
};
class DeleteUserQuotaApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserQuotaApplicationResponseBody> body{};

  DeleteUserQuotaApplicationResponse() {}

  explicit DeleteUserQuotaApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserQuotaApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserQuotaApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserQuotaApplicationResponse() = default;
};
class DeleteWaitingOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceGroupId{};
  shared_ptr<vector<string>> waitingOrderId{};

  DeleteWaitingOrdersRequest() {}

  explicit DeleteWaitingOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (waitingOrderId) {
      res["WaitingOrderId"] = boost::any(*waitingOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<long>(boost::any_cast<long>(m["ResourceGroupId"]));
    }
    if (m.find("WaitingOrderId") != m.end() && !m["WaitingOrderId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WaitingOrderId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WaitingOrderId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      waitingOrderId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteWaitingOrdersRequest() = default;
};
class DeleteWaitingOrdersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWaitingOrdersResponseBody() {}

  explicit DeleteWaitingOrdersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWaitingOrdersResponseBody() = default;
};
class DeleteWaitingOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWaitingOrdersResponseBody> body{};

  DeleteWaitingOrdersResponse() {}

  explicit DeleteWaitingOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWaitingOrdersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWaitingOrdersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWaitingOrdersResponse() = default;
};
class DescribeAccountAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> attributeName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  DescribeAccountAttributesRequest() {}

  explicit DescribeAccountAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttributeName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttributeName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attributeName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeAccountAttributesRequest() = default;
};
class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> diskCategory{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> value{};
  shared_ptr<string> zoneId{};

  DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem() {}

  explicit DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem() = default;
};
class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem>> valueItem{};

  DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues() {}

  explicit DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (valueItem) {
      vector<boost::any> temp1;
      for(auto item1:*valueItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ValueItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValueItem") != m.end() && !m["ValueItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ValueItem"].type()) {
        vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ValueItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        valueItem = make_shared<vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem>>(expect1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues() = default;
};
class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues> attributeValues{};

  DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem() {}

  explicit DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValues) {
      res["AttributeValues"] = attributeValues ? boost::any(attributeValues->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValues") != m.end() && !m["AttributeValues"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttributeValues"].type()) {
        DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttributeValues"]));
        attributeValues = make_shared<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues>(model1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem() = default;
};
class DescribeAccountAttributesResponseBodyAccountAttributeItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem>> accountAttributeItem{};

  DescribeAccountAttributesResponseBodyAccountAttributeItems() {}

  explicit DescribeAccountAttributesResponseBodyAccountAttributeItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountAttributeItem) {
      vector<boost::any> temp1;
      for(auto item1:*accountAttributeItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccountAttributeItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountAttributeItem") != m.end() && !m["AccountAttributeItem"].empty()) {
      if (typeid(vector<boost::any>) == m["AccountAttributeItem"].type()) {
        vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccountAttributeItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accountAttributeItem = make_shared<vector<DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem>>(expect1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponseBodyAccountAttributeItems() = default;
};
class DescribeAccountAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAccountAttributesResponseBodyAccountAttributeItems> accountAttributeItems{};
  shared_ptr<string> requestId{};

  DescribeAccountAttributesResponseBody() {}

  explicit DescribeAccountAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountAttributeItems) {
      res["AccountAttributeItems"] = accountAttributeItems ? boost::any(accountAttributeItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountAttributeItems") != m.end() && !m["AccountAttributeItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountAttributeItems"].type()) {
        DescribeAccountAttributesResponseBodyAccountAttributeItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountAttributeItems"]));
        accountAttributeItems = make_shared<DescribeAccountAttributesResponseBodyAccountAttributeItems>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAccountAttributesResponseBody() = default;
};
class DescribeAccountAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccountAttributesResponseBody> body{};

  DescribeAccountAttributesResponse() {}

  explicit DescribeAccountAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccountAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccountAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccountAttributesResponse() = default;
};
class DescribeAccountLimitsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeAccountLimitsRequestFilter() {}

  explicit DescribeAccountLimitsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAccountLimitsRequestFilter() = default;
};
class DescribeAccountLimitsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccountLimitsRequestFilter>> filter{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeAccountLimitsRequest() {}

  explicit DescribeAccountLimitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeAccountLimitsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccountLimitsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeAccountLimitsRequestFilter>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeAccountLimitsRequest() = default;
};
class DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet : public Darabonba::Model {
public:
  shared_ptr<vector<string>> limitValue{};

  DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet() {}

  explicit DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limitValue) {
      res["LimitValue"] = boost::any(*limitValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LimitValue") != m.end() && !m["LimitValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LimitValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LimitValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      limitValue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet() = default;
};
class DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit : public Darabonba::Model {
public:
  shared_ptr<string> limitName{};
  shared_ptr<DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet> limitValueSet{};

  DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit() {}

  explicit DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limitName) {
      res["LimitName"] = boost::any(*limitName);
    }
    if (limitValueSet) {
      res["LimitValueSet"] = limitValueSet ? boost::any(limitValueSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LimitName") != m.end() && !m["LimitName"].empty()) {
      limitName = make_shared<string>(boost::any_cast<string>(m["LimitName"]));
    }
    if (m.find("LimitValueSet") != m.end() && !m["LimitValueSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["LimitValueSet"].type()) {
        DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LimitValueSet"]));
        limitValueSet = make_shared<DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimitLimitValueSet>(model1);
      }
    }
  }


  virtual ~DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit() = default;
};
class DescribeAccountLimitsResponseBodyAccountLimitTypeSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit>> accountLimit{};

  DescribeAccountLimitsResponseBodyAccountLimitTypeSet() {}

  explicit DescribeAccountLimitsResponseBodyAccountLimitTypeSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountLimit) {
      vector<boost::any> temp1;
      for(auto item1:*accountLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccountLimit"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountLimit") != m.end() && !m["AccountLimit"].empty()) {
      if (typeid(vector<boost::any>) == m["AccountLimit"].type()) {
        vector<DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccountLimit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accountLimit = make_shared<vector<DescribeAccountLimitsResponseBodyAccountLimitTypeSetAccountLimit>>(expect1);
      }
    }
  }


  virtual ~DescribeAccountLimitsResponseBodyAccountLimitTypeSet() = default;
};
class DescribeAccountLimitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAccountLimitsResponseBodyAccountLimitTypeSet> accountLimitTypeSet{};
  shared_ptr<string> requestId{};

  DescribeAccountLimitsResponseBody() {}

  explicit DescribeAccountLimitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountLimitTypeSet) {
      res["AccountLimitTypeSet"] = accountLimitTypeSet ? boost::any(accountLimitTypeSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountLimitTypeSet") != m.end() && !m["AccountLimitTypeSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountLimitTypeSet"].type()) {
        DescribeAccountLimitsResponseBodyAccountLimitTypeSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountLimitTypeSet"]));
        accountLimitTypeSet = make_shared<DescribeAccountLimitsResponseBodyAccountLimitTypeSet>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAccountLimitsResponseBody() = default;
};
class DescribeAccountLimitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccountLimitsResponseBody> body{};

  DescribeAccountLimitsResponse() {}

  explicit DescribeAccountLimitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccountLimitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccountLimitsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccountLimitsResponse() = default;
};
class DescribeAccountQuotaAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeAccountQuotaAttributesRequest() {}

  explicit DescribeAccountQuotaAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeAccountQuotaAttributesRequest() = default;
};
class DescribeAccountQuotaAttributesResponseBodyQuotaAttributes : public Darabonba::Model {
public:
  shared_ptr<bool> ecsElasticQuotaEnable{};

  DescribeAccountQuotaAttributesResponseBodyQuotaAttributes() {}

  explicit DescribeAccountQuotaAttributesResponseBodyQuotaAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsElasticQuotaEnable) {
      res["EcsElasticQuotaEnable"] = boost::any(*ecsElasticQuotaEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsElasticQuotaEnable") != m.end() && !m["EcsElasticQuotaEnable"].empty()) {
      ecsElasticQuotaEnable = make_shared<bool>(boost::any_cast<bool>(m["EcsElasticQuotaEnable"]));
    }
  }


  virtual ~DescribeAccountQuotaAttributesResponseBodyQuotaAttributes() = default;
};
class DescribeAccountQuotaAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAccountQuotaAttributesResponseBodyQuotaAttributes> quotaAttributes{};
  shared_ptr<string> requestId{};

  DescribeAccountQuotaAttributesResponseBody() {}

  explicit DescribeAccountQuotaAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaAttributes) {
      res["QuotaAttributes"] = quotaAttributes ? boost::any(quotaAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaAttributes") != m.end() && !m["QuotaAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["QuotaAttributes"].type()) {
        DescribeAccountQuotaAttributesResponseBodyQuotaAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QuotaAttributes"]));
        quotaAttributes = make_shared<DescribeAccountQuotaAttributesResponseBodyQuotaAttributes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAccountQuotaAttributesResponseBody() = default;
};
class DescribeAccountQuotaAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccountQuotaAttributesResponseBody> body{};

  DescribeAccountQuotaAttributesResponse() {}

  explicit DescribeAccountQuotaAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccountQuotaAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccountQuotaAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccountQuotaAttributesResponse() = default;
};
class DescribeAutoProvisioningGroupCapacitiesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> autoProvisioningGroupId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeAutoProvisioningGroupCapacitiesRequest() {}

  explicit DescribeAutoProvisioningGroupCapacitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AutoProvisioningGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AutoProvisioningGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      autoProvisioningGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupCapacitiesRequest() = default;
};
class DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity : public Darabonba::Model {
public:
  shared_ptr<string> autoProvisioningGroupId{};
  shared_ptr<string> payAsYouGoCapacity{};
  shared_ptr<string> spotCapacity{};
  shared_ptr<string> totalCapacity{};

  DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity() {}

  explicit DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoProvisioningGroupId) {
      res["AutoProvisioningGroupId"] = boost::any(*autoProvisioningGroupId);
    }
    if (payAsYouGoCapacity) {
      res["PayAsYouGoCapacity"] = boost::any(*payAsYouGoCapacity);
    }
    if (spotCapacity) {
      res["SpotCapacity"] = boost::any(*spotCapacity);
    }
    if (totalCapacity) {
      res["TotalCapacity"] = boost::any(*totalCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoProvisioningGroupId") != m.end() && !m["AutoProvisioningGroupId"].empty()) {
      autoProvisioningGroupId = make_shared<string>(boost::any_cast<string>(m["AutoProvisioningGroupId"]));
    }
    if (m.find("PayAsYouGoCapacity") != m.end() && !m["PayAsYouGoCapacity"].empty()) {
      payAsYouGoCapacity = make_shared<string>(boost::any_cast<string>(m["PayAsYouGoCapacity"]));
    }
    if (m.find("SpotCapacity") != m.end() && !m["SpotCapacity"].empty()) {
      spotCapacity = make_shared<string>(boost::any_cast<string>(m["SpotCapacity"]));
    }
    if (m.find("TotalCapacity") != m.end() && !m["TotalCapacity"].empty()) {
      totalCapacity = make_shared<string>(boost::any_cast<string>(m["TotalCapacity"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity() = default;
};
class DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity>> capacity{};

  DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities() {}

  explicit DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacity) {
      vector<boost::any> temp1;
      for(auto item1:*capacity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Capacity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      if (typeid(vector<boost::any>) == m["Capacity"].type()) {
        vector<DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Capacity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        capacity = make_shared<vector<DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacitiesCapacity>>(expect1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities() = default;
};
class DescribeAutoProvisioningGroupCapacitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities> capacities{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeAutoProvisioningGroupCapacitiesResponseBody() {}

  explicit DescribeAutoProvisioningGroupCapacitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacities) {
      res["Capacities"] = capacities ? boost::any(capacities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capacities") != m.end() && !m["Capacities"].empty()) {
      if (typeid(map<string, boost::any>) == m["Capacities"].type()) {
        DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Capacities"]));
        capacities = make_shared<DescribeAutoProvisioningGroupCapacitiesResponseBodyCapacities>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAutoProvisioningGroupCapacitiesResponseBody() = default;
};
class DescribeAutoProvisioningGroupCapacitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoProvisioningGroupCapacitiesResponseBody> body{};

  DescribeAutoProvisioningGroupCapacitiesResponse() {}

  explicit DescribeAutoProvisioningGroupCapacitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoProvisioningGroupCapacitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoProvisioningGroupCapacitiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoProvisioningGroupCapacitiesResponse() = default;
};
class DescribeBandwidthPriceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> priceUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> verbose{};

  DescribeBandwidthPriceRequest() {}

  explicit DescribeBandwidthPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priceUnit) {
      res["PriceUnit"] = boost::any(*priceUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (verbose) {
      res["Verbose"] = boost::any(*verbose);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PriceUnit") != m.end() && !m["PriceUnit"].empty()) {
      priceUnit = make_shared<string>(boost::any_cast<string>(m["PriceUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Verbose") != m.end() && !m["Verbose"].empty()) {
      verbose = make_shared<bool>(boost::any_cast<bool>(m["Verbose"]));
    }
  }


  virtual ~DescribeBandwidthPriceRequest() = default;
};
class DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ruleId{};

  DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet() {}

  explicit DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet() = default;
};
class DescribeBandwidthPriceResponseBodyPriceInfoOrder : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> originalPrice{};
  shared_ptr<DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet> ruleIdSet{};
  shared_ptr<double> tradePrice{};

  DescribeBandwidthPriceResponseBodyPriceInfoOrder() {}

  explicit DescribeBandwidthPriceResponseBodyPriceInfoOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (ruleIdSet) {
      res["RuleIdSet"] = ruleIdSet ? boost::any(ruleIdSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("RuleIdSet") != m.end() && !m["RuleIdSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleIdSet"].type()) {
        DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleIdSet"]));
        ruleIdSet = make_shared<DescribeBandwidthPriceResponseBodyPriceInfoOrderRuleIdSet>(model1);
      }
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeBandwidthPriceResponseBodyPriceInfoOrder() = default;
};
class DescribeBandwidthPriceResponseBodyPriceInfoRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> title{};

  DescribeBandwidthPriceResponseBodyPriceInfoRulesRule() {}

  explicit DescribeBandwidthPriceResponseBodyPriceInfoRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeBandwidthPriceResponseBodyPriceInfoRulesRule() = default;
};
class DescribeBandwidthPriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBandwidthPriceResponseBodyPriceInfoRulesRule>> rule{};

  DescribeBandwidthPriceResponseBodyPriceInfoRules() {}

  explicit DescribeBandwidthPriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribeBandwidthPriceResponseBodyPriceInfoRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBandwidthPriceResponseBodyPriceInfoRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribeBandwidthPriceResponseBodyPriceInfoRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribeBandwidthPriceResponseBodyPriceInfoRules() = default;
};
class DescribeBandwidthPriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeBandwidthPriceResponseBodyPriceInfoOrder> order{};
  shared_ptr<DescribeBandwidthPriceResponseBodyPriceInfoRules> rules{};

  DescribeBandwidthPriceResponseBodyPriceInfo() {}

  explicit DescribeBandwidthPriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = order ? boost::any(order->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      if (typeid(map<string, boost::any>) == m["Order"].type()) {
        DescribeBandwidthPriceResponseBodyPriceInfoOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Order"]));
        order = make_shared<DescribeBandwidthPriceResponseBodyPriceInfoOrder>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribeBandwidthPriceResponseBodyPriceInfoRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribeBandwidthPriceResponseBodyPriceInfoRules>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthPriceResponseBodyPriceInfo() = default;
};
class DescribeBandwidthPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBandwidthPriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribeBandwidthPriceResponseBody() {}

  explicit DescribeBandwidthPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeBandwidthPriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeBandwidthPriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBandwidthPriceResponseBody() = default;
};
class DescribeBandwidthPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBandwidthPriceResponseBody> body{};

  DescribeBandwidthPriceResponse() {}

  explicit DescribeBandwidthPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandwidthPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandwidthPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthPriceResponse() = default;
};
class DescribeCapacityReservationsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCapacityReservationsRequestTag() {}

  explicit DescribeCapacityReservationsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCapacityReservationsRequestTag() = default;
};
class DescribeCapacityReservationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> capacityReservationIds{};
  shared_ptr<string> capacityReservationName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeCapacityReservationsRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  DescribeCapacityReservationsRequest() {}

  explicit DescribeCapacityReservationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservationIds) {
      res["CapacityReservationIds"] = boost::any(*capacityReservationIds);
    }
    if (capacityReservationName) {
      res["CapacityReservationName"] = boost::any(*capacityReservationName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservationIds") != m.end() && !m["CapacityReservationIds"].empty()) {
      capacityReservationIds = make_shared<string>(boost::any_cast<string>(m["CapacityReservationIds"]));
    }
    if (m.find("CapacityReservationName") != m.end() && !m["CapacityReservationName"].empty()) {
      capacityReservationName = make_shared<string>(boost::any_cast<string>(m["CapacityReservationName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCapacityReservationsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCapacityReservationsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCapacityReservationsRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeCapacityReservationsRequest() = default;
};
class DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation : public Darabonba::Model {
public:
  shared_ptr<long> availableInstanceCount{};
  shared_ptr<string> capacityReservationId{};
  shared_ptr<string> capacityReservationName{};
  shared_ptr<string> description{};
  shared_ptr<string> endDateType{};
  shared_ptr<string> instanceMatchCriteria{};
  shared_ptr<string> instancePlatform{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> timeSlot{};
  shared_ptr<long> totalInstanceCount{};
  shared_ptr<string> zoneId{};

  DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation() {}

  explicit DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableInstanceCount) {
      res["AvailableInstanceCount"] = boost::any(*availableInstanceCount);
    }
    if (capacityReservationId) {
      res["CapacityReservationId"] = boost::any(*capacityReservationId);
    }
    if (capacityReservationName) {
      res["CapacityReservationName"] = boost::any(*capacityReservationName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endDateType) {
      res["EndDateType"] = boost::any(*endDateType);
    }
    if (instanceMatchCriteria) {
      res["InstanceMatchCriteria"] = boost::any(*instanceMatchCriteria);
    }
    if (instancePlatform) {
      res["InstancePlatform"] = boost::any(*instancePlatform);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeSlot) {
      res["TimeSlot"] = boost::any(*timeSlot);
    }
    if (totalInstanceCount) {
      res["TotalInstanceCount"] = boost::any(*totalInstanceCount);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableInstanceCount") != m.end() && !m["AvailableInstanceCount"].empty()) {
      availableInstanceCount = make_shared<long>(boost::any_cast<long>(m["AvailableInstanceCount"]));
    }
    if (m.find("CapacityReservationId") != m.end() && !m["CapacityReservationId"].empty()) {
      capacityReservationId = make_shared<string>(boost::any_cast<string>(m["CapacityReservationId"]));
    }
    if (m.find("CapacityReservationName") != m.end() && !m["CapacityReservationName"].empty()) {
      capacityReservationName = make_shared<string>(boost::any_cast<string>(m["CapacityReservationName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndDateType") != m.end() && !m["EndDateType"].empty()) {
      endDateType = make_shared<string>(boost::any_cast<string>(m["EndDateType"]));
    }
    if (m.find("InstanceMatchCriteria") != m.end() && !m["InstanceMatchCriteria"].empty()) {
      instanceMatchCriteria = make_shared<string>(boost::any_cast<string>(m["InstanceMatchCriteria"]));
    }
    if (m.find("InstancePlatform") != m.end() && !m["InstancePlatform"].empty()) {
      instancePlatform = make_shared<string>(boost::any_cast<string>(m["InstancePlatform"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeSlot") != m.end() && !m["TimeSlot"].empty()) {
      timeSlot = make_shared<string>(boost::any_cast<string>(m["TimeSlot"]));
    }
    if (m.find("TotalInstanceCount") != m.end() && !m["TotalInstanceCount"].empty()) {
      totalInstanceCount = make_shared<long>(boost::any_cast<long>(m["TotalInstanceCount"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation() = default;
};
class DescribeCapacityReservationsResponseBodyCapacityReservations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation>> capacityReservation{};

  DescribeCapacityReservationsResponseBodyCapacityReservations() {}

  explicit DescribeCapacityReservationsResponseBodyCapacityReservations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservation) {
      vector<boost::any> temp1;
      for(auto item1:*capacityReservation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CapacityReservation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservation") != m.end() && !m["CapacityReservation"].empty()) {
      if (typeid(vector<boost::any>) == m["CapacityReservation"].type()) {
        vector<DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CapacityReservation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        capacityReservation = make_shared<vector<DescribeCapacityReservationsResponseBodyCapacityReservationsCapacityReservation>>(expect1);
      }
    }
  }


  virtual ~DescribeCapacityReservationsResponseBodyCapacityReservations() = default;
};
class DescribeCapacityReservationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCapacityReservationsResponseBodyCapacityReservations> capacityReservations{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCapacityReservationsResponseBody() {}

  explicit DescribeCapacityReservationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservations) {
      res["CapacityReservations"] = capacityReservations ? boost::any(capacityReservations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservations") != m.end() && !m["CapacityReservations"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityReservations"].type()) {
        DescribeCapacityReservationsResponseBodyCapacityReservations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityReservations"]));
        capacityReservations = make_shared<DescribeCapacityReservationsResponseBodyCapacityReservations>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCapacityReservationsResponseBody() = default;
};
class DescribeCapacityReservationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCapacityReservationsResponseBody> body{};

  DescribeCapacityReservationsResponse() {}

  explicit DescribeCapacityReservationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCapacityReservationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCapacityReservationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCapacityReservationsResponse() = default;
};
class DescribeCustomerIssueCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> layer{};
  shared_ptr<string> regionId{};

  DescribeCustomerIssueCategoryRequest() {}

  explicit DescribeCustomerIssueCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<long>(boost::any_cast<long>(m["Layer"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCustomerIssueCategoryRequest() = default;
};
class DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList : public Darabonba::Model {
public:
  shared_ptr<long> issueCategoryId{};
  shared_ptr<string> issueCategoryName{};
  shared_ptr<long> issueCategoryParentId{};
  shared_ptr<long> layer{};
  shared_ptr<string> mappingTools{};
  shared_ptr<string> metricSetId{};
  shared_ptr<string> resourceType{};

  DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList() {}

  explicit DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (issueCategoryId) {
      res["IssueCategoryId"] = boost::any(*issueCategoryId);
    }
    if (issueCategoryName) {
      res["IssueCategoryName"] = boost::any(*issueCategoryName);
    }
    if (issueCategoryParentId) {
      res["IssueCategoryParentId"] = boost::any(*issueCategoryParentId);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (mappingTools) {
      res["MappingTools"] = boost::any(*mappingTools);
    }
    if (metricSetId) {
      res["MetricSetId"] = boost::any(*metricSetId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IssueCategoryId") != m.end() && !m["IssueCategoryId"].empty()) {
      issueCategoryId = make_shared<long>(boost::any_cast<long>(m["IssueCategoryId"]));
    }
    if (m.find("IssueCategoryName") != m.end() && !m["IssueCategoryName"].empty()) {
      issueCategoryName = make_shared<string>(boost::any_cast<string>(m["IssueCategoryName"]));
    }
    if (m.find("IssueCategoryParentId") != m.end() && !m["IssueCategoryParentId"].empty()) {
      issueCategoryParentId = make_shared<long>(boost::any_cast<long>(m["IssueCategoryParentId"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<long>(boost::any_cast<long>(m["Layer"]));
    }
    if (m.find("MappingTools") != m.end() && !m["MappingTools"].empty()) {
      mappingTools = make_shared<string>(boost::any_cast<string>(m["MappingTools"]));
    }
    if (m.find("MetricSetId") != m.end() && !m["MetricSetId"].empty()) {
      metricSetId = make_shared<string>(boost::any_cast<string>(m["MetricSetId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList() = default;
};
class DescribeCustomerIssueCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList>> issueCategoryModelList{};
  shared_ptr<string> requestId{};

  DescribeCustomerIssueCategoryResponseBody() {}

  explicit DescribeCustomerIssueCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (issueCategoryModelList) {
      vector<boost::any> temp1;
      for(auto item1:*issueCategoryModelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IssueCategoryModelList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IssueCategoryModelList") != m.end() && !m["IssueCategoryModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["IssueCategoryModelList"].type()) {
        vector<DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IssueCategoryModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        issueCategoryModelList = make_shared<vector<DescribeCustomerIssueCategoryResponseBodyIssueCategoryModelList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCustomerIssueCategoryResponseBody() = default;
};
class DescribeCustomerIssueCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomerIssueCategoryResponseBody> body{};

  DescribeCustomerIssueCategoryResponse() {}

  explicit DescribeCustomerIssueCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomerIssueCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomerIssueCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomerIssueCategoryResponse() = default;
};
class DescribeDedicatedHostAutoRenewRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  DescribeDedicatedHostAutoRenewRequest() {}

  explicit DescribeDedicatedHostAutoRenewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewRequest() = default;
};
class DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenewEnabled{};
  shared_ptr<long> duration{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> renewalStatus{};

  DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute() {}

  explicit DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewEnabled) {
      res["AutoRenewEnabled"] = boost::any(*autoRenewEnabled);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenewEnabled") != m.end() && !m["AutoRenewEnabled"].empty()) {
      autoRenewEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewEnabled"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute() = default;
};
class DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute>> instanceRenewAttribute{};

  DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes() {}

  explicit DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRenewAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*instanceRenewAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceRenewAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRenewAttribute") != m.end() && !m["InstanceRenewAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceRenewAttribute"].type()) {
        vector<DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceRenewAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceRenewAttribute = make_shared<vector<DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributesInstanceRenewAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes() = default;
};
class DescribeDedicatedHostAutoRenewResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes> instanceRenewAttributes{};
  shared_ptr<string> requestId{};

  DescribeDedicatedHostAutoRenewResponseBody() {}

  explicit DescribeDedicatedHostAutoRenewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRenewAttributes) {
      res["InstanceRenewAttributes"] = instanceRenewAttributes ? boost::any(instanceRenewAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRenewAttributes") != m.end() && !m["InstanceRenewAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceRenewAttributes"].type()) {
        DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceRenewAttributes"]));
        instanceRenewAttributes = make_shared<DescribeDedicatedHostAutoRenewResponseBodyInstanceRenewAttributes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewResponseBody() = default;
};
class DescribeDedicatedHostAutoRenewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDedicatedHostAutoRenewResponseBody> body{};

  DescribeDedicatedHostAutoRenewResponse() {}

  explicit DescribeDedicatedHostAutoRenewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostAutoRenewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostAutoRenewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostAutoRenewResponse() = default;
};
class DescribeDedicatedHostClustersRequestSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> managedPrivateSpaceId{};

  DescribeDedicatedHostClustersRequestSchedulerOptions() {}

  explicit DescribeDedicatedHostClustersRequestSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedPrivateSpaceId) {
      res["ManagedPrivateSpaceId"] = boost::any(*managedPrivateSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedPrivateSpaceId") != m.end() && !m["ManagedPrivateSpaceId"].empty()) {
      managedPrivateSpaceId = make_shared<string>(boost::any_cast<string>(m["ManagedPrivateSpaceId"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersRequestSchedulerOptions() = default;
};
class DescribeDedicatedHostClustersRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDedicatedHostClustersRequestTag() {}

  explicit DescribeDedicatedHostClustersRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersRequestTag() = default;
};
class DescribeDedicatedHostClustersRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostClustersRequestSchedulerOptions> schedulerOptions{};
  shared_ptr<string> dedicatedHostClusterIds{};
  shared_ptr<string> dedicatedHostClusterName{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeDedicatedHostClustersRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  DescribeDedicatedHostClustersRequest() {}

  explicit DescribeDedicatedHostClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostClusterIds) {
      res["DedicatedHostClusterIds"] = boost::any(*dedicatedHostClusterIds);
    }
    if (dedicatedHostClusterName) {
      res["DedicatedHostClusterName"] = boost::any(*dedicatedHostClusterName);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        DescribeDedicatedHostClustersRequestSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<DescribeDedicatedHostClustersRequestSchedulerOptions>(model1);
      }
    }
    if (m.find("DedicatedHostClusterIds") != m.end() && !m["DedicatedHostClusterIds"].empty()) {
      dedicatedHostClusterIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterIds"]));
    }
    if (m.find("DedicatedHostClusterName") != m.end() && !m["DedicatedHostClusterName"].empty()) {
      dedicatedHostClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterName"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDedicatedHostClustersRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDedicatedHostClustersRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersRequest() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> managedPrivateSpaceId{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedPrivateSpaceId) {
      res["ManagedPrivateSpaceId"] = boost::any(*managedPrivateSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedPrivateSpaceId") != m.end() && !m["ManagedPrivateSpaceId"].empty()) {
      managedPrivateSpaceId = make_shared<string>(boost::any_cast<string>(m["ManagedPrivateSpaceId"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType : public Darabonba::Model {
public:
  shared_ptr<long> availableInstanceCapacity{};
  shared_ptr<string> instanceType{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableInstanceCapacity) {
      res["AvailableInstanceCapacity"] = boost::any(*availableInstanceCapacity);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableInstanceCapacity") != m.end() && !m["AvailableInstanceCapacity"].empty()) {
      availableInstanceCapacity = make_shared<long>(boost::any_cast<long>(m["AvailableInstanceCapacity"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType>> availableInstanceType{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableInstanceType) {
      vector<boost::any> temp1;
      for(auto item1:*availableInstanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableInstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableInstanceType") != m.end() && !m["AvailableInstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableInstanceType"].type()) {
        vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableInstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableInstanceType = make_shared<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity : public Darabonba::Model {
public:
  shared_ptr<long> availableDisk{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<long> totalDisk{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableDisk) {
      res["AvailableDisk"] = boost::any(*availableDisk);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (totalDisk) {
      res["TotalDisk"] = boost::any(*totalDisk);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableDisk") != m.end() && !m["AvailableDisk"].empty()) {
      availableDisk = make_shared<long>(boost::any_cast<long>(m["AvailableDisk"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("TotalDisk") != m.end() && !m["TotalDisk"].empty()) {
      totalDisk = make_shared<long>(boost::any_cast<long>(m["TotalDisk"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity>> localStorageCapacity{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localStorageCapacity) {
      vector<boost::any> temp1;
      for(auto item1:*localStorageCapacity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LocalStorageCapacity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalStorageCapacity") != m.end() && !m["LocalStorageCapacity"].empty()) {
      if (typeid(vector<boost::any>) == m["LocalStorageCapacity"].type()) {
        vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LocalStorageCapacity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        localStorageCapacity = make_shared<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes> availableInstanceTypes{};
  shared_ptr<long> availableMemory{};
  shared_ptr<long> availableVcpus{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities> localStorageCapacities{};
  shared_ptr<long> totalMemory{};
  shared_ptr<long> totalVcpus{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableInstanceTypes) {
      res["AvailableInstanceTypes"] = availableInstanceTypes ? boost::any(availableInstanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableMemory) {
      res["AvailableMemory"] = boost::any(*availableMemory);
    }
    if (availableVcpus) {
      res["AvailableVcpus"] = boost::any(*availableVcpus);
    }
    if (localStorageCapacities) {
      res["LocalStorageCapacities"] = localStorageCapacities ? boost::any(localStorageCapacities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (totalVcpus) {
      res["TotalVcpus"] = boost::any(*totalVcpus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableInstanceTypes") != m.end() && !m["AvailableInstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableInstanceTypes"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableInstanceTypes"]));
        availableInstanceTypes = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes>(model1);
      }
    }
    if (m.find("AvailableMemory") != m.end() && !m["AvailableMemory"].empty()) {
      availableMemory = make_shared<long>(boost::any_cast<long>(m["AvailableMemory"]));
    }
    if (m.find("AvailableVcpus") != m.end() && !m["AvailableVcpus"].empty()) {
      availableVcpus = make_shared<long>(boost::any_cast<long>(m["AvailableVcpus"]));
    }
    if (m.find("LocalStorageCapacities") != m.end() && !m["LocalStorageCapacities"].empty()) {
      if (typeid(map<string, boost::any>) == m["LocalStorageCapacities"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LocalStorageCapacities"]));
        localStorageCapacities = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities>(model1);
      }
    }
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<long>(boost::any_cast<long>(m["TotalMemory"]));
    }
    if (m.find("TotalVcpus") != m.end() && !m["TotalVcpus"].empty()) {
      totalVcpus = make_shared<long>(boost::any_cast<long>(m["TotalVcpus"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dedicatedHostId{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DedicatedHostId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DedicatedHostId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dedicatedHostId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag>> tag{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions> schedulerOptions{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity> dedicatedHostClusterCapacity{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostClusterName{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds> dedicatedHostIds{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags> tags{};
  shared_ptr<string> zoneId{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!schedulerOptions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerOptions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostClusterCapacity) {
      res["DedicatedHostClusterCapacity"] = dedicatedHostClusterCapacity ? boost::any(dedicatedHostClusterCapacity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostClusterName) {
      res["DedicatedHostClusterName"] = boost::any(*dedicatedHostClusterName);
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = dedicatedHostIds ? boost::any(dedicatedHostIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterSchedulerOptions>(model1);
      }
    }
    if (m.find("DedicatedHostClusterCapacity") != m.end() && !m["DedicatedHostClusterCapacity"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostClusterCapacity"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostClusterCapacity"]));
        dedicatedHostClusterCapacity = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity>(model1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostClusterName") != m.end() && !m["DedicatedHostClusterName"].empty()) {
      dedicatedHostClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterName"]));
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostIds"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostIds"]));
        dedicatedHostIds = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags>(model1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster() = default;
};
class DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster>> dedicatedHostCluster{};

  DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters() {}

  explicit DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostCluster) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHostCluster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHostCluster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostCluster") != m.end() && !m["DedicatedHostCluster"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHostCluster"].type()) {
        vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHostCluster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHostCluster = make_shared<vector<DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters() = default;
};
class DescribeDedicatedHostClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters> dedicatedHostClusters{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDedicatedHostClustersResponseBody() {}

  explicit DescribeDedicatedHostClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostClusters) {
      res["DedicatedHostClusters"] = dedicatedHostClusters ? boost::any(dedicatedHostClusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostClusters") != m.end() && !m["DedicatedHostClusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostClusters"].type()) {
        DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostClusters"]));
        dedicatedHostClusters = make_shared<DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDedicatedHostClustersResponseBody() = default;
};
class DescribeDedicatedHostClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDedicatedHostClustersResponseBody> body{};

  DescribeDedicatedHostClustersResponse() {}

  explicit DescribeDedicatedHostClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostClustersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostClustersResponse() = default;
};
class DescribeDedicatedHostTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> generation{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> supportInstanceTypeFamily{};

  DescribeDedicatedHostTypesRequest() {}

  explicit DescribeDedicatedHostTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (generation) {
      res["Generation"] = boost::any(*generation);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (supportInstanceTypeFamily) {
      res["SupportInstanceTypeFamily"] = boost::any(*supportInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("Generation") != m.end() && !m["Generation"].empty()) {
      generation = make_shared<string>(boost::any_cast<string>(m["Generation"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SupportInstanceTypeFamily") != m.end() && !m["SupportInstanceTypeFamily"].empty()) {
      supportInstanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["SupportInstanceTypeFamily"]));
    }
  }


  virtual ~DescribeDedicatedHostTypesRequest() = default;
};
class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportInstanceTypeFamily{};

  DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies() {}

  explicit DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportInstanceTypeFamily) {
      res["SupportInstanceTypeFamily"] = boost::any(*supportInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportInstanceTypeFamily") != m.end() && !m["SupportInstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportInstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportInstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportInstanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies() = default;
};
class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportInstanceTypesList{};

  DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList() {}

  explicit DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportInstanceTypesList) {
      res["SupportInstanceTypesList"] = boost::any(*supportInstanceTypesList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportInstanceTypesList") != m.end() && !m["SupportInstanceTypesList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportInstanceTypesList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportInstanceTypesList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportInstanceTypesList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList() = default;
};
class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType : public Darabonba::Model {
public:
  shared_ptr<string> cpuOverCommitRatioRange{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> GPUSpec{};
  shared_ptr<string> generation{};
  shared_ptr<long> localStorageAmount{};
  shared_ptr<long> localStorageCapacity{};
  shared_ptr<string> localStorageCategory{};
  shared_ptr<double> memorySize{};
  shared_ptr<long> physicalGpus{};
  shared_ptr<bool> supportCpuOverCommitRatio{};
  shared_ptr<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies> supportInstanceTypeFamilies{};
  shared_ptr<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList> supportInstanceTypesList{};
  shared_ptr<long> totalPhysicalCores{};
  shared_ptr<long> totalSockets{};
  shared_ptr<long> totalVcpus{};
  shared_ptr<long> totalVgpus{};

  DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType() {}

  explicit DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuOverCommitRatioRange) {
      res["CpuOverCommitRatioRange"] = boost::any(*cpuOverCommitRatioRange);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (GPUSpec) {
      res["GPUSpec"] = boost::any(*GPUSpec);
    }
    if (generation) {
      res["Generation"] = boost::any(*generation);
    }
    if (localStorageAmount) {
      res["LocalStorageAmount"] = boost::any(*localStorageAmount);
    }
    if (localStorageCapacity) {
      res["LocalStorageCapacity"] = boost::any(*localStorageCapacity);
    }
    if (localStorageCategory) {
      res["LocalStorageCategory"] = boost::any(*localStorageCategory);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    if (physicalGpus) {
      res["PhysicalGpus"] = boost::any(*physicalGpus);
    }
    if (supportCpuOverCommitRatio) {
      res["SupportCpuOverCommitRatio"] = boost::any(*supportCpuOverCommitRatio);
    }
    if (supportInstanceTypeFamilies) {
      res["SupportInstanceTypeFamilies"] = supportInstanceTypeFamilies ? boost::any(supportInstanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportInstanceTypesList) {
      res["SupportInstanceTypesList"] = supportInstanceTypesList ? boost::any(supportInstanceTypesList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalPhysicalCores) {
      res["TotalPhysicalCores"] = boost::any(*totalPhysicalCores);
    }
    if (totalSockets) {
      res["TotalSockets"] = boost::any(*totalSockets);
    }
    if (totalVcpus) {
      res["TotalVcpus"] = boost::any(*totalVcpus);
    }
    if (totalVgpus) {
      res["TotalVgpus"] = boost::any(*totalVgpus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuOverCommitRatioRange") != m.end() && !m["CpuOverCommitRatioRange"].empty()) {
      cpuOverCommitRatioRange = make_shared<string>(boost::any_cast<string>(m["CpuOverCommitRatioRange"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("GPUSpec") != m.end() && !m["GPUSpec"].empty()) {
      GPUSpec = make_shared<string>(boost::any_cast<string>(m["GPUSpec"]));
    }
    if (m.find("Generation") != m.end() && !m["Generation"].empty()) {
      generation = make_shared<string>(boost::any_cast<string>(m["Generation"]));
    }
    if (m.find("LocalStorageAmount") != m.end() && !m["LocalStorageAmount"].empty()) {
      localStorageAmount = make_shared<long>(boost::any_cast<long>(m["LocalStorageAmount"]));
    }
    if (m.find("LocalStorageCapacity") != m.end() && !m["LocalStorageCapacity"].empty()) {
      localStorageCapacity = make_shared<long>(boost::any_cast<long>(m["LocalStorageCapacity"]));
    }
    if (m.find("LocalStorageCategory") != m.end() && !m["LocalStorageCategory"].empty()) {
      localStorageCategory = make_shared<string>(boost::any_cast<string>(m["LocalStorageCategory"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<double>(boost::any_cast<double>(m["MemorySize"]));
    }
    if (m.find("PhysicalGpus") != m.end() && !m["PhysicalGpus"].empty()) {
      physicalGpus = make_shared<long>(boost::any_cast<long>(m["PhysicalGpus"]));
    }
    if (m.find("SupportCpuOverCommitRatio") != m.end() && !m["SupportCpuOverCommitRatio"].empty()) {
      supportCpuOverCommitRatio = make_shared<bool>(boost::any_cast<bool>(m["SupportCpuOverCommitRatio"]));
    }
    if (m.find("SupportInstanceTypeFamilies") != m.end() && !m["SupportInstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportInstanceTypeFamilies"].type()) {
        DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportInstanceTypeFamilies"]));
        supportInstanceTypeFamilies = make_shared<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypeFamilies>(model1);
      }
    }
    if (m.find("SupportInstanceTypesList") != m.end() && !m["SupportInstanceTypesList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportInstanceTypesList"].type()) {
        DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportInstanceTypesList"]));
        supportInstanceTypesList = make_shared<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportInstanceTypesList>(model1);
      }
    }
    if (m.find("TotalPhysicalCores") != m.end() && !m["TotalPhysicalCores"].empty()) {
      totalPhysicalCores = make_shared<long>(boost::any_cast<long>(m["TotalPhysicalCores"]));
    }
    if (m.find("TotalSockets") != m.end() && !m["TotalSockets"].empty()) {
      totalSockets = make_shared<long>(boost::any_cast<long>(m["TotalSockets"]));
    }
    if (m.find("TotalVcpus") != m.end() && !m["TotalVcpus"].empty()) {
      totalVcpus = make_shared<long>(boost::any_cast<long>(m["TotalVcpus"]));
    }
    if (m.find("TotalVgpus") != m.end() && !m["TotalVgpus"].empty()) {
      totalVgpus = make_shared<long>(boost::any_cast<long>(m["TotalVgpus"]));
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType() = default;
};
class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType>> dedicatedHostType{};

  DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes() {}

  explicit DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostType) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHostType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHostType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHostType"].type()) {
        vector<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHostType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHostType = make_shared<vector<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes() = default;
};
class DescribeDedicatedHostTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes> dedicatedHostTypes{};
  shared_ptr<string> requestId{};

  DescribeDedicatedHostTypesResponseBody() {}

  explicit DescribeDedicatedHostTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostTypes) {
      res["DedicatedHostTypes"] = dedicatedHostTypes ? boost::any(dedicatedHostTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostTypes") != m.end() && !m["DedicatedHostTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostTypes"].type()) {
        DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostTypes"]));
        dedicatedHostTypes = make_shared<DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDedicatedHostTypesResponseBody() = default;
};
class DescribeDedicatedHostTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDedicatedHostTypesResponseBody> body{};

  DescribeDedicatedHostTypesResponse() {}

  explicit DescribeDedicatedHostTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostTypesResponse() = default;
};
class DescribeDedicatedHostsRequestSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> managedPrivateSpaceId{};

  DescribeDedicatedHostsRequestSchedulerOptions() {}

  explicit DescribeDedicatedHostsRequestSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedPrivateSpaceId) {
      res["ManagedPrivateSpaceId"] = boost::any(*managedPrivateSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedPrivateSpaceId") != m.end() && !m["ManagedPrivateSpaceId"].empty()) {
      managedPrivateSpaceId = make_shared<string>(boost::any_cast<string>(m["ManagedPrivateSpaceId"]));
    }
  }


  virtual ~DescribeDedicatedHostsRequestSchedulerOptions() = default;
};
class DescribeDedicatedHostsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDedicatedHostsRequestTag() {}

  explicit DescribeDedicatedHostsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDedicatedHostsRequestTag() = default;
};
class DescribeDedicatedHostsRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostsRequestSchedulerOptions> schedulerOptions{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostIds{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeDedicatedHostsRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  DescribeDedicatedHostsRequest() {}

  explicit DescribeDedicatedHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = boost::any(*dedicatedHostIds);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        DescribeDedicatedHostsRequestSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<DescribeDedicatedHostsRequestSchedulerOptions>(model1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      dedicatedHostIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIds"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDedicatedHostsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDedicatedHostsRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDedicatedHostsRequest() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> managedPrivateSpaceId{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedPrivateSpaceId) {
      res["ManagedPrivateSpaceId"] = boost::any(*managedPrivateSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedPrivateSpaceId") != m.end() && !m["ManagedPrivateSpaceId"].empty()) {
      managedPrivateSpaceId = make_shared<string>(boost::any_cast<string>(m["ManagedPrivateSpaceId"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity : public Darabonba::Model {
public:
  shared_ptr<long> availableLocalStorage{};
  shared_ptr<double> availableMemory{};
  shared_ptr<long> availableVcpus{};
  shared_ptr<long> availableVgpus{};
  shared_ptr<string> localStorageCategory{};
  shared_ptr<long> totalLocalStorage{};
  shared_ptr<double> totalMemory{};
  shared_ptr<long> totalVcpus{};
  shared_ptr<long> totalVgpus{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableLocalStorage) {
      res["AvailableLocalStorage"] = boost::any(*availableLocalStorage);
    }
    if (availableMemory) {
      res["AvailableMemory"] = boost::any(*availableMemory);
    }
    if (availableVcpus) {
      res["AvailableVcpus"] = boost::any(*availableVcpus);
    }
    if (availableVgpus) {
      res["AvailableVgpus"] = boost::any(*availableVgpus);
    }
    if (localStorageCategory) {
      res["LocalStorageCategory"] = boost::any(*localStorageCategory);
    }
    if (totalLocalStorage) {
      res["TotalLocalStorage"] = boost::any(*totalLocalStorage);
    }
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (totalVcpus) {
      res["TotalVcpus"] = boost::any(*totalVcpus);
    }
    if (totalVgpus) {
      res["TotalVgpus"] = boost::any(*totalVgpus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableLocalStorage") != m.end() && !m["AvailableLocalStorage"].empty()) {
      availableLocalStorage = make_shared<long>(boost::any_cast<long>(m["AvailableLocalStorage"]));
    }
    if (m.find("AvailableMemory") != m.end() && !m["AvailableMemory"].empty()) {
      availableMemory = make_shared<double>(boost::any_cast<double>(m["AvailableMemory"]));
    }
    if (m.find("AvailableVcpus") != m.end() && !m["AvailableVcpus"].empty()) {
      availableVcpus = make_shared<long>(boost::any_cast<long>(m["AvailableVcpus"]));
    }
    if (m.find("AvailableVgpus") != m.end() && !m["AvailableVgpus"].empty()) {
      availableVgpus = make_shared<long>(boost::any_cast<long>(m["AvailableVgpus"]));
    }
    if (m.find("LocalStorageCategory") != m.end() && !m["LocalStorageCategory"].empty()) {
      localStorageCategory = make_shared<string>(boost::any_cast<string>(m["LocalStorageCategory"]));
    }
    if (m.find("TotalLocalStorage") != m.end() && !m["TotalLocalStorage"].empty()) {
      totalLocalStorage = make_shared<long>(boost::any_cast<long>(m["TotalLocalStorage"]));
    }
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<double>(boost::any_cast<double>(m["TotalMemory"]));
    }
    if (m.find("TotalVcpus") != m.end() && !m["TotalVcpus"].empty()) {
      totalVcpus = make_shared<long>(boost::any_cast<long>(m["TotalVcpus"]));
    }
    if (m.find("TotalVgpus") != m.end() && !m["TotalVgpus"].empty()) {
      totalVgpus = make_shared<long>(boost::any_cast<long>(m["TotalVgpus"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance>> instance{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<long> slbUdpTimeout{};
  shared_ptr<long> udpTimeout{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbUdpTimeout) {
      res["SlbUdpTimeout"] = boost::any(*slbUdpTimeout);
    }
    if (udpTimeout) {
      res["UdpTimeout"] = boost::any(*udpTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbUdpTimeout") != m.end() && !m["SlbUdpTimeout"].empty()) {
      slbUdpTimeout = make_shared<long>(boost::any_cast<long>(m["SlbUdpTimeout"]));
    }
    if (m.find("UdpTimeout") != m.end() && !m["UdpTimeout"].empty()) {
      udpTimeout = make_shared<long>(boost::any_cast<long>(m["UdpTimeout"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock>> operationLock{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLock) {
      vector<boost::any> temp1;
      for(auto item1:*operationLock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLock"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLock") != m.end() && !m["OperationLock"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLock"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLock = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportInstanceTypeFamily{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportInstanceTypeFamily) {
      res["SupportInstanceTypeFamily"] = boost::any(*supportInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportInstanceTypeFamily") != m.end() && !m["SupportInstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportInstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportInstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportInstanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportInstanceTypesList{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportInstanceTypesList) {
      res["SupportInstanceTypesList"] = boost::any(*supportInstanceTypesList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportInstanceTypesList") != m.end() && !m["SupportInstanceTypesList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportInstanceTypesList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportInstanceTypesList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportInstanceTypesList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedCustomInstanceTypeFamily{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedCustomInstanceTypeFamily) {
      res["SupportedCustomInstanceTypeFamily"] = boost::any(*supportedCustomInstanceTypeFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedCustomInstanceTypeFamily") != m.end() && !m["SupportedCustomInstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedCustomInstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedCustomInstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedCustomInstanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag>> tag{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions> schedulerOptions{};
  shared_ptr<string> actionOnMaintenance{};
  shared_ptr<string> autoPlacement{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity> capacity{};
  shared_ptr<string> chargeType{};
  shared_ptr<double> cpuOverCommitRatio{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> dedicatedHostType{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> GPUSpec{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo> hostDetailInfo{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances> instances{};
  shared_ptr<string> machineId{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes> networkAttributes{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks> operationLocks{};
  shared_ptr<long> physicalGpus{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> saleCycle{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies> supportInstanceTypeFamilies{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList> supportInstanceTypesList{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies> supportedCustomInstanceTypeFamilies{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags> tags{};
  shared_ptr<long> totalPhysicalCores{};
  shared_ptr<long> totalSockets{};
  shared_ptr<string> zoneId{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!schedulerOptions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerOptions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = boost::any(*actionOnMaintenance);
    }
    if (autoPlacement) {
      res["AutoPlacement"] = boost::any(*autoPlacement);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (capacity) {
      res["Capacity"] = capacity ? boost::any(capacity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (cpuOverCommitRatio) {
      res["CpuOverCommitRatio"] = boost::any(*cpuOverCommitRatio);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (dedicatedHostType) {
      res["DedicatedHostType"] = boost::any(*dedicatedHostType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (GPUSpec) {
      res["GPUSpec"] = boost::any(*GPUSpec);
    }
    if (hostDetailInfo) {
      res["HostDetailInfo"] = hostDetailInfo ? boost::any(hostDetailInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (machineId) {
      res["MachineId"] = boost::any(*machineId);
    }
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (physicalGpus) {
      res["PhysicalGpus"] = boost::any(*physicalGpus);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (saleCycle) {
      res["SaleCycle"] = boost::any(*saleCycle);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supportInstanceTypeFamilies) {
      res["SupportInstanceTypeFamilies"] = supportInstanceTypeFamilies ? boost::any(supportInstanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportInstanceTypesList) {
      res["SupportInstanceTypesList"] = supportInstanceTypesList ? boost::any(supportInstanceTypesList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportedCustomInstanceTypeFamilies) {
      res["SupportedCustomInstanceTypeFamilies"] = supportedCustomInstanceTypeFamilies ? boost::any(supportedCustomInstanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalPhysicalCores) {
      res["TotalPhysicalCores"] = boost::any(*totalPhysicalCores);
    }
    if (totalSockets) {
      res["TotalSockets"] = boost::any(*totalSockets);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions>(model1);
      }
    }
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      actionOnMaintenance = make_shared<string>(boost::any_cast<string>(m["ActionOnMaintenance"]));
    }
    if (m.find("AutoPlacement") != m.end() && !m["AutoPlacement"].empty()) {
      autoPlacement = make_shared<string>(boost::any_cast<string>(m["AutoPlacement"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      if (typeid(map<string, boost::any>) == m["Capacity"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Capacity"]));
        capacity = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity>(model1);
      }
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CpuOverCommitRatio") != m.end() && !m["CpuOverCommitRatio"].empty()) {
      cpuOverCommitRatio = make_shared<double>(boost::any_cast<double>(m["CpuOverCommitRatio"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("DedicatedHostType") != m.end() && !m["DedicatedHostType"].empty()) {
      dedicatedHostType = make_shared<string>(boost::any_cast<string>(m["DedicatedHostType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("GPUSpec") != m.end() && !m["GPUSpec"].empty()) {
      GPUSpec = make_shared<string>(boost::any_cast<string>(m["GPUSpec"]));
    }
    if (m.find("HostDetailInfo") != m.end() && !m["HostDetailInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostDetailInfo"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostDetailInfo"]));
        hostDetailInfo = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo>(model1);
      }
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances>(model1);
      }
    }
    if (m.find("MachineId") != m.end() && !m["MachineId"].empty()) {
      machineId = make_shared<string>(boost::any_cast<string>(m["MachineId"]));
    }
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes>(model1);
      }
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks>(model1);
      }
    }
    if (m.find("PhysicalGpus") != m.end() && !m["PhysicalGpus"].empty()) {
      physicalGpus = make_shared<long>(boost::any_cast<long>(m["PhysicalGpus"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SaleCycle") != m.end() && !m["SaleCycle"].empty()) {
      saleCycle = make_shared<string>(boost::any_cast<string>(m["SaleCycle"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SupportInstanceTypeFamilies") != m.end() && !m["SupportInstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportInstanceTypeFamilies"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportInstanceTypeFamilies"]));
        supportInstanceTypeFamilies = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypeFamilies>(model1);
      }
    }
    if (m.find("SupportInstanceTypesList") != m.end() && !m["SupportInstanceTypesList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportInstanceTypesList"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportInstanceTypesList"]));
        supportInstanceTypesList = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportInstanceTypesList>(model1);
      }
    }
    if (m.find("SupportedCustomInstanceTypeFamilies") != m.end() && !m["SupportedCustomInstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedCustomInstanceTypeFamilies"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedCustomInstanceTypeFamilies"]));
        supportedCustomInstanceTypeFamilies = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags>(model1);
      }
    }
    if (m.find("TotalPhysicalCores") != m.end() && !m["TotalPhysicalCores"].empty()) {
      totalPhysicalCores = make_shared<long>(boost::any_cast<long>(m["TotalPhysicalCores"]));
    }
    if (m.find("TotalSockets") != m.end() && !m["TotalSockets"].empty()) {
      totalSockets = make_shared<long>(boost::any_cast<long>(m["TotalSockets"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHosts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost>> dedicatedHost{};

  DescribeDedicatedHostsResponseBodyDedicatedHosts() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHost) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHost){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHost"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHost") != m.end() && !m["DedicatedHost"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHost"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHost"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHost = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHosts() = default;
};
class DescribeDedicatedHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHosts> dedicatedHosts{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDedicatedHostsResponseBody() {}

  explicit DescribeDedicatedHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHosts) {
      res["DedicatedHosts"] = dedicatedHosts ? boost::any(dedicatedHosts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHosts") != m.end() && !m["DedicatedHosts"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHosts"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHosts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHosts"]));
        dedicatedHosts = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHosts>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBody() = default;
};
class DescribeDedicatedHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDedicatedHostsResponseBody> body{};

  DescribeDedicatedHostsResponse() {}

  explicit DescribeDedicatedHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponse() = default;
};
class DescribeDiagnoseRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDiagnoseRequestTag() {}

  explicit DescribeDiagnoseRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDiagnoseRequestTag() = default;
};
class DescribeDiagnoseRequest : public Darabonba::Model {
public:
  shared_ptr<string> diagnoseAction{};
  shared_ptr<string> diagnoseId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> status{};
  shared_ptr<vector<DescribeDiagnoseRequestTag>> tag{};
  shared_ptr<long> type{};

  DescribeDiagnoseRequest() {}

  explicit DescribeDiagnoseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseAction) {
      res["DiagnoseAction"] = boost::any(*diagnoseAction);
    }
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseAction") != m.end() && !m["DiagnoseAction"].empty()) {
      diagnoseAction = make_shared<string>(boost::any_cast<string>(m["DiagnoseAction"]));
    }
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDiagnoseRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnoseRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDiagnoseRequestTag>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~DescribeDiagnoseRequest() = default;
};
class DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> diagnoseAction{};
  shared_ptr<string> diagnoseId{};
  shared_ptr<string> diagnoseRequestId{};
  shared_ptr<string> diskCategory{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceTypeName{};
  shared_ptr<string> izNo{};
  shared_ptr<string> mark{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> networkType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> solutions{};
  shared_ptr<long> star{};
  shared_ptr<string> status{};

  DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance() {}

  explicit DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (diagnoseAction) {
      res["DiagnoseAction"] = boost::any(*diagnoseAction);
    }
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (diagnoseRequestId) {
      res["DiagnoseRequestId"] = boost::any(*diagnoseRequestId);
    }
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceTypeName) {
      res["InstanceTypeName"] = boost::any(*instanceTypeName);
    }
    if (izNo) {
      res["IzNo"] = boost::any(*izNo);
    }
    if (mark) {
      res["Mark"] = boost::any(*mark);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (solutions) {
      res["Solutions"] = boost::any(*solutions);
    }
    if (star) {
      res["Star"] = boost::any(*star);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DiagnoseAction") != m.end() && !m["DiagnoseAction"].empty()) {
      diagnoseAction = make_shared<string>(boost::any_cast<string>(m["DiagnoseAction"]));
    }
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("DiagnoseRequestId") != m.end() && !m["DiagnoseRequestId"].empty()) {
      diagnoseRequestId = make_shared<string>(boost::any_cast<string>(m["DiagnoseRequestId"]));
    }
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceTypeName") != m.end() && !m["InstanceTypeName"].empty()) {
      instanceTypeName = make_shared<string>(boost::any_cast<string>(m["InstanceTypeName"]));
    }
    if (m.find("IzNo") != m.end() && !m["IzNo"].empty()) {
      izNo = make_shared<string>(boost::any_cast<string>(m["IzNo"]));
    }
    if (m.find("Mark") != m.end() && !m["Mark"].empty()) {
      mark = make_shared<string>(boost::any_cast<string>(m["Mark"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Solutions") != m.end() && !m["Solutions"].empty()) {
      solutions = make_shared<string>(boost::any_cast<string>(m["Solutions"]));
    }
    if (m.find("Star") != m.end() && !m["Star"].empty()) {
      star = make_shared<long>(boost::any_cast<long>(m["Star"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance() = default;
};
class DescribeDiagnoseResponseBodyDiagnoseInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance>> diagnoseInstance{};

  DescribeDiagnoseResponseBodyDiagnoseInstances() {}

  explicit DescribeDiagnoseResponseBodyDiagnoseInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseInstance) {
      vector<boost::any> temp1;
      for(auto item1:*diagnoseInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiagnoseInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseInstance") != m.end() && !m["DiagnoseInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["DiagnoseInstance"].type()) {
        vector<DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiagnoseInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diagnoseInstance = make_shared<vector<DescribeDiagnoseResponseBodyDiagnoseInstancesDiagnoseInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnoseResponseBodyDiagnoseInstances() = default;
};
class DescribeDiagnoseResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDiagnoseResponseBodyDiagnoseInstances> diagnoseInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDiagnoseResponseBody() {}

  explicit DescribeDiagnoseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseInstances) {
      res["DiagnoseInstances"] = diagnoseInstances ? boost::any(diagnoseInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseInstances") != m.end() && !m["DiagnoseInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiagnoseInstances"].type()) {
        DescribeDiagnoseResponseBodyDiagnoseInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiagnoseInstances"]));
        diagnoseInstances = make_shared<DescribeDiagnoseResponseBodyDiagnoseInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDiagnoseResponseBody() = default;
};
class DescribeDiagnoseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiagnoseResponseBody> body{};

  DescribeDiagnoseResponse() {}

  explicit DescribeDiagnoseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiagnoseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiagnoseResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiagnoseResponse() = default;
};
class DescribeDiagnosisOperateRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> operateRecordType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  DescribeDiagnosisOperateRecordsRequest() {}

  explicit DescribeDiagnosisOperateRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (operateRecordType) {
      res["OperateRecordType"] = boost::any(*operateRecordType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OperateRecordType") != m.end() && !m["OperateRecordType"].empty()) {
      operateRecordType = make_shared<string>(boost::any_cast<string>(m["OperateRecordType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDiagnosisOperateRecordsRequest() = default;
};
class DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> newInstanceType{};
  shared_ptr<string> newZoneId{};
  shared_ptr<string> operateDate{};
  shared_ptr<string> operateRecordType{};
  shared_ptr<string> zoneId{};

  DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels() {}

  explicit DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (newInstanceType) {
      res["NewInstanceType"] = boost::any(*newInstanceType);
    }
    if (newZoneId) {
      res["NewZoneId"] = boost::any(*newZoneId);
    }
    if (operateDate) {
      res["OperateDate"] = boost::any(*operateDate);
    }
    if (operateRecordType) {
      res["OperateRecordType"] = boost::any(*operateRecordType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NewInstanceType") != m.end() && !m["NewInstanceType"].empty()) {
      newInstanceType = make_shared<string>(boost::any_cast<string>(m["NewInstanceType"]));
    }
    if (m.find("NewZoneId") != m.end() && !m["NewZoneId"].empty()) {
      newZoneId = make_shared<string>(boost::any_cast<string>(m["NewZoneId"]));
    }
    if (m.find("OperateDate") != m.end() && !m["OperateDate"].empty()) {
      operateDate = make_shared<string>(boost::any_cast<string>(m["OperateDate"]));
    }
    if (m.find("OperateRecordType") != m.end() && !m["OperateRecordType"].empty()) {
      operateRecordType = make_shared<string>(boost::any_cast<string>(m["OperateRecordType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels() = default;
};
class DescribeDiagnosisOperateRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels>> diagnosisOperateRecordModels{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDiagnosisOperateRecordsResponseBody() {}

  explicit DescribeDiagnosisOperateRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnosisOperateRecordModels) {
      vector<boost::any> temp1;
      for(auto item1:*diagnosisOperateRecordModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiagnosisOperateRecordModels"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnosisOperateRecordModels") != m.end() && !m["DiagnosisOperateRecordModels"].empty()) {
      if (typeid(vector<boost::any>) == m["DiagnosisOperateRecordModels"].type()) {
        vector<DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiagnosisOperateRecordModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diagnosisOperateRecordModels = make_shared<vector<DescribeDiagnosisOperateRecordsResponseBodyDiagnosisOperateRecordModels>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDiagnosisOperateRecordsResponseBody() = default;
};
class DescribeDiagnosisOperateRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiagnosisOperateRecordsResponseBody> body{};

  DescribeDiagnosisOperateRecordsResponse() {}

  explicit DescribeDiagnosisOperateRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiagnosisOperateRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiagnosisOperateRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiagnosisOperateRecordsResponse() = default;
};
class DescribeDiagnosticReportsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> reportId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> severity{};
  shared_ptr<string> sourceSystem{};
  shared_ptr<string> status{};

  DescribeDiagnosticReportsRequest() {}

  explicit DescribeDiagnosticReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (sourceSystem) {
      res["SourceSystem"] = boost::any(*sourceSystem);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReportId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReportId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reportId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("SourceSystem") != m.end() && !m["SourceSystem"].empty()) {
      sourceSystem = make_shared<string>(boost::any_cast<string>(m["SourceSystem"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDiagnosticReportsRequest() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter>> parameter{};

  DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameter) {
      vector<boost::any> temp1;
      for(auto item1:*parameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Parameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Parameter") != m.end() && !m["Parameter"].empty()) {
      if (typeid(vector<boost::any>) == m["Parameter"].type()) {
        vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Parameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameter = make_shared<vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParametersParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction : public Darabonba::Model {
public:
  shared_ptr<string> actionCode{};
  shared_ptr<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters> parameters{};
  shared_ptr<string> url{};

  DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionCode) {
      res["ActionCode"] = boost::any(*actionCode);
    }
    if (parameters) {
      res["Parameters"] = parameters ? boost::any(parameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionCode") != m.end() && !m["ActionCode"].empty()) {
      actionCode = make_shared<string>(boost::any_cast<string>(m["ActionCode"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Parameters"].type()) {
        DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Parameters"]));
        parameters = make_shared<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedActionParameters>(model1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction>> recommendedAction{};

  DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendedAction) {
      vector<boost::any> temp1;
      for(auto item1:*recommendedAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendedAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendedAction") != m.end() && !m["RecommendedAction"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendedAction"].type()) {
        vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendedAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendedAction = make_shared<vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActionsRecommendedAction>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue : public Darabonba::Model {
public:
  shared_ptr<string> issueCategory{};
  shared_ptr<string> issueCode{};
  shared_ptr<string> message{};
  shared_ptr<string> occurrenceTime{};
  shared_ptr<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions> recommendedActions{};
  shared_ptr<string> severity{};

  DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (issueCategory) {
      res["IssueCategory"] = boost::any(*issueCategory);
    }
    if (issueCode) {
      res["IssueCode"] = boost::any(*issueCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (recommendedActions) {
      res["RecommendedActions"] = recommendedActions ? boost::any(recommendedActions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IssueCategory") != m.end() && !m["IssueCategory"].empty()) {
      issueCategory = make_shared<string>(boost::any_cast<string>(m["IssueCategory"]));
    }
    if (m.find("IssueCode") != m.end() && !m["IssueCode"].empty()) {
      issueCode = make_shared<string>(boost::any_cast<string>(m["IssueCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<string>(boost::any_cast<string>(m["OccurrenceTime"]));
    }
    if (m.find("RecommendedActions") != m.end() && !m["RecommendedActions"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendedActions"].type()) {
        DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendedActions"]));
        recommendedActions = make_shared<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssueRecommendedActions>(model1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportIssues : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue>> issue{};

  DescribeDiagnosticReportsResponseBodyReportsReportIssues() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportIssues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (issue) {
      vector<boost::any> temp1;
      for(auto item1:*issue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Issue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Issue") != m.end() && !m["Issue"].empty()) {
      if (typeid(vector<boost::any>) == m["Issue"].type()) {
        vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Issue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        issue = make_shared<vector<DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportIssues() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData>> itemData{};

  DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemData) {
      vector<boost::any> temp1;
      for(auto item1:*itemData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemData") != m.end() && !m["ItemData"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemData"].type()) {
        vector<DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemData = make_shared<vector<DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatasItemData>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> itemCategory{};
  shared_ptr<string> itemCode{};
  shared_ptr<DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas> itemDatas{};
  shared_ptr<string> occurrenceTime{};
  shared_ptr<string> severity{};
  shared_ptr<string> status{};

  DescribeDiagnosticReportsResponseBodyReportsReportItemsItem() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemCategory) {
      res["ItemCategory"] = boost::any(*itemCategory);
    }
    if (itemCode) {
      res["ItemCode"] = boost::any(*itemCode);
    }
    if (itemDatas) {
      res["ItemDatas"] = itemDatas ? boost::any(itemDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemCategory") != m.end() && !m["ItemCategory"].empty()) {
      itemCategory = make_shared<string>(boost::any_cast<string>(m["ItemCategory"]));
    }
    if (m.find("ItemCode") != m.end() && !m["ItemCode"].empty()) {
      itemCode = make_shared<string>(boost::any_cast<string>(m["ItemCode"]));
    }
    if (m.find("ItemDatas") != m.end() && !m["ItemDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemDatas"].type()) {
        DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemDatas"]));
        itemDatas = make_shared<DescribeDiagnosticReportsResponseBodyReportsReportItemsItemItemDatas>(model1);
      }
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<string>(boost::any_cast<string>(m["OccurrenceTime"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportItemsItem() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnosticReportsResponseBodyReportsReportItemsItem>> item{};

  DescribeDiagnosticReportsResponseBodyReportsReportItems() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<DescribeDiagnosticReportsResponseBodyReportsReportItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosticReportsResponseBodyReportsReportItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<DescribeDiagnosticReportsResponseBodyReportsReportItemsItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportItems() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent : public Darabonba::Model {
public:
  shared_ptr<string> eventID{};
  shared_ptr<string> eventName{};
  shared_ptr<string> publishTime{};

  DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventID) {
      res["EventID"] = boost::any(*eventID);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventID") != m.end() && !m["EventID"].empty()) {
      eventID = make_shared<string>(boost::any_cast<string>(m["EventID"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent>> recentEvent{};

  DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recentEvent) {
      vector<boost::any> temp1;
      for(auto item1:*recentEvent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecentEvent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecentEvent") != m.end() && !m["RecentEvent"].empty()) {
      if (typeid(vector<boost::any>) == m["RecentEvent"].type()) {
        vector<DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecentEvent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recentEvent = make_shared<vector<DescribeDiagnosticReportsResponseBodyReportsReportRecentEventsRecentEvent>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents() = default;
};
class DescribeDiagnosticReportsResponseBodyReportsReport : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> diagnosticCategory{};
  shared_ptr<string> endTime{};
  shared_ptr<string> finishedTime{};
  shared_ptr<string> invokeSystem{};
  shared_ptr<string> issueCategoryId{};
  shared_ptr<DescribeDiagnosticReportsResponseBodyReportsReportIssues> issues{};
  shared_ptr<DescribeDiagnosticReportsResponseBodyReportsReportItems> items{};
  shared_ptr<string> offlineDiagReportStatus{};
  shared_ptr<string> pePassword{};
  shared_ptr<DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents> recentEvents{};
  shared_ptr<string> reportId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> severity{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DescribeDiagnosticReportsResponseBodyReportsReport() {}

  explicit DescribeDiagnosticReportsResponseBodyReportsReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (diagnosticCategory) {
      res["DiagnosticCategory"] = boost::any(*diagnosticCategory);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (invokeSystem) {
      res["InvokeSystem"] = boost::any(*invokeSystem);
    }
    if (issueCategoryId) {
      res["IssueCategoryId"] = boost::any(*issueCategoryId);
    }
    if (issues) {
      res["Issues"] = issues ? boost::any(issues->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (offlineDiagReportStatus) {
      res["OfflineDiagReportStatus"] = boost::any(*offlineDiagReportStatus);
    }
    if (pePassword) {
      res["PePassword"] = boost::any(*pePassword);
    }
    if (recentEvents) {
      res["RecentEvents"] = recentEvents ? boost::any(recentEvents->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DiagnosticCategory") != m.end() && !m["DiagnosticCategory"].empty()) {
      diagnosticCategory = make_shared<string>(boost::any_cast<string>(m["DiagnosticCategory"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<string>(boost::any_cast<string>(m["FinishedTime"]));
    }
    if (m.find("InvokeSystem") != m.end() && !m["InvokeSystem"].empty()) {
      invokeSystem = make_shared<string>(boost::any_cast<string>(m["InvokeSystem"]));
    }
    if (m.find("IssueCategoryId") != m.end() && !m["IssueCategoryId"].empty()) {
      issueCategoryId = make_shared<string>(boost::any_cast<string>(m["IssueCategoryId"]));
    }
    if (m.find("Issues") != m.end() && !m["Issues"].empty()) {
      if (typeid(map<string, boost::any>) == m["Issues"].type()) {
        DescribeDiagnosticReportsResponseBodyReportsReportIssues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Issues"]));
        issues = make_shared<DescribeDiagnosticReportsResponseBodyReportsReportIssues>(model1);
      }
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDiagnosticReportsResponseBodyReportsReportItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDiagnosticReportsResponseBodyReportsReportItems>(model1);
      }
    }
    if (m.find("OfflineDiagReportStatus") != m.end() && !m["OfflineDiagReportStatus"].empty()) {
      offlineDiagReportStatus = make_shared<string>(boost::any_cast<string>(m["OfflineDiagReportStatus"]));
    }
    if (m.find("PePassword") != m.end() && !m["PePassword"].empty()) {
      pePassword = make_shared<string>(boost::any_cast<string>(m["PePassword"]));
    }
    if (m.find("RecentEvents") != m.end() && !m["RecentEvents"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecentEvents"].type()) {
        DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecentEvents"]));
        recentEvents = make_shared<DescribeDiagnosticReportsResponseBodyReportsReportRecentEvents>(model1);
      }
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReportsReport() = default;
};
class DescribeDiagnosticReportsResponseBodyReports : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiagnosticReportsResponseBodyReportsReport>> report{};

  DescribeDiagnosticReportsResponseBodyReports() {}

  explicit DescribeDiagnosticReportsResponseBodyReports(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (report) {
      vector<boost::any> temp1;
      for(auto item1:*report){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Report"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Report") != m.end() && !m["Report"].empty()) {
      if (typeid(vector<boost::any>) == m["Report"].type()) {
        vector<DescribeDiagnosticReportsResponseBodyReportsReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Report"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosticReportsResponseBodyReportsReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        report = make_shared<vector<DescribeDiagnosticReportsResponseBodyReportsReport>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBodyReports() = default;
};
class DescribeDiagnosticReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<DescribeDiagnosticReportsResponseBodyReports> reports{};
  shared_ptr<string> requestId{};

  DescribeDiagnosticReportsResponseBody() {}

  explicit DescribeDiagnosticReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (reports) {
      res["Reports"] = reports ? boost::any(reports->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      if (typeid(map<string, boost::any>) == m["Reports"].type()) {
        DescribeDiagnosticReportsResponseBodyReports model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Reports"]));
        reports = make_shared<DescribeDiagnosticReportsResponseBodyReports>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDiagnosticReportsResponseBody() = default;
};
class DescribeDiagnosticReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiagnosticReportsResponseBody> body{};

  DescribeDiagnosticReportsResponse() {}

  explicit DescribeDiagnosticReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiagnosticReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiagnosticReportsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportsResponse() = default;
};
class DescribeDiskReplicaPairsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeDiskReplicaPairsRequest() {}

  explicit DescribeDiskReplicaPairsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeDiskReplicaPairsRequest() = default;
};
class DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair : public Darabonba::Model {
public:
  shared_ptr<long> asyncCycle{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> destinationDiskId{};
  shared_ptr<string> destinationRegion{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> pairName{};
  shared_ptr<string> replicaPairId{};
  shared_ptr<string> rpoTime{};
  shared_ptr<string> sourceDiskId{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> status{};
  shared_ptr<long> totalCopiedSize{};

  DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair() {}

  explicit DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncCycle) {
      res["AsyncCycle"] = boost::any(*asyncCycle);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationDiskId) {
      res["DestinationDiskId"] = boost::any(*destinationDiskId);
    }
    if (destinationRegion) {
      res["DestinationRegion"] = boost::any(*destinationRegion);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (pairName) {
      res["PairName"] = boost::any(*pairName);
    }
    if (replicaPairId) {
      res["ReplicaPairId"] = boost::any(*replicaPairId);
    }
    if (rpoTime) {
      res["RpoTime"] = boost::any(*rpoTime);
    }
    if (sourceDiskId) {
      res["SourceDiskId"] = boost::any(*sourceDiskId);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCopiedSize) {
      res["TotalCopiedSize"] = boost::any(*totalCopiedSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncCycle") != m.end() && !m["AsyncCycle"].empty()) {
      asyncCycle = make_shared<long>(boost::any_cast<long>(m["AsyncCycle"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationDiskId") != m.end() && !m["DestinationDiskId"].empty()) {
      destinationDiskId = make_shared<string>(boost::any_cast<string>(m["DestinationDiskId"]));
    }
    if (m.find("DestinationRegion") != m.end() && !m["DestinationRegion"].empty()) {
      destinationRegion = make_shared<string>(boost::any_cast<string>(m["DestinationRegion"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("PairName") != m.end() && !m["PairName"].empty()) {
      pairName = make_shared<string>(boost::any_cast<string>(m["PairName"]));
    }
    if (m.find("ReplicaPairId") != m.end() && !m["ReplicaPairId"].empty()) {
      replicaPairId = make_shared<string>(boost::any_cast<string>(m["ReplicaPairId"]));
    }
    if (m.find("RpoTime") != m.end() && !m["RpoTime"].empty()) {
      rpoTime = make_shared<string>(boost::any_cast<string>(m["RpoTime"]));
    }
    if (m.find("SourceDiskId") != m.end() && !m["SourceDiskId"].empty()) {
      sourceDiskId = make_shared<string>(boost::any_cast<string>(m["SourceDiskId"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalCopiedSize") != m.end() && !m["TotalCopiedSize"].empty()) {
      totalCopiedSize = make_shared<long>(boost::any_cast<long>(m["TotalCopiedSize"]));
    }
  }


  virtual ~DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair() = default;
};
class DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair>> diskReplicaPair{};

  DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs() {}

  explicit DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskReplicaPair) {
      vector<boost::any> temp1;
      for(auto item1:*diskReplicaPair){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskReplicaPair"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskReplicaPair") != m.end() && !m["DiskReplicaPair"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskReplicaPair"].type()) {
        vector<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskReplicaPair"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskReplicaPair = make_shared<vector<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairsDiskReplicaPair>>(expect1);
      }
    }
  }


  virtual ~DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs() = default;
};
class DescribeDiskReplicaPairsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs> diskReplicaPairs{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeDiskReplicaPairsResponseBody() {}

  explicit DescribeDiskReplicaPairsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskReplicaPairs) {
      res["DiskReplicaPairs"] = diskReplicaPairs ? boost::any(diskReplicaPairs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskReplicaPairs") != m.end() && !m["DiskReplicaPairs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskReplicaPairs"].type()) {
        DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskReplicaPairs"]));
        diskReplicaPairs = make_shared<DescribeDiskReplicaPairsResponseBodyDiskReplicaPairs>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDiskReplicaPairsResponseBody() = default;
};
class DescribeDiskReplicaPairsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiskReplicaPairsResponseBody> body{};

  DescribeDiskReplicaPairsResponse() {}

  explicit DescribeDiskReplicaPairsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiskReplicaPairsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiskReplicaPairsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiskReplicaPairsResponse() = default;
};
class DescribeEcsScenarioFacadeRequestScenarioListScenarioResources : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<vector<string>> values{};

  DescribeEcsScenarioFacadeRequestScenarioListScenarioResources() {}

  explicit DescribeEcsScenarioFacadeRequestScenarioListScenarioResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEcsScenarioFacadeRequestScenarioListScenarioResources() = default;
};
class DescribeEcsScenarioFacadeRequestScenarioList : public Darabonba::Model {
public:
  shared_ptr<string> scenario{};
  shared_ptr<vector<DescribeEcsScenarioFacadeRequestScenarioListScenarioResources>> scenarioResources{};

  DescribeEcsScenarioFacadeRequestScenarioList() {}

  explicit DescribeEcsScenarioFacadeRequestScenarioList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (scenarioResources) {
      vector<boost::any> temp1;
      for(auto item1:*scenarioResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScenarioResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("ScenarioResources") != m.end() && !m["ScenarioResources"].empty()) {
      if (typeid(vector<boost::any>) == m["ScenarioResources"].type()) {
        vector<DescribeEcsScenarioFacadeRequestScenarioListScenarioResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScenarioResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEcsScenarioFacadeRequestScenarioListScenarioResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarioResources = make_shared<vector<DescribeEcsScenarioFacadeRequestScenarioListScenarioResources>>(expect1);
      }
    }
  }


  virtual ~DescribeEcsScenarioFacadeRequestScenarioList() = default;
};
class DescribeEcsScenarioFacadeRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> extMap{};
  shared_ptr<string> extParam{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeEcsScenarioFacadeRequestScenarioList>> scenarioList{};

  DescribeEcsScenarioFacadeRequest() {}

  explicit DescribeEcsScenarioFacadeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extMap) {
      res["ExtMap"] = boost::any(*extMap);
    }
    if (extParam) {
      res["ExtParam"] = boost::any(*extParam);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scenarioList) {
      vector<boost::any> temp1;
      for(auto item1:*scenarioList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScenarioList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtMap") != m.end() && !m["ExtMap"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ExtMap"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extMap = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ExtParam") != m.end() && !m["ExtParam"].empty()) {
      extParam = make_shared<string>(boost::any_cast<string>(m["ExtParam"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScenarioList") != m.end() && !m["ScenarioList"].empty()) {
      if (typeid(vector<boost::any>) == m["ScenarioList"].type()) {
        vector<DescribeEcsScenarioFacadeRequestScenarioList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScenarioList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEcsScenarioFacadeRequestScenarioList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarioList = make_shared<vector<DescribeEcsScenarioFacadeRequestScenarioList>>(expect1);
      }
    }
  }


  virtual ~DescribeEcsScenarioFacadeRequest() = default;
};
class DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<vector<string>> values{};

  DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData() {}

  explicit DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData() = default;
};
class DescribeEcsScenarioFacadeResponseBodyScenariosContents : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> action{};
  shared_ptr<map<string, string>> attributes{};
  shared_ptr<string> colorLevel{};
  shared_ptr<string> description{};
  shared_ptr<vector<DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData>> ecsScenarioContentData{};
  shared_ptr<string> icon{};
  shared_ptr<string> supportCancel{};
  shared_ptr<string> tips{};
  shared_ptr<string> title{};
  shared_ptr<map<string, string>> track{};

  DescribeEcsScenarioFacadeResponseBodyScenariosContents() {}

  explicit DescribeEcsScenarioFacadeResponseBodyScenariosContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (colorLevel) {
      res["ColorLevel"] = boost::any(*colorLevel);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ecsScenarioContentData) {
      vector<boost::any> temp1;
      for(auto item1:*ecsScenarioContentData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcsScenarioContentData"] = boost::any(temp1);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (supportCancel) {
      res["SupportCancel"] = boost::any(*supportCancel);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (track) {
      res["Track"] = boost::any(*track);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Action"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      action = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Attributes"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      attributes = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ColorLevel") != m.end() && !m["ColorLevel"].empty()) {
      colorLevel = make_shared<string>(boost::any_cast<string>(m["ColorLevel"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EcsScenarioContentData") != m.end() && !m["EcsScenarioContentData"].empty()) {
      if (typeid(vector<boost::any>) == m["EcsScenarioContentData"].type()) {
        vector<DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcsScenarioContentData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecsScenarioContentData = make_shared<vector<DescribeEcsScenarioFacadeResponseBodyScenariosContentsEcsScenarioContentData>>(expect1);
      }
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("SupportCancel") != m.end() && !m["SupportCancel"].empty()) {
      supportCancel = make_shared<string>(boost::any_cast<string>(m["SupportCancel"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Track") != m.end() && !m["Track"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Track"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      track = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~DescribeEcsScenarioFacadeResponseBodyScenariosContents() = default;
};
class DescribeEcsScenarioFacadeResponseBodyScenarios : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEcsScenarioFacadeResponseBodyScenariosContents>> contents{};
  shared_ptr<string> scenario{};

  DescribeEcsScenarioFacadeResponseBodyScenarios() {}

  explicit DescribeEcsScenarioFacadeResponseBodyScenarios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<DescribeEcsScenarioFacadeResponseBodyScenariosContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEcsScenarioFacadeResponseBodyScenariosContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<DescribeEcsScenarioFacadeResponseBodyScenariosContents>>(expect1);
      }
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
  }


  virtual ~DescribeEcsScenarioFacadeResponseBodyScenarios() = default;
};
class DescribeEcsScenarioFacadeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEcsScenarioFacadeResponseBodyScenarios>> scenarios{};

  DescribeEcsScenarioFacadeResponseBody() {}

  explicit DescribeEcsScenarioFacadeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scenarios) {
      vector<boost::any> temp1;
      for(auto item1:*scenarios){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scenarios"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scenarios") != m.end() && !m["Scenarios"].empty()) {
      if (typeid(vector<boost::any>) == m["Scenarios"].type()) {
        vector<DescribeEcsScenarioFacadeResponseBodyScenarios> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scenarios"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEcsScenarioFacadeResponseBodyScenarios model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarios = make_shared<vector<DescribeEcsScenarioFacadeResponseBodyScenarios>>(expect1);
      }
    }
  }


  virtual ~DescribeEcsScenarioFacadeResponseBody() = default;
};
class DescribeEcsScenarioFacadeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEcsScenarioFacadeResponseBody> body{};

  DescribeEcsScenarioFacadeResponse() {}

  explicit DescribeEcsScenarioFacadeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEcsScenarioFacadeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEcsScenarioFacadeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEcsScenarioFacadeResponse() = default;
};
class DescribeEniQosGroupInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosGroupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeEniQosGroupInfoRequest() {}

  explicit DescribeEniQosGroupInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosGroupName) {
      res["QosGroupName"] = boost::any(*qosGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosGroupName") != m.end() && !m["QosGroupName"].empty()) {
      qosGroupName = make_shared<string>(boost::any_cast<string>(m["QosGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeEniQosGroupInfoRequest() = default;
};
class DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> networkInterfaceId{};

  DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds() {}

  explicit DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds() = default;
};
class DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> qosGroupName{};
  shared_ptr<string> rx{};
  shared_ptr<string> rxPps{};
  shared_ptr<string> tx{};
  shared_ptr<string> txPps{};
  shared_ptr<string> type{};

  DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup() {}

  explicit DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (qosGroupName) {
      res["QosGroupName"] = boost::any(*qosGroupName);
    }
    if (rx) {
      res["Rx"] = boost::any(*rx);
    }
    if (rxPps) {
      res["RxPps"] = boost::any(*rxPps);
    }
    if (tx) {
      res["Tx"] = boost::any(*tx);
    }
    if (txPps) {
      res["TxPps"] = boost::any(*txPps);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("QosGroupName") != m.end() && !m["QosGroupName"].empty()) {
      qosGroupName = make_shared<string>(boost::any_cast<string>(m["QosGroupName"]));
    }
    if (m.find("Rx") != m.end() && !m["Rx"].empty()) {
      rx = make_shared<string>(boost::any_cast<string>(m["Rx"]));
    }
    if (m.find("RxPps") != m.end() && !m["RxPps"].empty()) {
      rxPps = make_shared<string>(boost::any_cast<string>(m["RxPps"]));
    }
    if (m.find("Tx") != m.end() && !m["Tx"].empty()) {
      tx = make_shared<string>(boost::any_cast<string>(m["Tx"]));
    }
    if (m.find("TxPps") != m.end() && !m["TxPps"].empty()) {
      txPps = make_shared<string>(boost::any_cast<string>(m["TxPps"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup() = default;
};
class DescribeEniQosGroupInfoResponseBodyQosGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds> networkInterfaceIds{};
  shared_ptr<DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup> qosGroup{};

  DescribeEniQosGroupInfoResponseBodyQosGroupInfo() {}

  explicit DescribeEniQosGroupInfoResponseBodyQosGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkInterfaceIds) {
      res["NetworkInterfaceIds"] = networkInterfaceIds ? boost::any(networkInterfaceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (qosGroup) {
      res["QosGroup"] = qosGroup ? boost::any(qosGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceIds"].type()) {
        DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceIds"]));
        networkInterfaceIds = make_shared<DescribeEniQosGroupInfoResponseBodyQosGroupInfoNetworkInterfaceIds>(model1);
      }
    }
    if (m.find("QosGroup") != m.end() && !m["QosGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["QosGroup"].type()) {
        DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QosGroup"]));
        qosGroup = make_shared<DescribeEniQosGroupInfoResponseBodyQosGroupInfoQosGroup>(model1);
      }
    }
  }


  virtual ~DescribeEniQosGroupInfoResponseBodyQosGroupInfo() = default;
};
class DescribeEniQosGroupInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEniQosGroupInfoResponseBodyQosGroupInfo> qosGroupInfo{};
  shared_ptr<string> requestId{};

  DescribeEniQosGroupInfoResponseBody() {}

  explicit DescribeEniQosGroupInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosGroupInfo) {
      res["QosGroupInfo"] = qosGroupInfo ? boost::any(qosGroupInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosGroupInfo") != m.end() && !m["QosGroupInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["QosGroupInfo"].type()) {
        DescribeEniQosGroupInfoResponseBodyQosGroupInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QosGroupInfo"]));
        qosGroupInfo = make_shared<DescribeEniQosGroupInfoResponseBodyQosGroupInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEniQosGroupInfoResponseBody() = default;
};
class DescribeEniQosGroupInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEniQosGroupInfoResponseBody> body{};

  DescribeEniQosGroupInfoResponse() {}

  explicit DescribeEniQosGroupInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEniQosGroupInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEniQosGroupInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEniQosGroupInfoResponse() = default;
};
class DescribeFunctionFeedbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> feedback{};
  shared_ptr<vector<string>> functionName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeFunctionFeedbackRequest() {}

  explicit DescribeFunctionFeedbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FunctionName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FunctionName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      functionName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeFunctionFeedbackRequest() = default;
};
class DescribeFunctionFeedbackResponseBodyDataFeedback : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> feedback{};
  shared_ptr<string> finishedTime{};
  shared_ptr<string> functionName{};
  shared_ptr<string> suggestion{};

  DescribeFunctionFeedbackResponseBodyDataFeedback() {}

  explicit DescribeFunctionFeedbackResponseBodyDataFeedback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<string>(boost::any_cast<string>(m["FinishedTime"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~DescribeFunctionFeedbackResponseBodyDataFeedback() = default;
};
class DescribeFunctionFeedbackResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFunctionFeedbackResponseBodyDataFeedback>> feedback{};

  DescribeFunctionFeedbackResponseBodyData() {}

  explicit DescribeFunctionFeedbackResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feedback) {
      vector<boost::any> temp1;
      for(auto item1:*feedback){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["feedback"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("feedback") != m.end() && !m["feedback"].empty()) {
      if (typeid(vector<boost::any>) == m["feedback"].type()) {
        vector<DescribeFunctionFeedbackResponseBodyDataFeedback> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["feedback"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFunctionFeedbackResponseBodyDataFeedback model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        feedback = make_shared<vector<DescribeFunctionFeedbackResponseBodyDataFeedback>>(expect1);
      }
    }
  }


  virtual ~DescribeFunctionFeedbackResponseBodyData() = default;
};
class DescribeFunctionFeedbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeFunctionFeedbackResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeFunctionFeedbackResponseBody() {}

  explicit DescribeFunctionFeedbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeFunctionFeedbackResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeFunctionFeedbackResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFunctionFeedbackResponseBody() = default;
};
class DescribeFunctionFeedbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFunctionFeedbackResponseBody> body{};

  DescribeFunctionFeedbackResponse() {}

  explicit DescribeFunctionFeedbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFunctionFeedbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFunctionFeedbackResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFunctionFeedbackResponse() = default;
};
class DescribeHavsInstanceTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeHavsInstanceTypesRequest() {}

  explicit DescribeHavsInstanceTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeHavsInstanceTypesRequest() = default;
};
class DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> havsInstanceTypes{};

  DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes() {}

  explicit DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (havsInstanceTypes) {
      res["HavsInstanceTypes"] = boost::any(*havsInstanceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HavsInstanceTypes") != m.end() && !m["HavsInstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HavsInstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HavsInstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      havsInstanceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes() = default;
};
class DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes> havsInstanceTypes{};

  DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse() {}

  explicit DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (havsInstanceTypes) {
      res["HavsInstanceTypes"] = havsInstanceTypes ? boost::any(havsInstanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HavsInstanceTypes") != m.end() && !m["HavsInstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["HavsInstanceTypes"].type()) {
        DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HavsInstanceTypes"]));
        havsInstanceTypes = make_shared<DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponseHavsInstanceTypes>(model1);
      }
    }
  }


  virtual ~DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse() = default;
};
class DescribeHavsInstanceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse> describeHavsInstanceTypesResponse{};
  shared_ptr<string> requestId{};

  DescribeHavsInstanceTypesResponseBody() {}

  explicit DescribeHavsInstanceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeHavsInstanceTypesResponse) {
      res["DescribeHavsInstanceTypesResponse"] = describeHavsInstanceTypesResponse ? boost::any(describeHavsInstanceTypesResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeHavsInstanceTypesResponse") != m.end() && !m["DescribeHavsInstanceTypesResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeHavsInstanceTypesResponse"].type()) {
        DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeHavsInstanceTypesResponse"]));
        describeHavsInstanceTypesResponse = make_shared<DescribeHavsInstanceTypesResponseBodyDescribeHavsInstanceTypesResponse>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHavsInstanceTypesResponseBody() = default;
};
class DescribeHavsInstanceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHavsInstanceTypesResponseBody> body{};

  DescribeHavsInstanceTypesResponse() {}

  explicit DescribeHavsInstanceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHavsInstanceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHavsInstanceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHavsInstanceTypesResponse() = default;
};
class DescribeImageAgreementRequest : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeImageAgreementRequest() {}

  explicit DescribeImageAgreementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeImageAgreementRequest() = default;
};
class DescribeImageAgreementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeImageAgreementResponseBody() {}

  explicit DescribeImageAgreementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeImageAgreementResponseBody() = default;
};
class DescribeImageAgreementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageAgreementResponseBody> body{};

  DescribeImageAgreementResponse() {}

  explicit DescribeImageAgreementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageAgreementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageAgreementResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageAgreementResponse() = default;
};
class DescribeImageCachesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> imageId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  DescribeImageCachesRequest() {}

  explicit DescribeImageCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeImageCachesRequest() = default;
};
class DescribeImageCachesResponseBodyImageCachesImageCache : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> imageId{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeImageCachesResponseBodyImageCachesImageCache() {}

  explicit DescribeImageCachesResponseBodyImageCachesImageCache(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeImageCachesResponseBodyImageCachesImageCache() = default;
};
class DescribeImageCachesResponseBodyImageCaches : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageCachesResponseBodyImageCachesImageCache>> imageCache{};

  DescribeImageCachesResponseBodyImageCaches() {}

  explicit DescribeImageCachesResponseBodyImageCaches(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageCache) {
      vector<boost::any> temp1;
      for(auto item1:*imageCache){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageCache"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageCache") != m.end() && !m["ImageCache"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageCache"].type()) {
        vector<DescribeImageCachesResponseBodyImageCachesImageCache> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageCache"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageCachesResponseBodyImageCachesImageCache model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageCache = make_shared<vector<DescribeImageCachesResponseBodyImageCachesImageCache>>(expect1);
      }
    }
  }


  virtual ~DescribeImageCachesResponseBodyImageCaches() = default;
};
class DescribeImageCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImageCachesResponseBodyImageCaches> imageCaches{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeImageCachesResponseBody() {}

  explicit DescribeImageCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageCaches) {
      res["ImageCaches"] = imageCaches ? boost::any(imageCaches->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageCaches") != m.end() && !m["ImageCaches"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageCaches"].type()) {
        DescribeImageCachesResponseBodyImageCaches model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageCaches"]));
        imageCaches = make_shared<DescribeImageCachesResponseBodyImageCaches>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageCachesResponseBody() = default;
};
class DescribeImageCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageCachesResponseBody> body{};

  DescribeImageCachesResponse() {}

  explicit DescribeImageCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageCachesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageCachesResponse() = default;
};
class DescribeImageFamiliesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  DescribeImageFamiliesRequest() {}

  explicit DescribeImageFamiliesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeImageFamiliesRequest() = default;
};
class DescribeImageFamiliesResponseBodyImageFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> imageFamily{};

  DescribeImageFamiliesResponseBodyImageFamilies() {}

  explicit DescribeImageFamiliesResponseBodyImageFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageFamily = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImageFamiliesResponseBodyImageFamilies() = default;
};
class DescribeImageFamiliesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImageFamiliesResponseBodyImageFamilies> imageFamilies{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeImageFamiliesResponseBody() {}

  explicit DescribeImageFamiliesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageFamilies) {
      res["ImageFamilies"] = imageFamilies ? boost::any(imageFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageFamilies") != m.end() && !m["ImageFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageFamilies"].type()) {
        DescribeImageFamiliesResponseBodyImageFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageFamilies"]));
        imageFamilies = make_shared<DescribeImageFamiliesResponseBodyImageFamilies>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageFamiliesResponseBody() = default;
};
class DescribeImageFamiliesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageFamiliesResponseBody> body{};

  DescribeImageFamiliesResponse() {}

  explicit DescribeImageFamiliesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageFamiliesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageFamiliesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageFamiliesResponse() = default;
};
class DescribeInstanceAutoRebootTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoRebootTimeFrom{};
  shared_ptr<string> autoRebootTimeTo{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeInstanceAutoRebootTimeRequest() {}

  explicit DescribeInstanceAutoRebootTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRebootTimeFrom) {
      res["AutoRebootTimeFrom"] = boost::any(*autoRebootTimeFrom);
    }
    if (autoRebootTimeTo) {
      res["AutoRebootTimeTo"] = boost::any(*autoRebootTimeTo);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRebootTimeFrom") != m.end() && !m["AutoRebootTimeFrom"].empty()) {
      autoRebootTimeFrom = make_shared<string>(boost::any_cast<string>(m["AutoRebootTimeFrom"]));
    }
    if (m.find("AutoRebootTimeTo") != m.end() && !m["AutoRebootTimeTo"].empty()) {
      autoRebootTimeTo = make_shared<string>(boost::any_cast<string>(m["AutoRebootTimeTo"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeInstanceAutoRebootTimeRequest() = default;
};
class DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> limitRebootTime{};
  shared_ptr<string> orderType{};
  shared_ptr<string> rebootTime{};

  DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo() {}

  explicit DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (limitRebootTime) {
      res["LimitRebootTime"] = boost::any(*limitRebootTime);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (rebootTime) {
      res["RebootTime"] = boost::any(*rebootTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LimitRebootTime") != m.end() && !m["LimitRebootTime"].empty()) {
      limitRebootTime = make_shared<string>(boost::any_cast<string>(m["LimitRebootTime"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RebootTime") != m.end() && !m["RebootTime"].empty()) {
      rebootTime = make_shared<string>(boost::any_cast<string>(m["RebootTime"]));
    }
  }


  virtual ~DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo() = default;
};
class DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo>> autoRebootInfo{};

  DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos() {}

  explicit DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRebootInfo) {
      vector<boost::any> temp1;
      for(auto item1:*autoRebootInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoRebootInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRebootInfo") != m.end() && !m["AutoRebootInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoRebootInfo"].type()) {
        vector<DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoRebootInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoRebootInfo = make_shared<vector<DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfosAutoRebootInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos() = default;
};
class DescribeInstanceAutoRebootTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos> autoRebootInfos{};
  shared_ptr<string> requestId{};

  DescribeInstanceAutoRebootTimeResponseBody() {}

  explicit DescribeInstanceAutoRebootTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRebootInfos) {
      res["AutoRebootInfos"] = autoRebootInfos ? boost::any(autoRebootInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRebootInfos") != m.end() && !m["AutoRebootInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["AutoRebootInfos"].type()) {
        DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AutoRebootInfos"]));
        autoRebootInfos = make_shared<DescribeInstanceAutoRebootTimeResponseBodyAutoRebootInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceAutoRebootTimeResponseBody() = default;
};
class DescribeInstanceAutoRebootTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceAutoRebootTimeResponseBody> body{};

  DescribeInstanceAutoRebootTimeResponse() {}

  explicit DescribeInstanceAutoRebootTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAutoRebootTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAutoRebootTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRebootTimeResponse() = default;
};
class DescribeInstanceHealthStatusRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> regionId{};

  DescribeInstanceHealthStatusRequest() {}

  explicit DescribeInstanceHealthStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeInstanceHealthStatusRequest() = default;
};
class DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus() {}

  explicit DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus() = default;
};
class DescribeInstanceHealthStatusResponseBodyHealthStatusModel : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus> healthStatus{};
  shared_ptr<string> instanceId{};

  DescribeInstanceHealthStatusResponseBodyHealthStatusModel() {}

  explicit DescribeInstanceHealthStatusResponseBodyHealthStatusModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthStatus) {
      res["HealthStatus"] = healthStatus ? boost::any(healthStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthStatus"].type()) {
        DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthStatus"]));
        healthStatus = make_shared<DescribeInstanceHealthStatusResponseBodyHealthStatusModelHealthStatus>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceHealthStatusResponseBodyHealthStatusModel() = default;
};
class DescribeInstanceHealthStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceHealthStatusResponseBodyHealthStatusModel>> healthStatusModel{};
  shared_ptr<string> requestId{};

  DescribeInstanceHealthStatusResponseBody() {}

  explicit DescribeInstanceHealthStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthStatusModel) {
      vector<boost::any> temp1;
      for(auto item1:*healthStatusModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthStatusModel"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthStatusModel") != m.end() && !m["HealthStatusModel"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthStatusModel"].type()) {
        vector<DescribeInstanceHealthStatusResponseBodyHealthStatusModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthStatusModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceHealthStatusResponseBodyHealthStatusModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthStatusModel = make_shared<vector<DescribeInstanceHealthStatusResponseBodyHealthStatusModel>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceHealthStatusResponseBody() = default;
};
class DescribeInstanceHealthStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceHealthStatusResponseBody> body{};

  DescribeInstanceHealthStatusResponse() {}

  explicit DescribeInstanceHealthStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceHealthStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceHealthStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceHealthStatusResponse() = default;
};
class DescribeInstanceMaintenanceAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeInstanceMaintenanceAttributesRequest() {}

  explicit DescribeInstanceMaintenanceAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesRequest() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportedValue{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedValue) {
      res["SupportedValue"] = boost::any(*supportedValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedValue") != m.end() && !m["SupportedValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedValue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues> supportedValues{};
  shared_ptr<string> value{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (supportedValues) {
      res["SupportedValues"] = supportedValues ? boost::any(supportedValues->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("SupportedValues") != m.end() && !m["SupportedValues"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedValues"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedValues"]));
        supportedValues = make_shared<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues>(model1);
      }
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow>> maintenanceWindow{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maintenanceWindow) {
      vector<boost::any> temp1;
      for(auto item1:*maintenanceWindow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MaintenanceWindow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaintenanceWindow") != m.end() && !m["MaintenanceWindow"].empty()) {
      if (typeid(vector<boost::any>) == m["MaintenanceWindow"].type()) {
        vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MaintenanceWindow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        maintenanceWindow = make_shared<vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance> actionOnMaintenance{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> liveMigration{};
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows> maintenanceWindows{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = actionOnMaintenance ? boost::any(actionOnMaintenance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (liveMigration) {
      res["LiveMigration"] = boost::any(*liveMigration);
    }
    if (maintenanceWindows) {
      res["MaintenanceWindows"] = maintenanceWindows ? boost::any(maintenanceWindows->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActionOnMaintenance"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActionOnMaintenance"]));
        actionOnMaintenance = make_shared<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LiveMigration") != m.end() && !m["LiveMigration"].empty()) {
      liveMigration = make_shared<bool>(boost::any_cast<bool>(m["LiveMigration"]));
    }
    if (m.find("MaintenanceWindows") != m.end() && !m["MaintenanceWindows"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaintenanceWindows"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaintenanceWindows"]));
        maintenanceWindows = make_shared<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute>> maintenanceAttribute{};

  DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maintenanceAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*maintenanceAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MaintenanceAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaintenanceAttribute") != m.end() && !m["MaintenanceAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["MaintenanceAttribute"].type()) {
        vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MaintenanceAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        maintenanceAttribute = make_shared<vector<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes() = default;
};
class DescribeInstanceMaintenanceAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes> maintenanceAttributes{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstanceMaintenanceAttributesResponseBody() {}

  explicit DescribeInstanceMaintenanceAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maintenanceAttributes) {
      res["MaintenanceAttributes"] = maintenanceAttributes ? boost::any(maintenanceAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaintenanceAttributes") != m.end() && !m["MaintenanceAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaintenanceAttributes"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaintenanceAttributes"]));
        maintenanceAttributes = make_shared<DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponseBody() = default;
};
class DescribeInstanceMaintenanceAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceMaintenanceAttributesResponseBody> body{};

  DescribeInstanceMaintenanceAttributesResponse() {}

  explicit DescribeInstanceMaintenanceAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceMaintenanceAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceMaintenanceAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMaintenanceAttributesResponse() = default;
};
class DescribeInstanceModificationPriceRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};

  DescribeInstanceModificationPriceRequestSystemDisk() {}

  explicit DescribeInstanceModificationPriceRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceRequestSystemDisk() = default;
};
class DescribeInstanceModificationPriceRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};

  DescribeInstanceModificationPriceRequestDataDisk() {}

  explicit DescribeInstanceModificationPriceRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceRequestDataDisk() = default;
};
class DescribeInstanceModificationPriceRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceModificationPriceRequestSystemDisk> systemDisk{};
  shared_ptr<vector<DescribeInstanceModificationPriceRequestDataDisk>> dataDisk{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeInstanceModificationPriceRequest() {}

  explicit DescribeInstanceModificationPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribeInstanceModificationPriceRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribeInstanceModificationPriceRequestSystemDisk>(model1);
      }
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribeInstanceModificationPriceRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceModificationPriceRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribeInstanceModificationPriceRequestDataDisk>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceRequest() = default;
};
class DescribeInstanceModificationPriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> originalPrice{};
  shared_ptr<double> tradePrice{};

  DescribeInstanceModificationPriceResponseBodyPriceInfoPrice() {}

  explicit DescribeInstanceModificationPriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBodyPriceInfoPrice() = default;
};
class DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule() {}

  explicit DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule() = default;
};
class DescribeInstanceModificationPriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule>> rule{};

  DescribeInstanceModificationPriceResponseBodyPriceInfoRules() {}

  explicit DescribeInstanceModificationPriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBodyPriceInfoRules() = default;
};
class DescribeInstanceModificationPriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceModificationPriceResponseBodyPriceInfoPrice> price{};
  shared_ptr<DescribeInstanceModificationPriceResponseBodyPriceInfoRules> rules{};

  DescribeInstanceModificationPriceResponseBodyPriceInfo() {}

  explicit DescribeInstanceModificationPriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribeInstanceModificationPriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribeInstanceModificationPriceResponseBodyPriceInfoPrice>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribeInstanceModificationPriceResponseBodyPriceInfoRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribeInstanceModificationPriceResponseBodyPriceInfoRules>(model1);
      }
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBodyPriceInfo() = default;
};
class DescribeInstanceModificationPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceModificationPriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribeInstanceModificationPriceResponseBody() {}

  explicit DescribeInstanceModificationPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeInstanceModificationPriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeInstanceModificationPriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceModificationPriceResponseBody() = default;
};
class DescribeInstanceModificationPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceModificationPriceResponseBody> body{};

  DescribeInstanceModificationPriceResponse() {}

  explicit DescribeInstanceModificationPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceModificationPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceModificationPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceModificationPriceResponse() = default;
};
class DescribeInstanceNeedRebootRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeInstanceNeedRebootRequest() {}

  explicit DescribeInstanceNeedRebootRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeInstanceNeedRebootRequest() = default;
};
class DescribeInstanceNeedRebootResponseBodyInstanceInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceInfo{};

  DescribeInstanceNeedRebootResponseBodyInstanceInfo() {}

  explicit DescribeInstanceNeedRebootResponseBodyInstanceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceInfo) {
      res["InstanceInfo"] = boost::any(*instanceInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceInfo") != m.end() && !m["InstanceInfo"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceInfo"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceInfo"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceInfo = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceNeedRebootResponseBodyInstanceInfo() = default;
};
class DescribeInstanceNeedRebootResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceNeedRebootResponseBodyInstanceInfo> instanceInfo{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstanceNeedRebootResponseBody() {}

  explicit DescribeInstanceNeedRebootResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceInfo) {
      res["InstanceInfo"] = instanceInfo ? boost::any(instanceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceInfo") != m.end() && !m["InstanceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceInfo"].type()) {
        DescribeInstanceNeedRebootResponseBodyInstanceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceInfo"]));
        instanceInfo = make_shared<DescribeInstanceNeedRebootResponseBodyInstanceInfo>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstanceNeedRebootResponseBody() = default;
};
class DescribeInstanceNeedRebootResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceNeedRebootResponseBody> body{};

  DescribeInstanceNeedRebootResponse() {}

  explicit DescribeInstanceNeedRebootResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceNeedRebootResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceNeedRebootResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceNeedRebootResponse() = default;
};
class DescribeInstancePerformanceRestrictHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeInstancePerformanceRestrictHistoryRequest() {}

  explicit DescribeInstancePerformanceRestrictHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeInstancePerformanceRestrictHistoryRequest() = default;
};
class DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals : public Darabonba::Model {
public:
  shared_ptr<vector<string>> interval{};

  DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals() {}

  explicit DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Interval"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Interval"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      interval = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals() = default;
};
class DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals> intervals{};

  DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory() {}

  explicit DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intervals) {
      res["Intervals"] = intervals ? boost::any(intervals->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Intervals") != m.end() && !m["Intervals"].empty()) {
      if (typeid(map<string, boost::any>) == m["Intervals"].type()) {
        DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Intervals"]));
        intervals = make_shared<DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistoryIntervals>(model1);
      }
    }
  }


  virtual ~DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory() = default;
};
class DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory>> performanceRestrictHistory{};

  DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories() {}

  explicit DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceRestrictHistory) {
      vector<boost::any> temp1;
      for(auto item1:*performanceRestrictHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PerformanceRestrictHistory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceRestrictHistory") != m.end() && !m["PerformanceRestrictHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["PerformanceRestrictHistory"].type()) {
        vector<DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PerformanceRestrictHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        performanceRestrictHistory = make_shared<vector<DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistoriesPerformanceRestrictHistory>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories() = default;
};
class DescribeInstancePerformanceRestrictHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories> performanceRestrictHistories{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstancePerformanceRestrictHistoryResponseBody() {}

  explicit DescribeInstancePerformanceRestrictHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (performanceRestrictHistories) {
      res["PerformanceRestrictHistories"] = performanceRestrictHistories ? boost::any(performanceRestrictHistories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PerformanceRestrictHistories") != m.end() && !m["PerformanceRestrictHistories"].empty()) {
      if (typeid(map<string, boost::any>) == m["PerformanceRestrictHistories"].type()) {
        DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PerformanceRestrictHistories"]));
        performanceRestrictHistories = make_shared<DescribeInstancePerformanceRestrictHistoryResponseBodyPerformanceRestrictHistories>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstancePerformanceRestrictHistoryResponseBody() = default;
};
class DescribeInstancePerformanceRestrictHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstancePerformanceRestrictHistoryResponseBody> body{};

  DescribeInstancePerformanceRestrictHistoryResponse() {}

  explicit DescribeInstancePerformanceRestrictHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancePerformanceRestrictHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancePerformanceRestrictHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancePerformanceRestrictHistoryResponse() = default;
};
class DescribeInstanceTypeResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> cores{};
  shared_ptr<vector<string>> instanceTypeFamilies{};
  shared_ptr<string> instanceTypeMatchMode{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<vector<double>> memories{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> searchTypes{};
  shared_ptr<vector<string>> zoneIds{};

  DescribeInstanceTypeResourceRequest() {}

  explicit DescribeInstanceTypeResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = boost::any(*instanceTypeFamilies);
    }
    if (instanceTypeMatchMode) {
      res["InstanceTypeMatchMode"] = boost::any(*instanceTypeMatchMode);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (memories) {
      res["Memories"] = boost::any(*memories);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (searchTypes) {
      res["SearchTypes"] = boost::any(*searchTypes);
    }
    if (zoneIds) {
      res["ZoneIds"] = boost::any(*zoneIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamilies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamilies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamilies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceTypeMatchMode") != m.end() && !m["InstanceTypeMatchMode"].empty()) {
      instanceTypeMatchMode = make_shared<string>(boost::any_cast<string>(m["InstanceTypeMatchMode"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Memories") != m.end() && !m["Memories"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["Memories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Memories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      memories = make_shared<vector<double>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SearchTypes") != m.end() && !m["SearchTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SearchTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SearchTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      searchTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ZoneIds") != m.end() && !m["ZoneIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceTypeResourceRequest() = default;
};
class DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth : public Darabonba::Model {
public:
  shared_ptr<long> adequacyScore{};
  shared_ptr<long> healthScore{};
  shared_ptr<long> hotScore{};
  shared_ptr<long> supplyScore{};

  DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth() {}

  explicit DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adequacyScore) {
      res["AdequacyScore"] = boost::any(*adequacyScore);
    }
    if (healthScore) {
      res["HealthScore"] = boost::any(*healthScore);
    }
    if (hotScore) {
      res["HotScore"] = boost::any(*hotScore);
    }
    if (supplyScore) {
      res["SupplyScore"] = boost::any(*supplyScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdequacyScore") != m.end() && !m["AdequacyScore"].empty()) {
      adequacyScore = make_shared<long>(boost::any_cast<long>(m["AdequacyScore"]));
    }
    if (m.find("HealthScore") != m.end() && !m["HealthScore"].empty()) {
      healthScore = make_shared<long>(boost::any_cast<long>(m["HealthScore"]));
    }
    if (m.find("HotScore") != m.end() && !m["HotScore"].empty()) {
      hotScore = make_shared<long>(boost::any_cast<long>(m["HotScore"]));
    }
    if (m.find("SupplyScore") != m.end() && !m["SupplyScore"].empty()) {
      supplyScore = make_shared<long>(boost::any_cast<long>(m["SupplyScore"]));
    }
  }


  virtual ~DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth() = default;
};
class DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchType{};
  shared_ptr<DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth> stockHealth{};
  shared_ptr<long> totalQuota{};
  shared_ptr<string> zoneId{};

  DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource() {}

  explicit DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchType) {
      res["SearchType"] = boost::any(*searchType);
    }
    if (stockHealth) {
      res["StockHealth"] = stockHealth ? boost::any(stockHealth->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalQuota) {
      res["TotalQuota"] = boost::any(*totalQuota);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchType") != m.end() && !m["SearchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["SearchType"]));
    }
    if (m.find("StockHealth") != m.end() && !m["StockHealth"].empty()) {
      if (typeid(map<string, boost::any>) == m["StockHealth"].type()) {
        DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StockHealth"]));
        stockHealth = make_shared<DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResourceStockHealth>(model1);
      }
    }
    if (m.find("TotalQuota") != m.end() && !m["TotalQuota"].empty()) {
      totalQuota = make_shared<long>(boost::any_cast<long>(m["TotalQuota"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource() = default;
};
class DescribeInstanceTypeResourceResponseBodyInstanceTypeResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource>> instanceTypeResource{};

  DescribeInstanceTypeResourceResponseBodyInstanceTypeResources() {}

  explicit DescribeInstanceTypeResourceResponseBodyInstanceTypeResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeResource) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeResource") != m.end() && !m["InstanceTypeResource"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeResource"].type()) {
        vector<DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeResource = make_shared<vector<DescribeInstanceTypeResourceResponseBodyInstanceTypeResourcesInstanceTypeResource>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTypeResourceResponseBodyInstanceTypeResources() = default;
};
class DescribeInstanceTypeResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceTypeResourceResponseBodyInstanceTypeResources> instanceTypeResources{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstanceTypeResourceResponseBody() {}

  explicit DescribeInstanceTypeResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeResources) {
      res["InstanceTypeResources"] = instanceTypeResources ? boost::any(instanceTypeResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeResources") != m.end() && !m["InstanceTypeResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypeResources"].type()) {
        DescribeInstanceTypeResourceResponseBodyInstanceTypeResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypeResources"]));
        instanceTypeResources = make_shared<DescribeInstanceTypeResourceResponseBodyInstanceTypeResources>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstanceTypeResourceResponseBody() = default;
};
class DescribeInstanceTypeResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceTypeResourceResponseBody> body{};

  DescribeInstanceTypeResourceResponse() {}

  explicit DescribeInstanceTypeResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTypeResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTypeResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTypeResourceResponse() = default;
};
class DescribeKMSKeyAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> channel{};
  shared_ptr<string> operator_{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> token{};

  DescribeKMSKeyAttributeRequest() {}

  explicit DescribeKMSKeyAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (appKey) {
      res["appKey"] = boost::any(*appKey);
    }
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("appKey") != m.end() && !m["appKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["appKey"]));
    }
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~DescribeKMSKeyAttributeRequest() = default;
};
class DescribeKMSKeyAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> creator{};
  shared_ptr<bool> ecsTagged{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeKMSKeyAttributeResponseBody() {}

  explicit DescribeKMSKeyAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (ecsTagged) {
      res["EcsTagged"] = boost::any(*ecsTagged);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("EcsTagged") != m.end() && !m["EcsTagged"].empty()) {
      ecsTagged = make_shared<bool>(boost::any_cast<bool>(m["EcsTagged"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeKMSKeyAttributeResponseBody() = default;
};
class DescribeKMSKeyAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeKMSKeyAttributeResponseBody> body{};

  DescribeKMSKeyAttributeResponse() {}

  explicit DescribeKMSKeyAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeKMSKeyAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeKMSKeyAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeKMSKeyAttributeResponse() = default;
};
class DescribeKMSKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> channel{};
  shared_ptr<string> operator_{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> token{};

  DescribeKMSKeysRequest() {}

  explicit DescribeKMSKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (appKey) {
      res["appKey"] = boost::any(*appKey);
    }
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("appKey") != m.end() && !m["appKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["appKey"]));
    }
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~DescribeKMSKeysRequest() = default;
};
class DescribeKMSKeysResponseBodyKMSKeyIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> kmsKeyId{};

  DescribeKMSKeysResponseBodyKMSKeyIds() {}

  explicit DescribeKMSKeysResponseBodyKMSKeyIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kmsKeyId) {
      res["kmsKeyId"] = boost::any(*kmsKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("kmsKeyId") != m.end() && !m["kmsKeyId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["kmsKeyId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["kmsKeyId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kmsKeyId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeKMSKeysResponseBodyKMSKeyIds() = default;
};
class DescribeKMSKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeKMSKeysResponseBodyKMSKeyIds> KMSKeyIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeKMSKeysResponseBody() {}

  explicit DescribeKMSKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (KMSKeyIds) {
      res["KMSKeyIds"] = KMSKeyIds ? boost::any(KMSKeyIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KMSKeyIds") != m.end() && !m["KMSKeyIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["KMSKeyIds"].type()) {
        DescribeKMSKeysResponseBodyKMSKeyIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KMSKeyIds"]));
        KMSKeyIds = make_shared<DescribeKMSKeysResponseBodyKMSKeyIds>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeKMSKeysResponseBody() = default;
};
class DescribeKMSKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeKMSKeysResponseBody> body{};

  DescribeKMSKeysResponse() {}

  explicit DescribeKMSKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeKMSKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeKMSKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeKMSKeysResponse() = default;
};
class DescribeLinkedKMSKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> channel{};
  shared_ptr<string> operator_{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> token{};

  DescribeLinkedKMSKeysRequest() {}

  explicit DescribeLinkedKMSKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (appKey) {
      res["appKey"] = boost::any(*appKey);
    }
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("appKey") != m.end() && !m["appKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["appKey"]));
    }
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~DescribeLinkedKMSKeysRequest() = default;
};
class DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> KMSKeyId{};

  DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey() {}

  explicit DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
  }


  virtual ~DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey() = default;
};
class DescribeLinkedKMSKeysResponseBodyKMSKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey>> KMSKey{};

  DescribeLinkedKMSKeysResponseBodyKMSKeys() {}

  explicit DescribeLinkedKMSKeysResponseBodyKMSKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (KMSKey) {
      vector<boost::any> temp1;
      for(auto item1:*KMSKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KMSKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KMSKey") != m.end() && !m["KMSKey"].empty()) {
      if (typeid(vector<boost::any>) == m["KMSKey"].type()) {
        vector<DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KMSKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        KMSKey = make_shared<vector<DescribeLinkedKMSKeysResponseBodyKMSKeysKMSKey>>(expect1);
      }
    }
  }


  virtual ~DescribeLinkedKMSKeysResponseBodyKMSKeys() = default;
};
class DescribeLinkedKMSKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLinkedKMSKeysResponseBodyKMSKeys> KMSKeys{};
  shared_ptr<string> requestId{};

  DescribeLinkedKMSKeysResponseBody() {}

  explicit DescribeLinkedKMSKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (KMSKeys) {
      res["KMSKeys"] = KMSKeys ? boost::any(KMSKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KMSKeys") != m.end() && !m["KMSKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["KMSKeys"].type()) {
        DescribeLinkedKMSKeysResponseBodyKMSKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KMSKeys"]));
        KMSKeys = make_shared<DescribeLinkedKMSKeysResponseBodyKMSKeys>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLinkedKMSKeysResponseBody() = default;
};
class DescribeLinkedKMSKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLinkedKMSKeysResponseBody> body{};

  DescribeLinkedKMSKeysResponse() {}

  explicit DescribeLinkedKMSKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLinkedKMSKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLinkedKMSKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLinkedKMSKeysResponse() = default;
};
class DescribeLocalDiskRepairActivitiesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> diskId{};
  shared_ptr<bool> includeHistory{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeLocalDiskRepairActivitiesRequest() {}

  explicit DescribeLocalDiskRepairActivitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (includeHistory) {
      res["IncludeHistory"] = boost::any(*includeHistory);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeHistory") != m.end() && !m["IncludeHistory"].empty()) {
      includeHistory = make_shared<bool>(boost::any_cast<bool>(m["IncludeHistory"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesRequest() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> name{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent : public Darabonba::Model {
public:
  shared_ptr<string> eventEndTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventTime{};
  shared_ptr<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType> eventType{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventEndTime) {
      res["EventEndTime"] = boost::any(*eventEndTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    if (eventType) {
      res["EventType"] = eventType ? boost::any(eventType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventEndTime") != m.end() && !m["EventEndTime"].empty()) {
      eventEndTime = make_shared<string>(boost::any_cast<string>(m["EventEndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<string>(boost::any_cast<string>(m["EventTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventType"].type()) {
        DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventType"]));
        eventType = make_shared<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEventEventType>(model1);
      }
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> name{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> name{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute : public Darabonba::Model {
public:
  shared_ptr<string> device{};
  shared_ptr<string> diskId{};
  shared_ptr<string> onlineRepairPolicy{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (onlineRepairPolicy) {
      res["OnlineRepairPolicy"] = boost::any(*onlineRepairPolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("OnlineRepairPolicy") != m.end() && !m["OnlineRepairPolicy"].empty()) {
      onlineRepairPolicy = make_shared<string>(boost::any_cast<string>(m["OnlineRepairPolicy"]));
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent : public Darabonba::Model {
public:
  shared_ptr<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus> eventCycleStatus{};
  shared_ptr<string> eventFinishTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventPublishTime{};
  shared_ptr<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType> eventType{};
  shared_ptr<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute> extendedAttribute{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> reason{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCycleStatus) {
      res["EventCycleStatus"] = eventCycleStatus ? boost::any(eventCycleStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventFinishTime) {
      res["EventFinishTime"] = boost::any(*eventFinishTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventPublishTime) {
      res["EventPublishTime"] = boost::any(*eventPublishTime);
    }
    if (eventType) {
      res["EventType"] = eventType ? boost::any(eventType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendedAttribute) {
      res["ExtendedAttribute"] = extendedAttribute ? boost::any(extendedAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventCycleStatus") != m.end() && !m["EventCycleStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventCycleStatus"].type()) {
        DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventCycleStatus"]));
        eventCycleStatus = make_shared<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventCycleStatus>(model1);
      }
    }
    if (m.find("EventFinishTime") != m.end() && !m["EventFinishTime"].empty()) {
      eventFinishTime = make_shared<string>(boost::any_cast<string>(m["EventFinishTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventPublishTime") != m.end() && !m["EventPublishTime"].empty()) {
      eventPublishTime = make_shared<string>(boost::any_cast<string>(m["EventPublishTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventType"].type()) {
        DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventType"]));
        eventType = make_shared<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventEventType>(model1);
      }
    }
    if (m.find("ExtendedAttribute") != m.end() && !m["ExtendedAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendedAttribute"].type()) {
        DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendedAttribute"]));
        extendedAttribute = make_shared<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEventExtendedAttribute>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent>> instanceEvent{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceEvent) {
      vector<boost::any> temp1;
      for(auto item1:*instanceEvent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceEvent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceEvent") != m.end() && !m["InstanceEvent"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceEvent"].type()) {
        vector<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceEvent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceEvent = make_shared<vector<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEventsInstanceEvent>>(expect1);
      }
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity : public Darabonba::Model {
public:
  shared_ptr<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent> diskEvent{};
  shared_ptr<string> diskId{};
  shared_ptr<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents> instanceEvents{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> progress{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskEvent) {
      res["DiskEvent"] = diskEvent ? boost::any(diskEvent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (instanceEvents) {
      res["InstanceEvents"] = instanceEvents ? boost::any(instanceEvents->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskEvent") != m.end() && !m["DiskEvent"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskEvent"].type()) {
        DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskEvent"]));
        diskEvent = make_shared<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityDiskEvent>(model1);
      }
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("InstanceEvents") != m.end() && !m["InstanceEvents"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceEvents"].type()) {
        DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceEvents"]));
        instanceEvents = make_shared<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivityInstanceEvents>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity>> localDiskRepairActivity{};

  DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localDiskRepairActivity) {
      vector<boost::any> temp1;
      for(auto item1:*localDiskRepairActivity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LocalDiskRepairActivity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalDiskRepairActivity") != m.end() && !m["LocalDiskRepairActivity"].empty()) {
      if (typeid(vector<boost::any>) == m["LocalDiskRepairActivity"].type()) {
        vector<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LocalDiskRepairActivity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        localDiskRepairActivity = make_shared<vector<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivitiesLocalDiskRepairActivity>>(expect1);
      }
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities() = default;
};
class DescribeLocalDiskRepairActivitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities> localDiskRepairActivities{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLocalDiskRepairActivitiesResponseBody() {}

  explicit DescribeLocalDiskRepairActivitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localDiskRepairActivities) {
      res["LocalDiskRepairActivities"] = localDiskRepairActivities ? boost::any(localDiskRepairActivities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalDiskRepairActivities") != m.end() && !m["LocalDiskRepairActivities"].empty()) {
      if (typeid(map<string, boost::any>) == m["LocalDiskRepairActivities"].type()) {
        DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LocalDiskRepairActivities"]));
        localDiskRepairActivities = make_shared<DescribeLocalDiskRepairActivitiesResponseBodyLocalDiskRepairActivities>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponseBody() = default;
};
class DescribeLocalDiskRepairActivitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLocalDiskRepairActivitiesResponseBody> body{};

  DescribeLocalDiskRepairActivitiesResponse() {}

  explicit DescribeLocalDiskRepairActivitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLocalDiskRepairActivitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLocalDiskRepairActivitiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLocalDiskRepairActivitiesResponse() = default;
};
class DescribeMigrationInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMigrationInstancesRequestTag() {}

  explicit DescribeMigrationInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMigrationInstancesRequestTag() = default;
};
class DescribeMigrationInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessMigrationType{};
  shared_ptr<string> hostname{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> migrationPlanId{};
  shared_ptr<string> migrationStatus{};
  shared_ptr<string> networkMigrationType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeMigrationInstancesRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  DescribeMigrationInstancesRequest() {}

  explicit DescribeMigrationInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessMigrationType) {
      res["BusinessMigrationType"] = boost::any(*businessMigrationType);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (migrationPlanId) {
      res["MigrationPlanId"] = boost::any(*migrationPlanId);
    }
    if (migrationStatus) {
      res["MigrationStatus"] = boost::any(*migrationStatus);
    }
    if (networkMigrationType) {
      res["NetworkMigrationType"] = boost::any(*networkMigrationType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessMigrationType") != m.end() && !m["BusinessMigrationType"].empty()) {
      businessMigrationType = make_shared<string>(boost::any_cast<string>(m["BusinessMigrationType"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MigrationPlanId") != m.end() && !m["MigrationPlanId"].empty()) {
      migrationPlanId = make_shared<string>(boost::any_cast<string>(m["MigrationPlanId"]));
    }
    if (m.find("MigrationStatus") != m.end() && !m["MigrationStatus"].empty()) {
      migrationStatus = make_shared<string>(boost::any_cast<string>(m["MigrationStatus"]));
    }
    if (m.find("NetworkMigrationType") != m.end() && !m["NetworkMigrationType"].empty()) {
      networkMigrationType = make_shared<string>(boost::any_cast<string>(m["NetworkMigrationType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeMigrationInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeMigrationInstancesRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeMigrationInstancesRequest() = default;
};
class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets() {}

  explicit DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets() = default;
};
class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition() {}

  explicit DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition() = default;
};
class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag() {}

  explicit DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag() = default;
};
class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag>> tag{};

  DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags() {}

  explicit DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags() = default;
};
class DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance : public Darabonba::Model {
public:
  shared_ptr<string> businessMigrationType{};
  shared_ptr<string> businessStatus{};
  shared_ptr<bool> changePublicIp{};
  shared_ptr<string> finishTime{};
  shared_ptr<bool> hasLocalDisk{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> internetIpAfterTransition{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> intranetIpAfterTransition{};
  shared_ptr<string> loadProgress{};
  shared_ptr<string> macAddressAfterTransition{};
  shared_ptr<string> mergeProgress{};
  shared_ptr<string> migrationPlanId{};
  shared_ptr<string> migrationStatus{};
  shared_ptr<string> name{};
  shared_ptr<bool> networkConnectivityStatus{};
  shared_ptr<long> networkMigrationType{};
  shared_ptr<bool> nonStandardInstanceType{};
  shared_ptr<string> privateMacAddress{};
  shared_ptr<string> publicMacAddress{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets> securityGroupIdSets{};
  shared_ptr<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition> securityGroupIdSetsAfterTransition{};
  shared_ptr<string> status{};
  shared_ptr<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags> tags{};
  shared_ptr<string> targetVSwitchId{};
  shared_ptr<string> targetVpcId{};
  shared_ptr<string> targetZoneId{};
  shared_ptr<string> transitionTime{};
  shared_ptr<string> zoneId{};

  DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance() {}

  explicit DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessMigrationType) {
      res["BusinessMigrationType"] = boost::any(*businessMigrationType);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (changePublicIp) {
      res["ChangePublicIp"] = boost::any(*changePublicIp);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (hasLocalDisk) {
      res["HasLocalDisk"] = boost::any(*hasLocalDisk);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (internetIpAfterTransition) {
      res["InternetIpAfterTransition"] = boost::any(*internetIpAfterTransition);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (intranetIpAfterTransition) {
      res["IntranetIpAfterTransition"] = boost::any(*intranetIpAfterTransition);
    }
    if (loadProgress) {
      res["LoadProgress"] = boost::any(*loadProgress);
    }
    if (macAddressAfterTransition) {
      res["MacAddressAfterTransition"] = boost::any(*macAddressAfterTransition);
    }
    if (mergeProgress) {
      res["MergeProgress"] = boost::any(*mergeProgress);
    }
    if (migrationPlanId) {
      res["MigrationPlanId"] = boost::any(*migrationPlanId);
    }
    if (migrationStatus) {
      res["MigrationStatus"] = boost::any(*migrationStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkConnectivityStatus) {
      res["NetworkConnectivityStatus"] = boost::any(*networkConnectivityStatus);
    }
    if (networkMigrationType) {
      res["NetworkMigrationType"] = boost::any(*networkMigrationType);
    }
    if (nonStandardInstanceType) {
      res["NonStandardInstanceType"] = boost::any(*nonStandardInstanceType);
    }
    if (privateMacAddress) {
      res["PrivateMacAddress"] = boost::any(*privateMacAddress);
    }
    if (publicMacAddress) {
      res["PublicMacAddress"] = boost::any(*publicMacAddress);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupIdSets) {
      res["SecurityGroupIdSets"] = securityGroupIdSets ? boost::any(securityGroupIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupIdSetsAfterTransition) {
      res["SecurityGroupIdSetsAfterTransition"] = securityGroupIdSetsAfterTransition ? boost::any(securityGroupIdSetsAfterTransition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetVSwitchId) {
      res["TargetVSwitchId"] = boost::any(*targetVSwitchId);
    }
    if (targetVpcId) {
      res["TargetVpcId"] = boost::any(*targetVpcId);
    }
    if (targetZoneId) {
      res["TargetZoneId"] = boost::any(*targetZoneId);
    }
    if (transitionTime) {
      res["TransitionTime"] = boost::any(*transitionTime);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessMigrationType") != m.end() && !m["BusinessMigrationType"].empty()) {
      businessMigrationType = make_shared<string>(boost::any_cast<string>(m["BusinessMigrationType"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ChangePublicIp") != m.end() && !m["ChangePublicIp"].empty()) {
      changePublicIp = make_shared<bool>(boost::any_cast<bool>(m["ChangePublicIp"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("HasLocalDisk") != m.end() && !m["HasLocalDisk"].empty()) {
      hasLocalDisk = make_shared<bool>(boost::any_cast<bool>(m["HasLocalDisk"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("InternetIpAfterTransition") != m.end() && !m["InternetIpAfterTransition"].empty()) {
      internetIpAfterTransition = make_shared<string>(boost::any_cast<string>(m["InternetIpAfterTransition"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("IntranetIpAfterTransition") != m.end() && !m["IntranetIpAfterTransition"].empty()) {
      intranetIpAfterTransition = make_shared<string>(boost::any_cast<string>(m["IntranetIpAfterTransition"]));
    }
    if (m.find("LoadProgress") != m.end() && !m["LoadProgress"].empty()) {
      loadProgress = make_shared<string>(boost::any_cast<string>(m["LoadProgress"]));
    }
    if (m.find("MacAddressAfterTransition") != m.end() && !m["MacAddressAfterTransition"].empty()) {
      macAddressAfterTransition = make_shared<string>(boost::any_cast<string>(m["MacAddressAfterTransition"]));
    }
    if (m.find("MergeProgress") != m.end() && !m["MergeProgress"].empty()) {
      mergeProgress = make_shared<string>(boost::any_cast<string>(m["MergeProgress"]));
    }
    if (m.find("MigrationPlanId") != m.end() && !m["MigrationPlanId"].empty()) {
      migrationPlanId = make_shared<string>(boost::any_cast<string>(m["MigrationPlanId"]));
    }
    if (m.find("MigrationStatus") != m.end() && !m["MigrationStatus"].empty()) {
      migrationStatus = make_shared<string>(boost::any_cast<string>(m["MigrationStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkConnectivityStatus") != m.end() && !m["NetworkConnectivityStatus"].empty()) {
      networkConnectivityStatus = make_shared<bool>(boost::any_cast<bool>(m["NetworkConnectivityStatus"]));
    }
    if (m.find("NetworkMigrationType") != m.end() && !m["NetworkMigrationType"].empty()) {
      networkMigrationType = make_shared<long>(boost::any_cast<long>(m["NetworkMigrationType"]));
    }
    if (m.find("NonStandardInstanceType") != m.end() && !m["NonStandardInstanceType"].empty()) {
      nonStandardInstanceType = make_shared<bool>(boost::any_cast<bool>(m["NonStandardInstanceType"]));
    }
    if (m.find("PrivateMacAddress") != m.end() && !m["PrivateMacAddress"].empty()) {
      privateMacAddress = make_shared<string>(boost::any_cast<string>(m["PrivateMacAddress"]));
    }
    if (m.find("PublicMacAddress") != m.end() && !m["PublicMacAddress"].empty()) {
      publicMacAddress = make_shared<string>(boost::any_cast<string>(m["PublicMacAddress"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupIdSets") != m.end() && !m["SecurityGroupIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIdSets"].type()) {
        DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIdSets"]));
        securityGroupIdSets = make_shared<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSets>(model1);
      }
    }
    if (m.find("SecurityGroupIdSetsAfterTransition") != m.end() && !m["SecurityGroupIdSetsAfterTransition"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIdSetsAfterTransition"].type()) {
        DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIdSetsAfterTransition"]));
        securityGroupIdSetsAfterTransition = make_shared<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceSecurityGroupIdSetsAfterTransition>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstanceTags>(model1);
      }
    }
    if (m.find("TargetVSwitchId") != m.end() && !m["TargetVSwitchId"].empty()) {
      targetVSwitchId = make_shared<string>(boost::any_cast<string>(m["TargetVSwitchId"]));
    }
    if (m.find("TargetVpcId") != m.end() && !m["TargetVpcId"].empty()) {
      targetVpcId = make_shared<string>(boost::any_cast<string>(m["TargetVpcId"]));
    }
    if (m.find("TargetZoneId") != m.end() && !m["TargetZoneId"].empty()) {
      targetZoneId = make_shared<string>(boost::any_cast<string>(m["TargetZoneId"]));
    }
    if (m.find("TransitionTime") != m.end() && !m["TransitionTime"].empty()) {
      transitionTime = make_shared<string>(boost::any_cast<string>(m["TransitionTime"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance() = default;
};
class DescribeMigrationInstancesResponseBodyMigrationInstanceSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance>> migrationInstance{};

  DescribeMigrationInstancesResponseBodyMigrationInstanceSet() {}

  explicit DescribeMigrationInstancesResponseBodyMigrationInstanceSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationInstance) {
      vector<boost::any> temp1;
      for(auto item1:*migrationInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MigrationInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationInstance") != m.end() && !m["MigrationInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["MigrationInstance"].type()) {
        vector<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MigrationInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        migrationInstance = make_shared<vector<DescribeMigrationInstancesResponseBodyMigrationInstanceSetMigrationInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationInstancesResponseBodyMigrationInstanceSet() = default;
};
class DescribeMigrationInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeMigrationInstancesResponseBodyMigrationInstanceSet> migrationInstanceSet{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeMigrationInstancesResponseBody() {}

  explicit DescribeMigrationInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationInstanceSet) {
      res["MigrationInstanceSet"] = migrationInstanceSet ? boost::any(migrationInstanceSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationInstanceSet") != m.end() && !m["MigrationInstanceSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationInstanceSet"].type()) {
        DescribeMigrationInstancesResponseBodyMigrationInstanceSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationInstanceSet"]));
        migrationInstanceSet = make_shared<DescribeMigrationInstancesResponseBodyMigrationInstanceSet>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeMigrationInstancesResponseBody() = default;
};
class DescribeMigrationInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMigrationInstancesResponseBody> body{};

  DescribeMigrationInstancesResponse() {}

  explicit DescribeMigrationInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrationInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrationInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrationInstancesResponse() = default;
};
class DescribeMigrationPlansRequest : public Darabonba::Model {
public:
  shared_ptr<string> migrationPlanId{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeMigrationPlansRequest() {}

  explicit DescribeMigrationPlansRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationPlanId) {
      res["MigrationPlanId"] = boost::any(*migrationPlanId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationPlanId") != m.end() && !m["MigrationPlanId"].empty()) {
      migrationPlanId = make_shared<string>(boost::any_cast<string>(m["MigrationPlanId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeMigrationPlansRequest() = default;
};
class DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupNo{};

  DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos() {}

  explicit DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupNo) {
      res["SecurityGroupNo"] = boost::any(*securityGroupNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupNo") != m.end() && !m["SecurityGroupNo"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupNo"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupNo"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupNo = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos() = default;
};
class DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<bool> enableAutoCreateVSwitch{};
  shared_ptr<bool> enableNetworkConnectivity{};
  shared_ptr<long> finishInstanceCount{};
  shared_ptr<string> migrationPlanId{};
  shared_ptr<string> name{};
  shared_ptr<bool> remainPrivateIp{};
  shared_ptr<bool> remainPublicMacAsPriority{};
  shared_ptr<DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos> securityGroupNos{};
  shared_ptr<string> status{};
  shared_ptr<string> targetVSwitchId{};
  shared_ptr<string> targetVpcId{};
  shared_ptr<string> targetZoneId{};
  shared_ptr<long> totalInstanceCount{};
  shared_ptr<string> type{};

  DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan() {}

  explicit DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (enableAutoCreateVSwitch) {
      res["EnableAutoCreateVSwitch"] = boost::any(*enableAutoCreateVSwitch);
    }
    if (enableNetworkConnectivity) {
      res["EnableNetworkConnectivity"] = boost::any(*enableNetworkConnectivity);
    }
    if (finishInstanceCount) {
      res["FinishInstanceCount"] = boost::any(*finishInstanceCount);
    }
    if (migrationPlanId) {
      res["MigrationPlanId"] = boost::any(*migrationPlanId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remainPrivateIp) {
      res["RemainPrivateIp"] = boost::any(*remainPrivateIp);
    }
    if (remainPublicMacAsPriority) {
      res["RemainPublicMacAsPriority"] = boost::any(*remainPublicMacAsPriority);
    }
    if (securityGroupNos) {
      res["SecurityGroupNos"] = securityGroupNos ? boost::any(securityGroupNos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetVSwitchId) {
      res["TargetVSwitchId"] = boost::any(*targetVSwitchId);
    }
    if (targetVpcId) {
      res["TargetVpcId"] = boost::any(*targetVpcId);
    }
    if (targetZoneId) {
      res["TargetZoneId"] = boost::any(*targetZoneId);
    }
    if (totalInstanceCount) {
      res["TotalInstanceCount"] = boost::any(*totalInstanceCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EnableAutoCreateVSwitch") != m.end() && !m["EnableAutoCreateVSwitch"].empty()) {
      enableAutoCreateVSwitch = make_shared<bool>(boost::any_cast<bool>(m["EnableAutoCreateVSwitch"]));
    }
    if (m.find("EnableNetworkConnectivity") != m.end() && !m["EnableNetworkConnectivity"].empty()) {
      enableNetworkConnectivity = make_shared<bool>(boost::any_cast<bool>(m["EnableNetworkConnectivity"]));
    }
    if (m.find("FinishInstanceCount") != m.end() && !m["FinishInstanceCount"].empty()) {
      finishInstanceCount = make_shared<long>(boost::any_cast<long>(m["FinishInstanceCount"]));
    }
    if (m.find("MigrationPlanId") != m.end() && !m["MigrationPlanId"].empty()) {
      migrationPlanId = make_shared<string>(boost::any_cast<string>(m["MigrationPlanId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RemainPrivateIp") != m.end() && !m["RemainPrivateIp"].empty()) {
      remainPrivateIp = make_shared<bool>(boost::any_cast<bool>(m["RemainPrivateIp"]));
    }
    if (m.find("RemainPublicMacAsPriority") != m.end() && !m["RemainPublicMacAsPriority"].empty()) {
      remainPublicMacAsPriority = make_shared<bool>(boost::any_cast<bool>(m["RemainPublicMacAsPriority"]));
    }
    if (m.find("SecurityGroupNos") != m.end() && !m["SecurityGroupNos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupNos"].type()) {
        DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupNos"]));
        securityGroupNos = make_shared<DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlanSecurityGroupNos>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetVSwitchId") != m.end() && !m["TargetVSwitchId"].empty()) {
      targetVSwitchId = make_shared<string>(boost::any_cast<string>(m["TargetVSwitchId"]));
    }
    if (m.find("TargetVpcId") != m.end() && !m["TargetVpcId"].empty()) {
      targetVpcId = make_shared<string>(boost::any_cast<string>(m["TargetVpcId"]));
    }
    if (m.find("TargetZoneId") != m.end() && !m["TargetZoneId"].empty()) {
      targetZoneId = make_shared<string>(boost::any_cast<string>(m["TargetZoneId"]));
    }
    if (m.find("TotalInstanceCount") != m.end() && !m["TotalInstanceCount"].empty()) {
      totalInstanceCount = make_shared<long>(boost::any_cast<long>(m["TotalInstanceCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan() = default;
};
class DescribeMigrationPlansResponseBodyMigrationPlanSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan>> migrationPlan{};

  DescribeMigrationPlansResponseBodyMigrationPlanSet() {}

  explicit DescribeMigrationPlansResponseBodyMigrationPlanSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationPlan) {
      vector<boost::any> temp1;
      for(auto item1:*migrationPlan){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MigrationPlan"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationPlan") != m.end() && !m["MigrationPlan"].empty()) {
      if (typeid(vector<boost::any>) == m["MigrationPlan"].type()) {
        vector<DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MigrationPlan"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        migrationPlan = make_shared<vector<DescribeMigrationPlansResponseBodyMigrationPlanSetMigrationPlan>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationPlansResponseBodyMigrationPlanSet() = default;
};
class DescribeMigrationPlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeMigrationPlansResponseBodyMigrationPlanSet> migrationPlanSet{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeMigrationPlansResponseBody() {}

  explicit DescribeMigrationPlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationPlanSet) {
      res["MigrationPlanSet"] = migrationPlanSet ? boost::any(migrationPlanSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationPlanSet") != m.end() && !m["MigrationPlanSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationPlanSet"].type()) {
        DescribeMigrationPlansResponseBodyMigrationPlanSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationPlanSet"]));
        migrationPlanSet = make_shared<DescribeMigrationPlansResponseBodyMigrationPlanSet>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeMigrationPlansResponseBody() = default;
};
class DescribeMigrationPlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMigrationPlansResponseBody> body{};

  DescribeMigrationPlansResponse() {}

  explicit DescribeMigrationPlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrationPlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrationPlansResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrationPlansResponse() = default;
};
class DescribeMigrationPreferencesRequest : public Darabonba::Model {
public:
  shared_ptr<string> migrationNetworkType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeMigrationPreferencesRequest() {}

  explicit DescribeMigrationPreferencesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationNetworkType) {
      res["MigrationNetworkType"] = boost::any(*migrationNetworkType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationNetworkType") != m.end() && !m["MigrationNetworkType"].empty()) {
      migrationNetworkType = make_shared<string>(boost::any_cast<string>(m["MigrationNetworkType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeMigrationPreferencesRequest() = default;
};
class DescribeMigrationPreferencesResponseBodyTargetZoneIdSet : public Darabonba::Model {
public:
  shared_ptr<vector<string>> targetZoneId{};

  DescribeMigrationPreferencesResponseBodyTargetZoneIdSet() {}

  explicit DescribeMigrationPreferencesResponseBodyTargetZoneIdSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetZoneId) {
      res["TargetZoneId"] = boost::any(*targetZoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetZoneId") != m.end() && !m["TargetZoneId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetZoneId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetZoneId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetZoneId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeMigrationPreferencesResponseBodyTargetZoneIdSet() = default;
};
class DescribeMigrationPreferencesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> migrationNetworkType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMigrationPreferencesResponseBodyTargetZoneIdSet> targetZoneIdSet{};

  DescribeMigrationPreferencesResponseBody() {}

  explicit DescribeMigrationPreferencesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationNetworkType) {
      res["MigrationNetworkType"] = boost::any(*migrationNetworkType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (targetZoneIdSet) {
      res["TargetZoneIdSet"] = targetZoneIdSet ? boost::any(targetZoneIdSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationNetworkType") != m.end() && !m["MigrationNetworkType"].empty()) {
      migrationNetworkType = make_shared<string>(boost::any_cast<string>(m["MigrationNetworkType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TargetZoneIdSet") != m.end() && !m["TargetZoneIdSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetZoneIdSet"].type()) {
        DescribeMigrationPreferencesResponseBodyTargetZoneIdSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetZoneIdSet"]));
        targetZoneIdSet = make_shared<DescribeMigrationPreferencesResponseBodyTargetZoneIdSet>(model1);
      }
    }
  }


  virtual ~DescribeMigrationPreferencesResponseBody() = default;
};
class DescribeMigrationPreferencesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMigrationPreferencesResponseBody> body{};

  DescribeMigrationPreferencesResponse() {}

  explicit DescribeMigrationPreferencesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrationPreferencesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrationPreferencesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrationPreferencesResponse() = default;
};
class DescribeNetworkInsightsAnalysisResultRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> networkInsightsAnalysisId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  DescribeNetworkInsightsAnalysisResultRequest() {}

  explicit DescribeNetworkInsightsAnalysisResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkInsightsAnalysisId) {
      res["NetworkInsightsAnalysisId"] = boost::any(*networkInsightsAnalysisId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkInsightsAnalysisId") != m.end() && !m["NetworkInsightsAnalysisId"].empty()) {
      networkInsightsAnalysisId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsAnalysisId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultRequest() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> vpcId{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> relativeGroupId{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relativeGroupId) {
      res["RelativeGroupId"] = boost::any(*relativeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelativeGroupId") != m.end() && !m["RelativeGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelativeGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelativeGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relativeGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> destGroupId{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> innerAccessPolicy{};
  shared_ptr<string> nicType{};
  shared_ptr<string> policy{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (destGroupId) {
      res["DestGroupId"] = boost::any(*destGroupId);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (innerAccessPolicy) {
      res["InnerAccessPolicy"] = boost::any(*innerAccessPolicy);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("DestGroupId") != m.end() && !m["DestGroupId"].empty()) {
      destGroupId = make_shared<string>(boost::any_cast<string>(m["DestGroupId"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("InnerAccessPolicy") != m.end() && !m["InnerAccessPolicy"].empty()) {
      innerAccessPolicy = make_shared<string>(boost::any_cast<string>(m["InnerAccessPolicy"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses : public Darabonba::Model {
public:
  shared_ptr<vector<string>> topProcess{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topProcess) {
      res["TopProcess"] = boost::any(*topProcess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopProcess") != m.end() && !m["TopProcess"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TopProcess"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TopProcess"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      topProcess = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations : public Darabonba::Model {
public:
  shared_ptr<string> actualIP{};
  shared_ptr<long> actualPort{};
  shared_ptr<string> expectIP{};
  shared_ptr<long> expectPort{};
  shared_ptr<string> expireDate{};
  shared_ptr<string> groupId{};
  shared_ptr<string> header{};
  shared_ptr<string> ip{};
  shared_ptr<string> missingFiles{};
  shared_ptr<string> netmask{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry> networkAclEntry{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<long> port{};
  shared_ptr<string> processName{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds> relativeGroupIds{};
  shared_ptr<string> rule{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl> securityGroupAcl{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses> topProcesses{};
  shared_ptr<string> usePercent{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualIP) {
      res["ActualIP"] = boost::any(*actualIP);
    }
    if (actualPort) {
      res["ActualPort"] = boost::any(*actualPort);
    }
    if (expectIP) {
      res["ExpectIP"] = boost::any(*expectIP);
    }
    if (expectPort) {
      res["ExpectPort"] = boost::any(*expectPort);
    }
    if (expireDate) {
      res["ExpireDate"] = boost::any(*expireDate);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (header) {
      res["Header"] = boost::any(*header);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (missingFiles) {
      res["MissingFiles"] = boost::any(*missingFiles);
    }
    if (netmask) {
      res["Netmask"] = boost::any(*netmask);
    }
    if (networkAclEntry) {
      res["NetworkAclEntry"] = networkAclEntry ? boost::any(networkAclEntry->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (relativeGroupIds) {
      res["RelativeGroupIds"] = relativeGroupIds ? boost::any(relativeGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (securityGroupAcl) {
      res["SecurityGroupAcl"] = securityGroupAcl ? boost::any(securityGroupAcl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (topProcesses) {
      res["TopProcesses"] = topProcesses ? boost::any(topProcesses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usePercent) {
      res["UsePercent"] = boost::any(*usePercent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualIP") != m.end() && !m["ActualIP"].empty()) {
      actualIP = make_shared<string>(boost::any_cast<string>(m["ActualIP"]));
    }
    if (m.find("ActualPort") != m.end() && !m["ActualPort"].empty()) {
      actualPort = make_shared<long>(boost::any_cast<long>(m["ActualPort"]));
    }
    if (m.find("ExpectIP") != m.end() && !m["ExpectIP"].empty()) {
      expectIP = make_shared<string>(boost::any_cast<string>(m["ExpectIP"]));
    }
    if (m.find("ExpectPort") != m.end() && !m["ExpectPort"].empty()) {
      expectPort = make_shared<long>(boost::any_cast<long>(m["ExpectPort"]));
    }
    if (m.find("ExpireDate") != m.end() && !m["ExpireDate"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["ExpireDate"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      header = make_shared<string>(boost::any_cast<string>(m["Header"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("MissingFiles") != m.end() && !m["MissingFiles"].empty()) {
      missingFiles = make_shared<string>(boost::any_cast<string>(m["MissingFiles"]));
    }
    if (m.find("Netmask") != m.end() && !m["Netmask"].empty()) {
      netmask = make_shared<string>(boost::any_cast<string>(m["Netmask"]));
    }
    if (m.find("NetworkAclEntry") != m.end() && !m["NetworkAclEntry"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAclEntry"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAclEntry"]));
        networkAclEntry = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsNetworkAclEntry>(model1);
      }
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("RelativeGroupIds") != m.end() && !m["RelativeGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelativeGroupIds"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelativeGroupIds"]));
        relativeGroupIds = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsRelativeGroupIds>(model1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("SecurityGroupAcl") != m.end() && !m["SecurityGroupAcl"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupAcl"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupAcl"]));
        securityGroupAcl = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsSecurityGroupAcl>(model1);
      }
    }
    if (m.find("TopProcesses") != m.end() && !m["TopProcesses"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopProcesses"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopProcesses"]));
        topProcesses = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanationsTopProcesses>(model1);
      }
    }
    if (m.find("UsePercent") != m.end() && !m["UsePercent"].empty()) {
      usePercent = make_shared<string>(boost::any_cast<string>(m["UsePercent"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations> explanations{};
  shared_ptr<string> itemName{};
  shared_ptr<string> reachable{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (explanations) {
      res["Explanations"] = explanations ? boost::any(explanations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (reachable) {
      res["Reachable"] = boost::any(*reachable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Explanations") != m.end() && !m["Explanations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Explanations"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Explanations"]));
        explanations = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItemExplanations>(model1);
      }
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Reachable") != m.end() && !m["Reachable"].empty()) {
      reachable = make_shared<string>(boost::any_cast<string>(m["Reachable"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem>> categoryItem{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryItem) {
      vector<boost::any> temp1;
      for(auto item1:*categoryItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CategoryItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryItem") != m.end() && !m["CategoryItem"].empty()) {
      if (typeid(vector<boost::any>) == m["CategoryItem"].type()) {
        vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CategoryItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categoryItem = make_shared<vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItemsCategoryItem>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems> categoryItems{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> reachable{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryItems) {
      res["CategoryItems"] = categoryItems ? boost::any(categoryItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (reachable) {
      res["Reachable"] = boost::any(*reachable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryItems") != m.end() && !m["CategoryItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["CategoryItems"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CategoryItems"]));
        categoryItems = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategoryCategoryItems>(model1);
      }
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Reachable") != m.end() && !m["Reachable"].empty()) {
      reachable = make_shared<string>(boost::any_cast<string>(m["Reachable"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory>> diagnoseCategory{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseCategory) {
      vector<boost::any> temp1;
      for(auto item1:*diagnoseCategory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiagnoseCategory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseCategory") != m.end() && !m["DiagnoseCategory"].empty()) {
      if (typeid(vector<boost::any>) == m["DiagnoseCategory"].type()) {
        vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiagnoseCategory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diagnoseCategory = make_shared<vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategoriesDiagnoseCategory>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> destinationCidrIp{};
  shared_ptr<string> direction{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> vpcId{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (destinationCidrIp) {
      res["DestinationCidrIp"] = boost::any(*destinationCidrIp);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DestinationCidrIp") != m.end() && !m["DestinationCidrIp"].empty()) {
      destinationCidrIp = make_shared<string>(boost::any_cast<string>(m["DestinationCidrIp"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> relativeGroupId{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relativeGroupId) {
      res["RelativeGroupId"] = boost::any(*relativeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelativeGroupId") != m.end() && !m["RelativeGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelativeGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelativeGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relativeGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> destGroupId{};
  shared_ptr<string> destGroupName{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> direction{};
  shared_ptr<string> innerAccessPolicy{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> ipv6DestCidrIp{};
  shared_ptr<string> ipv6SourceCidrIp{};
  shared_ptr<string> nicType{};
  shared_ptr<string> permissionDescription{};
  shared_ptr<string> policy{};
  shared_ptr<string> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourceGroupId{};
  shared_ptr<string> sourceGroupName{};
  shared_ptr<string> sourcePortRange{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (destGroupId) {
      res["DestGroupId"] = boost::any(*destGroupId);
    }
    if (destGroupName) {
      res["DestGroupName"] = boost::any(*destGroupName);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (innerAccessPolicy) {
      res["InnerAccessPolicy"] = boost::any(*innerAccessPolicy);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (ipv6DestCidrIp) {
      res["Ipv6DestCidrIp"] = boost::any(*ipv6DestCidrIp);
    }
    if (ipv6SourceCidrIp) {
      res["Ipv6SourceCidrIp"] = boost::any(*ipv6SourceCidrIp);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (permissionDescription) {
      res["PermissionDescription"] = boost::any(*permissionDescription);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourceGroupId) {
      res["SourceGroupId"] = boost::any(*sourceGroupId);
    }
    if (sourceGroupName) {
      res["SourceGroupName"] = boost::any(*sourceGroupName);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("DestGroupId") != m.end() && !m["DestGroupId"].empty()) {
      destGroupId = make_shared<string>(boost::any_cast<string>(m["DestGroupId"]));
    }
    if (m.find("DestGroupName") != m.end() && !m["DestGroupName"].empty()) {
      destGroupName = make_shared<string>(boost::any_cast<string>(m["DestGroupName"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("InnerAccessPolicy") != m.end() && !m["InnerAccessPolicy"].empty()) {
      innerAccessPolicy = make_shared<string>(boost::any_cast<string>(m["InnerAccessPolicy"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Ipv6DestCidrIp") != m.end() && !m["Ipv6DestCidrIp"].empty()) {
      ipv6DestCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6DestCidrIp"]));
    }
    if (m.find("Ipv6SourceCidrIp") != m.end() && !m["Ipv6SourceCidrIp"].empty()) {
      ipv6SourceCidrIp = make_shared<string>(boost::any_cast<string>(m["Ipv6SourceCidrIp"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("PermissionDescription") != m.end() && !m["PermissionDescription"].empty()) {
      permissionDescription = make_shared<string>(boost::any_cast<string>(m["PermissionDescription"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourceGroupId") != m.end() && !m["SourceGroupId"].empty()) {
      sourceGroupId = make_shared<string>(boost::any_cast<string>(m["SourceGroupId"]));
    }
    if (m.find("SourceGroupName") != m.end() && !m["SourceGroupName"].empty()) {
      sourceGroupName = make_shared<string>(boost::any_cast<string>(m["SourceGroupName"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories> diagnoseCategories{};
  shared_ptr<string> message{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry> networkAclEntry{};
  shared_ptr<string> reachable{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds> relativeGroupIds{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl> securityGroupAcl{};
  shared_ptr<long> sequence{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (diagnoseCategories) {
      res["DiagnoseCategories"] = diagnoseCategories ? boost::any(diagnoseCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (networkAclEntry) {
      res["NetworkAclEntry"] = networkAclEntry ? boost::any(networkAclEntry->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reachable) {
      res["Reachable"] = boost::any(*reachable);
    }
    if (relativeGroupIds) {
      res["RelativeGroupIds"] = relativeGroupIds ? boost::any(relativeGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityGroupAcl) {
      res["SecurityGroupAcl"] = securityGroupAcl ? boost::any(securityGroupAcl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DiagnoseCategories") != m.end() && !m["DiagnoseCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiagnoseCategories"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiagnoseCategories"]));
        diagnoseCategories = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentDiagnoseCategories>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NetworkAclEntry") != m.end() && !m["NetworkAclEntry"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAclEntry"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAclEntry"]));
        networkAclEntry = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentNetworkAclEntry>(model1);
      }
    }
    if (m.find("Reachable") != m.end() && !m["Reachable"].empty()) {
      reachable = make_shared<string>(boost::any_cast<string>(m["Reachable"]));
    }
    if (m.find("RelativeGroupIds") != m.end() && !m["RelativeGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelativeGroupIds"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelativeGroupIds"]));
        relativeGroupIds = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentRelativeGroupIds>(model1);
      }
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityGroupAcl") != m.end() && !m["SecurityGroupAcl"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupAcl"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupAcl"]));
        securityGroupAcl = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponentSecurityGroupAcl>(model1);
      }
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<long>(boost::any_cast<long>(m["Sequence"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent>> networkInsightsAnalysisComponent{};

  DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInsightsAnalysisComponent) {
      vector<boost::any> temp1;
      for(auto item1:*networkInsightsAnalysisComponent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInsightsAnalysisComponent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInsightsAnalysisComponent") != m.end() && !m["NetworkInsightsAnalysisComponent"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInsightsAnalysisComponent"].type()) {
        vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInsightsAnalysisComponent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInsightsAnalysisComponent = make_shared<vector<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponentsNetworkInsightsAnalysisComponent>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents() = default;
};
class DescribeNetworkInsightsAnalysisResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> destination{};
  shared_ptr<string> destinationIp{};
  shared_ptr<string> destinationPort{};
  shared_ptr<string> destinationType{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents> networkInsightsAnalysisComponents{};
  shared_ptr<string> networkInsightsAnalysisId{};
  shared_ptr<string> networkInsightsPathId{};
  shared_ptr<string> networkPathFound{};
  shared_ptr<string> protocol{};
  shared_ptr<string> requestId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> status{};

  DescribeNetworkInsightsAnalysisResultResponseBody() {}

  explicit DescribeNetworkInsightsAnalysisResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (destinationIp) {
      res["DestinationIp"] = boost::any(*destinationIp);
    }
    if (destinationPort) {
      res["DestinationPort"] = boost::any(*destinationPort);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (networkInsightsAnalysisComponents) {
      res["NetworkInsightsAnalysisComponents"] = networkInsightsAnalysisComponents ? boost::any(networkInsightsAnalysisComponents->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkInsightsAnalysisId) {
      res["NetworkInsightsAnalysisId"] = boost::any(*networkInsightsAnalysisId);
    }
    if (networkInsightsPathId) {
      res["NetworkInsightsPathId"] = boost::any(*networkInsightsPathId);
    }
    if (networkPathFound) {
      res["NetworkPathFound"] = boost::any(*networkPathFound);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("DestinationIp") != m.end() && !m["DestinationIp"].empty()) {
      destinationIp = make_shared<string>(boost::any_cast<string>(m["DestinationIp"]));
    }
    if (m.find("DestinationPort") != m.end() && !m["DestinationPort"].empty()) {
      destinationPort = make_shared<string>(boost::any_cast<string>(m["DestinationPort"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("NetworkInsightsAnalysisComponents") != m.end() && !m["NetworkInsightsAnalysisComponents"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInsightsAnalysisComponents"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInsightsAnalysisComponents"]));
        networkInsightsAnalysisComponents = make_shared<DescribeNetworkInsightsAnalysisResultResponseBodyNetworkInsightsAnalysisComponents>(model1);
      }
    }
    if (m.find("NetworkInsightsAnalysisId") != m.end() && !m["NetworkInsightsAnalysisId"].empty()) {
      networkInsightsAnalysisId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsAnalysisId"]));
    }
    if (m.find("NetworkInsightsPathId") != m.end() && !m["NetworkInsightsPathId"].empty()) {
      networkInsightsPathId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsPathId"]));
    }
    if (m.find("NetworkPathFound") != m.end() && !m["NetworkPathFound"].empty()) {
      networkPathFound = make_shared<string>(boost::any_cast<string>(m["NetworkPathFound"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponseBody() = default;
};
class DescribeNetworkInsightsAnalysisResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkInsightsAnalysisResultResponseBody> body{};

  DescribeNetworkInsightsAnalysisResultResponse() {}

  explicit DescribeNetworkInsightsAnalysisResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkInsightsAnalysisResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkInsightsAnalysisResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisResultResponse() = default;
};
class DescribeNetworkInsightsAnalysisesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<string>> networkInsightsAnalysisId{};
  shared_ptr<string> networkInsightsPathId{};
  shared_ptr<string> networkPathFound{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  DescribeNetworkInsightsAnalysisesRequest() {}

  explicit DescribeNetworkInsightsAnalysisesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (networkInsightsAnalysisId) {
      res["NetworkInsightsAnalysisId"] = boost::any(*networkInsightsAnalysisId);
    }
    if (networkInsightsPathId) {
      res["NetworkInsightsPathId"] = boost::any(*networkInsightsPathId);
    }
    if (networkPathFound) {
      res["NetworkPathFound"] = boost::any(*networkPathFound);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetworkInsightsAnalysisId") != m.end() && !m["NetworkInsightsAnalysisId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInsightsAnalysisId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInsightsAnalysisId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInsightsAnalysisId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkInsightsPathId") != m.end() && !m["NetworkInsightsPathId"].empty()) {
      networkInsightsPathId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsPathId"]));
    }
    if (m.find("NetworkPathFound") != m.end() && !m["NetworkPathFound"].empty()) {
      networkPathFound = make_shared<string>(boost::any_cast<string>(m["NetworkPathFound"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisesRequest() = default;
};
class DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> networkInsightsAnalysisId{};
  shared_ptr<string> networkInsightsPathId{};
  shared_ptr<string> networkPathFound{};
  shared_ptr<string> status{};

  DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet() {}

  explicit DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (networkInsightsAnalysisId) {
      res["NetworkInsightsAnalysisId"] = boost::any(*networkInsightsAnalysisId);
    }
    if (networkInsightsPathId) {
      res["NetworkInsightsPathId"] = boost::any(*networkInsightsPathId);
    }
    if (networkPathFound) {
      res["NetworkPathFound"] = boost::any(*networkPathFound);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("NetworkInsightsAnalysisId") != m.end() && !m["NetworkInsightsAnalysisId"].empty()) {
      networkInsightsAnalysisId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsAnalysisId"]));
    }
    if (m.find("NetworkInsightsPathId") != m.end() && !m["NetworkInsightsPathId"].empty()) {
      networkInsightsPathId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsPathId"]));
    }
    if (m.find("NetworkPathFound") != m.end() && !m["NetworkPathFound"].empty()) {
      networkPathFound = make_shared<string>(boost::any_cast<string>(m["NetworkPathFound"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet() = default;
};
class DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet>> networkInsightsAnalysisSet{};

  DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets() {}

  explicit DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInsightsAnalysisSet) {
      vector<boost::any> temp1;
      for(auto item1:*networkInsightsAnalysisSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInsightsAnalysisSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInsightsAnalysisSet") != m.end() && !m["NetworkInsightsAnalysisSet"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInsightsAnalysisSet"].type()) {
        vector<DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInsightsAnalysisSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInsightsAnalysisSet = make_shared<vector<DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSetsNetworkInsightsAnalysisSet>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets() = default;
};
class DescribeNetworkInsightsAnalysisesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets> networkInsightsAnalysisSets{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeNetworkInsightsAnalysisesResponseBody() {}

  explicit DescribeNetworkInsightsAnalysisesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (networkInsightsAnalysisSets) {
      res["NetworkInsightsAnalysisSets"] = networkInsightsAnalysisSets ? boost::any(networkInsightsAnalysisSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetworkInsightsAnalysisSets") != m.end() && !m["NetworkInsightsAnalysisSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInsightsAnalysisSets"].type()) {
        DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInsightsAnalysisSets"]));
        networkInsightsAnalysisSets = make_shared<DescribeNetworkInsightsAnalysisesResponseBodyNetworkInsightsAnalysisSets>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisesResponseBody() = default;
};
class DescribeNetworkInsightsAnalysisesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkInsightsAnalysisesResponseBody> body{};

  DescribeNetworkInsightsAnalysisesResponse() {}

  explicit DescribeNetworkInsightsAnalysisesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkInsightsAnalysisesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkInsightsAnalysisesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInsightsAnalysisesResponse() = default;
};
class DescribeNetworkInsightsPathsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<string>> networkInsightsPathId{};
  shared_ptr<string> networkPathFound{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  DescribeNetworkInsightsPathsRequest() {}

  explicit DescribeNetworkInsightsPathsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (networkInsightsPathId) {
      res["NetworkInsightsPathId"] = boost::any(*networkInsightsPathId);
    }
    if (networkPathFound) {
      res["NetworkPathFound"] = boost::any(*networkPathFound);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetworkInsightsPathId") != m.end() && !m["NetworkInsightsPathId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInsightsPathId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInsightsPathId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInsightsPathId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkPathFound") != m.end() && !m["NetworkPathFound"].empty()) {
      networkPathFound = make_shared<string>(boost::any_cast<string>(m["NetworkPathFound"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkInsightsPathsRequest() = default;
};
class DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> destination{};
  shared_ptr<string> destinationPort{};
  shared_ptr<string> destinationType{};
  shared_ptr<string> networkInsightsPathId{};
  shared_ptr<string> networkInsightsPathName{};
  shared_ptr<string> networkPathFound{};
  shared_ptr<string> protocol{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> status{};

  DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet() {}

  explicit DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (destinationPort) {
      res["DestinationPort"] = boost::any(*destinationPort);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (networkInsightsPathId) {
      res["NetworkInsightsPathId"] = boost::any(*networkInsightsPathId);
    }
    if (networkInsightsPathName) {
      res["NetworkInsightsPathName"] = boost::any(*networkInsightsPathName);
    }
    if (networkPathFound) {
      res["NetworkPathFound"] = boost::any(*networkPathFound);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("DestinationPort") != m.end() && !m["DestinationPort"].empty()) {
      destinationPort = make_shared<string>(boost::any_cast<string>(m["DestinationPort"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("NetworkInsightsPathId") != m.end() && !m["NetworkInsightsPathId"].empty()) {
      networkInsightsPathId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsPathId"]));
    }
    if (m.find("NetworkInsightsPathName") != m.end() && !m["NetworkInsightsPathName"].empty()) {
      networkInsightsPathName = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsPathName"]));
    }
    if (m.find("NetworkPathFound") != m.end() && !m["NetworkPathFound"].empty()) {
      networkPathFound = make_shared<string>(boost::any_cast<string>(m["NetworkPathFound"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet() = default;
};
class DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet>> networkInsightsPathSet{};

  DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets() {}

  explicit DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInsightsPathSet) {
      vector<boost::any> temp1;
      for(auto item1:*networkInsightsPathSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInsightsPathSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInsightsPathSet") != m.end() && !m["NetworkInsightsPathSet"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInsightsPathSet"].type()) {
        vector<DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInsightsPathSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInsightsPathSet = make_shared<vector<DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSetsNetworkInsightsPathSet>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets() = default;
};
class DescribeNetworkInsightsPathsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets> networkInsightsPathSets{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  DescribeNetworkInsightsPathsResponseBody() {}

  explicit DescribeNetworkInsightsPathsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (networkInsightsPathSets) {
      res["NetworkInsightsPathSets"] = networkInsightsPathSets ? boost::any(networkInsightsPathSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetworkInsightsPathSets") != m.end() && !m["NetworkInsightsPathSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInsightsPathSets"].type()) {
        DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInsightsPathSets"]));
        networkInsightsPathSets = make_shared<DescribeNetworkInsightsPathsResponseBodyNetworkInsightsPathSets>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNetworkInsightsPathsResponseBody() = default;
};
class DescribeNetworkInsightsPathsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkInsightsPathsResponseBody> body{};

  DescribeNetworkInsightsPathsResponse() {}

  explicit DescribeNetworkInsightsPathsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkInsightsPathsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkInsightsPathsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInsightsPathsResponse() = default;
};
class DescribeOrderAutoRebootTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeOrderAutoRebootTimeRequest() {}

  explicit DescribeOrderAutoRebootTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeOrderAutoRebootTimeRequest() = default;
};
class DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo : public Darabonba::Model {
public:
  shared_ptr<string> autoRebootTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> orderId{};

  DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo() {}

  explicit DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRebootTime) {
      res["AutoRebootTime"] = boost::any(*autoRebootTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRebootTime") != m.end() && !m["AutoRebootTime"].empty()) {
      autoRebootTime = make_shared<string>(boost::any_cast<string>(m["AutoRebootTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
  }


  virtual ~DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo() = default;
};
class DescribeOrderAutoRebootTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo> describeOrderAutoRebootTimeInfo{};
  shared_ptr<string> requestId{};

  DescribeOrderAutoRebootTimeResponseBody() {}

  explicit DescribeOrderAutoRebootTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeOrderAutoRebootTimeInfo) {
      res["DescribeOrderAutoRebootTimeInfo"] = describeOrderAutoRebootTimeInfo ? boost::any(describeOrderAutoRebootTimeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeOrderAutoRebootTimeInfo") != m.end() && !m["DescribeOrderAutoRebootTimeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeOrderAutoRebootTimeInfo"].type()) {
        DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeOrderAutoRebootTimeInfo"]));
        describeOrderAutoRebootTimeInfo = make_shared<DescribeOrderAutoRebootTimeResponseBodyDescribeOrderAutoRebootTimeInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOrderAutoRebootTimeResponseBody() = default;
};
class DescribeOrderAutoRebootTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrderAutoRebootTimeResponseBody> body{};

  DescribeOrderAutoRebootTimeResponse() {}

  explicit DescribeOrderAutoRebootTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrderAutoRebootTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrderAutoRebootTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrderAutoRebootTimeResponse() = default;
};
class DescribePrePaidResourceRefundPriceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  DescribePrePaidResourceRefundPriceRequest() {}

  explicit DescribePrePaidResourceRefundPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribePrePaidResourceRefundPriceRequest() = default;
};
class DescribePrePaidResourceRefundPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> refunds{};
  shared_ptr<string> requestId{};

  DescribePrePaidResourceRefundPriceResponseBody() {}

  explicit DescribePrePaidResourceRefundPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (refunds) {
      res["Refunds"] = boost::any(*refunds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("Refunds") != m.end() && !m["Refunds"].empty()) {
      refunds = make_shared<double>(boost::any_cast<double>(m["Refunds"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePrePaidResourceRefundPriceResponseBody() = default;
};
class DescribePrePaidResourceRefundPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePrePaidResourceRefundPriceResponseBody> body{};

  DescribePrePaidResourceRefundPriceResponse() {}

  explicit DescribePrePaidResourceRefundPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrePaidResourceRefundPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrePaidResourceRefundPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrePaidResourceRefundPriceResponse() = default;
};
class DescribePriceRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessInfo{};
  shared_ptr<string> commodity{};
  shared_ptr<string> defaultVpc{};
  shared_ptr<string> fromApp{};
  shared_ptr<bool> needSpotPrice{};
  shared_ptr<string> networkType{};
  shared_ptr<string> orderType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> verbose{};

  DescribePriceRequest() {}

  explicit DescribePriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    if (commodity) {
      res["Commodity"] = boost::any(*commodity);
    }
    if (defaultVpc) {
      res["DefaultVpc"] = boost::any(*defaultVpc);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (needSpotPrice) {
      res["NeedSpotPrice"] = boost::any(*needSpotPrice);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (verbose) {
      res["Verbose"] = boost::any(*verbose);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
    if (m.find("Commodity") != m.end() && !m["Commodity"].empty()) {
      commodity = make_shared<string>(boost::any_cast<string>(m["Commodity"]));
    }
    if (m.find("DefaultVpc") != m.end() && !m["DefaultVpc"].empty()) {
      defaultVpc = make_shared<string>(boost::any_cast<string>(m["DefaultVpc"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("NeedSpotPrice") != m.end() && !m["NeedSpotPrice"].empty()) {
      needSpotPrice = make_shared<bool>(boost::any_cast<bool>(m["NeedSpotPrice"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Verbose") != m.end() && !m["Verbose"].empty()) {
      verbose = make_shared<bool>(boost::any_cast<bool>(m["Verbose"]));
    }
  }


  virtual ~DescribePriceRequest() = default;
};
class DescribePriceResponseBodyPriceInfoOrderCouponsCoupon : public Darabonba::Model {
public:
  shared_ptr<string> couponNo{};
  shared_ptr<string> description{};
  shared_ptr<double> discountOff{};
  shared_ptr<bool> isSelected{};
  shared_ptr<string> name{};

  DescribePriceResponseBodyPriceInfoOrderCouponsCoupon() {}

  explicit DescribePriceResponseBodyPriceInfoOrderCouponsCoupon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (couponNo) {
      res["CouponNo"] = boost::any(*couponNo);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (discountOff) {
      res["DiscountOff"] = boost::any(*discountOff);
    }
    if (isSelected) {
      res["IsSelected"] = boost::any(*isSelected);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CouponNo") != m.end() && !m["CouponNo"].empty()) {
      couponNo = make_shared<string>(boost::any_cast<string>(m["CouponNo"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiscountOff") != m.end() && !m["DiscountOff"].empty()) {
      discountOff = make_shared<double>(boost::any_cast<double>(m["DiscountOff"]));
    }
    if (m.find("IsSelected") != m.end() && !m["IsSelected"].empty()) {
      isSelected = make_shared<bool>(boost::any_cast<bool>(m["IsSelected"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderCouponsCoupon() = default;
};
class DescribePriceResponseBodyPriceInfoOrderCoupons : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoOrderCouponsCoupon>> coupon{};

  DescribePriceResponseBodyPriceInfoOrderCoupons() {}

  explicit DescribePriceResponseBodyPriceInfoOrderCoupons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coupon) {
      vector<boost::any> temp1;
      for(auto item1:*coupon){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Coupon"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Coupon") != m.end() && !m["Coupon"].empty()) {
      if (typeid(vector<boost::any>) == m["Coupon"].type()) {
        vector<DescribePriceResponseBodyPriceInfoOrderCouponsCoupon> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Coupon"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoOrderCouponsCoupon model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coupon = make_shared<vector<DescribePriceResponseBodyPriceInfoOrderCouponsCoupon>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderCoupons() = default;
};
class DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> title{};

  DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule() {}

  explicit DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule() = default;
};
class DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule>> rule{};

  DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules() {}

  explicit DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules() = default;
};
class DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel : public Darabonba::Model {
public:
  shared_ptr<double> discountPrice{};
  shared_ptr<double> originalPrice{};
  shared_ptr<string> resource{};
  shared_ptr<DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules> subRules{};
  shared_ptr<double> tradePrice{};

  DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel() {}

  explicit DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (subRules) {
      res["SubRules"] = subRules ? boost::any(subRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("SubRules") != m.end() && !m["SubRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubRules"].type()) {
        DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubRules"]));
        subRules = make_shared<DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModelSubRules>(model1);
      }
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel() = default;
};
class DescribePriceResponseBodyPriceInfoOrderDetailInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel>> resourcePriceModel{};

  DescribePriceResponseBodyPriceInfoOrderDetailInfos() {}

  explicit DescribePriceResponseBodyPriceInfoOrderDetailInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePriceModel) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePriceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePriceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePriceModel") != m.end() && !m["ResourcePriceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePriceModel"].type()) {
        vector<DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePriceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePriceModel = make_shared<vector<DescribePriceResponseBodyPriceInfoOrderDetailInfosResourcePriceModel>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderDetailInfos() = default;
};
class DescribePriceResponseBodyPriceInfoOrderRuleIdSet : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ruleId{};

  DescribePriceResponseBodyPriceInfoOrderRuleIdSet() {}

  explicit DescribePriceResponseBodyPriceInfoOrderRuleIdSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderRuleIdSet() = default;
};
class DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ruleId{};

  DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet() {}

  explicit DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet() = default;
};
class DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder : public Darabonba::Model {
public:
  shared_ptr<double> discountPrice{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> originalPrice{};
  shared_ptr<DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet> ruleIdSet{};
  shared_ptr<double> tradePrice{};

  DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder() {}

  explicit DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (ruleIdSet) {
      res["RuleIdSet"] = ruleIdSet ? boost::any(ruleIdSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("RuleIdSet") != m.end() && !m["RuleIdSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleIdSet"].type()) {
        DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleIdSet"]));
        ruleIdSet = make_shared<DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrderRuleIdSet>(model1);
      }
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder() = default;
};
class DescribePriceResponseBodyPriceInfoOrderSubOrders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder>> subOrder{};

  DescribePriceResponseBodyPriceInfoOrderSubOrders() {}

  explicit DescribePriceResponseBodyPriceInfoOrderSubOrders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subOrder) {
      vector<boost::any> temp1;
      for(auto item1:*subOrder){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubOrder"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubOrder") != m.end() && !m["SubOrder"].empty()) {
      if (typeid(vector<boost::any>) == m["SubOrder"].type()) {
        vector<DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubOrder"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subOrder = make_shared<vector<DescribePriceResponseBodyPriceInfoOrderSubOrdersSubOrder>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderSubOrders() = default;
};
class DescribePriceResponseBodyPriceInfoOrder : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfoOrderCoupons> coupons{};
  shared_ptr<string> currency{};
  shared_ptr<DescribePriceResponseBodyPriceInfoOrderDetailInfos> detailInfos{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> originalPrice{};
  shared_ptr<DescribePriceResponseBodyPriceInfoOrderRuleIdSet> ruleIdSet{};
  shared_ptr<double> spotInstanceTypeOriginalPrice{};
  shared_ptr<double> spotInstanceTypePrice{};
  shared_ptr<DescribePriceResponseBodyPriceInfoOrderSubOrders> subOrders{};
  shared_ptr<double> tradePrice{};

  DescribePriceResponseBodyPriceInfoOrder() {}

  explicit DescribePriceResponseBodyPriceInfoOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coupons) {
      res["Coupons"] = coupons ? boost::any(coupons->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (detailInfos) {
      res["DetailInfos"] = detailInfos ? boost::any(detailInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (ruleIdSet) {
      res["RuleIdSet"] = ruleIdSet ? boost::any(ruleIdSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotInstanceTypeOriginalPrice) {
      res["SpotInstanceTypeOriginalPrice"] = boost::any(*spotInstanceTypeOriginalPrice);
    }
    if (spotInstanceTypePrice) {
      res["SpotInstanceTypePrice"] = boost::any(*spotInstanceTypePrice);
    }
    if (subOrders) {
      res["SubOrders"] = subOrders ? boost::any(subOrders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Coupons") != m.end() && !m["Coupons"].empty()) {
      if (typeid(map<string, boost::any>) == m["Coupons"].type()) {
        DescribePriceResponseBodyPriceInfoOrderCoupons model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Coupons"]));
        coupons = make_shared<DescribePriceResponseBodyPriceInfoOrderCoupons>(model1);
      }
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DetailInfos") != m.end() && !m["DetailInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetailInfos"].type()) {
        DescribePriceResponseBodyPriceInfoOrderDetailInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetailInfos"]));
        detailInfos = make_shared<DescribePriceResponseBodyPriceInfoOrderDetailInfos>(model1);
      }
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("RuleIdSet") != m.end() && !m["RuleIdSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleIdSet"].type()) {
        DescribePriceResponseBodyPriceInfoOrderRuleIdSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleIdSet"]));
        ruleIdSet = make_shared<DescribePriceResponseBodyPriceInfoOrderRuleIdSet>(model1);
      }
    }
    if (m.find("SpotInstanceTypeOriginalPrice") != m.end() && !m["SpotInstanceTypeOriginalPrice"].empty()) {
      spotInstanceTypeOriginalPrice = make_shared<double>(boost::any_cast<double>(m["SpotInstanceTypeOriginalPrice"]));
    }
    if (m.find("SpotInstanceTypePrice") != m.end() && !m["SpotInstanceTypePrice"].empty()) {
      spotInstanceTypePrice = make_shared<double>(boost::any_cast<double>(m["SpotInstanceTypePrice"]));
    }
    if (m.find("SubOrders") != m.end() && !m["SubOrders"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubOrders"].type()) {
        DescribePriceResponseBodyPriceInfoOrderSubOrders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubOrders"]));
        subOrders = make_shared<DescribePriceResponseBodyPriceInfoOrderSubOrders>(model1);
      }
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrder() = default;
};
class DescribePriceResponseBodyPriceInfoOrderParams : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderParam{};

  DescribePriceResponseBodyPriceInfoOrderParams() {}

  explicit DescribePriceResponseBodyPriceInfoOrderParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderParam) {
      res["OrderParam"] = boost::any(*orderParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderParam") != m.end() && !m["OrderParam"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderParam"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderParam"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderParam = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoOrderParams() = default;
};
class DescribePriceResponseBodyPriceInfoPriceWarning : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> msg{};

  DescribePriceResponseBodyPriceInfoPriceWarning() {}

  explicit DescribePriceResponseBodyPriceInfoPriceWarning(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPriceWarning() = default;
};
class DescribePriceResponseBodyPriceInfoRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> title{};

  DescribePriceResponseBodyPriceInfoRulesRule() {}

  explicit DescribePriceResponseBodyPriceInfoRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoRulesRule() = default;
};
class DescribePriceResponseBodyPriceInfoRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoRulesRule>> rule{};

  DescribePriceResponseBodyPriceInfoRules() {}

  explicit DescribePriceResponseBodyPriceInfoRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribePriceResponseBodyPriceInfoRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribePriceResponseBodyPriceInfoRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoRules() = default;
};
class DescribePriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfoOrder> order{};
  shared_ptr<DescribePriceResponseBodyPriceInfoOrderParams> orderParams{};
  shared_ptr<DescribePriceResponseBodyPriceInfoPriceWarning> priceWarning{};
  shared_ptr<DescribePriceResponseBodyPriceInfoRules> rules{};

  DescribePriceResponseBodyPriceInfo() {}

  explicit DescribePriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = order ? boost::any(order->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderParams) {
      res["OrderParams"] = orderParams ? boost::any(orderParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priceWarning) {
      res["PriceWarning"] = priceWarning ? boost::any(priceWarning->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      if (typeid(map<string, boost::any>) == m["Order"].type()) {
        DescribePriceResponseBodyPriceInfoOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Order"]));
        order = make_shared<DescribePriceResponseBodyPriceInfoOrder>(model1);
      }
    }
    if (m.find("OrderParams") != m.end() && !m["OrderParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderParams"].type()) {
        DescribePriceResponseBodyPriceInfoOrderParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderParams"]));
        orderParams = make_shared<DescribePriceResponseBodyPriceInfoOrderParams>(model1);
      }
    }
    if (m.find("PriceWarning") != m.end() && !m["PriceWarning"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceWarning"].type()) {
        DescribePriceResponseBodyPriceInfoPriceWarning model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceWarning"]));
        priceWarning = make_shared<DescribePriceResponseBodyPriceInfoPriceWarning>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribePriceResponseBodyPriceInfoRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribePriceResponseBodyPriceInfoRules>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfo() = default;
};
class DescribePriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribePriceResponseBody() {}

  explicit DescribePriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribePriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribePriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePriceResponseBody() = default;
};
class DescribePriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePriceResponseBody> body{};

  DescribePriceResponse() {}

  explicit DescribePriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceResponse() = default;
};
class DescribePrivatePoolsRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<string> type{};

  DescribePrivatePoolsRequestPrivatePoolOptions() {}

  explicit DescribePrivatePoolsRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePrivatePoolsRequestPrivatePoolOptions() = default;
};
class DescribePrivatePoolsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribePrivatePoolsRequestTag() {}

  explicit DescribePrivatePoolsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePrivatePoolsRequestTag() = default;
};
class DescribePrivatePoolsRequest : public Darabonba::Model {
public:
  shared_ptr<DescribePrivatePoolsRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> platform{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startTimeType{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribePrivatePoolsRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  DescribePrivatePoolsRequest() {}

  explicit DescribePrivatePoolsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startTimeType) {
      res["StartTimeType"] = boost::any(*startTimeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        DescribePrivatePoolsRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<DescribePrivatePoolsRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartTimeType") != m.end() && !m["StartTimeType"].empty()) {
      startTimeType = make_shared<string>(boost::any_cast<string>(m["StartTimeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribePrivatePoolsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrivatePoolsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribePrivatePoolsRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribePrivatePoolsRequest() = default;
};
class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<long> totalAmount{};
  shared_ptr<long> usedAmount{};
  shared_ptr<string> zoneId{};

  DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource() {}

  explicit DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    if (usedAmount) {
      res["UsedAmount"] = boost::any(*usedAmount);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
    if (m.find("UsedAmount") != m.end() && !m["UsedAmount"].empty()) {
      usedAmount = make_shared<long>(boost::any_cast<long>(m["UsedAmount"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource() = default;
};
class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource>> allocatedResource{};

  DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources() {}

  explicit DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocatedResource) {
      vector<boost::any> temp1;
      for(auto item1:*allocatedResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AllocatedResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocatedResource") != m.end() && !m["AllocatedResource"].empty()) {
      if (typeid(vector<boost::any>) == m["AllocatedResource"].type()) {
        vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AllocatedResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allocatedResource = make_shared<vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResourcesAllocatedResource>>(expect1);
      }
    }
  }


  virtual ~DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources() = default;
};
class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag() {}

  explicit DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag() = default;
};
class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag>> tag{};

  DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags() {}

  explicit DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags() = default;
};
class DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem : public Darabonba::Model {
public:
  shared_ptr<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources> allocatedResources{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> endTimeType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> latestStartTime{};
  shared_ptr<string> platform{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> privatePoolOptionsMatchCriteria{};
  shared_ptr<string> privatePoolOptionsName{};
  shared_ptr<string> privatePoolOptionsType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> startTimeType{};
  shared_ptr<string> status{};
  shared_ptr<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags> tags{};
  shared_ptr<string> totalAssuranceTimes{};
  shared_ptr<long> usedAssuranceTimes{};

  DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem() {}

  explicit DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocatedResources) {
      res["AllocatedResources"] = allocatedResources ? boost::any(allocatedResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimeType) {
      res["EndTimeType"] = boost::any(*endTimeType);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (latestStartTime) {
      res["LatestStartTime"] = boost::any(*latestStartTime);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (privatePoolOptionsMatchCriteria) {
      res["PrivatePoolOptionsMatchCriteria"] = boost::any(*privatePoolOptionsMatchCriteria);
    }
    if (privatePoolOptionsName) {
      res["PrivatePoolOptionsName"] = boost::any(*privatePoolOptionsName);
    }
    if (privatePoolOptionsType) {
      res["PrivatePoolOptionsType"] = boost::any(*privatePoolOptionsType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (startTimeType) {
      res["StartTimeType"] = boost::any(*startTimeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalAssuranceTimes) {
      res["TotalAssuranceTimes"] = boost::any(*totalAssuranceTimes);
    }
    if (usedAssuranceTimes) {
      res["UsedAssuranceTimes"] = boost::any(*usedAssuranceTimes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocatedResources") != m.end() && !m["AllocatedResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["AllocatedResources"].type()) {
        DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AllocatedResources"]));
        allocatedResources = make_shared<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemAllocatedResources>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndTimeType") != m.end() && !m["EndTimeType"].empty()) {
      endTimeType = make_shared<string>(boost::any_cast<string>(m["EndTimeType"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("LatestStartTime") != m.end() && !m["LatestStartTime"].empty()) {
      latestStartTime = make_shared<string>(boost::any_cast<string>(m["LatestStartTime"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("PrivatePoolOptionsMatchCriteria") != m.end() && !m["PrivatePoolOptionsMatchCriteria"].empty()) {
      privatePoolOptionsMatchCriteria = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsMatchCriteria"]));
    }
    if (m.find("PrivatePoolOptionsName") != m.end() && !m["PrivatePoolOptionsName"].empty()) {
      privatePoolOptionsName = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsName"]));
    }
    if (m.find("PrivatePoolOptionsType") != m.end() && !m["PrivatePoolOptionsType"].empty()) {
      privatePoolOptionsType = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StartTimeType") != m.end() && !m["StartTimeType"].empty()) {
      startTimeType = make_shared<string>(boost::any_cast<string>(m["StartTimeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItemTags>(model1);
      }
    }
    if (m.find("TotalAssuranceTimes") != m.end() && !m["TotalAssuranceTimes"].empty()) {
      totalAssuranceTimes = make_shared<string>(boost::any_cast<string>(m["TotalAssuranceTimes"]));
    }
    if (m.find("UsedAssuranceTimes") != m.end() && !m["UsedAssuranceTimes"].empty()) {
      usedAssuranceTimes = make_shared<long>(boost::any_cast<long>(m["UsedAssuranceTimes"]));
    }
  }


  virtual ~DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem() = default;
};
class DescribePrivatePoolsResponseBodyPrivatePoolSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem>> privatePoolItem{};

  DescribePrivatePoolsResponseBodyPrivatePoolSet() {}

  explicit DescribePrivatePoolsResponseBodyPrivatePoolSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolItem) {
      vector<boost::any> temp1;
      for(auto item1:*privatePoolItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivatePoolItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolItem") != m.end() && !m["PrivatePoolItem"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivatePoolItem"].type()) {
        vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivatePoolItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privatePoolItem = make_shared<vector<DescribePrivatePoolsResponseBodyPrivatePoolSetPrivatePoolItem>>(expect1);
      }
    }
  }


  virtual ~DescribePrivatePoolsResponseBodyPrivatePoolSet() = default;
};
class DescribePrivatePoolsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<DescribePrivatePoolsResponseBodyPrivatePoolSet> privatePoolSet{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePrivatePoolsResponseBody() {}

  explicit DescribePrivatePoolsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (privatePoolSet) {
      res["PrivatePoolSet"] = privatePoolSet ? boost::any(privatePoolSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PrivatePoolSet") != m.end() && !m["PrivatePoolSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolSet"].type()) {
        DescribePrivatePoolsResponseBodyPrivatePoolSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolSet"]));
        privatePoolSet = make_shared<DescribePrivatePoolsResponseBodyPrivatePoolSet>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePrivatePoolsResponseBody() = default;
};
class DescribePrivatePoolsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePrivatePoolsResponseBody> body{};

  DescribePrivatePoolsResponse() {}

  explicit DescribePrivatePoolsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrivatePoolsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrivatePoolsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrivatePoolsResponse() = default;
};
class DescribeRecommendProductRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> cores{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<string> instanceType{};
  shared_ptr<vector<string>> instanceTypeFamily{};
  shared_ptr<bool> instanceTypeSupportIPv6{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<double> maxPrice{};
  shared_ptr<double> memory{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> priorityStrategy{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> zoneMatchMode{};

  DescribeRecommendProductRequest() {}

  explicit DescribeRecommendProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (instanceTypeSupportIPv6) {
      res["InstanceTypeSupportIPv6"] = boost::any(*instanceTypeSupportIPv6);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priorityStrategy) {
      res["PriorityStrategy"] = boost::any(*priorityStrategy);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (zoneMatchMode) {
      res["ZoneMatchMode"] = boost::any(*zoneMatchMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypeFamily"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypeFamily"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamily = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceTypeSupportIPv6") != m.end() && !m["InstanceTypeSupportIPv6"].empty()) {
      instanceTypeSupportIPv6 = make_shared<bool>(boost::any_cast<bool>(m["InstanceTypeSupportIPv6"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PriorityStrategy") != m.end() && !m["PriorityStrategy"].empty()) {
      priorityStrategy = make_shared<string>(boost::any_cast<string>(m["PriorityStrategy"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ZoneMatchMode") != m.end() && !m["ZoneMatchMode"].empty()) {
      zoneMatchMode = make_shared<string>(boost::any_cast<string>(m["ZoneMatchMode"]));
    }
  }


  virtual ~DescribeRecommendProductRequest() = default;
};
class DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType : public Darabonba::Model {
public:
  shared_ptr<long> cores{};
  shared_ptr<string> generation{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<long> memory{};
  shared_ptr<string> supportIoOptimized{};

  DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType() {}

  explicit DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (generation) {
      res["Generation"] = boost::any(*generation);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (supportIoOptimized) {
      res["SupportIoOptimized"] = boost::any(*supportIoOptimized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("Generation") != m.end() && !m["Generation"].empty()) {
      generation = make_shared<string>(boost::any_cast<string>(m["Generation"]));
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("SupportIoOptimized") != m.end() && !m["SupportIoOptimized"].empty()) {
      supportIoOptimized = make_shared<string>(boost::any_cast<string>(m["SupportIoOptimized"]));
    }
  }


  virtual ~DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType() = default;
};
class DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType : public Darabonba::Model {
public:
  shared_ptr<string> capacitySpecification{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType> instanceType{};
  shared_ptr<string> networkType{};
  shared_ptr<double> price{};
  shared_ptr<long> priority{};
  shared_ptr<string> spotStrategy{};

  DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType() {}

  explicit DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacitySpecification) {
      res["CapacitySpecification"] = boost::any(*capacitySpecification);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceType) {
      res["InstanceType"] = instanceType ? boost::any(instanceType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (price) {
      res["Price"] = boost::any(*price);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacitySpecification") != m.end() && !m["CapacitySpecification"].empty()) {
      capacitySpecification = make_shared<string>(boost::any_cast<string>(m["CapacitySpecification"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceType"].type()) {
        DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceType"]));
        instanceType = make_shared<DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceTypeInstanceType>(model1);
      }
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["Price"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
  }


  virtual ~DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType() = default;
};
class DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType>> recommendInstanceType{};

  DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes() {}

  explicit DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendInstanceType) {
      vector<boost::any> temp1;
      for(auto item1:*recommendInstanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendInstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendInstanceType") != m.end() && !m["RecommendInstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendInstanceType"].type()) {
        vector<DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendInstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendInstanceType = make_shared<vector<DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypesRecommendInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes() = default;
};
class DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct : public Darabonba::Model {
public:
  shared_ptr<DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes> recommendInstanceTypes{};
  shared_ptr<string> zoneId{};

  DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct() {}

  explicit DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendInstanceTypes) {
      res["RecommendInstanceTypes"] = recommendInstanceTypes ? boost::any(recommendInstanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendInstanceTypes") != m.end() && !m["RecommendInstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendInstanceTypes"].type()) {
        DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendInstanceTypes"]));
        recommendInstanceTypes = make_shared<DescribeRecommendProductResponseBodyRecommendProductsRecommendProductRecommendInstanceTypes>(model1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct() = default;
};
class DescribeRecommendProductResponseBodyRecommendProducts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct>> recommendProduct{};

  DescribeRecommendProductResponseBodyRecommendProducts() {}

  explicit DescribeRecommendProductResponseBodyRecommendProducts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendProduct) {
      vector<boost::any> temp1;
      for(auto item1:*recommendProduct){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendProduct"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendProduct") != m.end() && !m["RecommendProduct"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendProduct"].type()) {
        vector<DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendProduct"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendProduct = make_shared<vector<DescribeRecommendProductResponseBodyRecommendProductsRecommendProduct>>(expect1);
      }
    }
  }


  virtual ~DescribeRecommendProductResponseBodyRecommendProducts() = default;
};
class DescribeRecommendProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRecommendProductResponseBodyRecommendProducts> recommendProducts{};
  shared_ptr<string> requestId{};

  DescribeRecommendProductResponseBody() {}

  explicit DescribeRecommendProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendProducts) {
      res["RecommendProducts"] = recommendProducts ? boost::any(recommendProducts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendProducts") != m.end() && !m["RecommendProducts"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendProducts"].type()) {
        DescribeRecommendProductResponseBodyRecommendProducts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendProducts"]));
        recommendProducts = make_shared<DescribeRecommendProductResponseBodyRecommendProducts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRecommendProductResponseBody() = default;
};
class DescribeRecommendProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecommendProductResponseBody> body{};

  DescribeRecommendProductResponse() {}

  explicit DescribeRecommendProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecommendProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecommendProductResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecommendProductResponse() = default;
};
class DescribeReservationDemandCommittedAmountRequestDemandPlan : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> instanceType{};

  DescribeReservationDemandCommittedAmountRequestDemandPlan() {}

  explicit DescribeReservationDemandCommittedAmountRequestDemandPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeReservationDemandCommittedAmountRequestDemandPlan() = default;
};
class DescribeReservationDemandCommittedAmountRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservationDemandCommittedAmountRequestDemandPlan>> demandPlan{};
  shared_ptr<string> instanceFamily{};
  shared_ptr<string> instanceFamilySet{};
  shared_ptr<string> offeringType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> planType{};
  shared_ptr<string> platform{};
  shared_ptr<string> purchaseMethod{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DescribeReservationDemandCommittedAmountRequest() {}

  explicit DescribeReservationDemandCommittedAmountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demandPlan) {
      vector<boost::any> temp1;
      for(auto item1:*demandPlan){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DemandPlan"] = boost::any(temp1);
    }
    if (instanceFamily) {
      res["InstanceFamily"] = boost::any(*instanceFamily);
    }
    if (instanceFamilySet) {
      res["InstanceFamilySet"] = boost::any(*instanceFamilySet);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (planType) {
      res["PlanType"] = boost::any(*planType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (purchaseMethod) {
      res["PurchaseMethod"] = boost::any(*purchaseMethod);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemandPlan") != m.end() && !m["DemandPlan"].empty()) {
      if (typeid(vector<boost::any>) == m["DemandPlan"].type()) {
        vector<DescribeReservationDemandCommittedAmountRequestDemandPlan> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DemandPlan"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservationDemandCommittedAmountRequestDemandPlan model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        demandPlan = make_shared<vector<DescribeReservationDemandCommittedAmountRequestDemandPlan>>(expect1);
      }
    }
    if (m.find("InstanceFamily") != m.end() && !m["InstanceFamily"].empty()) {
      instanceFamily = make_shared<string>(boost::any_cast<string>(m["InstanceFamily"]));
    }
    if (m.find("InstanceFamilySet") != m.end() && !m["InstanceFamilySet"].empty()) {
      instanceFamilySet = make_shared<string>(boost::any_cast<string>(m["InstanceFamilySet"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PlanType") != m.end() && !m["PlanType"].empty()) {
      planType = make_shared<string>(boost::any_cast<string>(m["PlanType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PurchaseMethod") != m.end() && !m["PurchaseMethod"].empty()) {
      purchaseMethod = make_shared<string>(boost::any_cast<string>(m["PurchaseMethod"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DescribeReservationDemandCommittedAmountRequest() = default;
};
class DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo : public Darabonba::Model {
public:
  shared_ptr<double> committedAmount{};
  shared_ptr<string> currency{};

  DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo() {}

  explicit DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (committedAmount) {
      res["CommittedAmount"] = boost::any(*committedAmount);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommittedAmount") != m.end() && !m["CommittedAmount"].empty()) {
      committedAmount = make_shared<double>(boost::any_cast<double>(m["CommittedAmount"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
  }


  virtual ~DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo() = default;
};
class DescribeReservationDemandCommittedAmountResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo> committedAmountInfo{};
  shared_ptr<string> requestId{};

  DescribeReservationDemandCommittedAmountResponseBody() {}

  explicit DescribeReservationDemandCommittedAmountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (committedAmountInfo) {
      res["CommittedAmountInfo"] = committedAmountInfo ? boost::any(committedAmountInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommittedAmountInfo") != m.end() && !m["CommittedAmountInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommittedAmountInfo"].type()) {
        DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommittedAmountInfo"]));
        committedAmountInfo = make_shared<DescribeReservationDemandCommittedAmountResponseBodyCommittedAmountInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeReservationDemandCommittedAmountResponseBody() = default;
};
class DescribeReservationDemandCommittedAmountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeReservationDemandCommittedAmountResponseBody> body{};

  DescribeReservationDemandCommittedAmountResponse() {}

  explicit DescribeReservationDemandCommittedAmountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservationDemandCommittedAmountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservationDemandCommittedAmountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservationDemandCommittedAmountResponse() = default;
};
class DescribeReservationDemandsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeReservationDemandsRequestTag() {}

  explicit DescribeReservationDemandsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeReservationDemandsRequestTag() = default;
};
class DescribeReservationDemandsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> demandId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeReservationDemandsRequestTag>> tag{};

  DescribeReservationDemandsRequest() {}

  explicit DescribeReservationDemandsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DemandId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DemandId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      demandId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeReservationDemandsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservationDemandsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeReservationDemandsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeReservationDemandsRequest() = default;
};
class DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations : public Darabonba::Model {
public:
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> planId{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> zoneId{};

  DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations() {}

  explicit DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (planId) {
      res["PlanId"] = boost::any(*planId);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("PlanId") != m.end() && !m["PlanId"].empty()) {
      planId = make_shared<string>(boost::any_cast<string>(m["PlanId"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations() = default;
};
class DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations>> capacityReservations{};

  DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource() {}

  explicit DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservations) {
      vector<boost::any> temp1;
      for(auto item1:*capacityReservations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CapacityReservations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservations") != m.end() && !m["CapacityReservations"].empty()) {
      if (typeid(vector<boost::any>) == m["CapacityReservations"].type()) {
        vector<DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CapacityReservations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        capacityReservations = make_shared<vector<DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResourceCapacityReservations>>(expect1);
      }
    }
  }


  virtual ~DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource() = default;
};
class DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations : public Darabonba::Model {
public:
  shared_ptr<string> approveCode{};
  shared_ptr<string> approveNotes{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> planId{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> zoneId{};

  DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations() {}

  explicit DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approveCode) {
      res["ApproveCode"] = boost::any(*approveCode);
    }
    if (approveNotes) {
      res["ApproveNotes"] = boost::any(*approveNotes);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (planId) {
      res["PlanId"] = boost::any(*planId);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApproveCode") != m.end() && !m["ApproveCode"].empty()) {
      approveCode = make_shared<string>(boost::any_cast<string>(m["ApproveCode"]));
    }
    if (m.find("ApproveNotes") != m.end() && !m["ApproveNotes"].empty()) {
      approveNotes = make_shared<string>(boost::any_cast<string>(m["ApproveNotes"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("PlanId") != m.end() && !m["PlanId"].empty()) {
      planId = make_shared<string>(boost::any_cast<string>(m["PlanId"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations() = default;
};
class DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations>> capacityReservations{};

  DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource() {}

  explicit DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservations) {
      vector<boost::any> temp1;
      for(auto item1:*capacityReservations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CapacityReservations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservations") != m.end() && !m["CapacityReservations"].empty()) {
      if (typeid(vector<boost::any>) == m["CapacityReservations"].type()) {
        vector<DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CapacityReservations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        capacityReservations = make_shared<vector<DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResourceCapacityReservations>>(expect1);
      }
    }
  }


  virtual ~DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource() = default;
};
class DescribeReservationDemandsResponseBodyDataDemandOrders : public Darabonba::Model {
public:
  shared_ptr<string> confirmType{};
  shared_ptr<string> couponAuto{};
  shared_ptr<string> couponType{};
  shared_ptr<string> demandId{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> instanceCpuCoreCount{};
  shared_ptr<string> instanceTypes{};
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> name{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> platform{};
  shared_ptr<string> productType{};
  shared_ptr<DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource> recommendResource{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource> reservationResource{};
  shared_ptr<string> reservedInstanceDescription{};
  shared_ptr<string> reservedInstanceId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> reservedInstanceOfferingType{};
  shared_ptr<string> resourceSupplyType{};
  shared_ptr<string> savingPlanDescription{};
  shared_ptr<double> savingPlanHourFee{};
  shared_ptr<string> savingPlanId{};
  shared_ptr<string> savingPlanInstanceTypeFamilyGroup{};
  shared_ptr<string> savingPlanName{};
  shared_ptr<string> savingPlanPayMode{};
  shared_ptr<string> savingPlanSavingType{};
  shared_ptr<string> savingPlanSpecType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> zoneIds{};

  DescribeReservationDemandsResponseBodyDataDemandOrders() {}

  explicit DescribeReservationDemandsResponseBodyDataDemandOrders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confirmType) {
      res["ConfirmType"] = boost::any(*confirmType);
    }
    if (couponAuto) {
      res["CouponAuto"] = boost::any(*couponAuto);
    }
    if (couponType) {
      res["CouponType"] = boost::any(*couponType);
    }
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceCpuCoreCount) {
      res["InstanceCpuCoreCount"] = boost::any(*instanceCpuCoreCount);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (recommendResource) {
      res["RecommendResource"] = recommendResource ? boost::any(recommendResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservationResource) {
      res["ReservationResource"] = reservationResource ? boost::any(reservationResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reservedInstanceDescription) {
      res["ReservedInstanceDescription"] = boost::any(*reservedInstanceDescription);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (reservedInstanceOfferingType) {
      res["ReservedInstanceOfferingType"] = boost::any(*reservedInstanceOfferingType);
    }
    if (resourceSupplyType) {
      res["ResourceSupplyType"] = boost::any(*resourceSupplyType);
    }
    if (savingPlanDescription) {
      res["SavingPlanDescription"] = boost::any(*savingPlanDescription);
    }
    if (savingPlanHourFee) {
      res["SavingPlanHourFee"] = boost::any(*savingPlanHourFee);
    }
    if (savingPlanId) {
      res["SavingPlanId"] = boost::any(*savingPlanId);
    }
    if (savingPlanInstanceTypeFamilyGroup) {
      res["SavingPlanInstanceTypeFamilyGroup"] = boost::any(*savingPlanInstanceTypeFamilyGroup);
    }
    if (savingPlanName) {
      res["SavingPlanName"] = boost::any(*savingPlanName);
    }
    if (savingPlanPayMode) {
      res["SavingPlanPayMode"] = boost::any(*savingPlanPayMode);
    }
    if (savingPlanSavingType) {
      res["SavingPlanSavingType"] = boost::any(*savingPlanSavingType);
    }
    if (savingPlanSpecType) {
      res["SavingPlanSpecType"] = boost::any(*savingPlanSpecType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zoneIds) {
      res["ZoneIds"] = boost::any(*zoneIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfirmType") != m.end() && !m["ConfirmType"].empty()) {
      confirmType = make_shared<string>(boost::any_cast<string>(m["ConfirmType"]));
    }
    if (m.find("CouponAuto") != m.end() && !m["CouponAuto"].empty()) {
      couponAuto = make_shared<string>(boost::any_cast<string>(m["CouponAuto"]));
    }
    if (m.find("CouponType") != m.end() && !m["CouponType"].empty()) {
      couponType = make_shared<string>(boost::any_cast<string>(m["CouponType"]));
    }
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceCpuCoreCount") != m.end() && !m["InstanceCpuCoreCount"].empty()) {
      instanceCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["InstanceCpuCoreCount"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      instanceTypes = make_shared<string>(boost::any_cast<string>(m["InstanceTypes"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RecommendResource") != m.end() && !m["RecommendResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendResource"].type()) {
        DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendResource"]));
        recommendResource = make_shared<DescribeReservationDemandsResponseBodyDataDemandOrdersRecommendResource>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservationResource") != m.end() && !m["ReservationResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservationResource"].type()) {
        DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservationResource"]));
        reservationResource = make_shared<DescribeReservationDemandsResponseBodyDataDemandOrdersReservationResource>(model1);
      }
    }
    if (m.find("ReservedInstanceDescription") != m.end() && !m["ReservedInstanceDescription"].empty()) {
      reservedInstanceDescription = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceDescription"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      reservedInstanceId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceId"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ReservedInstanceOfferingType") != m.end() && !m["ReservedInstanceOfferingType"].empty()) {
      reservedInstanceOfferingType = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceOfferingType"]));
    }
    if (m.find("ResourceSupplyType") != m.end() && !m["ResourceSupplyType"].empty()) {
      resourceSupplyType = make_shared<string>(boost::any_cast<string>(m["ResourceSupplyType"]));
    }
    if (m.find("SavingPlanDescription") != m.end() && !m["SavingPlanDescription"].empty()) {
      savingPlanDescription = make_shared<string>(boost::any_cast<string>(m["SavingPlanDescription"]));
    }
    if (m.find("SavingPlanHourFee") != m.end() && !m["SavingPlanHourFee"].empty()) {
      savingPlanHourFee = make_shared<double>(boost::any_cast<double>(m["SavingPlanHourFee"]));
    }
    if (m.find("SavingPlanId") != m.end() && !m["SavingPlanId"].empty()) {
      savingPlanId = make_shared<string>(boost::any_cast<string>(m["SavingPlanId"]));
    }
    if (m.find("SavingPlanInstanceTypeFamilyGroup") != m.end() && !m["SavingPlanInstanceTypeFamilyGroup"].empty()) {
      savingPlanInstanceTypeFamilyGroup = make_shared<string>(boost::any_cast<string>(m["SavingPlanInstanceTypeFamilyGroup"]));
    }
    if (m.find("SavingPlanName") != m.end() && !m["SavingPlanName"].empty()) {
      savingPlanName = make_shared<string>(boost::any_cast<string>(m["SavingPlanName"]));
    }
    if (m.find("SavingPlanPayMode") != m.end() && !m["SavingPlanPayMode"].empty()) {
      savingPlanPayMode = make_shared<string>(boost::any_cast<string>(m["SavingPlanPayMode"]));
    }
    if (m.find("SavingPlanSavingType") != m.end() && !m["SavingPlanSavingType"].empty()) {
      savingPlanSavingType = make_shared<string>(boost::any_cast<string>(m["SavingPlanSavingType"]));
    }
    if (m.find("SavingPlanSpecType") != m.end() && !m["SavingPlanSpecType"].empty()) {
      savingPlanSpecType = make_shared<string>(boost::any_cast<string>(m["SavingPlanSpecType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ZoneIds") != m.end() && !m["ZoneIds"].empty()) {
      zoneIds = make_shared<string>(boost::any_cast<string>(m["ZoneIds"]));
    }
  }


  virtual ~DescribeReservationDemandsResponseBodyDataDemandOrders() = default;
};
class DescribeReservationDemandsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservationDemandsResponseBodyDataDemandOrders>> demandOrders{};

  DescribeReservationDemandsResponseBodyData() {}

  explicit DescribeReservationDemandsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demandOrders) {
      vector<boost::any> temp1;
      for(auto item1:*demandOrders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DemandOrders"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemandOrders") != m.end() && !m["DemandOrders"].empty()) {
      if (typeid(vector<boost::any>) == m["DemandOrders"].type()) {
        vector<DescribeReservationDemandsResponseBodyDataDemandOrders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DemandOrders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservationDemandsResponseBodyDataDemandOrders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        demandOrders = make_shared<vector<DescribeReservationDemandsResponseBodyDataDemandOrders>>(expect1);
      }
    }
  }


  virtual ~DescribeReservationDemandsResponseBodyData() = default;
};
class DescribeReservationDemandsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeReservationDemandsResponseBodyData> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeReservationDemandsResponseBody() {}

  explicit DescribeReservationDemandsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeReservationDemandsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeReservationDemandsResponseBodyData>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeReservationDemandsResponseBody() = default;
};
class DescribeReservationDemandsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeReservationDemandsResponseBody> body{};

  DescribeReservationDemandsResponse() {}

  explicit DescribeReservationDemandsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservationDemandsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservationDemandsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservationDemandsResponse() = default;
};
class DescribeReservedInstanceAllocationsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeReservedInstanceAllocationsRequestTag() {}

  explicit DescribeReservedInstanceAllocationsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeReservedInstanceAllocationsRequestTag() = default;
};
class DescribeReservedInstanceAllocationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservedInstanceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeReservedInstanceAllocationsRequestTag>> tag{};

  DescribeReservedInstanceAllocationsRequest() {}

  explicit DescribeReservedInstanceAllocationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      reservedInstanceId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeReservedInstanceAllocationsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstanceAllocationsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeReservedInstanceAllocationsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstanceAllocationsRequest() = default;
};
class DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation : public Darabonba::Model {
public:
  shared_ptr<string> beAllocatedAccountId{};
  shared_ptr<string> reservedInstanceId{};
  shared_ptr<string> resourceOwnerId{};

  DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation() {}

  explicit DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beAllocatedAccountId) {
      res["BeAllocatedAccountId"] = boost::any(*beAllocatedAccountId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeAllocatedAccountId") != m.end() && !m["BeAllocatedAccountId"].empty()) {
      beAllocatedAccountId = make_shared<string>(boost::any_cast<string>(m["BeAllocatedAccountId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      reservedInstanceId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation() = default;
};
class DescribeReservedInstanceAllocationsResponseBodyAllocations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation>> allocation{};

  DescribeReservedInstanceAllocationsResponseBodyAllocations() {}

  explicit DescribeReservedInstanceAllocationsResponseBodyAllocations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocation) {
      vector<boost::any> temp1;
      for(auto item1:*allocation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Allocation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Allocation") != m.end() && !m["Allocation"].empty()) {
      if (typeid(vector<boost::any>) == m["Allocation"].type()) {
        vector<DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Allocation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allocation = make_shared<vector<DescribeReservedInstanceAllocationsResponseBodyAllocationsAllocation>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstanceAllocationsResponseBodyAllocations() = default;
};
class DescribeReservedInstanceAllocationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeReservedInstanceAllocationsResponseBodyAllocations> allocations{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeReservedInstanceAllocationsResponseBody() {}

  explicit DescribeReservedInstanceAllocationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocations) {
      res["Allocations"] = allocations ? boost::any(allocations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Allocations") != m.end() && !m["Allocations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Allocations"].type()) {
        DescribeReservedInstanceAllocationsResponseBodyAllocations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Allocations"]));
        allocations = make_shared<DescribeReservedInstanceAllocationsResponseBodyAllocations>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeReservedInstanceAllocationsResponseBody() = default;
};
class DescribeReservedInstanceAllocationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeReservedInstanceAllocationsResponseBody> body{};

  DescribeReservedInstanceAllocationsResponse() {}

  explicit DescribeReservedInstanceAllocationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservedInstanceAllocationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservedInstanceAllocationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservedInstanceAllocationsResponse() = default;
};
class DescribeReservedInstanceCategoriesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeReservedInstanceCategoriesRequestTag() {}

  explicit DescribeReservedInstanceCategoriesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeReservedInstanceCategoriesRequestTag() = default;
};
class DescribeReservedInstanceCategoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scope{};
  shared_ptr<vector<DescribeReservedInstanceCategoriesRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  DescribeReservedInstanceCategoriesRequest() {}

  explicit DescribeReservedInstanceCategoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeReservedInstanceCategoriesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstanceCategoriesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeReservedInstanceCategoriesRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeReservedInstanceCategoriesRequest() = default;
};
class DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> platform{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scope{};
  shared_ptr<string> zoneId{};

  DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory() {}

  explicit DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory() = default;
};
class DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory>> reservedInstanceCategory{};

  DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories() {}

  explicit DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstanceCategory) {
      vector<boost::any> temp1;
      for(auto item1:*reservedInstanceCategory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReservedInstanceCategory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstanceCategory") != m.end() && !m["ReservedInstanceCategory"].empty()) {
      if (typeid(vector<boost::any>) == m["ReservedInstanceCategory"].type()) {
        vector<DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReservedInstanceCategory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reservedInstanceCategory = make_shared<vector<DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategoriesReservedInstanceCategory>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories() = default;
};
class DescribeReservedInstanceCategoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories> reservedInstanceCategories{};
  shared_ptr<long> totalCount{};

  DescribeReservedInstanceCategoriesResponseBody() {}

  explicit DescribeReservedInstanceCategoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservedInstanceCategories) {
      res["ReservedInstanceCategories"] = reservedInstanceCategories ? boost::any(reservedInstanceCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservedInstanceCategories") != m.end() && !m["ReservedInstanceCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservedInstanceCategories"].type()) {
        DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservedInstanceCategories"]));
        reservedInstanceCategories = make_shared<DescribeReservedInstanceCategoriesResponseBodyReservedInstanceCategories>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeReservedInstanceCategoriesResponseBody() = default;
};
class DescribeReservedInstanceCategoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeReservedInstanceCategoriesResponseBody> body{};

  DescribeReservedInstanceCategoriesResponse() {}

  explicit DescribeReservedInstanceCategoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservedInstanceCategoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservedInstanceCategoriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservedInstanceCategoriesResponse() = default;
};
class DescribeReservedInstancePriceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeReservedInstancePriceRequestTag() {}

  explicit DescribeReservedInstancePriceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeReservedInstancePriceRequestTag() = default;
};
class DescribeReservedInstancePriceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> reservedInstanceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeReservedInstancePriceRequestTag>> tag{};

  DescribeReservedInstancePriceRequest() {}

  explicit DescribeReservedInstancePriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeReservedInstancePriceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancePriceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeReservedInstancePriceRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstancePriceRequest() = default;
};
class DescribeReservedInstancePriceResponseBodyPriceInfoOrder : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> reservedInstanceHourPrice{};
  shared_ptr<double> tradePrice{};

  DescribeReservedInstancePriceResponseBodyPriceInfoOrder() {}

  explicit DescribeReservedInstancePriceResponseBodyPriceInfoOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (reservedInstanceHourPrice) {
      res["ReservedInstanceHourPrice"] = boost::any(*reservedInstanceHourPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("ReservedInstanceHourPrice") != m.end() && !m["ReservedInstanceHourPrice"].empty()) {
      reservedInstanceHourPrice = make_shared<double>(boost::any_cast<double>(m["ReservedInstanceHourPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeReservedInstancePriceResponseBodyPriceInfoOrder() = default;
};
class DescribeReservedInstancePriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeReservedInstancePriceResponseBodyPriceInfoOrder> order{};

  DescribeReservedInstancePriceResponseBodyPriceInfo() {}

  explicit DescribeReservedInstancePriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = order ? boost::any(order->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      if (typeid(map<string, boost::any>) == m["Order"].type()) {
        DescribeReservedInstancePriceResponseBodyPriceInfoOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Order"]));
        order = make_shared<DescribeReservedInstancePriceResponseBodyPriceInfoOrder>(model1);
      }
    }
  }


  virtual ~DescribeReservedInstancePriceResponseBodyPriceInfo() = default;
};
class DescribeReservedInstancePriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeReservedInstancePriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribeReservedInstancePriceResponseBody() {}

  explicit DescribeReservedInstancePriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeReservedInstancePriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeReservedInstancePriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeReservedInstancePriceResponseBody() = default;
};
class DescribeReservedInstancePriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeReservedInstancePriceResponseBody> body{};

  DescribeReservedInstancePriceResponse() {}

  explicit DescribeReservedInstancePriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservedInstancePriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservedInstancePriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservedInstancePriceResponse() = default;
};
class DescribeReservedInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeReservedInstancesRequestTag() {}

  explicit DescribeReservedInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeReservedInstancesRequestTag() = default;
};
class DescribeReservedInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationType{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> offeringType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> reservedInstanceId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scope{};
  shared_ptr<vector<string>> status{};
  shared_ptr<vector<DescribeReservedInstancesRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  DescribeReservedInstancesRequest() {}

  explicit DescribeReservedInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationType) {
      res["AllocationType"] = boost::any(*allocationType);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationType") != m.end() && !m["AllocationType"].empty()) {
      allocationType = make_shared<string>(boost::any_cast<string>(m["AllocationType"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Status"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Status"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      status = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeReservedInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeReservedInstancesRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeReservedInstancesRequest() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock>> operationLock{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationLock) {
      vector<boost::any> temp1;
      for(auto item1:*operationLock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLock"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationLock") != m.end() && !m["OperationLock"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLock"].type()) {
        vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLock = make_shared<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag>> tag{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance : public Darabonba::Model {
public:
  shared_ptr<string> allocationStatus{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> offeringType{};
  shared_ptr<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks> operationLocks{};
  shared_ptr<string> platform{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservedInstanceId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scope{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags> tags{};
  shared_ptr<string> zoneId{};

  DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationStatus) {
      res["AllocationStatus"] = boost::any(*allocationStatus);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationStatus") != m.end() && !m["AllocationStatus"].empty()) {
      allocationStatus = make_shared<string>(boost::any_cast<string>(m["AllocationStatus"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks>(model1);
      }
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      reservedInstanceId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceId"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags>(model1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance() = default;
};
class DescribeReservedInstancesResponseBodyReservedInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance>> reservedInstance{};

  DescribeReservedInstancesResponseBodyReservedInstances() {}

  explicit DescribeReservedInstancesResponseBodyReservedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstance) {
      vector<boost::any> temp1;
      for(auto item1:*reservedInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReservedInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstance") != m.end() && !m["ReservedInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["ReservedInstance"].type()) {
        vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReservedInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reservedInstance = make_shared<vector<DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponseBodyReservedInstances() = default;
};
class DescribeReservedInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeReservedInstancesResponseBodyReservedInstances> reservedInstances{};
  shared_ptr<long> totalCount{};

  DescribeReservedInstancesResponseBody() {}

  explicit DescribeReservedInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservedInstances) {
      res["ReservedInstances"] = reservedInstances ? boost::any(reservedInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservedInstances") != m.end() && !m["ReservedInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservedInstances"].type()) {
        DescribeReservedInstancesResponseBodyReservedInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservedInstances"]));
        reservedInstances = make_shared<DescribeReservedInstancesResponseBodyReservedInstances>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeReservedInstancesResponseBody() = default;
};
class DescribeReservedInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeReservedInstancesResponseBody> body{};

  DescribeReservedInstancesResponse() {}

  explicit DescribeReservedInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservedInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservedInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservedInstancesResponse() = default;
};
class DescribeResourceAggregationsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributeValue{};
  shared_ptr<string> operation{};

  DescribeResourceAggregationsRequestFilter() {}

  explicit DescribeResourceAggregationsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValue) {
      res["AttributeValue"] = boost::any(*attributeValue);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValue") != m.end() && !m["AttributeValue"].empty()) {
      attributeValue = make_shared<string>(boost::any_cast<string>(m["AttributeValue"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
  }


  virtual ~DescribeResourceAggregationsRequestFilter() = default;
};
class DescribeResourceAggregationsRequestTagFilter : public Darabonba::Model {
public:
  shared_ptr<string> operation{};
  shared_ptr<string> tagKey{};
  shared_ptr<vector<string>> tagValues{};

  DescribeResourceAggregationsRequestTagFilter() {}

  explicit DescribeResourceAggregationsRequestTagFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValues) {
      res["TagValues"] = boost::any(*tagValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValues") != m.end() && !m["TagValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceAggregationsRequestTagFilter() = default;
};
class DescribeResourceAggregationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> aggregators{};
  shared_ptr<vector<DescribeResourceAggregationsRequestFilter>> filter{};
  shared_ptr<string> global{};
  shared_ptr<string> keyword{};
  shared_ptr<string> marker{};
  shared_ptr<long> maxItems{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionNo{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeResourceAggregationsRequestTagFilter>> tagFilter{};

  DescribeResourceAggregationsRequest() {}

  explicit DescribeResourceAggregationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregators) {
      res["Aggregators"] = boost::any(*aggregators);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (global) {
      res["Global"] = boost::any(*global);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (marker) {
      res["Marker"] = boost::any(*marker);
    }
    if (maxItems) {
      res["MaxItems"] = boost::any(*maxItems);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagFilter) {
      vector<boost::any> temp1;
      for(auto item1:*tagFilter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagFilter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregators") != m.end() && !m["Aggregators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Aggregators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Aggregators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aggregators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeResourceAggregationsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceAggregationsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeResourceAggregationsRequestFilter>>(expect1);
      }
    }
    if (m.find("Global") != m.end() && !m["Global"].empty()) {
      global = make_shared<string>(boost::any_cast<string>(m["Global"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Marker") != m.end() && !m["Marker"].empty()) {
      marker = make_shared<string>(boost::any_cast<string>(m["Marker"]));
    }
    if (m.find("MaxItems") != m.end() && !m["MaxItems"].empty()) {
      maxItems = make_shared<long>(boost::any_cast<long>(m["MaxItems"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagFilter") != m.end() && !m["TagFilter"].empty()) {
      if (typeid(vector<boost::any>) == m["TagFilter"].type()) {
        vector<DescribeResourceAggregationsRequestTagFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagFilter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceAggregationsRequestTagFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagFilter = make_shared<vector<DescribeResourceAggregationsRequestTagFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceAggregationsRequest() = default;
};
class DescribeResourceAggregationsResponseBodyAggregationsAggregation : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<string> keys{};

  DescribeResourceAggregationsResponseBodyAggregationsAggregation() {}

  explicit DescribeResourceAggregationsResponseBodyAggregationsAggregation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (keys) {
      res["Keys"] = boost::any(*keys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      keys = make_shared<string>(boost::any_cast<string>(m["Keys"]));
    }
  }


  virtual ~DescribeResourceAggregationsResponseBodyAggregationsAggregation() = default;
};
class DescribeResourceAggregationsResponseBodyAggregations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceAggregationsResponseBodyAggregationsAggregation>> aggregation{};

  DescribeResourceAggregationsResponseBodyAggregations() {}

  explicit DescribeResourceAggregationsResponseBodyAggregations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregation) {
      vector<boost::any> temp1;
      for(auto item1:*aggregation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Aggregation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregation") != m.end() && !m["Aggregation"].empty()) {
      if (typeid(vector<boost::any>) == m["Aggregation"].type()) {
        vector<DescribeResourceAggregationsResponseBodyAggregationsAggregation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Aggregation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceAggregationsResponseBodyAggregationsAggregation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregation = make_shared<vector<DescribeResourceAggregationsResponseBodyAggregationsAggregation>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceAggregationsResponseBodyAggregations() = default;
};
class DescribeResourceAggregationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceAggregationsResponseBodyAggregations> aggregations{};
  shared_ptr<string> requestId{};

  DescribeResourceAggregationsResponseBody() {}

  explicit DescribeResourceAggregationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregations) {
      res["Aggregations"] = aggregations ? boost::any(aggregations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregations") != m.end() && !m["Aggregations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Aggregations"].type()) {
        DescribeResourceAggregationsResponseBodyAggregations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Aggregations"]));
        aggregations = make_shared<DescribeResourceAggregationsResponseBodyAggregations>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeResourceAggregationsResponseBody() = default;
};
class DescribeResourceAggregationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceAggregationsResponseBody> body{};

  DescribeResourceAggregationsResponse() {}

  explicit DescribeResourceAggregationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceAggregationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceAggregationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceAggregationsResponse() = default;
};
class DescribeResourceAllocationRequestInstanceTypeModel : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> maxPrice{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<double> weightedCapacity{};

  DescribeResourceAllocationRequestInstanceTypeModel() {}

  explicit DescribeResourceAllocationRequestInstanceTypeModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<double>(boost::any_cast<double>(m["WeightedCapacity"]));
    }
  }


  virtual ~DescribeResourceAllocationRequestInstanceTypeModel() = default;
};
class DescribeResourceAllocationRequest : public Darabonba::Model {
public:
  shared_ptr<long> cores{};
  shared_ptr<vector<string>> dataDiskCategory{};
  shared_ptr<string> defaultTargetCapacityType{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<DescribeResourceAllocationRequestInstanceTypeModel>> instanceTypeModel{};
  shared_ptr<bool> instanceTypeSupportIPv6{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<double> maxPrice{};
  shared_ptr<double> memory{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> postPaidBaseCapacity{};
  shared_ptr<string> priorityStrategy{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceAmountType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> spotBaseCapacity{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<bool> strictSatisfiedTargetCapacity{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<long> targetCapacity{};
  shared_ptr<vector<string>> zoneId{};

  DescribeResourceAllocationRequest() {}

  explicit DescribeResourceAllocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (defaultTargetCapacityType) {
      res["DefaultTargetCapacityType"] = boost::any(*defaultTargetCapacityType);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeModel) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeModel"] = boost::any(temp1);
    }
    if (instanceTypeSupportIPv6) {
      res["InstanceTypeSupportIPv6"] = boost::any(*instanceTypeSupportIPv6);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (postPaidBaseCapacity) {
      res["PostPaidBaseCapacity"] = boost::any(*postPaidBaseCapacity);
    }
    if (priorityStrategy) {
      res["PriorityStrategy"] = boost::any(*priorityStrategy);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceAmountType) {
      res["ResourceAmountType"] = boost::any(*resourceAmountType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spotBaseCapacity) {
      res["SpotBaseCapacity"] = boost::any(*spotBaseCapacity);
    }
    if (spotInstancePools) {
      res["SpotInstancePools"] = boost::any(*spotInstancePools);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (strictSatisfiedTargetCapacity) {
      res["StrictSatisfiedTargetCapacity"] = boost::any(*strictSatisfiedTargetCapacity);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (targetCapacity) {
      res["TargetCapacity"] = boost::any(*targetCapacity);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataDiskCategory"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataDiskCategory"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataDiskCategory = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DefaultTargetCapacityType") != m.end() && !m["DefaultTargetCapacityType"].empty()) {
      defaultTargetCapacityType = make_shared<string>(boost::any_cast<string>(m["DefaultTargetCapacityType"]));
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypeModel") != m.end() && !m["InstanceTypeModel"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeModel"].type()) {
        vector<DescribeResourceAllocationRequestInstanceTypeModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceAllocationRequestInstanceTypeModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeModel = make_shared<vector<DescribeResourceAllocationRequestInstanceTypeModel>>(expect1);
      }
    }
    if (m.find("InstanceTypeSupportIPv6") != m.end() && !m["InstanceTypeSupportIPv6"].empty()) {
      instanceTypeSupportIPv6 = make_shared<bool>(boost::any_cast<bool>(m["InstanceTypeSupportIPv6"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PostPaidBaseCapacity") != m.end() && !m["PostPaidBaseCapacity"].empty()) {
      postPaidBaseCapacity = make_shared<long>(boost::any_cast<long>(m["PostPaidBaseCapacity"]));
    }
    if (m.find("PriorityStrategy") != m.end() && !m["PriorityStrategy"].empty()) {
      priorityStrategy = make_shared<string>(boost::any_cast<string>(m["PriorityStrategy"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceAmountType") != m.end() && !m["ResourceAmountType"].empty()) {
      resourceAmountType = make_shared<string>(boost::any_cast<string>(m["ResourceAmountType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SpotBaseCapacity") != m.end() && !m["SpotBaseCapacity"].empty()) {
      spotBaseCapacity = make_shared<long>(boost::any_cast<long>(m["SpotBaseCapacity"]));
    }
    if (m.find("SpotInstancePools") != m.end() && !m["SpotInstancePools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["SpotInstancePools"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StrictSatisfiedTargetCapacity") != m.end() && !m["StrictSatisfiedTargetCapacity"].empty()) {
      strictSatisfiedTargetCapacity = make_shared<bool>(boost::any_cast<bool>(m["StrictSatisfiedTargetCapacity"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("TargetCapacity") != m.end() && !m["TargetCapacity"].empty()) {
      targetCapacity = make_shared<long>(boost::any_cast<long>(m["TargetCapacity"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceAllocationRequest() = default;
};
class DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> networkType{};
  shared_ptr<double> price{};
  shared_ptr<string> regionId{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> zoneId{};

  DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel() {}

  explicit DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (price) {
      res["Price"] = boost::any(*price);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["Price"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel() = default;
};
class DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel>> resourceModel{};

  DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels() {}

  explicit DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceModel) {
      vector<boost::any> temp1;
      for(auto item1:*resourceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceModel") != m.end() && !m["ResourceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceModel"].type()) {
        vector<DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceModel = make_shared<vector<DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModelsResourceModel>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels() = default;
};
class DescribeResourceAllocationResponseBodyResourcePlanningResponse : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels> resourceModels{};
  shared_ptr<long> satisfiedAmount{};

  DescribeResourceAllocationResponseBodyResourcePlanningResponse() {}

  explicit DescribeResourceAllocationResponseBodyResourcePlanningResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceModels) {
      res["ResourceModels"] = resourceModels ? boost::any(resourceModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (satisfiedAmount) {
      res["SatisfiedAmount"] = boost::any(*satisfiedAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceModels") != m.end() && !m["ResourceModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceModels"].type()) {
        DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceModels"]));
        resourceModels = make_shared<DescribeResourceAllocationResponseBodyResourcePlanningResponseResourceModels>(model1);
      }
    }
    if (m.find("SatisfiedAmount") != m.end() && !m["SatisfiedAmount"].empty()) {
      satisfiedAmount = make_shared<long>(boost::any_cast<long>(m["SatisfiedAmount"]));
    }
  }


  virtual ~DescribeResourceAllocationResponseBodyResourcePlanningResponse() = default;
};
class DescribeResourceAllocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeResourceAllocationResponseBodyResourcePlanningResponse> resourcePlanningResponse{};

  DescribeResourceAllocationResponseBody() {}

  explicit DescribeResourceAllocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePlanningResponse) {
      res["ResourcePlanningResponse"] = resourcePlanningResponse ? boost::any(resourcePlanningResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePlanningResponse") != m.end() && !m["ResourcePlanningResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourcePlanningResponse"].type()) {
        DescribeResourceAllocationResponseBodyResourcePlanningResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourcePlanningResponse"]));
        resourcePlanningResponse = make_shared<DescribeResourceAllocationResponseBodyResourcePlanningResponse>(model1);
      }
    }
  }


  virtual ~DescribeResourceAllocationResponseBody() = default;
};
class DescribeResourceAllocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceAllocationResponseBody> body{};

  DescribeResourceAllocationResponse() {}

  explicit DescribeResourceAllocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceAllocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceAllocationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceAllocationResponse() = default;
};
class DescribeResourceDisplayRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeResourceDisplayRequestTemplateTag() {}

  explicit DescribeResourceDisplayRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeResourceDisplayRequestTemplateTag() = default;
};
class DescribeResourceDisplayRequest : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> firstBizLevel{};
  shared_ptr<vector<string>> instanceCategoryType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> secondBizLevel{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<vector<DescribeResourceDisplayRequestTemplateTag>> templateTag{};
  shared_ptr<string> zoneId{};

  DescribeResourceDisplayRequest() {}

  explicit DescribeResourceDisplayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (firstBizLevel) {
      res["FirstBizLevel"] = boost::any(*firstBizLevel);
    }
    if (instanceCategoryType) {
      res["InstanceCategoryType"] = boost::any(*instanceCategoryType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (secondBizLevel) {
      res["SecondBizLevel"] = boost::any(*secondBizLevel);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("FirstBizLevel") != m.end() && !m["FirstBizLevel"].empty()) {
      firstBizLevel = make_shared<string>(boost::any_cast<string>(m["FirstBizLevel"]));
    }
    if (m.find("InstanceCategoryType") != m.end() && !m["InstanceCategoryType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceCategoryType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceCategoryType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceCategoryType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecondBizLevel") != m.end() && !m["SecondBizLevel"].empty()) {
      secondBizLevel = make_shared<string>(boost::any_cast<string>(m["SecondBizLevel"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<DescribeResourceDisplayRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<DescribeResourceDisplayRequestTemplateTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeResourceDisplayRequest() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily : public Darabonba::Model {
public:
  shared_ptr<string> instanceTypeFamilyId{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags> tags{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeFamilyId) {
      res["InstanceTypeFamilyId"] = boost::any(*instanceTypeFamilyId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeFamilyId") != m.end() && !m["InstanceTypeFamilyId"].empty()) {
      instanceTypeFamilyId = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamilyId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamilyTags>(model1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily>> instanceTypeFamily{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeFamily) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeFamily){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeFamily"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeFamily"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeFamily"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeFamily = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamiliesInstanceTypeFamily>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies> instanceTypeFamilies{};
  shared_ptr<string> secondCategoryLevel{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = instanceTypeFamilies ? boost::any(instanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (secondCategoryLevel) {
      res["SecondCategoryLevel"] = boost::any(*secondCategoryLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypeFamilies"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypeFamilies"]));
        instanceTypeFamilies = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategoryInstanceTypeFamilies>(model1);
      }
    }
    if (m.find("SecondCategoryLevel") != m.end() && !m["SecondCategoryLevel"].empty()) {
      secondCategoryLevel = make_shared<string>(boost::any_cast<string>(m["SecondCategoryLevel"]));
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory>> instanceSecondCategory{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSecondCategory) {
      vector<boost::any> temp1;
      for(auto item1:*instanceSecondCategory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceSecondCategory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSecondCategory") != m.end() && !m["InstanceSecondCategory"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceSecondCategory"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceSecondCategory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceSecondCategory = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategoriesInstanceSecondCategory>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories> instanceSecondCategories{};
  shared_ptr<string> topCategoryLevel{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSecondCategories) {
      res["InstanceSecondCategories"] = instanceSecondCategories ? boost::any(instanceSecondCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (topCategoryLevel) {
      res["TopCategoryLevel"] = boost::any(*topCategoryLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSecondCategories") != m.end() && !m["InstanceSecondCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSecondCategories"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSecondCategories"]));
        instanceSecondCategories = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategoryInstanceSecondCategories>(model1);
      }
    }
    if (m.find("TopCategoryLevel") != m.end() && !m["TopCategoryLevel"].empty()) {
      topCategoryLevel = make_shared<string>(boost::any_cast<string>(m["TopCategoryLevel"]));
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory>> instanceTopCategory{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTopCategory) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTopCategory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTopCategory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTopCategory") != m.end() && !m["InstanceTopCategory"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTopCategory"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTopCategory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTopCategory = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategoriesInstanceTopCategory>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> zoneId{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory : public Darabonba::Model {
public:
  shared_ptr<string> categoryType{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories> instanceTopCategories{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds> zoneIds{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryType) {
      res["CategoryType"] = boost::any(*categoryType);
    }
    if (instanceTopCategories) {
      res["InstanceTopCategories"] = instanceTopCategories ? boost::any(instanceTopCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneIds) {
      res["ZoneIds"] = zoneIds ? boost::any(zoneIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryType") != m.end() && !m["CategoryType"].empty()) {
      categoryType = make_shared<string>(boost::any_cast<string>(m["CategoryType"]));
    }
    if (m.find("InstanceTopCategories") != m.end() && !m["InstanceTopCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTopCategories"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTopCategories"]));
        instanceTopCategories = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryInstanceTopCategories>(model1);
      }
    }
    if (m.find("ZoneIds") != m.end() && !m["ZoneIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ZoneIds"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ZoneIds"]));
        zoneIds = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategoryZoneIds>(model1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory>> instanceCategory{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCategory) {
      vector<boost::any> temp1;
      for(auto item1:*instanceCategory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceCategory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCategory") != m.end() && !m["InstanceCategory"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceCategory"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceCategory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceCategory = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategoriesInstanceCategory>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags> tags{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeTypeTags>(model1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType>> instanceChargeType{};

  DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceChargeType) {
      vector<boost::any> temp1;
      for(auto item1:*instanceChargeType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceChargeType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceChargeType"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceChargeType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceChargeType = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypesInstanceChargeType>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily : public Darabonba::Model {
public:
  shared_ptr<string> instanceTypeFamilyId{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags> tags{};

  DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeFamilyId) {
      res["InstanceTypeFamilyId"] = boost::any(*instanceTypeFamilyId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeFamilyId") != m.end() && !m["InstanceTypeFamilyId"].empty()) {
      instanceTypeFamilyId = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamilyId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamilyTags>(model1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily>> instanceTypeFamily{};

  DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeFamily) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeFamily){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeFamily"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeFamily"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeFamily"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeFamily = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamiliesInstanceTypeFamily>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup : public Darabonba::Model {
public:
  shared_ptr<string> instanceFamilyGroupName{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies> instanceTypeFamilies{};

  DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceFamilyGroupName) {
      res["InstanceFamilyGroupName"] = boost::any(*instanceFamilyGroupName);
    }
    if (instanceTypeFamilies) {
      res["InstanceTypeFamilies"] = instanceTypeFamilies ? boost::any(instanceTypeFamilies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceFamilyGroupName") != m.end() && !m["InstanceFamilyGroupName"].empty()) {
      instanceFamilyGroupName = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyGroupName"]));
    }
    if (m.find("InstanceTypeFamilies") != m.end() && !m["InstanceTypeFamilies"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypeFamilies"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypeFamilies"]));
        instanceTypeFamilies = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroupInstanceTypeFamilies>(model1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup>> instanceFamilyGroup{};

  DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceFamilyGroup) {
      vector<boost::any> temp1;
      for(auto item1:*instanceFamilyGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceFamilyGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceFamilyGroup") != m.end() && !m["InstanceFamilyGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceFamilyGroup"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceFamilyGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceFamilyGroup = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroupsInstanceFamilyGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups> instanceFamilyGroups{};
  shared_ptr<string> productName{};

  DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceFamilyGroups) {
      res["InstanceFamilyGroups"] = instanceFamilyGroups ? boost::any(instanceFamilyGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceFamilyGroups") != m.end() && !m["InstanceFamilyGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceFamilyGroups"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceFamilyGroups"]));
        instanceFamilyGroups = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategoryInstanceFamilyGroups>(model1);
      }
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayProductCategories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory>> productCategory{};

  DescribeResourceDisplayResponseBodyResourceDisplayProductCategories() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayProductCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCategory) {
      vector<boost::any> temp1;
      for(auto item1:*productCategory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductCategory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCategory") != m.end() && !m["ProductCategory"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductCategory"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductCategory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productCategory = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayProductCategoriesProductCategory>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayProductCategories() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayZonesZone : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags> tags{};
  shared_ptr<string> zoneId{};

  DescribeResourceDisplayResponseBodyResourceDisplayZonesZone() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayZonesZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayZonesZoneTags>(model1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayZonesZone() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplayZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceDisplayResponseBodyResourceDisplayZonesZone>> zone{};

  DescribeResourceDisplayResponseBodyResourceDisplayZones() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplayZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zone) {
      vector<boost::any> temp1;
      for(auto item1:*zone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      if (typeid(vector<boost::any>) == m["Zone"].type()) {
        vector<DescribeResourceDisplayResponseBodyResourceDisplayZonesZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceDisplayResponseBodyResourceDisplayZonesZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zone = make_shared<vector<DescribeResourceDisplayResponseBodyResourceDisplayZonesZone>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplayZones() = default;
};
class DescribeResourceDisplayResponseBodyResourceDisplay : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories> instanceCategories{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes> instanceChargeTypes{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayProductCategories> productCategories{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplayZones> zones{};

  DescribeResourceDisplayResponseBodyResourceDisplay() {}

  explicit DescribeResourceDisplayResponseBodyResourceDisplay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCategories) {
      res["InstanceCategories"] = instanceCategories ? boost::any(instanceCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceChargeTypes) {
      res["InstanceChargeTypes"] = instanceChargeTypes ? boost::any(instanceChargeTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (productCategories) {
      res["ProductCategories"] = productCategories ? boost::any(productCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zones) {
      res["Zones"] = zones ? boost::any(zones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCategories") != m.end() && !m["InstanceCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceCategories"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceCategories"]));
        instanceCategories = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayInstanceCategories>(model1);
      }
    }
    if (m.find("InstanceChargeTypes") != m.end() && !m["InstanceChargeTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceChargeTypes"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceChargeTypes"]));
        instanceChargeTypes = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayInstanceChargeTypes>(model1);
      }
    }
    if (m.find("ProductCategories") != m.end() && !m["ProductCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProductCategories"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayProductCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProductCategories"]));
        productCategories = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayProductCategories>(model1);
      }
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(map<string, boost::any>) == m["Zones"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplayZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Zones"]));
        zones = make_shared<DescribeResourceDisplayResponseBodyResourceDisplayZones>(model1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBodyResourceDisplay() = default;
};
class DescribeResourceDisplayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeResourceDisplayResponseBodyResourceDisplay> resourceDisplay{};

  DescribeResourceDisplayResponseBody() {}

  explicit DescribeResourceDisplayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceDisplay) {
      res["ResourceDisplay"] = resourceDisplay ? boost::any(resourceDisplay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceDisplay") != m.end() && !m["ResourceDisplay"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceDisplay"].type()) {
        DescribeResourceDisplayResponseBodyResourceDisplay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceDisplay"]));
        resourceDisplay = make_shared<DescribeResourceDisplayResponseBodyResourceDisplay>(model1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponseBody() = default;
};
class DescribeResourceDisplayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceDisplayResponseBody> body{};

  DescribeResourceDisplayResponse() {}

  explicit DescribeResourceDisplayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceDisplayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceDisplayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceDisplayResponse() = default;
};
class DescribeResourceFilterAttributesRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeResourceFilterAttributesRequestTemplateTag() {}

  explicit DescribeResourceFilterAttributesRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeResourceFilterAttributesRequestTemplateTag() = default;
};
class DescribeResourceFilterAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeResourceFilterAttributesRequestTemplateTag>> templateTag{};

  DescribeResourceFilterAttributesRequest() {}

  explicit DescribeResourceFilterAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<DescribeResourceFilterAttributesRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceFilterAttributesRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<DescribeResourceFilterAttributesRequestTemplateTag>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceFilterAttributesRequest() = default;
};
class DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportOperation{};

  DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations() {}

  explicit DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportOperation) {
      res["SupportOperation"] = boost::any(*supportOperation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportOperation") != m.end() && !m["SupportOperation"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportOperation"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportOperation"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportOperation = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations() = default;
};
class DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues : public Darabonba::Model {
public:
  shared_ptr<vector<string>> value{};

  DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues() {}

  explicit DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues() = default;
};
class DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations> supportOperations{};
  shared_ptr<string> type{};
  shared_ptr<DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues> values{};

  DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute() {}

  explicit DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (supportOperations) {
      res["SupportOperations"] = supportOperations ? boost::any(supportOperations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = values ? boost::any(values->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SupportOperations") != m.end() && !m["SupportOperations"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportOperations"].type()) {
        DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportOperations"]));
        supportOperations = make_shared<DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeSupportOperations>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      if (typeid(map<string, boost::any>) == m["Values"].type()) {
        DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Values"]));
        values = make_shared<DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttributeValues>(model1);
      }
    }
  }


  virtual ~DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute() = default;
};
class DescribeResourceFilterAttributesResponseBodyFilterAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute>> filterAttribute{};

  DescribeResourceFilterAttributesResponseBodyFilterAttributes() {}

  explicit DescribeResourceFilterAttributesResponseBodyFilterAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*filterAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FilterAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterAttribute") != m.end() && !m["FilterAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["FilterAttribute"].type()) {
        vector<DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FilterAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filterAttribute = make_shared<vector<DescribeResourceFilterAttributesResponseBodyFilterAttributesFilterAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceFilterAttributesResponseBodyFilterAttributes() = default;
};
class DescribeResourceFilterAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceFilterAttributesResponseBodyFilterAttributes> filterAttributes{};
  shared_ptr<string> requestId{};

  DescribeResourceFilterAttributesResponseBody() {}

  explicit DescribeResourceFilterAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterAttributes) {
      res["FilterAttributes"] = filterAttributes ? boost::any(filterAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterAttributes") != m.end() && !m["FilterAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterAttributes"].type()) {
        DescribeResourceFilterAttributesResponseBodyFilterAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterAttributes"]));
        filterAttributes = make_shared<DescribeResourceFilterAttributesResponseBodyFilterAttributes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeResourceFilterAttributesResponseBody() = default;
};
class DescribeResourceFilterAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceFilterAttributesResponseBody> body{};

  DescribeResourceFilterAttributesResponse() {}

  explicit DescribeResourceFilterAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceFilterAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceFilterAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceFilterAttributesResponse() = default;
};
class DescribeResourceRecommendFiltersRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeResourceRecommendFiltersRequestTemplateTag() {}

  explicit DescribeResourceRecommendFiltersRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeResourceRecommendFiltersRequestTemplateTag() = default;
};
class DescribeResourceRecommendFiltersRequest : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributeValue{};
  shared_ptr<string> global{};
  shared_ptr<long> maxItems{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionNo{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeResourceRecommendFiltersRequestTemplateTag>> templateTag{};

  DescribeResourceRecommendFiltersRequest() {}

  explicit DescribeResourceRecommendFiltersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValue) {
      res["AttributeValue"] = boost::any(*attributeValue);
    }
    if (global) {
      res["Global"] = boost::any(*global);
    }
    if (maxItems) {
      res["MaxItems"] = boost::any(*maxItems);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValue") != m.end() && !m["AttributeValue"].empty()) {
      attributeValue = make_shared<string>(boost::any_cast<string>(m["AttributeValue"]));
    }
    if (m.find("Global") != m.end() && !m["Global"].empty()) {
      global = make_shared<string>(boost::any_cast<string>(m["Global"]));
    }
    if (m.find("MaxItems") != m.end() && !m["MaxItems"].empty()) {
      maxItems = make_shared<long>(boost::any_cast<long>(m["MaxItems"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<DescribeResourceRecommendFiltersRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceRecommendFiltersRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<DescribeResourceRecommendFiltersRequestTemplateTag>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceRecommendFiltersRequest() = default;
};
class DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributeValue{};
  shared_ptr<string> product{};
  shared_ptr<string> resourceType{};

  DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter() {}

  explicit DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValue) {
      res["AttributeValue"] = boost::any(*attributeValue);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValue") != m.end() && !m["AttributeValue"].empty()) {
      attributeValue = make_shared<string>(boost::any_cast<string>(m["AttributeValue"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter() = default;
};
class DescribeResourceRecommendFiltersResponseBodyRecommendFilters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter>> recommendFilter{};

  DescribeResourceRecommendFiltersResponseBodyRecommendFilters() {}

  explicit DescribeResourceRecommendFiltersResponseBodyRecommendFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendFilter) {
      vector<boost::any> temp1;
      for(auto item1:*recommendFilter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendFilter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendFilter") != m.end() && !m["RecommendFilter"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendFilter"].type()) {
        vector<DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendFilter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendFilter = make_shared<vector<DescribeResourceRecommendFiltersResponseBodyRecommendFiltersRecommendFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceRecommendFiltersResponseBodyRecommendFilters() = default;
};
class DescribeResourceRecommendFiltersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceRecommendFiltersResponseBodyRecommendFilters> recommendFilters{};
  shared_ptr<string> requestId{};

  DescribeResourceRecommendFiltersResponseBody() {}

  explicit DescribeResourceRecommendFiltersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendFilters) {
      res["RecommendFilters"] = recommendFilters ? boost::any(recommendFilters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendFilters") != m.end() && !m["RecommendFilters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendFilters"].type()) {
        DescribeResourceRecommendFiltersResponseBodyRecommendFilters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendFilters"]));
        recommendFilters = make_shared<DescribeResourceRecommendFiltersResponseBodyRecommendFilters>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeResourceRecommendFiltersResponseBody() = default;
};
class DescribeResourceRecommendFiltersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceRecommendFiltersResponseBody> body{};

  DescribeResourceRecommendFiltersResponse() {}

  explicit DescribeResourceRecommendFiltersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceRecommendFiltersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceRecommendFiltersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceRecommendFiltersResponse() = default;
};
class DescribeResourceSolutionsRequestInstanceTypeModel : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> weightedCapacity{};

  DescribeResourceSolutionsRequestInstanceTypeModel() {}

  explicit DescribeResourceSolutionsRequestInstanceTypeModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (weightedCapacity) {
      res["WeightedCapacity"] = boost::any(*weightedCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("WeightedCapacity") != m.end() && !m["WeightedCapacity"].empty()) {
      weightedCapacity = make_shared<double>(boost::any_cast<double>(m["WeightedCapacity"]));
    }
  }


  virtual ~DescribeResourceSolutionsRequestInstanceTypeModel() = default;
};
class DescribeResourceSolutionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> cores{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<DescribeResourceSolutionsRequestInstanceTypeModel>> instanceTypeModel{};
  shared_ptr<bool> instanceTypeSupportIPv6{};
  shared_ptr<bool> matchOpenInstances{};
  shared_ptr<double> maxPrice{};
  shared_ptr<double> memory{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceAmountType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<long> targetCapacity{};
  shared_ptr<vector<string>> zoneId{};

  DescribeResourceSolutionsRequest() {}

  explicit DescribeResourceSolutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceFamilyLevel) {
      res["InstanceFamilyLevel"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeModel) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypeModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypeModel"] = boost::any(temp1);
    }
    if (instanceTypeSupportIPv6) {
      res["InstanceTypeSupportIPv6"] = boost::any(*instanceTypeSupportIPv6);
    }
    if (matchOpenInstances) {
      res["MatchOpenInstances"] = boost::any(*matchOpenInstances);
    }
    if (maxPrice) {
      res["MaxPrice"] = boost::any(*maxPrice);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceAmountType) {
      res["ResourceAmountType"] = boost::any(*resourceAmountType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskCategory) {
      res["SystemDiskCategory"] = boost::any(*systemDiskCategory);
    }
    if (targetCapacity) {
      res["TargetCapacity"] = boost::any(*targetCapacity);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceFamilyLevel") != m.end() && !m["InstanceFamilyLevel"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["InstanceFamilyLevel"]));
    }
    if (m.find("InstanceTypeModel") != m.end() && !m["InstanceTypeModel"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypeModel"].type()) {
        vector<DescribeResourceSolutionsRequestInstanceTypeModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypeModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceSolutionsRequestInstanceTypeModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypeModel = make_shared<vector<DescribeResourceSolutionsRequestInstanceTypeModel>>(expect1);
      }
    }
    if (m.find("InstanceTypeSupportIPv6") != m.end() && !m["InstanceTypeSupportIPv6"].empty()) {
      instanceTypeSupportIPv6 = make_shared<bool>(boost::any_cast<bool>(m["InstanceTypeSupportIPv6"]));
    }
    if (m.find("MatchOpenInstances") != m.end() && !m["MatchOpenInstances"].empty()) {
      matchOpenInstances = make_shared<bool>(boost::any_cast<bool>(m["MatchOpenInstances"]));
    }
    if (m.find("MaxPrice") != m.end() && !m["MaxPrice"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["MaxPrice"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceAmountType") != m.end() && !m["ResourceAmountType"].empty()) {
      resourceAmountType = make_shared<string>(boost::any_cast<string>(m["ResourceAmountType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SystemDiskCategory") != m.end() && !m["SystemDiskCategory"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["SystemDiskCategory"]));
    }
    if (m.find("TargetCapacity") != m.end() && !m["TargetCapacity"].empty()) {
      targetCapacity = make_shared<long>(boost::any_cast<long>(m["TargetCapacity"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceSolutionsRequest() = default;
};
class DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons : public Darabonba::Model {
public:
  shared_ptr<vector<string>> recommendReason{};

  DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons() {}

  explicit DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendReason) {
      res["RecommendReason"] = boost::any(*recommendReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendReason") != m.end() && !m["RecommendReason"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecommendReason"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecommendReason"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recommendReason = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons() = default;
};
class DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> deliveryTime{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};

  DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel() {}

  explicit DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (deliveryTime) {
      res["DeliveryTime"] = boost::any(*deliveryTime);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("DeliveryTime") != m.end() && !m["DeliveryTime"].empty()) {
      deliveryTime = make_shared<string>(boost::any_cast<string>(m["DeliveryTime"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel() = default;
};
class DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel>> resourceModel{};

  DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels() {}

  explicit DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceModel) {
      vector<boost::any> temp1;
      for(auto item1:*resourceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceModel") != m.end() && !m["ResourceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceModel"].type()) {
        vector<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceModel = make_shared<vector<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModelsResourceModel>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels() = default;
};
class DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse : public Darabonba::Model {
public:
  shared_ptr<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons> recommendReasons{};
  shared_ptr<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels> resourceModels{};
  shared_ptr<long> satisfiedAmount{};

  DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse() {}

  explicit DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendReasons) {
      res["RecommendReasons"] = recommendReasons ? boost::any(recommendReasons->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceModels) {
      res["ResourceModels"] = resourceModels ? boost::any(resourceModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (satisfiedAmount) {
      res["SatisfiedAmount"] = boost::any(*satisfiedAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendReasons") != m.end() && !m["RecommendReasons"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendReasons"].type()) {
        DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendReasons"]));
        recommendReasons = make_shared<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseRecommendReasons>(model1);
      }
    }
    if (m.find("ResourceModels") != m.end() && !m["ResourceModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceModels"].type()) {
        DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceModels"]));
        resourceModels = make_shared<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponseResourceModels>(model1);
      }
    }
    if (m.find("SatisfiedAmount") != m.end() && !m["SatisfiedAmount"].empty()) {
      satisfiedAmount = make_shared<long>(boost::any_cast<long>(m["SatisfiedAmount"]));
    }
  }


  virtual ~DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse() = default;
};
class DescribeResourceSolutionsResponseBodyResourcePlanningResponses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse>> resourcePlanningResponse{};

  DescribeResourceSolutionsResponseBodyResourcePlanningResponses() {}

  explicit DescribeResourceSolutionsResponseBodyResourcePlanningResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePlanningResponse) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePlanningResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePlanningResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePlanningResponse") != m.end() && !m["ResourcePlanningResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePlanningResponse"].type()) {
        vector<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePlanningResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePlanningResponse = make_shared<vector<DescribeResourceSolutionsResponseBodyResourcePlanningResponsesResourcePlanningResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceSolutionsResponseBodyResourcePlanningResponses() = default;
};
class DescribeResourceSolutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeResourceSolutionsResponseBodyResourcePlanningResponses> resourcePlanningResponses{};

  DescribeResourceSolutionsResponseBody() {}

  explicit DescribeResourceSolutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePlanningResponses) {
      res["ResourcePlanningResponses"] = resourcePlanningResponses ? boost::any(resourcePlanningResponses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePlanningResponses") != m.end() && !m["ResourcePlanningResponses"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourcePlanningResponses"].type()) {
        DescribeResourceSolutionsResponseBodyResourcePlanningResponses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourcePlanningResponses"]));
        resourcePlanningResponses = make_shared<DescribeResourceSolutionsResponseBodyResourcePlanningResponses>(model1);
      }
    }
  }


  virtual ~DescribeResourceSolutionsResponseBody() = default;
};
class DescribeResourceSolutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceSolutionsResponseBody> body{};

  DescribeResourceSolutionsResponse() {}

  explicit DescribeResourceSolutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceSolutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceSolutionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceSolutionsResponse() = default;
};
class DescribeResourcesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributeValue{};
  shared_ptr<string> operation{};

  DescribeResourcesRequestFilter() {}

  explicit DescribeResourcesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValue) {
      res["AttributeValue"] = boost::any(*attributeValue);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValue") != m.end() && !m["AttributeValue"].empty()) {
      attributeValue = make_shared<string>(boost::any_cast<string>(m["AttributeValue"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
  }


  virtual ~DescribeResourcesRequestFilter() = default;
};
class DescribeResourcesRequestTagFilter : public Darabonba::Model {
public:
  shared_ptr<string> operation{};
  shared_ptr<string> tagKey{};
  shared_ptr<vector<string>> tagValues{};

  DescribeResourcesRequestTagFilter() {}

  explicit DescribeResourcesRequestTagFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValues) {
      res["TagValues"] = boost::any(*tagValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValues") != m.end() && !m["TagValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourcesRequestTagFilter() = default;
};
class DescribeResourcesRequestTemplateTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeResourcesRequestTemplateTag() {}

  explicit DescribeResourcesRequestTemplateTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeResourcesRequestTemplateTag() = default;
};
class DescribeResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourcesRequestFilter>> filter{};
  shared_ptr<string> global{};
  shared_ptr<string> keyword{};
  shared_ptr<string> marker{};
  shared_ptr<long> maxItems{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionNo{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeResourcesRequestTagFilter>> tagFilter{};
  shared_ptr<vector<DescribeResourcesRequestTemplateTag>> templateTag{};

  DescribeResourcesRequest() {}

  explicit DescribeResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (global) {
      res["Global"] = boost::any(*global);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (marker) {
      res["Marker"] = boost::any(*marker);
    }
    if (maxItems) {
      res["MaxItems"] = boost::any(*maxItems);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagFilter) {
      vector<boost::any> temp1;
      for(auto item1:*tagFilter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagFilter"] = boost::any(temp1);
    }
    if (templateTag) {
      vector<boost::any> temp1;
      for(auto item1:*templateTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeResourcesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourcesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeResourcesRequestFilter>>(expect1);
      }
    }
    if (m.find("Global") != m.end() && !m["Global"].empty()) {
      global = make_shared<string>(boost::any_cast<string>(m["Global"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Marker") != m.end() && !m["Marker"].empty()) {
      marker = make_shared<string>(boost::any_cast<string>(m["Marker"]));
    }
    if (m.find("MaxItems") != m.end() && !m["MaxItems"].empty()) {
      maxItems = make_shared<long>(boost::any_cast<long>(m["MaxItems"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagFilter") != m.end() && !m["TagFilter"].empty()) {
      if (typeid(vector<boost::any>) == m["TagFilter"].type()) {
        vector<DescribeResourcesRequestTagFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagFilter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourcesRequestTagFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagFilter = make_shared<vector<DescribeResourcesRequestTagFilter>>(expect1);
      }
    }
    if (m.find("TemplateTag") != m.end() && !m["TemplateTag"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateTag"].type()) {
        vector<DescribeResourcesRequestTemplateTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourcesRequestTemplateTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateTag = make_shared<vector<DescribeResourcesRequestTemplateTag>>(expect1);
      }
    }
  }


  virtual ~DescribeResourcesRequest() = default;
};
class DescribeResourcesResponseBodyResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> createTime{};
  shared_ptr<string> matchedAttributes{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> updateTime{};

  DescribeResourcesResponseBodyResourcesResource() {}

  explicit DescribeResourcesResponseBodyResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (matchedAttributes) {
      res["MatchedAttributes"] = boost::any(*matchedAttributes);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("MatchedAttributes") != m.end() && !m["MatchedAttributes"].empty()) {
      matchedAttributes = make_shared<string>(boost::any_cast<string>(m["MatchedAttributes"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeResourcesResponseBodyResourcesResource() = default;
};
class DescribeResourcesResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourcesResponseBodyResourcesResource>> resource{};

  DescribeResourcesResponseBodyResources() {}

  explicit DescribeResourcesResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeResourcesResponseBodyResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourcesResponseBodyResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeResourcesResponseBodyResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeResourcesResponseBodyResources() = default;
};
class DescribeResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> estimatedTotal{};
  shared_ptr<string> marker{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeResourcesResponseBodyResources> resources{};
  shared_ptr<bool> truncated{};

  DescribeResourcesResponseBody() {}

  explicit DescribeResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (estimatedTotal) {
      res["EstimatedTotal"] = boost::any(*estimatedTotal);
    }
    if (marker) {
      res["Marker"] = boost::any(*marker);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (truncated) {
      res["Truncated"] = boost::any(*truncated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EstimatedTotal") != m.end() && !m["EstimatedTotal"].empty()) {
      estimatedTotal = make_shared<long>(boost::any_cast<long>(m["EstimatedTotal"]));
    }
    if (m.find("Marker") != m.end() && !m["Marker"].empty()) {
      marker = make_shared<string>(boost::any_cast<string>(m["Marker"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeResourcesResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeResourcesResponseBodyResources>(model1);
      }
    }
    if (m.find("Truncated") != m.end() && !m["Truncated"].empty()) {
      truncated = make_shared<bool>(boost::any_cast<bool>(m["Truncated"]));
    }
  }


  virtual ~DescribeResourcesResponseBody() = default;
};
class DescribeResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourcesResponseBody> body{};

  DescribeResourcesResponse() {}

  explicit DescribeResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourcesResponse() = default;
};
class DescribeRiUtilizationRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeRiUtilizationRequestTag() {}

  explicit DescribeRiUtilizationRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeRiUtilizationRequestTag() = default;
};
class DescribeRiUtilizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> reservedInstanceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeRiUtilizationRequestTag>> tag{};

  DescribeRiUtilizationRequest() {}

  explicit DescribeRiUtilizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeRiUtilizationRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiUtilizationRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeRiUtilizationRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeRiUtilizationRequest() = default;
};
class DescribeRiUtilizationResponseBodyUtilizationsUtilization : public Darabonba::Model {
public:
  shared_ptr<string> reservedInstanceId{};
  shared_ptr<string> utilization{};

  DescribeRiUtilizationResponseBodyUtilizationsUtilization() {}

  explicit DescribeRiUtilizationResponseBodyUtilizationsUtilization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (utilization) {
      res["Utilization"] = boost::any(*utilization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      reservedInstanceId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceId"]));
    }
    if (m.find("Utilization") != m.end() && !m["Utilization"].empty()) {
      utilization = make_shared<string>(boost::any_cast<string>(m["Utilization"]));
    }
  }


  virtual ~DescribeRiUtilizationResponseBodyUtilizationsUtilization() = default;
};
class DescribeRiUtilizationResponseBodyUtilizations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRiUtilizationResponseBodyUtilizationsUtilization>> utilization{};

  DescribeRiUtilizationResponseBodyUtilizations() {}

  explicit DescribeRiUtilizationResponseBodyUtilizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (utilization) {
      vector<boost::any> temp1;
      for(auto item1:*utilization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Utilization"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Utilization") != m.end() && !m["Utilization"].empty()) {
      if (typeid(vector<boost::any>) == m["Utilization"].type()) {
        vector<DescribeRiUtilizationResponseBodyUtilizationsUtilization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Utilization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiUtilizationResponseBodyUtilizationsUtilization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        utilization = make_shared<vector<DescribeRiUtilizationResponseBodyUtilizationsUtilization>>(expect1);
      }
    }
  }


  virtual ~DescribeRiUtilizationResponseBodyUtilizations() = default;
};
class DescribeRiUtilizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRiUtilizationResponseBodyUtilizations> utilizations{};

  DescribeRiUtilizationResponseBody() {}

  explicit DescribeRiUtilizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (utilizations) {
      res["Utilizations"] = utilizations ? boost::any(utilizations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Utilizations") != m.end() && !m["Utilizations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Utilizations"].type()) {
        DescribeRiUtilizationResponseBodyUtilizations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Utilizations"]));
        utilizations = make_shared<DescribeRiUtilizationResponseBodyUtilizations>(model1);
      }
    }
  }


  virtual ~DescribeRiUtilizationResponseBody() = default;
};
class DescribeRiUtilizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRiUtilizationResponseBody> body{};

  DescribeRiUtilizationResponse() {}

  explicit DescribeRiUtilizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiUtilizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiUtilizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiUtilizationResponse() = default;
};
class DescribeScenePurchaseRecommendRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  DescribeScenePurchaseRecommendRequestPrivatePoolOptions() {}

  explicit DescribeScenePurchaseRecommendRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~DescribeScenePurchaseRecommendRequestPrivatePoolOptions() = default;
};
class DescribeScenePurchaseRecommendRequestSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostClusterId{};

  DescribeScenePurchaseRecommendRequestSchedulerOptions() {}

  explicit DescribeScenePurchaseRecommendRequestSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
  }


  virtual ~DescribeScenePurchaseRecommendRequestSchedulerOptions() = default;
};
class DescribeScenePurchaseRecommendRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> size{};

  DescribeScenePurchaseRecommendRequestDataDisk() {}

  explicit DescribeScenePurchaseRecommendRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeScenePurchaseRecommendRequestDataDisk() = default;
};
class DescribeScenePurchaseRecommendRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> storageClusterId{};

  DescribeScenePurchaseRecommendRequestSystemDisk() {}

  explicit DescribeScenePurchaseRecommendRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageClusterId) {
      res["StorageClusterId"] = boost::any(*storageClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageClusterId") != m.end() && !m["StorageClusterId"].empty()) {
      storageClusterId = make_shared<string>(boost::any_cast<string>(m["StorageClusterId"]));
    }
  }


  virtual ~DescribeScenePurchaseRecommendRequestSystemDisk() = default;
};
class DescribeScenePurchaseRecommendRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeScenePurchaseRecommendRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<DescribeScenePurchaseRecommendRequestSchedulerOptions> schedulerOptions{};
  shared_ptr<long> amount{};
  shared_ptr<vector<DescribeScenePurchaseRecommendRequestDataDisk>> dataDisk{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> productId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sceneId{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<DescribeScenePurchaseRecommendRequestSystemDisk> systemDisk{};
  shared_ptr<string> tenancy{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};

  DescribeScenePurchaseRecommendRequest() {}

  explicit DescribeScenePurchaseRecommendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        DescribeScenePurchaseRecommendRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<DescribeScenePurchaseRecommendRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        DescribeScenePurchaseRecommendRequestSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<DescribeScenePurchaseRecommendRequestSchedulerOptions>(model1);
      }
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribeScenePurchaseRecommendRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScenePurchaseRecommendRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribeScenePurchaseRecommendRequestDataDisk>>(expect1);
      }
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<long>(boost::any_cast<long>(m["ProductId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<long>(boost::any_cast<long>(m["SceneId"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribeScenePurchaseRecommendRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribeScenePurchaseRecommendRequestSystemDisk>(model1);
      }
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeScenePurchaseRecommendRequest() = default;
};
class DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> effectiveDate{};
  shared_ptr<string> payMode{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> recommendReason{};
  shared_ptr<string> type{};

  DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec() {}

  explicit DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (effectiveDate) {
      res["EffectiveDate"] = boost::any(*effectiveDate);
    }
    if (payMode) {
      res["PayMode"] = boost::any(*payMode);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (recommendReason) {
      res["RecommendReason"] = boost::any(*recommendReason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EffectiveDate") != m.end() && !m["EffectiveDate"].empty()) {
      effectiveDate = make_shared<string>(boost::any_cast<string>(m["EffectiveDate"]));
    }
    if (m.find("PayMode") != m.end() && !m["PayMode"].empty()) {
      payMode = make_shared<string>(boost::any_cast<string>(m["PayMode"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("RecommendReason") != m.end() && !m["RecommendReason"].empty()) {
      recommendReason = make_shared<string>(boost::any_cast<string>(m["RecommendReason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec() = default;
};
class DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec>> recommendSpSpec{};

  DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs() {}

  explicit DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendSpSpec) {
      vector<boost::any> temp1;
      for(auto item1:*recommendSpSpec){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendSpSpec"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendSpSpec") != m.end() && !m["RecommendSpSpec"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendSpSpec"].type()) {
        vector<DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendSpSpec"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendSpSpec = make_shared<vector<DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecsRecommendSpSpec>>(expect1);
      }
    }
  }


  virtual ~DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs() = default;
};
class DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct : public Darabonba::Model {
public:
  shared_ptr<DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs> recommendSpSpecs{};
  shared_ptr<string> regionId{};

  DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct() {}

  explicit DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendSpSpecs) {
      res["RecommendSpSpecs"] = recommendSpSpecs ? boost::any(recommendSpSpecs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendSpSpecs") != m.end() && !m["RecommendSpSpecs"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendSpSpecs"].type()) {
        DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendSpSpecs"]));
        recommendSpSpecs = make_shared<DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProductRecommendSpSpecs>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct() = default;
};
class DescribeScenePurchaseRecommendResponseBodyRecommendProducts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct>> recommendProduct{};

  DescribeScenePurchaseRecommendResponseBodyRecommendProducts() {}

  explicit DescribeScenePurchaseRecommendResponseBodyRecommendProducts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendProduct) {
      vector<boost::any> temp1;
      for(auto item1:*recommendProduct){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendProduct"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendProduct") != m.end() && !m["RecommendProduct"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendProduct"].type()) {
        vector<DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendProduct"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendProduct = make_shared<vector<DescribeScenePurchaseRecommendResponseBodyRecommendProductsRecommendProduct>>(expect1);
      }
    }
  }


  virtual ~DescribeScenePurchaseRecommendResponseBodyRecommendProducts() = default;
};
class DescribeScenePurchaseRecommendResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeScenePurchaseRecommendResponseBodyRecommendProducts> recommendProducts{};
  shared_ptr<string> requestId{};

  DescribeScenePurchaseRecommendResponseBody() {}

  explicit DescribeScenePurchaseRecommendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendProducts) {
      res["RecommendProducts"] = recommendProducts ? boost::any(recommendProducts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendProducts") != m.end() && !m["RecommendProducts"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendProducts"].type()) {
        DescribeScenePurchaseRecommendResponseBodyRecommendProducts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendProducts"]));
        recommendProducts = make_shared<DescribeScenePurchaseRecommendResponseBodyRecommendProducts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeScenePurchaseRecommendResponseBody() = default;
};
class DescribeScenePurchaseRecommendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScenePurchaseRecommendResponseBody> body{};

  DescribeScenePurchaseRecommendResponse() {}

  explicit DescribeScenePurchaseRecommendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScenePurchaseRecommendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScenePurchaseRecommendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScenePurchaseRecommendResponse() = default;
};
class DescribeSceneResourceRecommendRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> productId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sceneId{};

  DescribeSceneResourceRecommendRequest() {}

  explicit DescribeSceneResourceRecommendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (productId) {
      res["ProductId"] = boost::any(*productId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProductId") != m.end() && !m["ProductId"].empty()) {
      productId = make_shared<long>(boost::any_cast<long>(m["ProductId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<long>(boost::any_cast<long>(m["SceneId"]));
    }
  }


  virtual ~DescribeSceneResourceRecommendRequest() = default;
};
class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType : public Darabonba::Model {
public:
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> instanceTypeName{};
  shared_ptr<long> priority{};

  DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType() {}

  explicit DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (instanceTypeName) {
      res["InstanceTypeName"] = boost::any(*instanceTypeName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("InstanceTypeName") != m.end() && !m["InstanceTypeName"].empty()) {
      instanceTypeName = make_shared<string>(boost::any_cast<string>(m["InstanceTypeName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType() = default;
};
class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType>> instanceType{};

  DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes() {}

  explicit DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      vector<boost::any> temp1;
      for(auto item1:*instanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceType"].type()) {
        vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceType = make_shared<vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypesInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes() = default;
};
class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec : public Darabonba::Model {
public:
  shared_ptr<long> cores{};
  shared_ptr<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes> instanceTypes{};
  shared_ptr<double> memory{};

  DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec() {}

  explicit DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = instanceTypes ? boost::any(instanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypes"].type()) {
        DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypes"]));
        instanceTypes = make_shared<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpecInstanceTypes>(model1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
  }


  virtual ~DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec() = default;
};
class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec>> recommendInstanceSpec{};

  DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs() {}

  explicit DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendInstanceSpec) {
      vector<boost::any> temp1;
      for(auto item1:*recommendInstanceSpec){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendInstanceSpec"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendInstanceSpec") != m.end() && !m["RecommendInstanceSpec"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendInstanceSpec"].type()) {
        vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendInstanceSpec"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendInstanceSpec = make_shared<vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecsRecommendInstanceSpec>>(expect1);
      }
    }
  }


  virtual ~DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs() = default;
};
class DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct : public Darabonba::Model {
public:
  shared_ptr<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs> recommendInstanceSpecs{};
  shared_ptr<string> recommendReason{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> zoneId{};

  DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct() {}

  explicit DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendInstanceSpecs) {
      res["RecommendInstanceSpecs"] = recommendInstanceSpecs ? boost::any(recommendInstanceSpecs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recommendReason) {
      res["RecommendReason"] = boost::any(*recommendReason);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendInstanceSpecs") != m.end() && !m["RecommendInstanceSpecs"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendInstanceSpecs"].type()) {
        DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendInstanceSpecs"]));
        recommendInstanceSpecs = make_shared<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProductRecommendInstanceSpecs>(model1);
      }
    }
    if (m.find("RecommendReason") != m.end() && !m["RecommendReason"].empty()) {
      recommendReason = make_shared<string>(boost::any_cast<string>(m["RecommendReason"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct() = default;
};
class DescribeSceneResourceRecommendResponseBodyRecommendProducts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct>> recommendProduct{};

  DescribeSceneResourceRecommendResponseBodyRecommendProducts() {}

  explicit DescribeSceneResourceRecommendResponseBodyRecommendProducts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendProduct) {
      vector<boost::any> temp1;
      for(auto item1:*recommendProduct){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecommendProduct"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendProduct") != m.end() && !m["RecommendProduct"].empty()) {
      if (typeid(vector<boost::any>) == m["RecommendProduct"].type()) {
        vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecommendProduct"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendProduct = make_shared<vector<DescribeSceneResourceRecommendResponseBodyRecommendProductsRecommendProduct>>(expect1);
      }
    }
  }


  virtual ~DescribeSceneResourceRecommendResponseBodyRecommendProducts() = default;
};
class DescribeSceneResourceRecommendResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSceneResourceRecommendResponseBodyRecommendProducts> recommendProducts{};
  shared_ptr<string> requestId{};

  DescribeSceneResourceRecommendResponseBody() {}

  explicit DescribeSceneResourceRecommendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendProducts) {
      res["RecommendProducts"] = recommendProducts ? boost::any(recommendProducts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendProducts") != m.end() && !m["RecommendProducts"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendProducts"].type()) {
        DescribeSceneResourceRecommendResponseBodyRecommendProducts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendProducts"]));
        recommendProducts = make_shared<DescribeSceneResourceRecommendResponseBodyRecommendProducts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSceneResourceRecommendResponseBody() = default;
};
class DescribeSceneResourceRecommendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSceneResourceRecommendResponseBody> body{};

  DescribeSceneResourceRecommendResponse() {}

  explicit DescribeSceneResourceRecommendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSceneResourceRecommendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSceneResourceRecommendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSceneResourceRecommendResponse() = default;
};
class DescribeSpotInstanceAdviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> cores{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<double> memory{};
  shared_ptr<long> minCores{};
  shared_ptr<double> minMemory{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  DescribeSpotInstanceAdviceRequest() {}

  explicit DescribeSpotInstanceAdviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (minCores) {
      res["MinCores"] = boost::any(*minCores);
    }
    if (minMemory) {
      res["MinMemory"] = boost::any(*minMemory);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
    if (m.find("MinCores") != m.end() && !m["MinCores"].empty()) {
      minCores = make_shared<long>(boost::any_cast<long>(m["MinCores"]));
    }
    if (m.find("MinMemory") != m.end() && !m["MinMemory"].empty()) {
      minMemory = make_shared<double>(boost::any_cast<double>(m["MinMemory"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeSpotInstanceAdviceRequest() = default;
};
class DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones : public Darabonba::Model {
public:
  shared_ptr<vector<string>> availableSpotZone{};

  DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones() {}

  explicit DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableSpotZone) {
      res["AvailableSpotZone"] = boost::any(*availableSpotZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableSpotZone") != m.end() && !m["AvailableSpotZone"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AvailableSpotZone"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AvailableSpotZone"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      availableSpotZone = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones() = default;
};
class DescribeSpotInstanceAdviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones> availableSpotZones{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};

  DescribeSpotInstanceAdviceResponseBody() {}

  explicit DescribeSpotInstanceAdviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableSpotZones) {
      res["AvailableSpotZones"] = availableSpotZones ? boost::any(availableSpotZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableSpotZones") != m.end() && !m["AvailableSpotZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableSpotZones"].type()) {
        DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableSpotZones"]));
        availableSpotZones = make_shared<DescribeSpotInstanceAdviceResponseBodyAvailableSpotZones>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSpotInstanceAdviceResponseBody() = default;
};
class DescribeSpotInstanceAdviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSpotInstanceAdviceResponseBody> body{};

  DescribeSpotInstanceAdviceResponse() {}

  explicit DescribeSpotInstanceAdviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSpotInstanceAdviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSpotInstanceAdviceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSpotInstanceAdviceResponse() = default;
};
class DescribeStorageCapacityUnitAllocationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> storageCapacityUnitId{};

  DescribeStorageCapacityUnitAllocationsRequest() {}

  explicit DescribeStorageCapacityUnitAllocationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (storageCapacityUnitId) {
      res["StorageCapacityUnitId"] = boost::any(*storageCapacityUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StorageCapacityUnitId") != m.end() && !m["StorageCapacityUnitId"].empty()) {
      storageCapacityUnitId = make_shared<string>(boost::any_cast<string>(m["StorageCapacityUnitId"]));
    }
  }


  virtual ~DescribeStorageCapacityUnitAllocationsRequest() = default;
};
class DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation : public Darabonba::Model {
public:
  shared_ptr<string> beAllocatedAccountId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> storageCapacityUnitId{};

  DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation() {}

  explicit DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beAllocatedAccountId) {
      res["BeAllocatedAccountId"] = boost::any(*beAllocatedAccountId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (storageCapacityUnitId) {
      res["StorageCapacityUnitId"] = boost::any(*storageCapacityUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeAllocatedAccountId") != m.end() && !m["BeAllocatedAccountId"].empty()) {
      beAllocatedAccountId = make_shared<string>(boost::any_cast<string>(m["BeAllocatedAccountId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("StorageCapacityUnitId") != m.end() && !m["StorageCapacityUnitId"].empty()) {
      storageCapacityUnitId = make_shared<string>(boost::any_cast<string>(m["StorageCapacityUnitId"]));
    }
  }


  virtual ~DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation() = default;
};
class DescribeStorageCapacityUnitAllocationsResponseBodyAllocations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation>> allocation{};

  DescribeStorageCapacityUnitAllocationsResponseBodyAllocations() {}

  explicit DescribeStorageCapacityUnitAllocationsResponseBodyAllocations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocation) {
      vector<boost::any> temp1;
      for(auto item1:*allocation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Allocation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Allocation") != m.end() && !m["Allocation"].empty()) {
      if (typeid(vector<boost::any>) == m["Allocation"].type()) {
        vector<DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Allocation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allocation = make_shared<vector<DescribeStorageCapacityUnitAllocationsResponseBodyAllocationsAllocation>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitAllocationsResponseBodyAllocations() = default;
};
class DescribeStorageCapacityUnitAllocationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeStorageCapacityUnitAllocationsResponseBodyAllocations> allocations{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeStorageCapacityUnitAllocationsResponseBody() {}

  explicit DescribeStorageCapacityUnitAllocationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocations) {
      res["Allocations"] = allocations ? boost::any(allocations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Allocations") != m.end() && !m["Allocations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Allocations"].type()) {
        DescribeStorageCapacityUnitAllocationsResponseBodyAllocations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Allocations"]));
        allocations = make_shared<DescribeStorageCapacityUnitAllocationsResponseBodyAllocations>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeStorageCapacityUnitAllocationsResponseBody() = default;
};
class DescribeStorageCapacityUnitAllocationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStorageCapacityUnitAllocationsResponseBody> body{};

  DescribeStorageCapacityUnitAllocationsResponse() {}

  explicit DescribeStorageCapacityUnitAllocationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageCapacityUnitAllocationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageCapacityUnitAllocationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitAllocationsResponse() = default;
};
class DescribeStorageCapacityUnitDeductFactorRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeStorageCapacityUnitDeductFactorRequestTag() {}

  explicit DescribeStorageCapacityUnitDeductFactorRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeStorageCapacityUnitDeductFactorRequestTag() = default;
};
class DescribeStorageCapacityUnitDeductFactorRequest : public Darabonba::Model {
public:
  shared_ptr<string> deductField{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> storageType{};
  shared_ptr<vector<DescribeStorageCapacityUnitDeductFactorRequestTag>> tag{};

  DescribeStorageCapacityUnitDeductFactorRequest() {}

  explicit DescribeStorageCapacityUnitDeductFactorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deductField) {
      res["DeductField"] = boost::any(*deductField);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeductField") != m.end() && !m["DeductField"].empty()) {
      deductField = make_shared<string>(boost::any_cast<string>(m["DeductField"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeStorageCapacityUnitDeductFactorRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageCapacityUnitDeductFactorRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeStorageCapacityUnitDeductFactorRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitDeductFactorRequest() = default;
};
class DescribeStorageCapacityUnitDeductFactorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deductFactor{};
  shared_ptr<string> requestId{};

  DescribeStorageCapacityUnitDeductFactorResponseBody() {}

  explicit DescribeStorageCapacityUnitDeductFactorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deductFactor) {
      res["DeductFactor"] = boost::any(*deductFactor);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeductFactor") != m.end() && !m["DeductFactor"].empty()) {
      deductFactor = make_shared<string>(boost::any_cast<string>(m["DeductFactor"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeStorageCapacityUnitDeductFactorResponseBody() = default;
};
class DescribeStorageCapacityUnitDeductFactorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStorageCapacityUnitDeductFactorResponseBody> body{};

  DescribeStorageCapacityUnitDeductFactorResponse() {}

  explicit DescribeStorageCapacityUnitDeductFactorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageCapacityUnitDeductFactorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageCapacityUnitDeductFactorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageCapacityUnitDeductFactorResponse() = default;
};
class DescribeStorageSetDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> diskIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};

  DescribeStorageSetDetailsRequest() {}

  explicit DescribeStorageSetDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["DiskIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
  }


  virtual ~DescribeStorageSetDetailsRequest() = default;
};
class DescribeStorageSetDetailsResponseBodyDisksDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> zoneId{};

  DescribeStorageSetDetailsResponseBodyDisksDisk() {}

  explicit DescribeStorageSetDetailsResponseBodyDisksDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeStorageSetDetailsResponseBodyDisksDisk() = default;
};
class DescribeStorageSetDetailsResponseBodyDisks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStorageSetDetailsResponseBodyDisksDisk>> disk{};

  DescribeStorageSetDetailsResponseBodyDisks() {}

  explicit DescribeStorageSetDetailsResponseBodyDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      vector<boost::any> temp1;
      for(auto item1:*disk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      if (typeid(vector<boost::any>) == m["Disk"].type()) {
        vector<DescribeStorageSetDetailsResponseBodyDisksDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageSetDetailsResponseBodyDisksDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disk = make_shared<vector<DescribeStorageSetDetailsResponseBodyDisksDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageSetDetailsResponseBodyDisks() = default;
};
class DescribeStorageSetDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeStorageSetDetailsResponseBodyDisks> disks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeStorageSetDetailsResponseBody() {}

  explicit DescribeStorageSetDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disks) {
      res["Disks"] = disks ? boost::any(disks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Disks"].type()) {
        DescribeStorageSetDetailsResponseBodyDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Disks"]));
        disks = make_shared<DescribeStorageSetDetailsResponseBodyDisks>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeStorageSetDetailsResponseBody() = default;
};
class DescribeStorageSetDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStorageSetDetailsResponseBody> body{};

  DescribeStorageSetDetailsResponse() {}

  explicit DescribeStorageSetDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageSetDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageSetDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageSetDetailsResponse() = default;
};
class DescribeStorageSetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> storageSetIds{};
  shared_ptr<string> storageSetName{};
  shared_ptr<string> zoneId{};

  DescribeStorageSetsRequest() {}

  explicit DescribeStorageSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (storageSetIds) {
      res["StorageSetIds"] = boost::any(*storageSetIds);
    }
    if (storageSetName) {
      res["StorageSetName"] = boost::any(*storageSetName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StorageSetIds") != m.end() && !m["StorageSetIds"].empty()) {
      storageSetIds = make_shared<string>(boost::any_cast<string>(m["StorageSetIds"]));
    }
    if (m.find("StorageSetName") != m.end() && !m["StorageSetName"].empty()) {
      storageSetName = make_shared<string>(boost::any_cast<string>(m["StorageSetName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeStorageSetsRequest() = default;
};
class DescribeStorageSetsResponseBodyStorageSetsStorageSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<string> storageSetName{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<string> zoneId{};

  DescribeStorageSetsResponseBodyStorageSetsStorageSet() {}

  explicit DescribeStorageSetsResponseBodyStorageSetsStorageSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetName) {
      res["StorageSetName"] = boost::any(*storageSetName);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetName") != m.end() && !m["StorageSetName"].empty()) {
      storageSetName = make_shared<string>(boost::any_cast<string>(m["StorageSetName"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeStorageSetsResponseBodyStorageSetsStorageSet() = default;
};
class DescribeStorageSetsResponseBodyStorageSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStorageSetsResponseBodyStorageSetsStorageSet>> storageSet{};

  DescribeStorageSetsResponseBodyStorageSets() {}

  explicit DescribeStorageSetsResponseBodyStorageSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageSet) {
      vector<boost::any> temp1;
      for(auto item1:*storageSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StorageSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageSet") != m.end() && !m["StorageSet"].empty()) {
      if (typeid(vector<boost::any>) == m["StorageSet"].type()) {
        vector<DescribeStorageSetsResponseBodyStorageSetsStorageSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StorageSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageSetsResponseBodyStorageSetsStorageSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        storageSet = make_shared<vector<DescribeStorageSetsResponseBodyStorageSetsStorageSet>>(expect1);
      }
    }
  }


  virtual ~DescribeStorageSetsResponseBodyStorageSets() = default;
};
class DescribeStorageSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeStorageSetsResponseBodyStorageSets> storageSets{};
  shared_ptr<long> totalCount{};

  DescribeStorageSetsResponseBody() {}

  explicit DescribeStorageSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageSets) {
      res["StorageSets"] = storageSets ? boost::any(storageSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageSets") != m.end() && !m["StorageSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["StorageSets"].type()) {
        DescribeStorageSetsResponseBodyStorageSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StorageSets"]));
        storageSets = make_shared<DescribeStorageSetsResponseBodyStorageSets>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeStorageSetsResponseBody() = default;
};
class DescribeStorageSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStorageSetsResponseBody> body{};

  DescribeStorageSetsResponse() {}

  explicit DescribeStorageSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageSetsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageSetsResponse() = default;
};
class DescribeTransitionVSwitchesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> vpcId{};

  DescribeTransitionVSwitchesRequest() {}

  explicit DescribeTransitionVSwitchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeTransitionVSwitchesRequest() = default;
};
class DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel : public Darabonba::Model {
public:
  shared_ptr<string> CIDR{};
  shared_ptr<string> description{};
  shared_ptr<string> izNo{};
  shared_ptr<string> name{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel() {}

  explicit DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CIDR) {
      res["CIDR"] = boost::any(*CIDR);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (izNo) {
      res["IzNo"] = boost::any(*izNo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CIDR") != m.end() && !m["CIDR"].empty()) {
      CIDR = make_shared<string>(boost::any_cast<string>(m["CIDR"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IzNo") != m.end() && !m["IzNo"].empty()) {
      izNo = make_shared<string>(boost::any_cast<string>(m["IzNo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel() = default;
};
class DescribeTransitionVSwitchesResponseBodyVSwitchModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel>> model{};

  DescribeTransitionVSwitchesResponseBodyVSwitchModels() {}

  explicit DescribeTransitionVSwitchesResponseBodyVSwitchModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<DescribeTransitionVSwitchesResponseBodyVSwitchModelsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeTransitionVSwitchesResponseBodyVSwitchModels() = default;
};
class DescribeTransitionVSwitchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeTransitionVSwitchesResponseBodyVSwitchModels> vSwitchModels{};

  DescribeTransitionVSwitchesResponseBody() {}

  explicit DescribeTransitionVSwitchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (vSwitchModels) {
      res["VSwitchModels"] = vSwitchModels ? boost::any(vSwitchModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("VSwitchModels") != m.end() && !m["VSwitchModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchModels"].type()) {
        DescribeTransitionVSwitchesResponseBodyVSwitchModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchModels"]));
        vSwitchModels = make_shared<DescribeTransitionVSwitchesResponseBodyVSwitchModels>(model1);
      }
    }
  }


  virtual ~DescribeTransitionVSwitchesResponseBody() = default;
};
class DescribeTransitionVSwitchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTransitionVSwitchesResponseBody> body{};

  DescribeTransitionVSwitchesResponse() {}

  explicit DescribeTransitionVSwitchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTransitionVSwitchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTransitionVSwitchesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTransitionVSwitchesResponse() = default;
};
class DescribeTransitionVpcAndVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  DescribeTransitionVpcAndVSwitchRequest() {}

  explicit DescribeTransitionVpcAndVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTransitionVpcAndVSwitchRequest() = default;
};
class DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> message{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel() {}

  explicit DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel() = default;
};
class DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel>> model{};

  DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels() {}

  explicit DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModelsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels() = default;
};
class DescribeTransitionVpcAndVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels> vmTransitionModels{};

  DescribeTransitionVpcAndVSwitchResponseBody() {}

  explicit DescribeTransitionVpcAndVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vmTransitionModels) {
      res["VmTransitionModels"] = vmTransitionModels ? boost::any(vmTransitionModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VmTransitionModels") != m.end() && !m["VmTransitionModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["VmTransitionModels"].type()) {
        DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VmTransitionModels"]));
        vmTransitionModels = make_shared<DescribeTransitionVpcAndVSwitchResponseBodyVmTransitionModels>(model1);
      }
    }
  }


  virtual ~DescribeTransitionVpcAndVSwitchResponseBody() = default;
};
class DescribeTransitionVpcAndVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTransitionVpcAndVSwitchResponseBody> body{};

  DescribeTransitionVpcAndVSwitchResponse() {}

  explicit DescribeTransitionVpcAndVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTransitionVpcAndVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTransitionVpcAndVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTransitionVpcAndVSwitchResponse() = default;
};
class DescribeTransitionVpcsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  DescribeTransitionVpcsRequest() {}

  explicit DescribeTransitionVpcsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTransitionVpcsRequest() = default;
};
class DescribeTransitionVpcsResponseBodyVpcModelsModel : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  DescribeTransitionVpcsResponseBodyVpcModelsModel() {}

  explicit DescribeTransitionVpcsResponseBodyVpcModelsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeTransitionVpcsResponseBodyVpcModelsModel() = default;
};
class DescribeTransitionVpcsResponseBodyVpcModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTransitionVpcsResponseBodyVpcModelsModel>> model{};

  DescribeTransitionVpcsResponseBodyVpcModels() {}

  explicit DescribeTransitionVpcsResponseBodyVpcModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<DescribeTransitionVpcsResponseBodyVpcModelsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTransitionVpcsResponseBodyVpcModelsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<DescribeTransitionVpcsResponseBodyVpcModelsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeTransitionVpcsResponseBodyVpcModels() = default;
};
class DescribeTransitionVpcsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeTransitionVpcsResponseBodyVpcModels> vpcModels{};

  DescribeTransitionVpcsResponseBody() {}

  explicit DescribeTransitionVpcsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (vpcModels) {
      res["VpcModels"] = vpcModels ? boost::any(vpcModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("VpcModels") != m.end() && !m["VpcModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcModels"].type()) {
        DescribeTransitionVpcsResponseBodyVpcModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcModels"]));
        vpcModels = make_shared<DescribeTransitionVpcsResponseBodyVpcModels>(model1);
      }
    }
  }


  virtual ~DescribeTransitionVpcsResponseBody() = default;
};
class DescribeTransitionVpcsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTransitionVpcsResponseBody> body{};

  DescribeTransitionVpcsResponse() {}

  explicit DescribeTransitionVpcsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTransitionVpcsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTransitionVpcsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTransitionVpcsResponse() = default;
};
class DescribeUserAvailableIpServiceProvidersRequest : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeUserAvailableIpServiceProvidersRequest() {}

  explicit DescribeUserAvailableIpServiceProvidersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeUserAvailableIpServiceProvidersRequest() = default;
};
class DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider() {}

  explicit DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider() = default;
};
class DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider>> ipServiceProvider{};

  DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders() {}

  explicit DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipServiceProvider) {
      vector<boost::any> temp1;
      for(auto item1:*ipServiceProvider){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpServiceProvider"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpServiceProvider") != m.end() && !m["IpServiceProvider"].empty()) {
      if (typeid(vector<boost::any>) == m["IpServiceProvider"].type()) {
        vector<DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpServiceProvider"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipServiceProvider = make_shared<vector<DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProvidersIpServiceProvider>>(expect1);
      }
    }
  }


  virtual ~DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders() = default;
};
class DescribeUserAvailableIpServiceProvidersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders> ipServiceProviders{};
  shared_ptr<string> requestId{};

  DescribeUserAvailableIpServiceProvidersResponseBody() {}

  explicit DescribeUserAvailableIpServiceProvidersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipServiceProviders) {
      res["IpServiceProviders"] = ipServiceProviders ? boost::any(ipServiceProviders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpServiceProviders") != m.end() && !m["IpServiceProviders"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpServiceProviders"].type()) {
        DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpServiceProviders"]));
        ipServiceProviders = make_shared<DescribeUserAvailableIpServiceProvidersResponseBodyIpServiceProviders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserAvailableIpServiceProvidersResponseBody() = default;
};
class DescribeUserAvailableIpServiceProvidersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserAvailableIpServiceProvidersResponseBody> body{};

  DescribeUserAvailableIpServiceProvidersResponse() {}

  explicit DescribeUserAvailableIpServiceProvidersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserAvailableIpServiceProvidersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserAvailableIpServiceProvidersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserAvailableIpServiceProvidersResponse() = default;
};
class DescribeUserQuotaApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> quotaType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> pageSize{};

  DescribeUserQuotaApplicationsRequest() {}

  explicit DescribeUserQuotaApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (quotaType) {
      res["QuotaType"] = boost::any(*quotaType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("QuotaType") != m.end() && !m["QuotaType"].empty()) {
      quotaType = make_shared<string>(boost::any_cast<string>(m["QuotaType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~DescribeUserQuotaApplicationsRequest() = default;
};
class DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> comment{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> quotaType{};
  shared_ptr<long> quotaValue{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> zoneId{};

  DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication() {}

  explicit DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (quotaType) {
      res["QuotaType"] = boost::any(*quotaType);
    }
    if (quotaValue) {
      res["QuotaValue"] = boost::any(*quotaValue);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("QuotaType") != m.end() && !m["QuotaType"].empty()) {
      quotaType = make_shared<string>(boost::any_cast<string>(m["QuotaType"]));
    }
    if (m.find("QuotaValue") != m.end() && !m["QuotaValue"].empty()) {
      quotaValue = make_shared<long>(boost::any_cast<long>(m["QuotaValue"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication() = default;
};
class DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication>> userQuotaApplication{};

  DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications() {}

  explicit DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userQuotaApplication) {
      vector<boost::any> temp1;
      for(auto item1:*userQuotaApplication){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserQuotaApplication"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserQuotaApplication") != m.end() && !m["UserQuotaApplication"].empty()) {
      if (typeid(vector<boost::any>) == m["UserQuotaApplication"].type()) {
        vector<DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserQuotaApplication"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userQuotaApplication = make_shared<vector<DescribeUserQuotaApplicationsResponseBodyUserQuotaApplicationsUserQuotaApplication>>(expect1);
      }
    }
  }


  virtual ~DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications() = default;
};
class DescribeUserQuotaApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications> userQuotaApplications{};

  DescribeUserQuotaApplicationsResponseBody() {}

  explicit DescribeUserQuotaApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userQuotaApplications) {
      res["UserQuotaApplications"] = userQuotaApplications ? boost::any(userQuotaApplications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserQuotaApplications") != m.end() && !m["UserQuotaApplications"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserQuotaApplications"].type()) {
        DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserQuotaApplications"]));
        userQuotaApplications = make_shared<DescribeUserQuotaApplicationsResponseBodyUserQuotaApplications>(model1);
      }
    }
  }


  virtual ~DescribeUserQuotaApplicationsResponseBody() = default;
};
class DescribeUserQuotaApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserQuotaApplicationsResponseBody> body{};

  DescribeUserQuotaApplicationsResponse() {}

  explicit DescribeUserQuotaApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserQuotaApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserQuotaApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserQuotaApplicationsResponse() = default;
};
class DescribeVpcHavsInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResultSize{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> vpcIdList{};

  DescribeVpcHavsInstancesRequest() {}

  explicit DescribeVpcHavsInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResultSize) {
      res["MaxResultSize"] = boost::any(*maxResultSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcIdList) {
      res["VpcIdList"] = boost::any(*vpcIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResultSize") != m.end() && !m["MaxResultSize"].empty()) {
      maxResultSize = make_shared<long>(boost::any_cast<long>(m["MaxResultSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcIdList") != m.end() && !m["VpcIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VpcIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VpcIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vpcIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcHavsInstancesRequest() = default;
};
class DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance : public Darabonba::Model {
public:
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> reason{};

  DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance() {}

  explicit DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance() = default;
};
class DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance>> havsInstance{};

  DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances() {}

  explicit DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (havsInstance) {
      vector<boost::any> temp1;
      for(auto item1:*havsInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HavsInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HavsInstance") != m.end() && !m["HavsInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["HavsInstance"].type()) {
        vector<DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HavsInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        havsInstance = make_shared<vector<DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstancesHavsInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances() = default;
};
class DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance : public Darabonba::Model {
public:
  shared_ptr<DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances> havsInstances{};
  shared_ptr<string> vpcId{};

  DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance() {}

  explicit DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (havsInstances) {
      res["HavsInstances"] = havsInstances ? boost::any(havsInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HavsInstances") != m.end() && !m["HavsInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["HavsInstances"].type()) {
        DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HavsInstances"]));
        havsInstances = make_shared<DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstanceHavsInstances>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance() = default;
};
class DescribeVpcHavsInstancesResponseBodyVpcHavsInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance>> vpcHavsInstance{};

  DescribeVpcHavsInstancesResponseBodyVpcHavsInstances() {}

  explicit DescribeVpcHavsInstancesResponseBodyVpcHavsInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcHavsInstance) {
      vector<boost::any> temp1;
      for(auto item1:*vpcHavsInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcHavsInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcHavsInstance") != m.end() && !m["VpcHavsInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcHavsInstance"].type()) {
        vector<DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcHavsInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcHavsInstance = make_shared<vector<DescribeVpcHavsInstancesResponseBodyVpcHavsInstancesVpcHavsInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcHavsInstancesResponseBodyVpcHavsInstances() = default;
};
class DescribeVpcHavsInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVpcHavsInstancesResponseBodyVpcHavsInstances> vpcHavsInstances{};

  DescribeVpcHavsInstancesResponseBody() {}

  explicit DescribeVpcHavsInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcHavsInstances) {
      res["VpcHavsInstances"] = vpcHavsInstances ? boost::any(vpcHavsInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcHavsInstances") != m.end() && !m["VpcHavsInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcHavsInstances"].type()) {
        DescribeVpcHavsInstancesResponseBodyVpcHavsInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcHavsInstances"]));
        vpcHavsInstances = make_shared<DescribeVpcHavsInstancesResponseBodyVpcHavsInstances>(model1);
      }
    }
  }


  virtual ~DescribeVpcHavsInstancesResponseBody() = default;
};
class DescribeVpcHavsInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpcHavsInstancesResponseBody> body{};

  DescribeVpcHavsInstancesResponse() {}

  explicit DescribeVpcHavsInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcHavsInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcHavsInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcHavsInstancesResponse() = default;
};
class DescribeWaitingOrdersRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeWaitingOrdersRequestTag() {}

  explicit DescribeWaitingOrdersRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeWaitingOrdersRequestTag() = default;
};
class DescribeWaitingOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeWaitingOrdersRequestTag>> tag{};
  shared_ptr<vector<string>> waitingOrderId{};

  DescribeWaitingOrdersRequest() {}

  explicit DescribeWaitingOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (waitingOrderId) {
      res["WaitingOrderId"] = boost::any(*waitingOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeWaitingOrdersRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWaitingOrdersRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeWaitingOrdersRequestTag>>(expect1);
      }
    }
    if (m.find("WaitingOrderId") != m.end() && !m["WaitingOrderId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WaitingOrderId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WaitingOrderId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      waitingOrderId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeWaitingOrdersRequest() = default;
};
class DescribeWaitingOrdersResponseBodyDataInstanceInfos : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> resultCode{};

  DescribeWaitingOrdersResponseBodyDataInstanceInfos() {}

  explicit DescribeWaitingOrdersResponseBodyDataInstanceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
  }


  virtual ~DescribeWaitingOrdersResponseBodyDataInstanceInfos() = default;
};
class DescribeWaitingOrdersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> failedMessage{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<vector<DescribeWaitingOrdersResponseBodyDataInstanceInfos>> instanceInfos{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> lxCreateParam{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<long> successAmount{};
  shared_ptr<string> waitingOrderId{};
  shared_ptr<string> zoneId{};

  DescribeWaitingOrdersResponseBodyData() {}

  explicit DescribeWaitingOrdersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (failedMessage) {
      res["FailedMessage"] = boost::any(*failedMessage);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*instanceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceInfos"] = boost::any(temp1);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (lxCreateParam) {
      res["LxCreateParam"] = boost::any(*lxCreateParam);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successAmount) {
      res["SuccessAmount"] = boost::any(*successAmount);
    }
    if (waitingOrderId) {
      res["WaitingOrderId"] = boost::any(*waitingOrderId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FailedMessage") != m.end() && !m["FailedMessage"].empty()) {
      failedMessage = make_shared<string>(boost::any_cast<string>(m["FailedMessage"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceInfos") != m.end() && !m["InstanceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceInfos"].type()) {
        vector<DescribeWaitingOrdersResponseBodyDataInstanceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWaitingOrdersResponseBodyDataInstanceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceInfos = make_shared<vector<DescribeWaitingOrdersResponseBodyDataInstanceInfos>>(expect1);
      }
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("LxCreateParam") != m.end() && !m["LxCreateParam"].empty()) {
      lxCreateParam = make_shared<string>(boost::any_cast<string>(m["LxCreateParam"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SuccessAmount") != m.end() && !m["SuccessAmount"].empty()) {
      successAmount = make_shared<long>(boost::any_cast<long>(m["SuccessAmount"]));
    }
    if (m.find("WaitingOrderId") != m.end() && !m["WaitingOrderId"].empty()) {
      waitingOrderId = make_shared<string>(boost::any_cast<string>(m["WaitingOrderId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeWaitingOrdersResponseBodyData() = default;
};
class DescribeWaitingOrdersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWaitingOrdersResponseBodyData>> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWaitingOrdersResponseBody() {}

  explicit DescribeWaitingOrdersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeWaitingOrdersResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWaitingOrdersResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeWaitingOrdersResponseBodyData>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWaitingOrdersResponseBody() = default;
};
class DescribeWaitingOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWaitingOrdersResponseBody> body{};

  DescribeWaitingOrdersResponse() {}

  explicit DescribeWaitingOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWaitingOrdersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWaitingOrdersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWaitingOrdersResponse() = default;
};
class FeedbackDiagnoseRequest : public Darabonba::Model {
public:
  shared_ptr<string> diagnoseId{};
  shared_ptr<string> mark{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> star{};

  FeedbackDiagnoseRequest() {}

  explicit FeedbackDiagnoseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (mark) {
      res["Mark"] = boost::any(*mark);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (star) {
      res["Star"] = boost::any(*star);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("Mark") != m.end() && !m["Mark"].empty()) {
      mark = make_shared<string>(boost::any_cast<string>(m["Mark"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Star") != m.end() && !m["Star"].empty()) {
      star = make_shared<long>(boost::any_cast<long>(m["Star"]));
    }
  }


  virtual ~FeedbackDiagnoseRequest() = default;
};
class FeedbackDiagnoseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  FeedbackDiagnoseResponseBody() {}

  explicit FeedbackDiagnoseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FeedbackDiagnoseResponseBody() = default;
};
class FeedbackDiagnoseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FeedbackDiagnoseResponseBody> body{};

  FeedbackDiagnoseResponse() {}

  explicit FeedbackDiagnoseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FeedbackDiagnoseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FeedbackDiagnoseResponseBody>(model1);
      }
    }
  }


  virtual ~FeedbackDiagnoseResponse() = default;
};
class GetLaunchTemplateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetLaunchTemplateDataRequest() {}

  explicit GetLaunchTemplateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetLaunchTemplateDataRequest() = default;
};
class GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> diskName{};
  shared_ptr<long> iops{};
  shared_ptr<long> size{};

  GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk() {}

  explicit GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (iops) {
      res["Iops"] = boost::any(*iops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Iops") != m.end() && !m["Iops"].empty()) {
      iops = make_shared<long>(boost::any_cast<long>(m["Iops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk() = default;
};
class GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encrypted{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};

  GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk() {}

  explicit GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["Encrypted"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk() = default;
};
class GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks : public Darabonba::Model {
public:
  shared_ptr<vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk>> dataDisk{};

  GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks() {}

  explicit GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisksDataDisk>>(expect1);
      }
    }
  }


  virtual ~GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks() = default;
};
class GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vSwitchId{};

  GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface() {}

  explicit GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface() = default;
};
class GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface>> networkInterface{};

  GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces() {}

  explicit GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterface) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterface){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterface"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterface") != m.end() && !m["NetworkInterface"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterface"].type()) {
        vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterface"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterface = make_shared<vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfacesNetworkInterface>>(expect1);
      }
    }
  }


  virtual ~GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces() = default;
};
class GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag() {}

  explicit GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag() = default;
};
class GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags : public Darabonba::Model {
public:
  shared_ptr<vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag>> instanceTag{};

  GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags() {}

  explicit GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTag) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTag") != m.end() && !m["InstanceTag"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTag"].type()) {
        vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTag = make_shared<vector<GetLaunchTemplateDataResponseBodyLaunchTemplateDataTagsInstanceTag>>(expect1);
      }
    }
  }


  virtual ~GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags() = default;
};
class GetLaunchTemplateDataResponseBodyLaunchTemplateData : public Darabonba::Model {
public:
  shared_ptr<GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk> systemDisk{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks> dataDisks{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableVmOsConfig{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<string> keyPairName{};
  shared_ptr<GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces> networkInterfaces{};
  shared_ptr<string> networkType{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<long> period{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> securityEnhancementStrategy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<long> spotDuration{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags> tags{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  GetLaunchTemplateDataResponseBodyLaunchTemplateData() {}

  explicit GetLaunchTemplateDataResponseBodyLaunchTemplateData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!systemDisk) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("systemDisk is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (dataDisks) {
      res["DataDisks"] = dataDisks ? boost::any(dataDisks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableVmOsConfig) {
      res["EnableVmOsConfig"] = boost::any(*enableVmOsConfig);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (networkInterfaces) {
      res["NetworkInterfaces"] = networkInterfaces ? boost::any(networkInterfaces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<GetLaunchTemplateDataResponseBodyLaunchTemplateDataSystemDisk>(model1);
      }
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDisks"].type()) {
        GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDisks"]));
        dataDisks = make_shared<GetLaunchTemplateDataResponseBodyLaunchTemplateDataDataDisks>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableVmOsConfig") != m.end() && !m["EnableVmOsConfig"].empty()) {
      enableVmOsConfig = make_shared<bool>(boost::any_cast<bool>(m["EnableVmOsConfig"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaces"].type()) {
        GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaces"]));
        networkInterfaces = make_shared<GetLaunchTemplateDataResponseBodyLaunchTemplateDataNetworkInterfaces>(model1);
      }
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<bool>(boost::any_cast<bool>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<GetLaunchTemplateDataResponseBodyLaunchTemplateDataTags>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~GetLaunchTemplateDataResponseBodyLaunchTemplateData() = default;
};
class GetLaunchTemplateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLaunchTemplateDataResponseBodyLaunchTemplateData> launchTemplateData{};
  shared_ptr<string> requestId{};

  GetLaunchTemplateDataResponseBody() {}

  explicit GetLaunchTemplateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTemplateData) {
      res["LaunchTemplateData"] = launchTemplateData ? boost::any(launchTemplateData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTemplateData") != m.end() && !m["LaunchTemplateData"].empty()) {
      if (typeid(map<string, boost::any>) == m["LaunchTemplateData"].type()) {
        GetLaunchTemplateDataResponseBodyLaunchTemplateData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LaunchTemplateData"]));
        launchTemplateData = make_shared<GetLaunchTemplateDataResponseBodyLaunchTemplateData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLaunchTemplateDataResponseBody() = default;
};
class GetLaunchTemplateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLaunchTemplateDataResponseBody> body{};

  GetLaunchTemplateDataResponse() {}

  explicit GetLaunchTemplateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLaunchTemplateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLaunchTemplateDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetLaunchTemplateDataResponse() = default;
};
class InnerDescribeNetworkInterfaceInGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> type{};

  InnerDescribeNetworkInterfaceInGroupRequest() {}

  explicit InnerDescribeNetworkInterfaceInGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupRequest() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> publicIpAddress{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment : public Darabonba::Model {
public:
  shared_ptr<long> deviceIndex{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> trunkNetworkInterfaceId{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIndex) {
      res["DeviceIndex"] = boost::any(*deviceIndex);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (trunkNetworkInterfaceId) {
      res["TrunkNetworkInterfaceId"] = boost::any(*trunkNetworkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIndex") != m.end() && !m["DeviceIndex"].empty()) {
      deviceIndex = make_shared<long>(boost::any_cast<long>(m["DeviceIndex"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TrunkNetworkInterfaceId") != m.end() && !m["TrunkNetworkInterfaceId"].empty()) {
      trunkNetworkInterfaceId = make_shared<string>(boost::any_cast<string>(m["TrunkNetworkInterfaceId"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set : public Darabonba::Model {
public:
  shared_ptr<string> ipv6Address{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets : public Darabonba::Model {
public:
  shared_ptr<vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set>> ipv6Set{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Set) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Set){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Set"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Set") != m.end() && !m["Ipv6Set"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Set"].type()) {
        vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Set = make_shared<vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set>>(expect1);
      }
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> publicIpAddress{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet : public Darabonba::Model {
public:
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp> associatedPublicIp{};
  shared_ptr<bool> primary{};
  shared_ptr<string> privateIpAddress{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedPublicIp) {
      res["AssociatedPublicIp"] = associatedPublicIp ? boost::any(associatedPublicIp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedPublicIp") != m.end() && !m["AssociatedPublicIp"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedPublicIp"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedPublicIp"]));
        associatedPublicIp = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp>(model1);
      }
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets : public Darabonba::Model {
public:
  shared_ptr<vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet>> privateIpSet{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpSet) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpSet"].type()) {
        vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpSet = make_shared<vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet>>(expect1);
      }
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags : public Darabonba::Model {
public:
  shared_ptr<vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag>> tag{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag>>(expect1);
      }
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet : public Darabonba::Model {
public:
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp> associatedPublicIp{};
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment> attachment{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets> ipv6Sets{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets> privateIpSets{};
  shared_ptr<long> queueNumber{};
  shared_ptr<long> queuePairNumber{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds> securityGroupIds{};
  shared_ptr<long> serviceID{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> status{};
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags> tags{};
  shared_ptr<string> type{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedPublicIp) {
      res["AssociatedPublicIp"] = associatedPublicIp ? boost::any(associatedPublicIp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attachment) {
      res["Attachment"] = attachment ? boost::any(attachment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipv6Sets) {
      res["Ipv6Sets"] = ipv6Sets ? boost::any(ipv6Sets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (privateIpSets) {
      res["PrivateIpSets"] = privateIpSets ? boost::any(privateIpSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queueNumber) {
      res["QueueNumber"] = boost::any(*queueNumber);
    }
    if (queuePairNumber) {
      res["QueuePairNumber"] = boost::any(*queuePairNumber);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceID) {
      res["ServiceID"] = boost::any(*serviceID);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedPublicIp") != m.end() && !m["AssociatedPublicIp"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedPublicIp"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedPublicIp"]));
        associatedPublicIp = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp>(model1);
      }
    }
    if (m.find("Attachment") != m.end() && !m["Attachment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Attachment"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Attachment"]));
        attachment = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ipv6Sets") != m.end() && !m["Ipv6Sets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Sets"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Sets"]));
        ipv6Sets = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets>(model1);
      }
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("PrivateIpSets") != m.end() && !m["PrivateIpSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpSets"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpSets"]));
        privateIpSets = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets>(model1);
      }
    }
    if (m.find("QueueNumber") != m.end() && !m["QueueNumber"].empty()) {
      queueNumber = make_shared<long>(boost::any_cast<long>(m["QueueNumber"]));
    }
    if (m.find("QueuePairNumber") != m.end() && !m["QueuePairNumber"].empty()) {
      queuePairNumber = make_shared<long>(boost::any_cast<long>(m["QueuePairNumber"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds>(model1);
      }
    }
    if (m.find("ServiceID") != m.end() && !m["ServiceID"].empty()) {
      serviceID = make_shared<long>(boost::any_cast<long>(m["ServiceID"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets : public Darabonba::Model {
public:
  shared_ptr<vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet>> networkInterfaceSet{};

  InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceSet) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaceSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaceSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceSet") != m.end() && !m["NetworkInterfaceSet"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaceSet"].type()) {
        vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaceSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaceSet = make_shared<vector<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSetsNetworkInterfaceSet>>(expect1);
      }
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets> networkInterfaceSets{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  InnerDescribeNetworkInterfaceInGroupResponseBody() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceSets) {
      res["NetworkInterfaceSets"] = networkInterfaceSets ? boost::any(networkInterfaceSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceSets") != m.end() && !m["NetworkInterfaceSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceSets"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceSets"]));
        networkInterfaceSets = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBodyNetworkInterfaceSets>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponseBody() = default;
};
class InnerDescribeNetworkInterfaceInGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InnerDescribeNetworkInterfaceInGroupResponseBody> body{};

  InnerDescribeNetworkInterfaceInGroupResponse() {}

  explicit InnerDescribeNetworkInterfaceInGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InnerDescribeNetworkInterfaceInGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InnerDescribeNetworkInterfaceInGroupResponseBody>(model1);
      }
    }
  }


  virtual ~InnerDescribeNetworkInterfaceInGroupResponse() = default;
};
class JoinEniQosGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosGroupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  JoinEniQosGroupRequest() {}

  explicit JoinEniQosGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosGroupName) {
      res["QosGroupName"] = boost::any(*qosGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosGroupName") != m.end() && !m["QosGroupName"].empty()) {
      qosGroupName = make_shared<string>(boost::any_cast<string>(m["QosGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~JoinEniQosGroupRequest() = default;
};
class JoinEniQosGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinEniQosGroupResponseBody() {}

  explicit JoinEniQosGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinEniQosGroupResponseBody() = default;
};
class JoinEniQosGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinEniQosGroupResponseBody> body{};

  JoinEniQosGroupResponse() {}

  explicit JoinEniQosGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinEniQosGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinEniQosGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinEniQosGroupResponse() = default;
};
class LeaveEniQosGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  LeaveEniQosGroupRequest() {}

  explicit LeaveEniQosGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~LeaveEniQosGroupRequest() = default;
};
class LeaveEniQosGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  LeaveEniQosGroupResponseBody() {}

  explicit LeaveEniQosGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LeaveEniQosGroupResponseBody() = default;
};
class LeaveEniQosGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LeaveEniQosGroupResponseBody> body{};

  LeaveEniQosGroupResponse() {}

  explicit LeaveEniQosGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LeaveEniQosGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LeaveEniQosGroupResponseBody>(model1);
      }
    }
  }


  virtual ~LeaveEniQosGroupResponse() = default;
};
class ListAccountEcsQuotasRequest : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> quotaResourceName{};
  shared_ptr<string> quotaResourceType{};
  shared_ptr<string> quotaUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sortField{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> zoneId{};

  ListAccountEcsQuotasRequest() {}

  explicit ListAccountEcsQuotasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (quotaResourceName) {
      res["QuotaResourceName"] = boost::any(*quotaResourceName);
    }
    if (quotaResourceType) {
      res["QuotaResourceType"] = boost::any(*quotaResourceType);
    }
    if (quotaUnit) {
      res["QuotaUnit"] = boost::any(*quotaUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sortField) {
      res["SortField"] = boost::any(*sortField);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QuotaResourceName") != m.end() && !m["QuotaResourceName"].empty()) {
      quotaResourceName = make_shared<string>(boost::any_cast<string>(m["QuotaResourceName"]));
    }
    if (m.find("QuotaResourceType") != m.end() && !m["QuotaResourceType"].empty()) {
      quotaResourceType = make_shared<string>(boost::any_cast<string>(m["QuotaResourceType"]));
    }
    if (m.find("QuotaUnit") != m.end() && !m["QuotaUnit"].empty()) {
      quotaUnit = make_shared<string>(boost::any_cast<string>(m["QuotaUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SortField") != m.end() && !m["SortField"].empty()) {
      sortField = make_shared<string>(boost::any_cast<string>(m["SortField"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListAccountEcsQuotasRequest() = default;
};
class ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota : public Darabonba::Model {
public:
  shared_ptr<string> applicationStatus{};
  shared_ptr<long> baseQuota{};
  shared_ptr<long> baseQuotaUsage{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> quotaResourceName{};
  shared_ptr<string> quotaResourceType{};
  shared_ptr<string> quotaUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<long> reservedQuota{};
  shared_ptr<long> reservedQuotaUsage{};
  shared_ptr<long> totalQuota{};
  shared_ptr<long> totalQuotaUsage{};
  shared_ptr<string> zoneId{};

  ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota() {}

  explicit ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationStatus) {
      res["ApplicationStatus"] = boost::any(*applicationStatus);
    }
    if (baseQuota) {
      res["BaseQuota"] = boost::any(*baseQuota);
    }
    if (baseQuotaUsage) {
      res["BaseQuotaUsage"] = boost::any(*baseQuotaUsage);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (quotaResourceName) {
      res["QuotaResourceName"] = boost::any(*quotaResourceName);
    }
    if (quotaResourceType) {
      res["QuotaResourceType"] = boost::any(*quotaResourceType);
    }
    if (quotaUnit) {
      res["QuotaUnit"] = boost::any(*quotaUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedQuota) {
      res["ReservedQuota"] = boost::any(*reservedQuota);
    }
    if (reservedQuotaUsage) {
      res["ReservedQuotaUsage"] = boost::any(*reservedQuotaUsage);
    }
    if (totalQuota) {
      res["TotalQuota"] = boost::any(*totalQuota);
    }
    if (totalQuotaUsage) {
      res["TotalQuotaUsage"] = boost::any(*totalQuotaUsage);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationStatus") != m.end() && !m["ApplicationStatus"].empty()) {
      applicationStatus = make_shared<string>(boost::any_cast<string>(m["ApplicationStatus"]));
    }
    if (m.find("BaseQuota") != m.end() && !m["BaseQuota"].empty()) {
      baseQuota = make_shared<long>(boost::any_cast<long>(m["BaseQuota"]));
    }
    if (m.find("BaseQuotaUsage") != m.end() && !m["BaseQuotaUsage"].empty()) {
      baseQuotaUsage = make_shared<long>(boost::any_cast<long>(m["BaseQuotaUsage"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("QuotaResourceName") != m.end() && !m["QuotaResourceName"].empty()) {
      quotaResourceName = make_shared<string>(boost::any_cast<string>(m["QuotaResourceName"]));
    }
    if (m.find("QuotaResourceType") != m.end() && !m["QuotaResourceType"].empty()) {
      quotaResourceType = make_shared<string>(boost::any_cast<string>(m["QuotaResourceType"]));
    }
    if (m.find("QuotaUnit") != m.end() && !m["QuotaUnit"].empty()) {
      quotaUnit = make_shared<string>(boost::any_cast<string>(m["QuotaUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedQuota") != m.end() && !m["ReservedQuota"].empty()) {
      reservedQuota = make_shared<long>(boost::any_cast<long>(m["ReservedQuota"]));
    }
    if (m.find("ReservedQuotaUsage") != m.end() && !m["ReservedQuotaUsage"].empty()) {
      reservedQuotaUsage = make_shared<long>(boost::any_cast<long>(m["ReservedQuotaUsage"]));
    }
    if (m.find("TotalQuota") != m.end() && !m["TotalQuota"].empty()) {
      totalQuota = make_shared<long>(boost::any_cast<long>(m["TotalQuota"]));
    }
    if (m.find("TotalQuotaUsage") != m.end() && !m["TotalQuotaUsage"].empty()) {
      totalQuotaUsage = make_shared<long>(boost::any_cast<long>(m["TotalQuotaUsage"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota() = default;
};
class ListAccountEcsQuotasResponseBodyEcsQuotas : public Darabonba::Model {
public:
  shared_ptr<vector<ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota>> ecsQuota{};

  ListAccountEcsQuotasResponseBodyEcsQuotas() {}

  explicit ListAccountEcsQuotasResponseBodyEcsQuotas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsQuota) {
      vector<boost::any> temp1;
      for(auto item1:*ecsQuota){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcsQuota"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsQuota") != m.end() && !m["EcsQuota"].empty()) {
      if (typeid(vector<boost::any>) == m["EcsQuota"].type()) {
        vector<ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcsQuota"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecsQuota = make_shared<vector<ListAccountEcsQuotasResponseBodyEcsQuotasEcsQuota>>(expect1);
      }
    }
  }


  virtual ~ListAccountEcsQuotasResponseBodyEcsQuotas() = default;
};
class ListAccountEcsQuotasResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAccountEcsQuotasResponseBodyEcsQuotas> ecsQuotas{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListAccountEcsQuotasResponseBody() {}

  explicit ListAccountEcsQuotasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsQuotas) {
      res["EcsQuotas"] = ecsQuotas ? boost::any(ecsQuotas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsQuotas") != m.end() && !m["EcsQuotas"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcsQuotas"].type()) {
        ListAccountEcsQuotasResponseBodyEcsQuotas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcsQuotas"]));
        ecsQuotas = make_shared<ListAccountEcsQuotasResponseBodyEcsQuotas>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAccountEcsQuotasResponseBody() = default;
};
class ListAccountEcsQuotasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAccountEcsQuotasResponseBody> body{};

  ListAccountEcsQuotasResponse() {}

  explicit ListAccountEcsQuotasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAccountEcsQuotasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAccountEcsQuotasResponseBody>(model1);
      }
    }
  }


  virtual ~ListAccountEcsQuotasResponse() = default;
};
class ListServiceSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cloudAssistantDeliverySettings{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListServiceSettingsRequest() {}

  explicit ListServiceSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudAssistantDeliverySettings) {
      res["CloudAssistantDeliverySettings"] = boost::any(*cloudAssistantDeliverySettings);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudAssistantDeliverySettings") != m.end() && !m["CloudAssistantDeliverySettings"].empty()) {
      cloudAssistantDeliverySettings = make_shared<bool>(boost::any_cast<bool>(m["CloudAssistantDeliverySettings"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListServiceSettingsRequest() = default;
};
class ListServiceSettingsResponseBodyCloudAssistantDeliverySettings : public Darabonba::Model {
public:
  shared_ptr<string> ossBucketName{};
  shared_ptr<bool> ossEnabled{};
  shared_ptr<string> ossKeyPrefix{};
  shared_ptr<bool> slsEnabled{};
  shared_ptr<string> slsLogstoreName{};
  shared_ptr<string> slsProjectName{};

  ListServiceSettingsResponseBodyCloudAssistantDeliverySettings() {}

  explicit ListServiceSettingsResponseBodyCloudAssistantDeliverySettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossBucketName) {
      res["OssBucketName"] = boost::any(*ossBucketName);
    }
    if (ossEnabled) {
      res["OssEnabled"] = boost::any(*ossEnabled);
    }
    if (ossKeyPrefix) {
      res["OssKeyPrefix"] = boost::any(*ossKeyPrefix);
    }
    if (slsEnabled) {
      res["SlsEnabled"] = boost::any(*slsEnabled);
    }
    if (slsLogstoreName) {
      res["SlsLogstoreName"] = boost::any(*slsLogstoreName);
    }
    if (slsProjectName) {
      res["SlsProjectName"] = boost::any(*slsProjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssBucketName") != m.end() && !m["OssBucketName"].empty()) {
      ossBucketName = make_shared<string>(boost::any_cast<string>(m["OssBucketName"]));
    }
    if (m.find("OssEnabled") != m.end() && !m["OssEnabled"].empty()) {
      ossEnabled = make_shared<bool>(boost::any_cast<bool>(m["OssEnabled"]));
    }
    if (m.find("OssKeyPrefix") != m.end() && !m["OssKeyPrefix"].empty()) {
      ossKeyPrefix = make_shared<string>(boost::any_cast<string>(m["OssKeyPrefix"]));
    }
    if (m.find("SlsEnabled") != m.end() && !m["SlsEnabled"].empty()) {
      slsEnabled = make_shared<bool>(boost::any_cast<bool>(m["SlsEnabled"]));
    }
    if (m.find("SlsLogstoreName") != m.end() && !m["SlsLogstoreName"].empty()) {
      slsLogstoreName = make_shared<string>(boost::any_cast<string>(m["SlsLogstoreName"]));
    }
    if (m.find("SlsProjectName") != m.end() && !m["SlsProjectName"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["SlsProjectName"]));
    }
  }


  virtual ~ListServiceSettingsResponseBodyCloudAssistantDeliverySettings() = default;
};
class ListServiceSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListServiceSettingsResponseBodyCloudAssistantDeliverySettings> cloudAssistantDeliverySettings{};
  shared_ptr<string> requestId{};

  ListServiceSettingsResponseBody() {}

  explicit ListServiceSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudAssistantDeliverySettings) {
      res["CloudAssistantDeliverySettings"] = cloudAssistantDeliverySettings ? boost::any(cloudAssistantDeliverySettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudAssistantDeliverySettings") != m.end() && !m["CloudAssistantDeliverySettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["CloudAssistantDeliverySettings"].type()) {
        ListServiceSettingsResponseBodyCloudAssistantDeliverySettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CloudAssistantDeliverySettings"]));
        cloudAssistantDeliverySettings = make_shared<ListServiceSettingsResponseBodyCloudAssistantDeliverySettings>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListServiceSettingsResponseBody() = default;
};
class ListServiceSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceSettingsResponseBody> body{};

  ListServiceSettingsResponse() {}

  explicit ListServiceSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceSettingsResponse() = default;
};
class ModifyCapacityReservationRequest : public Darabonba::Model {
public:
  shared_ptr<string> capacityReservationId{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> token{};

  ModifyCapacityReservationRequest() {}

  explicit ModifyCapacityReservationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservationId) {
      res["CapacityReservationId"] = boost::any(*capacityReservationId);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservationId") != m.end() && !m["CapacityReservationId"].empty()) {
      capacityReservationId = make_shared<string>(boost::any_cast<string>(m["CapacityReservationId"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ModifyCapacityReservationRequest() = default;
};
class ModifyCapacityReservationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCapacityReservationResponseBody() {}

  explicit ModifyCapacityReservationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCapacityReservationResponseBody() = default;
};
class ModifyCapacityReservationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCapacityReservationResponseBody> body{};

  ModifyCapacityReservationResponse() {}

  explicit ModifyCapacityReservationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCapacityReservationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCapacityReservationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCapacityReservationResponse() = default;
};
class ModifyDedicatedHostAttributeRequestNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<long> slbUdpTimeout{};
  shared_ptr<long> udpTimeout{};

  ModifyDedicatedHostAttributeRequestNetworkAttributes() {}

  explicit ModifyDedicatedHostAttributeRequestNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbUdpTimeout) {
      res["SlbUdpTimeout"] = boost::any(*slbUdpTimeout);
    }
    if (udpTimeout) {
      res["UdpTimeout"] = boost::any(*udpTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbUdpTimeout") != m.end() && !m["SlbUdpTimeout"].empty()) {
      slbUdpTimeout = make_shared<long>(boost::any_cast<long>(m["SlbUdpTimeout"]));
    }
    if (m.find("UdpTimeout") != m.end() && !m["UdpTimeout"].empty()) {
      udpTimeout = make_shared<long>(boost::any_cast<long>(m["UdpTimeout"]));
    }
  }


  virtual ~ModifyDedicatedHostAttributeRequestNetworkAttributes() = default;
};
class ModifyDedicatedHostAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyDedicatedHostAttributeRequestNetworkAttributes> networkAttributes{};
  shared_ptr<string> actionOnMaintenance{};
  shared_ptr<string> autoPlacement{};
  shared_ptr<double> cpuOverCommitRatio{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyDedicatedHostAttributeRequest() {}

  explicit ModifyDedicatedHostAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = boost::any(*actionOnMaintenance);
    }
    if (autoPlacement) {
      res["AutoPlacement"] = boost::any(*autoPlacement);
    }
    if (cpuOverCommitRatio) {
      res["CpuOverCommitRatio"] = boost::any(*cpuOverCommitRatio);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        ModifyDedicatedHostAttributeRequestNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<ModifyDedicatedHostAttributeRequestNetworkAttributes>(model1);
      }
    }
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      actionOnMaintenance = make_shared<string>(boost::any_cast<string>(m["ActionOnMaintenance"]));
    }
    if (m.find("AutoPlacement") != m.end() && !m["AutoPlacement"].empty()) {
      autoPlacement = make_shared<string>(boost::any_cast<string>(m["AutoPlacement"]));
    }
    if (m.find("CpuOverCommitRatio") != m.end() && !m["CpuOverCommitRatio"].empty()) {
      cpuOverCommitRatio = make_shared<double>(boost::any_cast<double>(m["CpuOverCommitRatio"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyDedicatedHostAttributeRequest() = default;
};
class ModifyDedicatedHostAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostAttributeResponseBody() {}

  explicit ModifyDedicatedHostAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostAttributeResponseBody() = default;
};
class ModifyDedicatedHostAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDedicatedHostAttributeResponseBody> body{};

  ModifyDedicatedHostAttributeResponse() {}

  explicit ModifyDedicatedHostAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostAttributeResponse() = default;
};
class ModifyDedicatedHostAutoReleaseTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyDedicatedHostAutoReleaseTimeRequest() {}

  explicit ModifyDedicatedHostAutoReleaseTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyDedicatedHostAutoReleaseTimeRequest() = default;
};
class ModifyDedicatedHostAutoReleaseTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostAutoReleaseTimeResponseBody() {}

  explicit ModifyDedicatedHostAutoReleaseTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostAutoReleaseTimeResponseBody() = default;
};
class ModifyDedicatedHostAutoReleaseTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDedicatedHostAutoReleaseTimeResponseBody> body{};

  ModifyDedicatedHostAutoReleaseTimeResponse() {}

  explicit ModifyDedicatedHostAutoReleaseTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostAutoReleaseTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostAutoReleaseTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostAutoReleaseTimeResponse() = default;
};
class ModifyDedicatedHostAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> duration{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> renewalStatus{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  ModifyDedicatedHostAutoRenewAttributeRequest() {}

  explicit ModifyDedicatedHostAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ModifyDedicatedHostAutoRenewAttributeRequest() = default;
};
class ModifyDedicatedHostAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostAutoRenewAttributeResponseBody() {}

  explicit ModifyDedicatedHostAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostAutoRenewAttributeResponseBody() = default;
};
class ModifyDedicatedHostAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDedicatedHostAutoRenewAttributeResponseBody> body{};

  ModifyDedicatedHostAutoRenewAttributeResponse() {}

  explicit ModifyDedicatedHostAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostAutoRenewAttributeResponse() = default;
};
class ModifyDedicatedHostClusterAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostClusterName{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyDedicatedHostClusterAttributeRequest() {}

  explicit ModifyDedicatedHostClusterAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostClusterName) {
      res["DedicatedHostClusterName"] = boost::any(*dedicatedHostClusterName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostClusterName") != m.end() && !m["DedicatedHostClusterName"].empty()) {
      dedicatedHostClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyDedicatedHostClusterAttributeRequest() = default;
};
class ModifyDedicatedHostClusterAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostClusterAttributeResponseBody() {}

  explicit ModifyDedicatedHostClusterAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostClusterAttributeResponseBody() = default;
};
class ModifyDedicatedHostClusterAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDedicatedHostClusterAttributeResponseBody> body{};

  ModifyDedicatedHostClusterAttributeResponse() {}

  explicit ModifyDedicatedHostClusterAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostClusterAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostClusterAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostClusterAttributeResponse() = default;
};
class ModifyDiagnoseRequest : public Darabonba::Model {
public:
  shared_ptr<string> diagnoseId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  ModifyDiagnoseRequest() {}

  explicit ModifyDiagnoseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyDiagnoseRequest() = default;
};
class ModifyDiagnoseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> data{};

  ModifyDiagnoseResponseBody() {}

  explicit ModifyDiagnoseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["data"]));
    }
  }


  virtual ~ModifyDiagnoseResponseBody() = default;
};
class ModifyDiagnoseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDiagnoseResponseBody> body{};

  ModifyDiagnoseResponse() {}

  explicit ModifyDiagnoseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDiagnoseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDiagnoseResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDiagnoseResponse() = default;
};
class ModifyDiskSpecRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> diskCategory{};
  shared_ptr<string> diskId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyDiskSpecRequest() {}

  explicit ModifyDiskSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (diskCategory) {
      res["DiskCategory"] = boost::any(*diskCategory);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("DiskCategory") != m.end() && !m["DiskCategory"].empty()) {
      diskCategory = make_shared<string>(boost::any_cast<string>(m["DiskCategory"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyDiskSpecRequest() = default;
};
class ModifyDiskSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyDiskSpecResponseBody() {}

  explicit ModifyDiskSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDiskSpecResponseBody() = default;
};
class ModifyDiskSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDiskSpecResponseBody> body{};

  ModifyDiskSpecResponse() {}

  explicit ModifyDiskSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDiskSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDiskSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDiskSpecResponse() = default;
};
class ModifyEniQosGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosGroupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> rx{};
  shared_ptr<long> rxPps{};
  shared_ptr<long> tx{};
  shared_ptr<long> txPps{};

  ModifyEniQosGroupRequest() {}

  explicit ModifyEniQosGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosGroupName) {
      res["QosGroupName"] = boost::any(*qosGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (rx) {
      res["Rx"] = boost::any(*rx);
    }
    if (rxPps) {
      res["RxPps"] = boost::any(*rxPps);
    }
    if (tx) {
      res["Tx"] = boost::any(*tx);
    }
    if (txPps) {
      res["TxPps"] = boost::any(*txPps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosGroupName") != m.end() && !m["QosGroupName"].empty()) {
      qosGroupName = make_shared<string>(boost::any_cast<string>(m["QosGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Rx") != m.end() && !m["Rx"].empty()) {
      rx = make_shared<long>(boost::any_cast<long>(m["Rx"]));
    }
    if (m.find("RxPps") != m.end() && !m["RxPps"].empty()) {
      rxPps = make_shared<long>(boost::any_cast<long>(m["RxPps"]));
    }
    if (m.find("Tx") != m.end() && !m["Tx"].empty()) {
      tx = make_shared<long>(boost::any_cast<long>(m["Tx"]));
    }
    if (m.find("TxPps") != m.end() && !m["TxPps"].empty()) {
      txPps = make_shared<long>(boost::any_cast<long>(m["TxPps"]));
    }
  }


  virtual ~ModifyEniQosGroupRequest() = default;
};
class ModifyEniQosGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEniQosGroupResponseBody() {}

  explicit ModifyEniQosGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEniQosGroupResponseBody() = default;
};
class ModifyEniQosGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEniQosGroupResponseBody> body{};

  ModifyEniQosGroupResponse() {}

  explicit ModifyEniQosGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEniQosGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEniQosGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEniQosGroupResponse() = default;
};
class ModifyImageAdvancedAttributeRequestFlag : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<bool> value{};

  ModifyImageAdvancedAttributeRequestFlag() {}

  explicit ModifyImageAdvancedAttributeRequestFlag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<bool>(boost::any_cast<bool>(m["Value"]));
    }
  }


  virtual ~ModifyImageAdvancedAttributeRequestFlag() = default;
};
class ModifyImageAdvancedAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyImageAdvancedAttributeRequestFlag>> flag{};
  shared_ptr<string> imageId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> supportIoOptimized{};

  ModifyImageAdvancedAttributeRequest() {}

  explicit ModifyImageAdvancedAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      vector<boost::any> temp1;
      for(auto item1:*flag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Flag"] = boost::any(temp1);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (supportIoOptimized) {
      res["SupportIoOptimized"] = boost::any(*supportIoOptimized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      if (typeid(vector<boost::any>) == m["Flag"].type()) {
        vector<ModifyImageAdvancedAttributeRequestFlag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Flag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyImageAdvancedAttributeRequestFlag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flag = make_shared<vector<ModifyImageAdvancedAttributeRequestFlag>>(expect1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SupportIoOptimized") != m.end() && !m["SupportIoOptimized"].empty()) {
      supportIoOptimized = make_shared<string>(boost::any_cast<string>(m["SupportIoOptimized"]));
    }
  }


  virtual ~ModifyImageAdvancedAttributeRequest() = default;
};
class ModifyImageAdvancedAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyImageAdvancedAttributeResponseBody() {}

  explicit ModifyImageAdvancedAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageAdvancedAttributeResponseBody() = default;
};
class ModifyImageAdvancedAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyImageAdvancedAttributeResponseBody> body{};

  ModifyImageAdvancedAttributeResponse() {}

  explicit ModifyImageAdvancedAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageAdvancedAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageAdvancedAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageAdvancedAttributeResponse() = default;
};
class ModifyInstanceAutoRebootTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoRebootTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyInstanceAutoRebootTimeRequest() {}

  explicit ModifyInstanceAutoRebootTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRebootTime) {
      res["AutoRebootTime"] = boost::any(*autoRebootTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRebootTime") != m.end() && !m["AutoRebootTime"].empty()) {
      autoRebootTime = make_shared<string>(boost::any_cast<string>(m["AutoRebootTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyInstanceAutoRebootTimeRequest() = default;
};
class ModifyInstanceAutoRebootTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAutoRebootTimeResponseBody() {}

  explicit ModifyInstanceAutoRebootTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAutoRebootTimeResponseBody() = default;
};
class ModifyInstanceAutoRebootTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceAutoRebootTimeResponseBody> body{};

  ModifyInstanceAutoRebootTimeResponse() {}

  explicit ModifyInstanceAutoRebootTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAutoRebootTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAutoRebootTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAutoRebootTimeResponse() = default;
};
class ModifyInstanceCapacityReservationAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> capacityReservationId{};
  shared_ptr<string> capacityReservationPreference{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyInstanceCapacityReservationAttributesRequest() {}

  explicit ModifyInstanceCapacityReservationAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservationId) {
      res["CapacityReservationId"] = boost::any(*capacityReservationId);
    }
    if (capacityReservationPreference) {
      res["CapacityReservationPreference"] = boost::any(*capacityReservationPreference);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservationId") != m.end() && !m["CapacityReservationId"].empty()) {
      capacityReservationId = make_shared<string>(boost::any_cast<string>(m["CapacityReservationId"]));
    }
    if (m.find("CapacityReservationPreference") != m.end() && !m["CapacityReservationPreference"].empty()) {
      capacityReservationPreference = make_shared<string>(boost::any_cast<string>(m["CapacityReservationPreference"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyInstanceCapacityReservationAttributesRequest() = default;
};
class ModifyInstanceCapacityReservationAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceCapacityReservationAttributesResponseBody() {}

  explicit ModifyInstanceCapacityReservationAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceCapacityReservationAttributesResponseBody() = default;
};
class ModifyInstanceCapacityReservationAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceCapacityReservationAttributesResponseBody> body{};

  ModifyInstanceCapacityReservationAttributesResponse() {}

  explicit ModifyInstanceCapacityReservationAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceCapacityReservationAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceCapacityReservationAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceCapacityReservationAttributesResponse() = default;
};
class ModifyInstanceChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> couponNo{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> includeDataDisks{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceIds{};
  shared_ptr<bool> isDetailFee{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyInstanceChargeTypeRequest() {}

  explicit ModifyInstanceChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (couponNo) {
      res["CouponNo"] = boost::any(*couponNo);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (includeDataDisks) {
      res["IncludeDataDisks"] = boost::any(*includeDataDisks);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (isDetailFee) {
      res["IsDetailFee"] = boost::any(*isDetailFee);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CouponNo") != m.end() && !m["CouponNo"].empty()) {
      couponNo = make_shared<string>(boost::any_cast<string>(m["CouponNo"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("IncludeDataDisks") != m.end() && !m["IncludeDataDisks"].empty()) {
      includeDataDisks = make_shared<bool>(boost::any_cast<bool>(m["IncludeDataDisks"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("IsDetailFee") != m.end() && !m["IsDetailFee"].empty()) {
      isDetailFee = make_shared<bool>(boost::any_cast<bool>(m["IsDetailFee"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyInstanceChargeTypeRequest() = default;
};
class ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<string> fee{};
  shared_ptr<string> instanceId{};

  ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance() {}

  explicit ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (fee) {
      res["Fee"] = boost::any(*fee);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("Fee") != m.end() && !m["Fee"].empty()) {
      fee = make_shared<string>(boost::any_cast<string>(m["Fee"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance() = default;
};
class ModifyInstanceChargeTypeResponseBodyFeeOfInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance>> feeOfInstance{};

  ModifyInstanceChargeTypeResponseBodyFeeOfInstances() {}

  explicit ModifyInstanceChargeTypeResponseBodyFeeOfInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeOfInstance) {
      vector<boost::any> temp1;
      for(auto item1:*feeOfInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FeeOfInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeeOfInstance") != m.end() && !m["FeeOfInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["FeeOfInstance"].type()) {
        vector<ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FeeOfInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        feeOfInstance = make_shared<vector<ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance>>(expect1);
      }
    }
  }


  virtual ~ModifyInstanceChargeTypeResponseBodyFeeOfInstances() = default;
};
class ModifyInstanceChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyInstanceChargeTypeResponseBodyFeeOfInstances> feeOfInstances{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyInstanceChargeTypeResponseBody() {}

  explicit ModifyInstanceChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeOfInstances) {
      res["FeeOfInstances"] = feeOfInstances ? boost::any(feeOfInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeeOfInstances") != m.end() && !m["FeeOfInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["FeeOfInstances"].type()) {
        ModifyInstanceChargeTypeResponseBodyFeeOfInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FeeOfInstances"]));
        feeOfInstances = make_shared<ModifyInstanceChargeTypeResponseBodyFeeOfInstances>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceChargeTypeResponseBody() = default;
};
class ModifyInstanceChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceChargeTypeResponseBody> body{};

  ModifyInstanceChargeTypeResponse() {}

  explicit ModifyInstanceChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceChargeTypeResponse() = default;
};
class ModifyInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> affinity{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> migrationType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tenancy{};

  ModifyInstanceDeploymentRequest() {}

  explicit ModifyInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (migrationType) {
      res["MigrationType"] = boost::any(*migrationType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MigrationType") != m.end() && !m["MigrationType"].empty()) {
      migrationType = make_shared<string>(boost::any_cast<string>(m["MigrationType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
  }


  virtual ~ModifyInstanceDeploymentRequest() = default;
};
class ModifyInstanceDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceDeploymentResponseBody() {}

  explicit ModifyInstanceDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceDeploymentResponseBody() = default;
};
class ModifyInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceDeploymentResponseBody> body{};

  ModifyInstanceDeploymentResponse() {}

  explicit ModifyInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceDeploymentResponse() = default;
};
class ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow() {}

  explicit ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow() = default;
};
class ModifyInstanceMaintenanceAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionOnMaintenance{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<bool> liveMigration{};
  shared_ptr<vector<ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow>> maintenanceWindow{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyInstanceMaintenanceAttributesRequest() {}

  explicit ModifyInstanceMaintenanceAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionOnMaintenance) {
      res["ActionOnMaintenance"] = boost::any(*actionOnMaintenance);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (liveMigration) {
      res["LiveMigration"] = boost::any(*liveMigration);
    }
    if (maintenanceWindow) {
      vector<boost::any> temp1;
      for(auto item1:*maintenanceWindow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MaintenanceWindow"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionOnMaintenance") != m.end() && !m["ActionOnMaintenance"].empty()) {
      actionOnMaintenance = make_shared<string>(boost::any_cast<string>(m["ActionOnMaintenance"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LiveMigration") != m.end() && !m["LiveMigration"].empty()) {
      liveMigration = make_shared<bool>(boost::any_cast<bool>(m["LiveMigration"]));
    }
    if (m.find("MaintenanceWindow") != m.end() && !m["MaintenanceWindow"].empty()) {
      if (typeid(vector<boost::any>) == m["MaintenanceWindow"].type()) {
        vector<ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MaintenanceWindow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        maintenanceWindow = make_shared<vector<ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyInstanceMaintenanceAttributesRequest() = default;
};
class ModifyInstanceMaintenanceAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceMaintenanceAttributesResponseBody() {}

  explicit ModifyInstanceMaintenanceAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceMaintenanceAttributesResponseBody() = default;
};
class ModifyInstanceMaintenanceAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceMaintenanceAttributesResponseBody> body{};

  ModifyInstanceMaintenanceAttributesResponse() {}

  explicit ModifyInstanceMaintenanceAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceMaintenanceAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceMaintenanceAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceMaintenanceAttributesResponse() = default;
};
class ModifyMigratableInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> businessMigrationType{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<long> networkMigrationType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  ModifyMigratableInstancesRequest() {}

  explicit ModifyMigratableInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessMigrationType) {
      res["BusinessMigrationType"] = boost::any(*businessMigrationType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkMigrationType) {
      res["NetworkMigrationType"] = boost::any(*networkMigrationType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessMigrationType") != m.end() && !m["BusinessMigrationType"].empty()) {
      businessMigrationType = make_shared<long>(boost::any_cast<long>(m["BusinessMigrationType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkMigrationType") != m.end() && !m["NetworkMigrationType"].empty()) {
      networkMigrationType = make_shared<long>(boost::any_cast<long>(m["NetworkMigrationType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ModifyMigratableInstancesRequest() = default;
};
class ModifyMigratableInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyMigratableInstancesResponseBody() {}

  explicit ModifyMigratableInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyMigratableInstancesResponseBody() = default;
};
class ModifyMigratableInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMigratableInstancesResponseBody> body{};

  ModifyMigratableInstancesResponse() {}

  explicit ModifyMigratableInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMigratableInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMigratableInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMigratableInstancesResponse() = default;
};
class ModifyMigrationInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalMigrationTime{};
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> networkMigrationType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyMigrationInstancesRequest() {}

  explicit ModifyMigrationInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalMigrationTime) {
      res["GlobalMigrationTime"] = boost::any(*globalMigrationTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkMigrationType) {
      res["NetworkMigrationType"] = boost::any(*networkMigrationType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalMigrationTime") != m.end() && !m["GlobalMigrationTime"].empty()) {
      globalMigrationTime = make_shared<string>(boost::any_cast<string>(m["GlobalMigrationTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkMigrationType") != m.end() && !m["NetworkMigrationType"].empty()) {
      networkMigrationType = make_shared<string>(boost::any_cast<string>(m["NetworkMigrationType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyMigrationInstancesRequest() = default;
};
class ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};

  ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel() {}

  explicit ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel() = default;
};
class ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel>> failModel{};

  ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels() {}

  explicit ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failModel) {
      vector<boost::any> temp1;
      for(auto item1:*failModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailModel") != m.end() && !m["FailModel"].empty()) {
      if (typeid(vector<boost::any>) == m["FailModel"].type()) {
        vector<ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failModel = make_shared<vector<ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModelsFailModel>>(expect1);
      }
    }
  }


  virtual ~ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels() = default;
};
class ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel : public Darabonba::Model {
public:
  shared_ptr<ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels> failModels{};
  shared_ptr<string> instanceId{};

  ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel() {}

  explicit ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failModels) {
      res["FailModels"] = failModels ? boost::any(failModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailModels") != m.end() && !m["FailModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailModels"].type()) {
        ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailModels"]));
        failModels = make_shared<ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModelFailModels>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel() = default;
};
class ModifyMigrationInstancesResponseBodyInstancesFailModels : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel>> instancesFailModel{};

  ModifyMigrationInstancesResponseBodyInstancesFailModels() {}

  explicit ModifyMigrationInstancesResponseBodyInstancesFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancesFailModel) {
      vector<boost::any> temp1;
      for(auto item1:*instancesFailModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstancesFailModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstancesFailModel") != m.end() && !m["InstancesFailModel"].empty()) {
      if (typeid(vector<boost::any>) == m["InstancesFailModel"].type()) {
        vector<ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstancesFailModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancesFailModel = make_shared<vector<ModifyMigrationInstancesResponseBodyInstancesFailModelsInstancesFailModel>>(expect1);
      }
    }
  }


  virtual ~ModifyMigrationInstancesResponseBodyInstancesFailModels() = default;
};
class ModifyMigrationInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyMigrationInstancesResponseBodyInstancesFailModels> instancesFailModels{};
  shared_ptr<string> requestId{};

  ModifyMigrationInstancesResponseBody() {}

  explicit ModifyMigrationInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancesFailModels) {
      res["InstancesFailModels"] = instancesFailModels ? boost::any(instancesFailModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstancesFailModels") != m.end() && !m["InstancesFailModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstancesFailModels"].type()) {
        ModifyMigrationInstancesResponseBodyInstancesFailModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstancesFailModels"]));
        instancesFailModels = make_shared<ModifyMigrationInstancesResponseBodyInstancesFailModels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyMigrationInstancesResponseBody() = default;
};
class ModifyMigrationInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMigrationInstancesResponseBody> body{};

  ModifyMigrationInstancesResponse() {}

  explicit ModifyMigrationInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMigrationInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMigrationInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMigrationInstancesResponse() = default;
};
class ModifyMigrationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> migrationPlanId{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyMigrationPlanRequest() {}

  explicit ModifyMigrationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationPlanId) {
      res["MigrationPlanId"] = boost::any(*migrationPlanId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationPlanId") != m.end() && !m["MigrationPlanId"].empty()) {
      migrationPlanId = make_shared<string>(boost::any_cast<string>(m["MigrationPlanId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyMigrationPlanRequest() = default;
};
class ModifyMigrationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyMigrationPlanResponseBody() {}

  explicit ModifyMigrationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyMigrationPlanResponseBody() = default;
};
class ModifyMigrationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMigrationPlanResponseBody> body{};

  ModifyMigrationPlanResponse() {}

  explicit ModifyMigrationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMigrationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMigrationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMigrationPlanResponse() = default;
};
class ModifyOrderAutoRebootTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoRebootTime{};
  shared_ptr<long> orderId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyOrderAutoRebootTimeRequest() {}

  explicit ModifyOrderAutoRebootTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRebootTime) {
      res["AutoRebootTime"] = boost::any(*autoRebootTime);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRebootTime") != m.end() && !m["AutoRebootTime"].empty()) {
      autoRebootTime = make_shared<string>(boost::any_cast<string>(m["AutoRebootTime"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyOrderAutoRebootTimeRequest() = default;
};
class ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo : public Darabonba::Model {
public:
  shared_ptr<string> autoRebootTime{};
  shared_ptr<long> orderId{};

  ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo() {}

  explicit ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRebootTime) {
      res["AutoRebootTime"] = boost::any(*autoRebootTime);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRebootTime") != m.end() && !m["AutoRebootTime"].empty()) {
      autoRebootTime = make_shared<string>(boost::any_cast<string>(m["AutoRebootTime"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
  }


  virtual ~ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo() = default;
};
class ModifyOrderAutoRebootTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo> modifyOrderAutoRebootTimeInfo{};
  shared_ptr<string> requestId{};

  ModifyOrderAutoRebootTimeResponseBody() {}

  explicit ModifyOrderAutoRebootTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifyOrderAutoRebootTimeInfo) {
      res["ModifyOrderAutoRebootTimeInfo"] = modifyOrderAutoRebootTimeInfo ? boost::any(modifyOrderAutoRebootTimeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModifyOrderAutoRebootTimeInfo") != m.end() && !m["ModifyOrderAutoRebootTimeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModifyOrderAutoRebootTimeInfo"].type()) {
        ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModifyOrderAutoRebootTimeInfo"]));
        modifyOrderAutoRebootTimeInfo = make_shared<ModifyOrderAutoRebootTimeResponseBodyModifyOrderAutoRebootTimeInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOrderAutoRebootTimeResponseBody() = default;
};
class ModifyOrderAutoRebootTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOrderAutoRebootTimeResponseBody> body{};

  ModifyOrderAutoRebootTimeResponse() {}

  explicit ModifyOrderAutoRebootTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOrderAutoRebootTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOrderAutoRebootTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOrderAutoRebootTimeResponse() = default;
};
class ModifyPrivatePoolRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ModifyPrivatePoolRequestPrivatePoolOptions() {}

  explicit ModifyPrivatePoolRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyPrivatePoolRequestPrivatePoolOptions() = default;
};
class ModifyPrivatePoolRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyPrivatePoolRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> endTimeType{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> platform{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startTime{};

  ModifyPrivatePoolRequest() {}

  explicit ModifyPrivatePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimeType) {
      res["EndTimeType"] = boost::any(*endTimeType);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        ModifyPrivatePoolRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<ModifyPrivatePoolRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndTimeType") != m.end() && !m["EndTimeType"].empty()) {
      endTimeType = make_shared<string>(boost::any_cast<string>(m["EndTimeType"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ModifyPrivatePoolRequest() = default;
};
class ModifyPrivatePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPrivatePoolResponseBody() {}

  explicit ModifyPrivatePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPrivatePoolResponseBody() = default;
};
class ModifyPrivatePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPrivatePoolResponseBody> body{};

  ModifyPrivatePoolResponse() {}

  explicit ModifyPrivatePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPrivatePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPrivatePoolResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPrivatePoolResponse() = default;
};
class ModifyReservationDemandRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> planId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> zoneId{};

  ModifyReservationDemandRequestPrivatePoolOptions() {}

  explicit ModifyReservationDemandRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (planId) {
      res["PlanId"] = boost::any(*planId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("PlanId") != m.end() && !m["PlanId"].empty()) {
      planId = make_shared<string>(boost::any_cast<string>(m["PlanId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ModifyReservationDemandRequestPrivatePoolOptions() = default;
};
class ModifyReservationDemandRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyReservationDemandRequestTag() {}

  explicit ModifyReservationDemandRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyReservationDemandRequestTag() = default;
};
class ModifyReservationDemandRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> confirmType{};
  shared_ptr<bool> couponAuto{};
  shared_ptr<string> couponType{};
  shared_ptr<string> demandId{};
  shared_ptr<string> description{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<long> instanceCpuCoreCount{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> instanceTypes{};
  shared_ptr<string> matchCriteria{};
  shared_ptr<string> name{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> platform{};
  shared_ptr<vector<ModifyReservationDemandRequestPrivatePoolOptions>> privatePoolOptions{};
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservedInstanceDescription{};
  shared_ptr<string> reservedInstanceGroupId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> reservedInstanceOfferingType{};
  shared_ptr<string> reservedInstanceScope{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceSupplyType{};
  shared_ptr<string> savingPlanDescription{};
  shared_ptr<double> savingPlanHourFee{};
  shared_ptr<string> savingPlanId{};
  shared_ptr<string> savingPlanInstanceTypeFamilyGroup{};
  shared_ptr<string> savingPlanName{};
  shared_ptr<string> savingPlanPayMode{};
  shared_ptr<string> savingPlanSavingType{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<ModifyReservationDemandRequestTag>> tag{};
  shared_ptr<string> zoneIds{};

  ModifyReservationDemandRequest() {}

  explicit ModifyReservationDemandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (confirmType) {
      res["ConfirmType"] = boost::any(*confirmType);
    }
    if (couponAuto) {
      res["CouponAuto"] = boost::any(*couponAuto);
    }
    if (couponType) {
      res["CouponType"] = boost::any(*couponType);
    }
    if (demandId) {
      res["DemandId"] = boost::any(*demandId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceCpuCoreCount) {
      res["InstanceCpuCoreCount"] = boost::any(*instanceCpuCoreCount);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (privatePoolOptions) {
      vector<boost::any> temp1;
      for(auto item1:*privatePoolOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivatePoolOptions"] = boost::any(temp1);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceDescription) {
      res["ReservedInstanceDescription"] = boost::any(*reservedInstanceDescription);
    }
    if (reservedInstanceGroupId) {
      res["ReservedInstanceGroupId"] = boost::any(*reservedInstanceGroupId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (reservedInstanceOfferingType) {
      res["ReservedInstanceOfferingType"] = boost::any(*reservedInstanceOfferingType);
    }
    if (reservedInstanceScope) {
      res["ReservedInstanceScope"] = boost::any(*reservedInstanceScope);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceSupplyType) {
      res["ResourceSupplyType"] = boost::any(*resourceSupplyType);
    }
    if (savingPlanDescription) {
      res["SavingPlanDescription"] = boost::any(*savingPlanDescription);
    }
    if (savingPlanHourFee) {
      res["SavingPlanHourFee"] = boost::any(*savingPlanHourFee);
    }
    if (savingPlanId) {
      res["SavingPlanId"] = boost::any(*savingPlanId);
    }
    if (savingPlanInstanceTypeFamilyGroup) {
      res["SavingPlanInstanceTypeFamilyGroup"] = boost::any(*savingPlanInstanceTypeFamilyGroup);
    }
    if (savingPlanName) {
      res["SavingPlanName"] = boost::any(*savingPlanName);
    }
    if (savingPlanPayMode) {
      res["SavingPlanPayMode"] = boost::any(*savingPlanPayMode);
    }
    if (savingPlanSavingType) {
      res["SavingPlanSavingType"] = boost::any(*savingPlanSavingType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneIds) {
      res["ZoneIds"] = boost::any(*zoneIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfirmType") != m.end() && !m["ConfirmType"].empty()) {
      confirmType = make_shared<string>(boost::any_cast<string>(m["ConfirmType"]));
    }
    if (m.find("CouponAuto") != m.end() && !m["CouponAuto"].empty()) {
      couponAuto = make_shared<bool>(boost::any_cast<bool>(m["CouponAuto"]));
    }
    if (m.find("CouponType") != m.end() && !m["CouponType"].empty()) {
      couponType = make_shared<string>(boost::any_cast<string>(m["CouponType"]));
    }
    if (m.find("DemandId") != m.end() && !m["DemandId"].empty()) {
      demandId = make_shared<string>(boost::any_cast<string>(m["DemandId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceCpuCoreCount") != m.end() && !m["InstanceCpuCoreCount"].empty()) {
      instanceCpuCoreCount = make_shared<long>(boost::any_cast<long>(m["InstanceCpuCoreCount"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      instanceTypes = make_shared<string>(boost::any_cast<string>(m["InstanceTypes"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivatePoolOptions"].type()) {
        vector<ModifyReservationDemandRequestPrivatePoolOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivatePoolOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyReservationDemandRequestPrivatePoolOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privatePoolOptions = make_shared<vector<ModifyReservationDemandRequestPrivatePoolOptions>>(expect1);
      }
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceDescription") != m.end() && !m["ReservedInstanceDescription"].empty()) {
      reservedInstanceDescription = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceDescription"]));
    }
    if (m.find("ReservedInstanceGroupId") != m.end() && !m["ReservedInstanceGroupId"].empty()) {
      reservedInstanceGroupId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceGroupId"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ReservedInstanceOfferingType") != m.end() && !m["ReservedInstanceOfferingType"].empty()) {
      reservedInstanceOfferingType = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceOfferingType"]));
    }
    if (m.find("ReservedInstanceScope") != m.end() && !m["ReservedInstanceScope"].empty()) {
      reservedInstanceScope = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceScope"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceSupplyType") != m.end() && !m["ResourceSupplyType"].empty()) {
      resourceSupplyType = make_shared<string>(boost::any_cast<string>(m["ResourceSupplyType"]));
    }
    if (m.find("SavingPlanDescription") != m.end() && !m["SavingPlanDescription"].empty()) {
      savingPlanDescription = make_shared<string>(boost::any_cast<string>(m["SavingPlanDescription"]));
    }
    if (m.find("SavingPlanHourFee") != m.end() && !m["SavingPlanHourFee"].empty()) {
      savingPlanHourFee = make_shared<double>(boost::any_cast<double>(m["SavingPlanHourFee"]));
    }
    if (m.find("SavingPlanId") != m.end() && !m["SavingPlanId"].empty()) {
      savingPlanId = make_shared<string>(boost::any_cast<string>(m["SavingPlanId"]));
    }
    if (m.find("SavingPlanInstanceTypeFamilyGroup") != m.end() && !m["SavingPlanInstanceTypeFamilyGroup"].empty()) {
      savingPlanInstanceTypeFamilyGroup = make_shared<string>(boost::any_cast<string>(m["SavingPlanInstanceTypeFamilyGroup"]));
    }
    if (m.find("SavingPlanName") != m.end() && !m["SavingPlanName"].empty()) {
      savingPlanName = make_shared<string>(boost::any_cast<string>(m["SavingPlanName"]));
    }
    if (m.find("SavingPlanPayMode") != m.end() && !m["SavingPlanPayMode"].empty()) {
      savingPlanPayMode = make_shared<string>(boost::any_cast<string>(m["SavingPlanPayMode"]));
    }
    if (m.find("SavingPlanSavingType") != m.end() && !m["SavingPlanSavingType"].empty()) {
      savingPlanSavingType = make_shared<string>(boost::any_cast<string>(m["SavingPlanSavingType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyReservationDemandRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyReservationDemandRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyReservationDemandRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneIds") != m.end() && !m["ZoneIds"].empty()) {
      zoneIds = make_shared<string>(boost::any_cast<string>(m["ZoneIds"]));
    }
  }


  virtual ~ModifyReservationDemandRequest() = default;
};
class ModifyReservationDemandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyReservationDemandResponseBody() {}

  explicit ModifyReservationDemandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyReservationDemandResponseBody() = default;
};
class ModifyReservationDemandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyReservationDemandResponseBody> body{};

  ModifyReservationDemandResponse() {}

  explicit ModifyReservationDemandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyReservationDemandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyReservationDemandResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyReservationDemandResponse() = default;
};
class ModifyReservedInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservedInstanceId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyReservedInstanceAttributeRequest() {}

  explicit ModifyReservedInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      reservedInstanceId = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceId"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyReservedInstanceAttributeRequest() = default;
};
class ModifyReservedInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyReservedInstanceAttributeResponseBody() {}

  explicit ModifyReservedInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyReservedInstanceAttributeResponseBody() = default;
};
class ModifyReservedInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyReservedInstanceAttributeResponseBody> body{};

  ModifyReservedInstanceAttributeResponse() {}

  explicit ModifyReservedInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyReservedInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyReservedInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyReservedInstanceAttributeResponse() = default;
};
class ModifyReservedInstancesRequestConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> scope{};
  shared_ptr<string> zoneId{};

  ModifyReservedInstancesRequestConfiguration() {}

  explicit ModifyReservedInstancesRequestConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ModifyReservedInstancesRequestConfiguration() = default;
};
class ModifyReservedInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyReservedInstancesRequestTag() {}

  explicit ModifyReservedInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyReservedInstancesRequestTag() = default;
};
class ModifyReservedInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyReservedInstancesRequestConfiguration>> configuration{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> reservedInstanceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ModifyReservedInstancesRequestTag>> tag{};

  ModifyReservedInstancesRequest() {}

  explicit ModifyReservedInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      vector<boost::any> temp1;
      for(auto item1:*configuration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configuration"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(vector<boost::any>) == m["Configuration"].type()) {
        vector<ModifyReservedInstancesRequestConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configuration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyReservedInstancesRequestConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configuration = make_shared<vector<ModifyReservedInstancesRequestConfiguration>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyReservedInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyReservedInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyReservedInstancesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ModifyReservedInstancesRequest() = default;
};
class ModifyReservedInstancesResponseBodyReservedInstanceIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> reservedInstanceId{};

  ModifyReservedInstancesResponseBodyReservedInstanceIdSets() {}

  explicit ModifyReservedInstancesResponseBodyReservedInstanceIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyReservedInstancesResponseBodyReservedInstanceIdSets() = default;
};
class ModifyReservedInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifyReservedInstancesResponseBodyReservedInstanceIdSets> reservedInstanceIdSets{};

  ModifyReservedInstancesResponseBody() {}

  explicit ModifyReservedInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservedInstanceIdSets) {
      res["ReservedInstanceIdSets"] = reservedInstanceIdSets ? boost::any(reservedInstanceIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservedInstanceIdSets") != m.end() && !m["ReservedInstanceIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservedInstanceIdSets"].type()) {
        ModifyReservedInstancesResponseBodyReservedInstanceIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservedInstanceIdSets"]));
        reservedInstanceIdSets = make_shared<ModifyReservedInstancesResponseBodyReservedInstanceIdSets>(model1);
      }
    }
  }


  virtual ~ModifyReservedInstancesResponseBody() = default;
};
class ModifyReservedInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyReservedInstancesResponseBody> body{};

  ModifyReservedInstancesResponse() {}

  explicit ModifyReservedInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyReservedInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyReservedInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyReservedInstancesResponse() = default;
};
class ModifyResourceDiagnosisStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> diagnosisStatus{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  ModifyResourceDiagnosisStatusRequest() {}

  explicit ModifyResourceDiagnosisStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnosisStatus) {
      res["DiagnosisStatus"] = boost::any(*diagnosisStatus);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnosisStatus") != m.end() && !m["DiagnosisStatus"].empty()) {
      diagnosisStatus = make_shared<string>(boost::any_cast<string>(m["DiagnosisStatus"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ModifyResourceDiagnosisStatusRequest() = default;
};
class ModifyResourceDiagnosisStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyResourceDiagnosisStatusResponseBody() {}

  explicit ModifyResourceDiagnosisStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyResourceDiagnosisStatusResponseBody() = default;
};
class ModifyResourceDiagnosisStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyResourceDiagnosisStatusResponseBody> body{};

  ModifyResourceDiagnosisStatusResponse() {}

  explicit ModifyResourceDiagnosisStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyResourceDiagnosisStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyResourceDiagnosisStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyResourceDiagnosisStatusResponse() = default;
};
class ModifyResourceMetaRequestMeta : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyResourceMetaRequestMeta() {}

  explicit ModifyResourceMetaRequestMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ModifyResourceMetaRequestMeta() = default;
};
class ModifyResourceMetaRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyResourceMetaRequestMeta>> meta{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  ModifyResourceMetaRequest() {}

  explicit ModifyResourceMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      vector<boost::any> temp1;
      for(auto item1:*meta){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Meta"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      if (typeid(vector<boost::any>) == m["Meta"].type()) {
        vector<ModifyResourceMetaRequestMeta> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Meta"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyResourceMetaRequestMeta model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meta = make_shared<vector<ModifyResourceMetaRequestMeta>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ModifyResourceMetaRequest() = default;
};
class ModifyResourceMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyResourceMetaResponseBody() {}

  explicit ModifyResourceMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyResourceMetaResponseBody() = default;
};
class ModifyResourceMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyResourceMetaResponseBody> body{};

  ModifyResourceMetaResponse() {}

  explicit ModifyResourceMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyResourceMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyResourceMetaResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyResourceMetaResponse() = default;
};
class ModifyStorageSetAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> storageSetId{};
  shared_ptr<string> storageSetName{};

  ModifyStorageSetAttributeRequest() {}

  explicit ModifyStorageSetAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetName) {
      res["StorageSetName"] = boost::any(*storageSetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetName") != m.end() && !m["StorageSetName"].empty()) {
      storageSetName = make_shared<string>(boost::any_cast<string>(m["StorageSetName"]));
    }
  }


  virtual ~ModifyStorageSetAttributeRequest() = default;
};
class ModifyStorageSetAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStorageSetAttributeResponseBody() {}

  explicit ModifyStorageSetAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStorageSetAttributeResponseBody() = default;
};
class ModifyStorageSetAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyStorageSetAttributeResponseBody> body{};

  ModifyStorageSetAttributeResponse() {}

  explicit ModifyStorageSetAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStorageSetAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStorageSetAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStorageSetAttributeResponse() = default;
};
class ModifyWaitingOrderRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyWaitingOrderRequestTag() {}

  explicit ModifyWaitingOrderRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyWaitingOrderRequestTag() = default;
};
class ModifyWaitingOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ModifyWaitingOrderRequestTag>> tag{};
  shared_ptr<string> waitingOrderId{};

  ModifyWaitingOrderRequest() {}

  explicit ModifyWaitingOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (waitingOrderId) {
      res["WaitingOrderId"] = boost::any(*waitingOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyWaitingOrderRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyWaitingOrderRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyWaitingOrderRequestTag>>(expect1);
      }
    }
    if (m.find("WaitingOrderId") != m.end() && !m["WaitingOrderId"].empty()) {
      waitingOrderId = make_shared<string>(boost::any_cast<string>(m["WaitingOrderId"]));
    }
  }


  virtual ~ModifyWaitingOrderRequest() = default;
};
class ModifyWaitingOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWaitingOrderResponseBody() {}

  explicit ModifyWaitingOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWaitingOrderResponseBody() = default;
};
class ModifyWaitingOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWaitingOrderResponseBody> body{};

  ModifyWaitingOrderResponse() {}

  explicit ModifyWaitingOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWaitingOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWaitingOrderResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWaitingOrderResponse() = default;
};
class PurchaseReservedInstancesOfferingRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PurchaseReservedInstancesOfferingRequestTag() {}

  explicit PurchaseReservedInstancesOfferingRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PurchaseReservedInstancesOfferingRequestTag() = default;
};
class PurchaseReservedInstancesOfferingRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> businessInfo{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> fromApp{};
  shared_ptr<long> instanceAmount{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> offeringType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> platform{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservedInstanceName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scope{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<PurchaseReservedInstancesOfferingRequestTag>> tag{};
  shared_ptr<string> zoneId{};

  PurchaseReservedInstancesOfferingRequest() {}

  explicit PurchaseReservedInstancesOfferingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (instanceAmount) {
      res["InstanceAmount"] = boost::any(*instanceAmount);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservedInstanceName) {
      res["ReservedInstanceName"] = boost::any(*reservedInstanceName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("InstanceAmount") != m.end() && !m["InstanceAmount"].empty()) {
      instanceAmount = make_shared<long>(boost::any_cast<long>(m["InstanceAmount"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservedInstanceName") != m.end() && !m["ReservedInstanceName"].empty()) {
      reservedInstanceName = make_shared<string>(boost::any_cast<string>(m["ReservedInstanceName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<PurchaseReservedInstancesOfferingRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PurchaseReservedInstancesOfferingRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<PurchaseReservedInstancesOfferingRequestTag>>(expect1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~PurchaseReservedInstancesOfferingRequest() = default;
};
class PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> reservedInstanceId{};

  PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets() {}

  explicit PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservedInstanceId) {
      res["ReservedInstanceId"] = boost::any(*reservedInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservedInstanceId") != m.end() && !m["ReservedInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReservedInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReservedInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reservedInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets() = default;
};
class PurchaseReservedInstancesOfferingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets> reservedInstanceIdSets{};

  PurchaseReservedInstancesOfferingResponseBody() {}

  explicit PurchaseReservedInstancesOfferingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservedInstanceIdSets) {
      res["ReservedInstanceIdSets"] = reservedInstanceIdSets ? boost::any(reservedInstanceIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservedInstanceIdSets") != m.end() && !m["ReservedInstanceIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservedInstanceIdSets"].type()) {
        PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservedInstanceIdSets"]));
        reservedInstanceIdSets = make_shared<PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets>(model1);
      }
    }
  }


  virtual ~PurchaseReservedInstancesOfferingResponseBody() = default;
};
class PurchaseReservedInstancesOfferingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PurchaseReservedInstancesOfferingResponseBody> body{};

  PurchaseReservedInstancesOfferingResponse() {}

  explicit PurchaseReservedInstancesOfferingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PurchaseReservedInstancesOfferingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PurchaseReservedInstancesOfferingResponseBody>(model1);
      }
    }
  }


  virtual ~PurchaseReservedInstancesOfferingResponse() = default;
};
class PurchaseSavingPlanOfferingRequest : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> committedAmount{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceFamily{};
  shared_ptr<string> instanceFamilySet{};
  shared_ptr<string> name{};
  shared_ptr<string> offeringType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> planType{};
  shared_ptr<string> purchaseMethod{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> startTime{};

  PurchaseSavingPlanOfferingRequest() {}

  explicit PurchaseSavingPlanOfferingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (committedAmount) {
      res["CommittedAmount"] = boost::any(*committedAmount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceFamily) {
      res["InstanceFamily"] = boost::any(*instanceFamily);
    }
    if (instanceFamilySet) {
      res["InstanceFamilySet"] = boost::any(*instanceFamilySet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (offeringType) {
      res["OfferingType"] = boost::any(*offeringType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (planType) {
      res["PlanType"] = boost::any(*planType);
    }
    if (purchaseMethod) {
      res["PurchaseMethod"] = boost::any(*purchaseMethod);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CommittedAmount") != m.end() && !m["CommittedAmount"].empty()) {
      committedAmount = make_shared<string>(boost::any_cast<string>(m["CommittedAmount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceFamily") != m.end() && !m["InstanceFamily"].empty()) {
      instanceFamily = make_shared<string>(boost::any_cast<string>(m["InstanceFamily"]));
    }
    if (m.find("InstanceFamilySet") != m.end() && !m["InstanceFamilySet"].empty()) {
      instanceFamilySet = make_shared<string>(boost::any_cast<string>(m["InstanceFamilySet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OfferingType") != m.end() && !m["OfferingType"].empty()) {
      offeringType = make_shared<string>(boost::any_cast<string>(m["OfferingType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PlanType") != m.end() && !m["PlanType"].empty()) {
      planType = make_shared<string>(boost::any_cast<string>(m["PlanType"]));
    }
    if (m.find("PurchaseMethod") != m.end() && !m["PurchaseMethod"].empty()) {
      purchaseMethod = make_shared<string>(boost::any_cast<string>(m["PurchaseMethod"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~PurchaseSavingPlanOfferingRequest() = default;
};
class PurchaseSavingPlanOfferingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> savingPlanIdSets{};

  PurchaseSavingPlanOfferingResponseBody() {}

  explicit PurchaseSavingPlanOfferingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (savingPlanIdSets) {
      res["SavingPlanIdSets"] = boost::any(*savingPlanIdSets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SavingPlanIdSets") != m.end() && !m["SavingPlanIdSets"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SavingPlanIdSets"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SavingPlanIdSets"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      savingPlanIdSets = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PurchaseSavingPlanOfferingResponseBody() = default;
};
class PurchaseSavingPlanOfferingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PurchaseSavingPlanOfferingResponseBody> body{};

  PurchaseSavingPlanOfferingResponse() {}

  explicit PurchaseSavingPlanOfferingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PurchaseSavingPlanOfferingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PurchaseSavingPlanOfferingResponseBody>(model1);
      }
    }
  }


  virtual ~PurchaseSavingPlanOfferingResponse() = default;
};
class PurchaseStorageCapacityUnitRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PurchaseStorageCapacityUnitRequestTag() {}

  explicit PurchaseStorageCapacityUnitRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PurchaseStorageCapacityUnitRequestTag() = default;
};
class PurchaseStorageCapacityUnitRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> capacity{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> extendParams{};
  shared_ptr<string> fromApp{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<PurchaseStorageCapacityUnitRequestTag>> tag{};

  PurchaseStorageCapacityUnitRequest() {}

  explicit PurchaseStorageCapacityUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extendParams) {
      res["ExtendParams"] = boost::any(*extendParams);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtendParams") != m.end() && !m["ExtendParams"].empty()) {
      extendParams = make_shared<string>(boost::any_cast<string>(m["ExtendParams"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<PurchaseStorageCapacityUnitRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PurchaseStorageCapacityUnitRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<PurchaseStorageCapacityUnitRequestTag>>(expect1);
      }
    }
  }


  virtual ~PurchaseStorageCapacityUnitRequest() = default;
};
class PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> storageCapacityUnitId{};

  PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds() {}

  explicit PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageCapacityUnitId) {
      res["StorageCapacityUnitId"] = boost::any(*storageCapacityUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageCapacityUnitId") != m.end() && !m["StorageCapacityUnitId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StorageCapacityUnitId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StorageCapacityUnitId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      storageCapacityUnitId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds() = default;
};
class PurchaseStorageCapacityUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds> storageCapacityUnitIds{};

  PurchaseStorageCapacityUnitResponseBody() {}

  explicit PurchaseStorageCapacityUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageCapacityUnitIds) {
      res["StorageCapacityUnitIds"] = storageCapacityUnitIds ? boost::any(storageCapacityUnitIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageCapacityUnitIds") != m.end() && !m["StorageCapacityUnitIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["StorageCapacityUnitIds"].type()) {
        PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StorageCapacityUnitIds"]));
        storageCapacityUnitIds = make_shared<PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds>(model1);
      }
    }
  }


  virtual ~PurchaseStorageCapacityUnitResponseBody() = default;
};
class PurchaseStorageCapacityUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PurchaseStorageCapacityUnitResponseBody> body{};

  PurchaseStorageCapacityUnitResponse() {}

  explicit PurchaseStorageCapacityUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PurchaseStorageCapacityUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PurchaseStorageCapacityUnitResponseBody>(model1);
      }
    }
  }


  virtual ~PurchaseStorageCapacityUnitResponse() = default;
};
class QueryEniQosGroupByEniRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryEniQosGroupByEniRequest() {}

  explicit QueryEniQosGroupByEniRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryEniQosGroupByEniRequest() = default;
};
class QueryEniQosGroupByEniResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> qosGroupName{};
  shared_ptr<string> requestId{};

  QueryEniQosGroupByEniResponseBody() {}

  explicit QueryEniQosGroupByEniResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosGroupName) {
      res["QosGroupName"] = boost::any(*qosGroupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosGroupName") != m.end() && !m["QosGroupName"].empty()) {
      qosGroupName = make_shared<string>(boost::any_cast<string>(m["QosGroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryEniQosGroupByEniResponseBody() = default;
};
class QueryEniQosGroupByEniResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEniQosGroupByEniResponseBody> body{};

  QueryEniQosGroupByEniResponse() {}

  explicit QueryEniQosGroupByEniResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEniQosGroupByEniResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEniQosGroupByEniResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEniQosGroupByEniResponse() = default;
};
class QueryEniQosGroupByInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryEniQosGroupByInstanceRequest() {}

  explicit QueryEniQosGroupByInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryEniQosGroupByInstanceRequest() = default;
};
class QueryEniQosGroupByInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> eniQosGroups{};

  QueryEniQosGroupByInstanceResponseBodyData() {}

  explicit QueryEniQosGroupByInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eniQosGroups) {
      res["EniQosGroups"] = boost::any(*eniQosGroups);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EniQosGroups") != m.end() && !m["EniQosGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EniQosGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EniQosGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eniQosGroups = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryEniQosGroupByInstanceResponseBodyData() = default;
};
class QueryEniQosGroupByInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryEniQosGroupByInstanceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  QueryEniQosGroupByInstanceResponseBody() {}

  explicit QueryEniQosGroupByInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEniQosGroupByInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEniQosGroupByInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryEniQosGroupByInstanceResponseBody() = default;
};
class QueryEniQosGroupByInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEniQosGroupByInstanceResponseBody> body{};

  QueryEniQosGroupByInstanceResponse() {}

  explicit QueryEniQosGroupByInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEniQosGroupByInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEniQosGroupByInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEniQosGroupByInstanceResponse() = default;
};
class ReAddMigrationTaskInPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> migrationPlanId{};
  shared_ptr<string> migrationTime{};
  shared_ptr<string> networkMigrationType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ReAddMigrationTaskInPlanRequest() {}

  explicit ReAddMigrationTaskInPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (migrationPlanId) {
      res["MigrationPlanId"] = boost::any(*migrationPlanId);
    }
    if (migrationTime) {
      res["MigrationTime"] = boost::any(*migrationTime);
    }
    if (networkMigrationType) {
      res["NetworkMigrationType"] = boost::any(*networkMigrationType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MigrationPlanId") != m.end() && !m["MigrationPlanId"].empty()) {
      migrationPlanId = make_shared<string>(boost::any_cast<string>(m["MigrationPlanId"]));
    }
    if (m.find("MigrationTime") != m.end() && !m["MigrationTime"].empty()) {
      migrationTime = make_shared<string>(boost::any_cast<string>(m["MigrationTime"]));
    }
    if (m.find("NetworkMigrationType") != m.end() && !m["NetworkMigrationType"].empty()) {
      networkMigrationType = make_shared<string>(boost::any_cast<string>(m["NetworkMigrationType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ReAddMigrationTaskInPlanRequest() = default;
};
class ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};

  ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels() {}

  explicit ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels() = default;
};
class ReAddMigrationTaskInPlanResponseBodyFailModels : public Darabonba::Model {
public:
  shared_ptr<vector<ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels>> failModels{};

  ReAddMigrationTaskInPlanResponseBodyFailModels() {}

  explicit ReAddMigrationTaskInPlanResponseBodyFailModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failModels) {
      vector<boost::any> temp1;
      for(auto item1:*failModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailModels"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailModels") != m.end() && !m["FailModels"].empty()) {
      if (typeid(vector<boost::any>) == m["FailModels"].type()) {
        vector<ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failModels = make_shared<vector<ReAddMigrationTaskInPlanResponseBodyFailModelsFailModels>>(expect1);
      }
    }
  }


  virtual ~ReAddMigrationTaskInPlanResponseBodyFailModels() = default;
};
class ReAddMigrationTaskInPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<ReAddMigrationTaskInPlanResponseBodyFailModels> failModels{};
  shared_ptr<string> requestId{};

  ReAddMigrationTaskInPlanResponseBody() {}

  explicit ReAddMigrationTaskInPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failModels) {
      res["FailModels"] = failModels ? boost::any(failModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailModels") != m.end() && !m["FailModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailModels"].type()) {
        ReAddMigrationTaskInPlanResponseBodyFailModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailModels"]));
        failModels = make_shared<ReAddMigrationTaskInPlanResponseBodyFailModels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReAddMigrationTaskInPlanResponseBody() = default;
};
class ReAddMigrationTaskInPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReAddMigrationTaskInPlanResponseBody> body{};

  ReAddMigrationTaskInPlanResponse() {}

  explicit ReAddMigrationTaskInPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReAddMigrationTaskInPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReAddMigrationTaskInPlanResponseBody>(model1);
      }
    }
  }


  virtual ~ReAddMigrationTaskInPlanResponse() = default;
};
class ReleaseCapacityReservationRequest : public Darabonba::Model {
public:
  shared_ptr<string> capacityReservationId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> token{};

  ReleaseCapacityReservationRequest() {}

  explicit ReleaseCapacityReservationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityReservationId) {
      res["CapacityReservationId"] = boost::any(*capacityReservationId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityReservationId") != m.end() && !m["CapacityReservationId"].empty()) {
      capacityReservationId = make_shared<string>(boost::any_cast<string>(m["CapacityReservationId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ReleaseCapacityReservationRequest() = default;
};
class ReleaseCapacityReservationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseCapacityReservationResponseBody() {}

  explicit ReleaseCapacityReservationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseCapacityReservationResponseBody() = default;
};
class ReleaseCapacityReservationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseCapacityReservationResponseBody> body{};

  ReleaseCapacityReservationResponse() {}

  explicit ReleaseCapacityReservationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseCapacityReservationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseCapacityReservationResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseCapacityReservationResponse() = default;
};
class ReleaseDedicatedHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<bool> force{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> token{};

  ReleaseDedicatedHostRequest() {}

  explicit ReleaseDedicatedHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ReleaseDedicatedHostRequest() = default;
};
class ReleaseDedicatedHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseDedicatedHostResponseBody() {}

  explicit ReleaseDedicatedHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseDedicatedHostResponseBody() = default;
};
class ReleaseDedicatedHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseDedicatedHostResponseBody> body{};

  ReleaseDedicatedHostResponse() {}

  explicit ReleaseDedicatedHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseDedicatedHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseDedicatedHostResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseDedicatedHostResponse() = default;
};
class RenewDedicatedHostsRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessInfo{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> dedicatedHostIds{};
  shared_ptr<string> fromApp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  RenewDedicatedHostsRequest() {}

  explicit RenewDedicatedHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dedicatedHostIds) {
      res["DedicatedHostIds"] = boost::any(*dedicatedHostIds);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DedicatedHostIds") != m.end() && !m["DedicatedHostIds"].empty()) {
      dedicatedHostIds = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIds"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~RenewDedicatedHostsRequest() = default;
};
class RenewDedicatedHostsResponseBodyDedicatedHostIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dedicatedHostId{};

  RenewDedicatedHostsResponseBodyDedicatedHostIdSets() {}

  explicit RenewDedicatedHostsResponseBodyDedicatedHostIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DedicatedHostId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DedicatedHostId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dedicatedHostId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RenewDedicatedHostsResponseBodyDedicatedHostIdSets() = default;
};
class RenewDedicatedHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<RenewDedicatedHostsResponseBodyDedicatedHostIdSets> dedicatedHostIdSets{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  RenewDedicatedHostsResponseBody() {}

  explicit RenewDedicatedHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostIdSets) {
      res["DedicatedHostIdSets"] = dedicatedHostIdSets ? boost::any(dedicatedHostIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostIdSets") != m.end() && !m["DedicatedHostIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostIdSets"].type()) {
        RenewDedicatedHostsResponseBodyDedicatedHostIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostIdSets"]));
        dedicatedHostIdSets = make_shared<RenewDedicatedHostsResponseBodyDedicatedHostIdSets>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewDedicatedHostsResponseBody() = default;
};
class RenewDedicatedHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewDedicatedHostsResponseBody> body{};

  RenewDedicatedHostsResponse() {}

  explicit RenewDedicatedHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewDedicatedHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewDedicatedHostsResponseBody>(model1);
      }
    }
  }


  virtual ~RenewDedicatedHostsResponse() = default;
};
class ReviewDiagnosticReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceSystem{};
  shared_ptr<string> status{};

  ReviewDiagnosticReportRequest() {}

  explicit ReviewDiagnosticReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceSystem) {
      res["SourceSystem"] = boost::any(*sourceSystem);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceSystem") != m.end() && !m["SourceSystem"].empty()) {
      sourceSystem = make_shared<string>(boost::any_cast<string>(m["SourceSystem"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ReviewDiagnosticReportRequest() = default;
};
class ReviewDiagnosticReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  ReviewDiagnosticReportResponseBody() {}

  explicit ReviewDiagnosticReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ReviewDiagnosticReportResponseBody() = default;
};
class ReviewDiagnosticReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReviewDiagnosticReportResponseBody> body{};

  ReviewDiagnosticReportResponse() {}

  explicit ReviewDiagnosticReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReviewDiagnosticReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReviewDiagnosticReportResponseBody>(model1);
      }
    }
  }


  virtual ~ReviewDiagnosticReportResponse() = default;
};
class RunInstancesRequestHibernationOptions : public Darabonba::Model {
public:
  shared_ptr<bool> configured{};

  RunInstancesRequestHibernationOptions() {}

  explicit RunInstancesRequestHibernationOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configured) {
      res["Configured"] = boost::any(*configured);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configured") != m.end() && !m["Configured"].empty()) {
      configured = make_shared<bool>(boost::any_cast<bool>(m["Configured"]));
    }
  }


  virtual ~RunInstancesRequestHibernationOptions() = default;
};
class RunInstancesRequestPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  RunInstancesRequestPrivatePoolOptions() {}

  explicit RunInstancesRequestPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["MatchCriteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchCriteria") != m.end() && !m["MatchCriteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["MatchCriteria"]));
    }
  }


  virtual ~RunInstancesRequestPrivatePoolOptions() = default;
};
class RunInstancesRequestSchedulerOptions : public Darabonba::Model {
public:
  shared_ptr<string> managedPrivateSpaceId{};

  RunInstancesRequestSchedulerOptions() {}

  explicit RunInstancesRequestSchedulerOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedPrivateSpaceId) {
      res["ManagedPrivateSpaceId"] = boost::any(*managedPrivateSpaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedPrivateSpaceId") != m.end() && !m["ManagedPrivateSpaceId"].empty()) {
      managedPrivateSpaceId = make_shared<string>(boost::any_cast<string>(m["ManagedPrivateSpaceId"]));
    }
  }


  virtual ~RunInstancesRequestSchedulerOptions() = default;
};
class RunInstancesRequestSecurityOptions : public Darabonba::Model {
public:
  shared_ptr<string> confidentialComputingMode{};
  shared_ptr<string> trustedSystemMode{};

  RunInstancesRequestSecurityOptions() {}

  explicit RunInstancesRequestSecurityOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confidentialComputingMode) {
      res["ConfidentialComputingMode"] = boost::any(*confidentialComputingMode);
    }
    if (trustedSystemMode) {
      res["TrustedSystemMode"] = boost::any(*trustedSystemMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfidentialComputingMode") != m.end() && !m["ConfidentialComputingMode"].empty()) {
      confidentialComputingMode = make_shared<string>(boost::any_cast<string>(m["ConfidentialComputingMode"]));
    }
    if (m.find("TrustedSystemMode") != m.end() && !m["TrustedSystemMode"].empty()) {
      trustedSystemMode = make_shared<string>(boost::any_cast<string>(m["TrustedSystemMode"]));
    }
  }


  virtual ~RunInstancesRequestSecurityOptions() = default;
};
class RunInstancesRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> diskName{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> size{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<string> storageClusterId{};

  RunInstancesRequestSystemDisk() {}

  explicit RunInstancesRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (storageClusterId) {
      res["StorageClusterId"] = boost::any(*storageClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("StorageClusterId") != m.end() && !m["StorageClusterId"].empty()) {
      storageClusterId = make_shared<string>(boost::any_cast<string>(m["StorageClusterId"]));
    }
  }


  virtual ~RunInstancesRequestSystemDisk() = default;
};
class RunInstancesRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<string> category{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> storageClusterId{};

  RunInstancesRequestDataDisk() {}

  explicit RunInstancesRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["AutoSnapshotPolicyId"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["BurstingEnabled"] = boost::any(*burstingEnabled);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (performanceLevel) {
      res["PerformanceLevel"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["ProvisionedIops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (storageClusterId) {
      res["StorageClusterId"] = boost::any(*storageClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSnapshotPolicyId") != m.end() && !m["AutoSnapshotPolicyId"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["AutoSnapshotPolicyId"]));
    }
    if (m.find("BurstingEnabled") != m.end() && !m["BurstingEnabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["BurstingEnabled"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("PerformanceLevel") != m.end() && !m["PerformanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["PerformanceLevel"]));
    }
    if (m.find("ProvisionedIops") != m.end() && !m["ProvisionedIops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["ProvisionedIops"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("StorageClusterId") != m.end() && !m["StorageClusterId"].empty()) {
      storageClusterId = make_shared<string>(boost::any_cast<string>(m["StorageClusterId"]));
    }
  }


  virtual ~RunInstancesRequestDataDisk() = default;
};
class RunInstancesRequestImageOptions : public Darabonba::Model {
public:
  shared_ptr<bool> loginAsNonRoot{};

  RunInstancesRequestImageOptions() {}

  explicit RunInstancesRequestImageOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginAsNonRoot) {
      res["LoginAsNonRoot"] = boost::any(*loginAsNonRoot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginAsNonRoot") != m.end() && !m["LoginAsNonRoot"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["LoginAsNonRoot"]));
    }
  }


  virtual ~RunInstancesRequestImageOptions() = default;
};
class RunInstancesRequestInstance : public Darabonba::Model {
public:
  shared_ptr<string> privateIpAddress{};

  RunInstancesRequestInstance() {}

  explicit RunInstancesRequestInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
  }


  virtual ~RunInstancesRequestInstance() = default;
};
class RunInstancesRequestNetworkInterface : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceType{};
  shared_ptr<vector<string>> ipv6Address{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> networkInterfaceTrafficMode{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<long> queuePairNumber{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> vSwitchId{};

  RunInstancesRequestNetworkInterface() {}

  explicit RunInstancesRequestNetworkInterface(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (networkInterfaceTrafficMode) {
      res["NetworkInterfaceTrafficMode"] = boost::any(*networkInterfaceTrafficMode);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (queuePairNumber) {
      res["QueuePairNumber"] = boost::any(*queuePairNumber);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("NetworkInterfaceTrafficMode") != m.end() && !m["NetworkInterfaceTrafficMode"].empty()) {
      networkInterfaceTrafficMode = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceTrafficMode"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("QueuePairNumber") != m.end() && !m["QueuePairNumber"].empty()) {
      queuePairNumber = make_shared<long>(boost::any_cast<long>(m["QueuePairNumber"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~RunInstancesRequestNetworkInterface() = default;
};
class RunInstancesRequestSecurityGroupRule : public Darabonba::Model {
public:
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> nicType{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> priority{};

  RunInstancesRequestSecurityGroupRule() {}

  explicit RunInstancesRequestSecurityGroupRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (nicType) {
      res["NicType"] = boost::any(*nicType);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NicType") != m.end() && !m["NicType"].empty()) {
      nicType = make_shared<string>(boost::any_cast<string>(m["NicType"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
  }


  virtual ~RunInstancesRequestSecurityGroupRule() = default;
};
class RunInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  RunInstancesRequestTag() {}

  explicit RunInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~RunInstancesRequestTag() = default;
};
class RunInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<RunInstancesRequestHibernationOptions> hibernationOptions{};
  shared_ptr<RunInstancesRequestPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<RunInstancesRequestSchedulerOptions> schedulerOptions{};
  shared_ptr<RunInstancesRequestSecurityOptions> securityOptions{};
  shared_ptr<RunInstancesRequestSystemDisk> systemDisk{};
  shared_ptr<string> affinity{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> businessInfo{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> creditSpecification{};
  shared_ptr<vector<RunInstancesRequestDataDisk>> dataDisk{};
  shared_ptr<string> dedicatedHostClusterId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> defaultVpc{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> deploymentSetGroupNo{};
  shared_ptr<string> deploymentSetId{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> fromApp{};
  shared_ptr<string> hostName{};
  shared_ptr<vector<string>> hostNames{};
  shared_ptr<string> hpcClusterId{};
  shared_ptr<string> httpEndpoint{};
  shared_ptr<long> httpPutResponseHopLimit{};
  shared_ptr<string> httpTokens{};
  shared_ptr<string> imageFamily{};
  shared_ptr<string> imageId{};
  shared_ptr<RunInstancesRequestImageOptions> imageOptions{};
  shared_ptr<vector<RunInstancesRequestInstance>> instance{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ioOptimized{};
  shared_ptr<vector<string>> ipv6Address{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> isp{};
  shared_ptr<string> keyPairName{};
  shared_ptr<long> maxAmount{};
  shared_ptr<long> minAmount{};
  shared_ptr<vector<RunInstancesRequestNetworkInterface>> networkInterface{};
  shared_ptr<string> networkType{};
  shared_ptr<string> nodeControllerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<string> recycleBinResourceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> relationOrderId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityEnhancementStrategy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<vector<RunInstancesRequestSecurityGroupRule>> securityGroupRule{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotInterruptionBehavior{};
  shared_ptr<double> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> storageSetId{};
  shared_ptr<long> storageSetPartitionNumber{};
  shared_ptr<vector<RunInstancesRequestTag>> tag{};
  shared_ptr<string> tenancy{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};

  RunInstancesRequest() {}

  explicit RunInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hibernationOptions) {
      res["HibernationOptions"] = hibernationOptions ? boost::any(hibernationOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privatePoolOptions) {
      res["PrivatePoolOptions"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulerOptions) {
      res["SchedulerOptions"] = schedulerOptions ? boost::any(schedulerOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityOptions) {
      res["SecurityOptions"] = securityOptions ? boost::any(securityOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (affinity) {
      res["Affinity"] = boost::any(*affinity);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (creditSpecification) {
      res["CreditSpecification"] = boost::any(*creditSpecification);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (dedicatedHostClusterId) {
      res["DedicatedHostClusterId"] = boost::any(*dedicatedHostClusterId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (defaultVpc) {
      res["DefaultVpc"] = boost::any(*defaultVpc);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (deploymentSetGroupNo) {
      res["DeploymentSetGroupNo"] = boost::any(*deploymentSetGroupNo);
    }
    if (deploymentSetId) {
      res["DeploymentSetId"] = boost::any(*deploymentSetId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (fromApp) {
      res["FromApp"] = boost::any(*fromApp);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostNames) {
      res["HostNames"] = boost::any(*hostNames);
    }
    if (hpcClusterId) {
      res["HpcClusterId"] = boost::any(*hpcClusterId);
    }
    if (httpEndpoint) {
      res["HttpEndpoint"] = boost::any(*httpEndpoint);
    }
    if (httpPutResponseHopLimit) {
      res["HttpPutResponseHopLimit"] = boost::any(*httpPutResponseHopLimit);
    }
    if (httpTokens) {
      res["HttpTokens"] = boost::any(*httpTokens);
    }
    if (imageFamily) {
      res["ImageFamily"] = boost::any(*imageFamily);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageOptions) {
      res["ImageOptions"] = imageOptions ? boost::any(imageOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (maxAmount) {
      res["MaxAmount"] = boost::any(*maxAmount);
    }
    if (minAmount) {
      res["MinAmount"] = boost::any(*minAmount);
    }
    if (networkInterface) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterface){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterface"] = boost::any(temp1);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (nodeControllerId) {
      res["NodeControllerId"] = boost::any(*nodeControllerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (ramRoleName) {
      res["RamRoleName"] = boost::any(*ramRoleName);
    }
    if (recycleBinResourceId) {
      res["RecycleBinResourceId"] = boost::any(*recycleBinResourceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (relationOrderId) {
      res["RelationOrderId"] = boost::any(*relationOrderId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityEnhancementStrategy) {
      res["SecurityEnhancementStrategy"] = boost::any(*securityEnhancementStrategy);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (securityGroupRule) {
      vector<boost::any> temp1;
      for(auto item1:*securityGroupRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityGroupRule"] = boost::any(temp1);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotInterruptionBehavior) {
      res["SpotInterruptionBehavior"] = boost::any(*spotInterruptionBehavior);
    }
    if (spotPriceLimit) {
      res["SpotPriceLimit"] = boost::any(*spotPriceLimit);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (storageSetId) {
      res["StorageSetId"] = boost::any(*storageSetId);
    }
    if (storageSetPartitionNumber) {
      res["StorageSetPartitionNumber"] = boost::any(*storageSetPartitionNumber);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (tenancy) {
      res["Tenancy"] = boost::any(*tenancy);
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HibernationOptions") != m.end() && !m["HibernationOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["HibernationOptions"].type()) {
        RunInstancesRequestHibernationOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HibernationOptions"]));
        hibernationOptions = make_shared<RunInstancesRequestHibernationOptions>(model1);
      }
    }
    if (m.find("PrivatePoolOptions") != m.end() && !m["PrivatePoolOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivatePoolOptions"].type()) {
        RunInstancesRequestPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivatePoolOptions"]));
        privatePoolOptions = make_shared<RunInstancesRequestPrivatePoolOptions>(model1);
      }
    }
    if (m.find("SchedulerOptions") != m.end() && !m["SchedulerOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerOptions"].type()) {
        RunInstancesRequestSchedulerOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerOptions"]));
        schedulerOptions = make_shared<RunInstancesRequestSchedulerOptions>(model1);
      }
    }
    if (m.find("SecurityOptions") != m.end() && !m["SecurityOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityOptions"].type()) {
        RunInstancesRequestSecurityOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityOptions"]));
        securityOptions = make_shared<RunInstancesRequestSecurityOptions>(model1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        RunInstancesRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<RunInstancesRequestSystemDisk>(model1);
      }
    }
    if (m.find("Affinity") != m.end() && !m["Affinity"].empty()) {
      affinity = make_shared<string>(boost::any_cast<string>(m["Affinity"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreditSpecification") != m.end() && !m["CreditSpecification"].empty()) {
      creditSpecification = make_shared<string>(boost::any_cast<string>(m["CreditSpecification"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<RunInstancesRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<RunInstancesRequestDataDisk>>(expect1);
      }
    }
    if (m.find("DedicatedHostClusterId") != m.end() && !m["DedicatedHostClusterId"].empty()) {
      dedicatedHostClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostClusterId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DefaultVpc") != m.end() && !m["DefaultVpc"].empty()) {
      defaultVpc = make_shared<string>(boost::any_cast<string>(m["DefaultVpc"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("DeploymentSetGroupNo") != m.end() && !m["DeploymentSetGroupNo"].empty()) {
      deploymentSetGroupNo = make_shared<string>(boost::any_cast<string>(m["DeploymentSetGroupNo"]));
    }
    if (m.find("DeploymentSetId") != m.end() && !m["DeploymentSetId"].empty()) {
      deploymentSetId = make_shared<string>(boost::any_cast<string>(m["DeploymentSetId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("FromApp") != m.end() && !m["FromApp"].empty()) {
      fromApp = make_shared<string>(boost::any_cast<string>(m["FromApp"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostNames") != m.end() && !m["HostNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HpcClusterId") != m.end() && !m["HpcClusterId"].empty()) {
      hpcClusterId = make_shared<string>(boost::any_cast<string>(m["HpcClusterId"]));
    }
    if (m.find("HttpEndpoint") != m.end() && !m["HttpEndpoint"].empty()) {
      httpEndpoint = make_shared<string>(boost::any_cast<string>(m["HttpEndpoint"]));
    }
    if (m.find("HttpPutResponseHopLimit") != m.end() && !m["HttpPutResponseHopLimit"].empty()) {
      httpPutResponseHopLimit = make_shared<long>(boost::any_cast<long>(m["HttpPutResponseHopLimit"]));
    }
    if (m.find("HttpTokens") != m.end() && !m["HttpTokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["HttpTokens"]));
    }
    if (m.find("ImageFamily") != m.end() && !m["ImageFamily"].empty()) {
      imageFamily = make_shared<string>(boost::any_cast<string>(m["ImageFamily"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageOptions") != m.end() && !m["ImageOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageOptions"].type()) {
        RunInstancesRequestImageOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageOptions"]));
        imageOptions = make_shared<RunInstancesRequestImageOptions>(model1);
      }
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<RunInstancesRequestInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<RunInstancesRequestInstance>>(expect1);
      }
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<string>(boost::any_cast<string>(m["IoOptimized"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("MaxAmount") != m.end() && !m["MaxAmount"].empty()) {
      maxAmount = make_shared<long>(boost::any_cast<long>(m["MaxAmount"]));
    }
    if (m.find("MinAmount") != m.end() && !m["MinAmount"].empty()) {
      minAmount = make_shared<long>(boost::any_cast<long>(m["MinAmount"]));
    }
    if (m.find("NetworkInterface") != m.end() && !m["NetworkInterface"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterface"].type()) {
        vector<RunInstancesRequestNetworkInterface> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterface"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestNetworkInterface model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterface = make_shared<vector<RunInstancesRequestNetworkInterface>>(expect1);
      }
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("NodeControllerId") != m.end() && !m["NodeControllerId"].empty()) {
      nodeControllerId = make_shared<string>(boost::any_cast<string>(m["NodeControllerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("RamRoleName") != m.end() && !m["RamRoleName"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["RamRoleName"]));
    }
    if (m.find("RecycleBinResourceId") != m.end() && !m["RecycleBinResourceId"].empty()) {
      recycleBinResourceId = make_shared<string>(boost::any_cast<string>(m["RecycleBinResourceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RelationOrderId") != m.end() && !m["RelationOrderId"].empty()) {
      relationOrderId = make_shared<string>(boost::any_cast<string>(m["RelationOrderId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityEnhancementStrategy") != m.end() && !m["SecurityEnhancementStrategy"].empty()) {
      securityEnhancementStrategy = make_shared<string>(boost::any_cast<string>(m["SecurityEnhancementStrategy"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityGroupRule") != m.end() && !m["SecurityGroupRule"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityGroupRule"].type()) {
        vector<RunInstancesRequestSecurityGroupRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityGroupRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestSecurityGroupRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityGroupRule = make_shared<vector<RunInstancesRequestSecurityGroupRule>>(expect1);
      }
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotInterruptionBehavior") != m.end() && !m["SpotInterruptionBehavior"].empty()) {
      spotInterruptionBehavior = make_shared<string>(boost::any_cast<string>(m["SpotInterruptionBehavior"]));
    }
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      spotPriceLimit = make_shared<double>(boost::any_cast<double>(m["SpotPriceLimit"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("StorageSetId") != m.end() && !m["StorageSetId"].empty()) {
      storageSetId = make_shared<string>(boost::any_cast<string>(m["StorageSetId"]));
    }
    if (m.find("StorageSetPartitionNumber") != m.end() && !m["StorageSetPartitionNumber"].empty()) {
      storageSetPartitionNumber = make_shared<long>(boost::any_cast<long>(m["StorageSetPartitionNumber"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<RunInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<RunInstancesRequestTag>>(expect1);
      }
    }
    if (m.find("Tenancy") != m.end() && !m["Tenancy"].empty()) {
      tenancy = make_shared<string>(boost::any_cast<string>(m["Tenancy"]));
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~RunInstancesRequest() = default;
};
class RunInstancesResponseBodyInstanceIdSets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIdSet{};

  RunInstancesResponseBodyInstanceIdSets() {}

  explicit RunInstancesResponseBodyInstanceIdSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdSet) {
      res["InstanceIdSet"] = boost::any(*instanceIdSet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIdSet") != m.end() && !m["InstanceIdSet"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIdSet"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIdSet"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIdSet = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunInstancesResponseBodyInstanceIdSets() = default;
};
class RunInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunInstancesResponseBodyInstanceIdSets> instanceIdSets{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  RunInstancesResponseBody() {}

  explicit RunInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdSets) {
      res["InstanceIdSets"] = instanceIdSets ? boost::any(instanceIdSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIdSets") != m.end() && !m["InstanceIdSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIdSets"].type()) {
        RunInstancesResponseBodyInstanceIdSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIdSets"]));
        instanceIdSets = make_shared<RunInstancesResponseBodyInstanceIdSets>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~RunInstancesResponseBody() = default;
};
class RunInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunInstancesResponseBody> body{};

  RunInstancesResponse() {}

  explicit RunInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RunInstancesResponse() = default;
};
class SetInstanceAutoReleaseTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  SetInstanceAutoReleaseTimeRequest() {}

  explicit SetInstanceAutoReleaseTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~SetInstanceAutoReleaseTimeRequest() = default;
};
class SetInstanceAutoReleaseTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetInstanceAutoReleaseTimeResponseBody() {}

  explicit SetInstanceAutoReleaseTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetInstanceAutoReleaseTimeResponseBody() = default;
};
class SetInstanceAutoReleaseTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetInstanceAutoReleaseTimeResponseBody> body{};

  SetInstanceAutoReleaseTimeResponse() {}

  explicit SetInstanceAutoReleaseTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetInstanceAutoReleaseTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetInstanceAutoReleaseTimeResponseBody>(model1);
      }
    }
  }


  virtual ~SetInstanceAutoReleaseTimeResponse() = default;
};
class StartNetworkInsightsAnalysisRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> networkInsightsPathId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  StartNetworkInsightsAnalysisRequest() {}

  explicit StartNetworkInsightsAnalysisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkInsightsPathId) {
      res["NetworkInsightsPathId"] = boost::any(*networkInsightsPathId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkInsightsPathId") != m.end() && !m["NetworkInsightsPathId"].empty()) {
      networkInsightsPathId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsPathId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~StartNetworkInsightsAnalysisRequest() = default;
};
class StartNetworkInsightsAnalysisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkInsightsAnalysisId{};
  shared_ptr<string> requestId{};

  StartNetworkInsightsAnalysisResponseBody() {}

  explicit StartNetworkInsightsAnalysisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInsightsAnalysisId) {
      res["NetworkInsightsAnalysisId"] = boost::any(*networkInsightsAnalysisId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInsightsAnalysisId") != m.end() && !m["NetworkInsightsAnalysisId"].empty()) {
      networkInsightsAnalysisId = make_shared<string>(boost::any_cast<string>(m["NetworkInsightsAnalysisId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartNetworkInsightsAnalysisResponseBody() = default;
};
class StartNetworkInsightsAnalysisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartNetworkInsightsAnalysisResponseBody> body{};

  StartNetworkInsightsAnalysisResponse() {}

  explicit StartNetworkInsightsAnalysisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartNetworkInsightsAnalysisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartNetworkInsightsAnalysisResponseBody>(model1);
      }
    }
  }


  virtual ~StartNetworkInsightsAnalysisResponse() = default;
};
class UpdateServiceSettingsRequestCloudAssistantDeliverySettings : public Darabonba::Model {
public:
  shared_ptr<string> ossBucketName{};
  shared_ptr<bool> ossEnabled{};
  shared_ptr<string> ossKeyPrefix{};
  shared_ptr<bool> slsEnabled{};
  shared_ptr<string> slsLogstoreName{};
  shared_ptr<string> slsProjectName{};

  UpdateServiceSettingsRequestCloudAssistantDeliverySettings() {}

  explicit UpdateServiceSettingsRequestCloudAssistantDeliverySettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossBucketName) {
      res["OssBucketName"] = boost::any(*ossBucketName);
    }
    if (ossEnabled) {
      res["OssEnabled"] = boost::any(*ossEnabled);
    }
    if (ossKeyPrefix) {
      res["OssKeyPrefix"] = boost::any(*ossKeyPrefix);
    }
    if (slsEnabled) {
      res["SlsEnabled"] = boost::any(*slsEnabled);
    }
    if (slsLogstoreName) {
      res["SlsLogstoreName"] = boost::any(*slsLogstoreName);
    }
    if (slsProjectName) {
      res["SlsProjectName"] = boost::any(*slsProjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssBucketName") != m.end() && !m["OssBucketName"].empty()) {
      ossBucketName = make_shared<string>(boost::any_cast<string>(m["OssBucketName"]));
    }
    if (m.find("OssEnabled") != m.end() && !m["OssEnabled"].empty()) {
      ossEnabled = make_shared<bool>(boost::any_cast<bool>(m["OssEnabled"]));
    }
    if (m.find("OssKeyPrefix") != m.end() && !m["OssKeyPrefix"].empty()) {
      ossKeyPrefix = make_shared<string>(boost::any_cast<string>(m["OssKeyPrefix"]));
    }
    if (m.find("SlsEnabled") != m.end() && !m["SlsEnabled"].empty()) {
      slsEnabled = make_shared<bool>(boost::any_cast<bool>(m["SlsEnabled"]));
    }
    if (m.find("SlsLogstoreName") != m.end() && !m["SlsLogstoreName"].empty()) {
      slsLogstoreName = make_shared<string>(boost::any_cast<string>(m["SlsLogstoreName"]));
    }
    if (m.find("SlsProjectName") != m.end() && !m["SlsProjectName"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["SlsProjectName"]));
    }
  }


  virtual ~UpdateServiceSettingsRequestCloudAssistantDeliverySettings() = default;
};
class UpdateServiceSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateServiceSettingsRequestCloudAssistantDeliverySettings> cloudAssistantDeliverySettings{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateServiceSettingsRequest() {}

  explicit UpdateServiceSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudAssistantDeliverySettings) {
      res["CloudAssistantDeliverySettings"] = cloudAssistantDeliverySettings ? boost::any(cloudAssistantDeliverySettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudAssistantDeliverySettings") != m.end() && !m["CloudAssistantDeliverySettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["CloudAssistantDeliverySettings"].type()) {
        UpdateServiceSettingsRequestCloudAssistantDeliverySettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CloudAssistantDeliverySettings"]));
        cloudAssistantDeliverySettings = make_shared<UpdateServiceSettingsRequestCloudAssistantDeliverySettings>(model1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateServiceSettingsRequest() = default;
};
class UpdateServiceSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateServiceSettingsResponseBody() {}

  explicit UpdateServiceSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateServiceSettingsResponseBody() = default;
};
class UpdateServiceSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateServiceSettingsResponseBody> body{};

  UpdateServiceSettingsResponse() {}

  explicit UpdateServiceSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateServiceSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateServiceSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateServiceSettingsResponse() = default;
};
class UnmountPEDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceSystem{};
  shared_ptr<string> status{};

  UnmountPEDiskRequest() {}

  explicit UnmountPEDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceSystem) {
      res["SourceSystem"] = boost::any(*sourceSystem);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceSystem") != m.end() && !m["SourceSystem"].empty()) {
      sourceSystem = make_shared<string>(boost::any_cast<string>(m["SourceSystem"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UnmountPEDiskRequest() = default;
};
class UnmountPEDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  UnmountPEDiskResponseBody() {}

  explicit UnmountPEDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UnmountPEDiskResponseBody() = default;
};
class UnmountPEDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnmountPEDiskResponseBody> body{};

  UnmountPEDiskResponse() {}

  explicit UnmountPEDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnmountPEDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnmountPEDiskResponseBody>(model1);
      }
    }
  }


  virtual ~UnmountPEDiskResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddMigratableInstancesResponse addMigratableInstancesWithOptions(shared_ptr<AddMigratableInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMigratableInstancesResponse addMigratableInstances(shared_ptr<AddMigratableInstancesRequest> request);
  AllocateDedicatedHostsResponse allocateDedicatedHostsWithOptions(shared_ptr<AllocateDedicatedHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateDedicatedHostsResponse allocateDedicatedHosts(shared_ptr<AllocateDedicatedHostsRequest> request);
  CancelMigrationInstancesResponse cancelMigrationInstancesWithOptions(shared_ptr<CancelMigrationInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelMigrationInstancesResponse cancelMigrationInstances(shared_ptr<CancelMigrationInstancesRequest> request);
  CancelMigrationPlanResponse cancelMigrationPlanWithOptions(shared_ptr<CancelMigrationPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelMigrationPlanResponse cancelMigrationPlan(shared_ptr<CancelMigrationPlanRequest> request);
  ConfigureSecurityGroupPermissionsResponse configureSecurityGroupPermissionsWithOptions(shared_ptr<ConfigureSecurityGroupPermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureSecurityGroupPermissionsResponse configureSecurityGroupPermissions(shared_ptr<ConfigureSecurityGroupPermissionsRequest> request);
  ConfirmReservationDemandResponse confirmReservationDemandWithOptions(shared_ptr<ConfirmReservationDemandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmReservationDemandResponse confirmReservationDemand(shared_ptr<ConfirmReservationDemandRequest> request);
  CreateCapacityReservationResponse createCapacityReservationWithOptions(shared_ptr<CreateCapacityReservationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCapacityReservationResponse createCapacityReservation(shared_ptr<CreateCapacityReservationRequest> request);
  CreateDedicatedBlockStorageClusterResponse createDedicatedBlockStorageClusterWithOptions(shared_ptr<CreateDedicatedBlockStorageClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedBlockStorageClusterResponse createDedicatedBlockStorageCluster(shared_ptr<CreateDedicatedBlockStorageClusterRequest> request);
  CreateDedicatedHostClusterResponse createDedicatedHostClusterWithOptions(shared_ptr<CreateDedicatedHostClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedHostClusterResponse createDedicatedHostCluster(shared_ptr<CreateDedicatedHostClusterRequest> request);
  CreateDefaultAutoSnapshotPolicyResponse createDefaultAutoSnapshotPolicyWithOptions(shared_ptr<CreateDefaultAutoSnapshotPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDefaultAutoSnapshotPolicyResponse createDefaultAutoSnapshotPolicy(shared_ptr<CreateDefaultAutoSnapshotPolicyRequest> request);
  CreateDiagnoseResponse createDiagnoseWithOptions(shared_ptr<CreateDiagnoseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiagnoseResponse createDiagnose(shared_ptr<CreateDiagnoseRequest> request);
  CreateDiagnosisOperateRecordsResponse createDiagnosisOperateRecordsWithOptions(shared_ptr<CreateDiagnosisOperateRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiagnosisOperateRecordsResponse createDiagnosisOperateRecords(shared_ptr<CreateDiagnosisOperateRecordsRequest> request);
  CreateDiagnosticReportResponse createDiagnosticReportWithOptions(shared_ptr<CreateDiagnosticReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiagnosticReportResponse createDiagnosticReport(shared_ptr<CreateDiagnosticReportRequest> request);
  CreateDisksResponse createDisksWithOptions(shared_ptr<CreateDisksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDisksResponse createDisks(shared_ptr<CreateDisksRequest> request);
  CreateElasticityAssuranceResponse createElasticityAssuranceWithOptions(shared_ptr<CreateElasticityAssuranceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateElasticityAssuranceResponse createElasticityAssurance(shared_ptr<CreateElasticityAssuranceRequest> request);
  CreateEniQosGroupResponse createEniQosGroupWithOptions(shared_ptr<CreateEniQosGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEniQosGroupResponse createEniQosGroup(shared_ptr<CreateEniQosGroupRequest> request);
  CreateFunctionFeedbackResponse createFunctionFeedbackWithOptions(shared_ptr<CreateFunctionFeedbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFunctionFeedbackResponse createFunctionFeedback(shared_ptr<CreateFunctionFeedbackRequest> request);
  CreateImageCacheResponse createImageCacheWithOptions(shared_ptr<CreateImageCacheRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageCacheResponse createImageCache(shared_ptr<CreateImageCacheRequest> request);
  CreateIssueCategoryReportRelationResponse createIssueCategoryReportRelationWithOptions(shared_ptr<CreateIssueCategoryReportRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIssueCategoryReportRelationResponse createIssueCategoryReportRelation(shared_ptr<CreateIssueCategoryReportRelationRequest> request);
  CreateMigrationPlanResponse createMigrationPlanWithOptions(shared_ptr<CreateMigrationPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMigrationPlanResponse createMigrationPlan(shared_ptr<CreateMigrationPlanRequest> request);
  CreateNetworkInsightsPathResponse createNetworkInsightsPathWithOptions(shared_ptr<CreateNetworkInsightsPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkInsightsPathResponse createNetworkInsightsPath(shared_ptr<CreateNetworkInsightsPathRequest> request);
  CreateOrderResponse createOrderWithOptions(shared_ptr<CreateOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrderResponse createOrder(shared_ptr<CreateOrderRequest> request);
  CreateReservationDemandResponse createReservationDemandWithOptions(shared_ptr<CreateReservationDemandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateReservationDemandResponse createReservationDemand(shared_ptr<CreateReservationDemandRequest> request);
  CreateStorageSetResponse createStorageSetWithOptions(shared_ptr<CreateStorageSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStorageSetResponse createStorageSet(shared_ptr<CreateStorageSetRequest> request);
  CreateUserQuotaApplicationResponse createUserQuotaApplicationWithOptions(shared_ptr<CreateUserQuotaApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserQuotaApplicationResponse createUserQuotaApplication(shared_ptr<CreateUserQuotaApplicationRequest> request);
  CreateVolumesResponse createVolumesWithOptions(shared_ptr<CreateVolumesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVolumesResponse createVolumes(shared_ptr<CreateVolumesRequest> request);
  CreateWaitingOrderResponse createWaitingOrderWithOptions(shared_ptr<CreateWaitingOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWaitingOrderResponse createWaitingOrder(shared_ptr<CreateWaitingOrderRequest> request);
  DeleteDedicatedHostClusterResponse deleteDedicatedHostClusterWithOptions(shared_ptr<DeleteDedicatedHostClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDedicatedHostClusterResponse deleteDedicatedHostCluster(shared_ptr<DeleteDedicatedHostClusterRequest> request);
  DeleteEniQosGroupResponse deleteEniQosGroupWithOptions(shared_ptr<DeleteEniQosGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEniQosGroupResponse deleteEniQosGroup(shared_ptr<DeleteEniQosGroupRequest> request);
  DeleteImageCacheResponse deleteImageCacheWithOptions(shared_ptr<DeleteImageCacheRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteImageCacheResponse deleteImageCache(shared_ptr<DeleteImageCacheRequest> request);
  DeleteMigratableInstancesResponse deleteMigratableInstancesWithOptions(shared_ptr<DeleteMigratableInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMigratableInstancesResponse deleteMigratableInstances(shared_ptr<DeleteMigratableInstancesRequest> request);
  DeleteNetworkInsightsAnalysisResponse deleteNetworkInsightsAnalysisWithOptions(shared_ptr<DeleteNetworkInsightsAnalysisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkInsightsAnalysisResponse deleteNetworkInsightsAnalysis(shared_ptr<DeleteNetworkInsightsAnalysisRequest> request);
  DeleteNetworkInsightsPathResponse deleteNetworkInsightsPathWithOptions(shared_ptr<DeleteNetworkInsightsPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkInsightsPathResponse deleteNetworkInsightsPath(shared_ptr<DeleteNetworkInsightsPathRequest> request);
  DeleteReservationDemandResponse deleteReservationDemandWithOptions(shared_ptr<DeleteReservationDemandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteReservationDemandResponse deleteReservationDemand(shared_ptr<DeleteReservationDemandRequest> request);
  DeleteStorageSetResponse deleteStorageSetWithOptions(shared_ptr<DeleteStorageSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStorageSetResponse deleteStorageSet(shared_ptr<DeleteStorageSetRequest> request);
  DeleteUserQuotaApplicationResponse deleteUserQuotaApplicationWithOptions(shared_ptr<DeleteUserQuotaApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserQuotaApplicationResponse deleteUserQuotaApplication(shared_ptr<DeleteUserQuotaApplicationRequest> request);
  DeleteWaitingOrdersResponse deleteWaitingOrdersWithOptions(shared_ptr<DeleteWaitingOrdersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWaitingOrdersResponse deleteWaitingOrders(shared_ptr<DeleteWaitingOrdersRequest> request);
  DescribeAccountAttributesResponse describeAccountAttributesWithOptions(shared_ptr<DescribeAccountAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccountAttributesResponse describeAccountAttributes(shared_ptr<DescribeAccountAttributesRequest> request);
  DescribeAccountLimitsResponse describeAccountLimitsWithOptions(shared_ptr<DescribeAccountLimitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccountLimitsResponse describeAccountLimits(shared_ptr<DescribeAccountLimitsRequest> request);
  DescribeAccountQuotaAttributesResponse describeAccountQuotaAttributesWithOptions(shared_ptr<DescribeAccountQuotaAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccountQuotaAttributesResponse describeAccountQuotaAttributes(shared_ptr<DescribeAccountQuotaAttributesRequest> request);
  DescribeAutoProvisioningGroupCapacitiesResponse describeAutoProvisioningGroupCapacitiesWithOptions(shared_ptr<DescribeAutoProvisioningGroupCapacitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoProvisioningGroupCapacitiesResponse describeAutoProvisioningGroupCapacities(shared_ptr<DescribeAutoProvisioningGroupCapacitiesRequest> request);
  DescribeBandwidthPriceResponse describeBandwidthPriceWithOptions(shared_ptr<DescribeBandwidthPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandwidthPriceResponse describeBandwidthPrice(shared_ptr<DescribeBandwidthPriceRequest> request);
  DescribeCapacityReservationsResponse describeCapacityReservationsWithOptions(shared_ptr<DescribeCapacityReservationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCapacityReservationsResponse describeCapacityReservations(shared_ptr<DescribeCapacityReservationsRequest> request);
  DescribeCustomerIssueCategoryResponse describeCustomerIssueCategoryWithOptions(shared_ptr<DescribeCustomerIssueCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomerIssueCategoryResponse describeCustomerIssueCategory(shared_ptr<DescribeCustomerIssueCategoryRequest> request);
  DescribeDedicatedHostAutoRenewResponse describeDedicatedHostAutoRenewWithOptions(shared_ptr<DescribeDedicatedHostAutoRenewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostAutoRenewResponse describeDedicatedHostAutoRenew(shared_ptr<DescribeDedicatedHostAutoRenewRequest> request);
  DescribeDedicatedHostClustersResponse describeDedicatedHostClustersWithOptions(shared_ptr<DescribeDedicatedHostClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostClustersResponse describeDedicatedHostClusters(shared_ptr<DescribeDedicatedHostClustersRequest> request);
  DescribeDedicatedHostTypesResponse describeDedicatedHostTypesWithOptions(shared_ptr<DescribeDedicatedHostTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostTypesResponse describeDedicatedHostTypes(shared_ptr<DescribeDedicatedHostTypesRequest> request);
  DescribeDedicatedHostsResponse describeDedicatedHostsWithOptions(shared_ptr<DescribeDedicatedHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostsResponse describeDedicatedHosts(shared_ptr<DescribeDedicatedHostsRequest> request);
  DescribeDiagnoseResponse describeDiagnoseWithOptions(shared_ptr<DescribeDiagnoseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiagnoseResponse describeDiagnose(shared_ptr<DescribeDiagnoseRequest> request);
  DescribeDiagnosisOperateRecordsResponse describeDiagnosisOperateRecordsWithOptions(shared_ptr<DescribeDiagnosisOperateRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiagnosisOperateRecordsResponse describeDiagnosisOperateRecords(shared_ptr<DescribeDiagnosisOperateRecordsRequest> request);
  DescribeDiagnosticReportsResponse describeDiagnosticReportsWithOptions(shared_ptr<DescribeDiagnosticReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiagnosticReportsResponse describeDiagnosticReports(shared_ptr<DescribeDiagnosticReportsRequest> request);
  DescribeDiskReplicaPairsResponse describeDiskReplicaPairsWithOptions(shared_ptr<DescribeDiskReplicaPairsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiskReplicaPairsResponse describeDiskReplicaPairs(shared_ptr<DescribeDiskReplicaPairsRequest> request);
  DescribeEcsScenarioFacadeResponse describeEcsScenarioFacadeWithOptions(shared_ptr<DescribeEcsScenarioFacadeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEcsScenarioFacadeResponse describeEcsScenarioFacade(shared_ptr<DescribeEcsScenarioFacadeRequest> request);
  DescribeEniQosGroupInfoResponse describeEniQosGroupInfoWithOptions(shared_ptr<DescribeEniQosGroupInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEniQosGroupInfoResponse describeEniQosGroupInfo(shared_ptr<DescribeEniQosGroupInfoRequest> request);
  DescribeFunctionFeedbackResponse describeFunctionFeedbackWithOptions(shared_ptr<DescribeFunctionFeedbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFunctionFeedbackResponse describeFunctionFeedback(shared_ptr<DescribeFunctionFeedbackRequest> request);
  DescribeHavsInstanceTypesResponse describeHavsInstanceTypesWithOptions(shared_ptr<DescribeHavsInstanceTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHavsInstanceTypesResponse describeHavsInstanceTypes(shared_ptr<DescribeHavsInstanceTypesRequest> request);
  DescribeImageAgreementResponse describeImageAgreementWithOptions(shared_ptr<DescribeImageAgreementRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageAgreementResponse describeImageAgreement(shared_ptr<DescribeImageAgreementRequest> request);
  DescribeImageCachesResponse describeImageCachesWithOptions(shared_ptr<DescribeImageCachesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageCachesResponse describeImageCaches(shared_ptr<DescribeImageCachesRequest> request);
  DescribeImageFamiliesResponse describeImageFamiliesWithOptions(shared_ptr<DescribeImageFamiliesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageFamiliesResponse describeImageFamilies(shared_ptr<DescribeImageFamiliesRequest> request);
  DescribeInstanceAutoRebootTimeResponse describeInstanceAutoRebootTimeWithOptions(shared_ptr<DescribeInstanceAutoRebootTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAutoRebootTimeResponse describeInstanceAutoRebootTime(shared_ptr<DescribeInstanceAutoRebootTimeRequest> request);
  DescribeInstanceHealthStatusResponse describeInstanceHealthStatusWithOptions(shared_ptr<DescribeInstanceHealthStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceHealthStatusResponse describeInstanceHealthStatus(shared_ptr<DescribeInstanceHealthStatusRequest> request);
  DescribeInstanceMaintenanceAttributesResponse describeInstanceMaintenanceAttributesWithOptions(shared_ptr<DescribeInstanceMaintenanceAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceMaintenanceAttributesResponse describeInstanceMaintenanceAttributes(shared_ptr<DescribeInstanceMaintenanceAttributesRequest> request);
  DescribeInstanceModificationPriceResponse describeInstanceModificationPriceWithOptions(shared_ptr<DescribeInstanceModificationPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceModificationPriceResponse describeInstanceModificationPrice(shared_ptr<DescribeInstanceModificationPriceRequest> request);
  DescribeInstanceNeedRebootResponse describeInstanceNeedRebootWithOptions(shared_ptr<DescribeInstanceNeedRebootRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceNeedRebootResponse describeInstanceNeedReboot(shared_ptr<DescribeInstanceNeedRebootRequest> request);
  DescribeInstancePerformanceRestrictHistoryResponse describeInstancePerformanceRestrictHistoryWithOptions(shared_ptr<DescribeInstancePerformanceRestrictHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancePerformanceRestrictHistoryResponse describeInstancePerformanceRestrictHistory(shared_ptr<DescribeInstancePerformanceRestrictHistoryRequest> request);
  DescribeInstanceTypeResourceResponse describeInstanceTypeResourceWithOptions(shared_ptr<DescribeInstanceTypeResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTypeResourceResponse describeInstanceTypeResource(shared_ptr<DescribeInstanceTypeResourceRequest> request);
  DescribeKMSKeyAttributeResponse describeKMSKeyAttributeWithOptions(shared_ptr<DescribeKMSKeyAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKMSKeyAttributeResponse describeKMSKeyAttribute(shared_ptr<DescribeKMSKeyAttributeRequest> request);
  DescribeKMSKeysResponse describeKMSKeysWithOptions(shared_ptr<DescribeKMSKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKMSKeysResponse describeKMSKeys(shared_ptr<DescribeKMSKeysRequest> request);
  DescribeLinkedKMSKeysResponse describeLinkedKMSKeysWithOptions(shared_ptr<DescribeLinkedKMSKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLinkedKMSKeysResponse describeLinkedKMSKeys(shared_ptr<DescribeLinkedKMSKeysRequest> request);
  DescribeLocalDiskRepairActivitiesResponse describeLocalDiskRepairActivitiesWithOptions(shared_ptr<DescribeLocalDiskRepairActivitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLocalDiskRepairActivitiesResponse describeLocalDiskRepairActivities(shared_ptr<DescribeLocalDiskRepairActivitiesRequest> request);
  DescribeMigrationInstancesResponse describeMigrationInstancesWithOptions(shared_ptr<DescribeMigrationInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrationInstancesResponse describeMigrationInstances(shared_ptr<DescribeMigrationInstancesRequest> request);
  DescribeMigrationPlansResponse describeMigrationPlansWithOptions(shared_ptr<DescribeMigrationPlansRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrationPlansResponse describeMigrationPlans(shared_ptr<DescribeMigrationPlansRequest> request);
  DescribeMigrationPreferencesResponse describeMigrationPreferencesWithOptions(shared_ptr<DescribeMigrationPreferencesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrationPreferencesResponse describeMigrationPreferences(shared_ptr<DescribeMigrationPreferencesRequest> request);
  DescribeNetworkInsightsAnalysisResultResponse describeNetworkInsightsAnalysisResultWithOptions(shared_ptr<DescribeNetworkInsightsAnalysisResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkInsightsAnalysisResultResponse describeNetworkInsightsAnalysisResult(shared_ptr<DescribeNetworkInsightsAnalysisResultRequest> request);
  DescribeNetworkInsightsAnalysisesResponse describeNetworkInsightsAnalysisesWithOptions(shared_ptr<DescribeNetworkInsightsAnalysisesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkInsightsAnalysisesResponse describeNetworkInsightsAnalysises(shared_ptr<DescribeNetworkInsightsAnalysisesRequest> request);
  DescribeNetworkInsightsPathsResponse describeNetworkInsightsPathsWithOptions(shared_ptr<DescribeNetworkInsightsPathsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkInsightsPathsResponse describeNetworkInsightsPaths(shared_ptr<DescribeNetworkInsightsPathsRequest> request);
  DescribeOrderAutoRebootTimeResponse describeOrderAutoRebootTimeWithOptions(shared_ptr<DescribeOrderAutoRebootTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrderAutoRebootTimeResponse describeOrderAutoRebootTime(shared_ptr<DescribeOrderAutoRebootTimeRequest> request);
  DescribePrePaidResourceRefundPriceResponse describePrePaidResourceRefundPriceWithOptions(shared_ptr<DescribePrePaidResourceRefundPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrePaidResourceRefundPriceResponse describePrePaidResourceRefundPrice(shared_ptr<DescribePrePaidResourceRefundPriceRequest> request);
  DescribePriceResponse describePriceWithOptions(shared_ptr<DescribePriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceResponse describePrice(shared_ptr<DescribePriceRequest> request);
  DescribePrivatePoolsResponse describePrivatePoolsWithOptions(shared_ptr<DescribePrivatePoolsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrivatePoolsResponse describePrivatePools(shared_ptr<DescribePrivatePoolsRequest> request);
  DescribeRecommendProductResponse describeRecommendProductWithOptions(shared_ptr<DescribeRecommendProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecommendProductResponse describeRecommendProduct(shared_ptr<DescribeRecommendProductRequest> request);
  DescribeReservationDemandCommittedAmountResponse describeReservationDemandCommittedAmountWithOptions(shared_ptr<DescribeReservationDemandCommittedAmountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservationDemandCommittedAmountResponse describeReservationDemandCommittedAmount(shared_ptr<DescribeReservationDemandCommittedAmountRequest> request);
  DescribeReservationDemandsResponse describeReservationDemandsWithOptions(shared_ptr<DescribeReservationDemandsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservationDemandsResponse describeReservationDemands(shared_ptr<DescribeReservationDemandsRequest> request);
  DescribeReservedInstanceAllocationsResponse describeReservedInstanceAllocationsWithOptions(shared_ptr<DescribeReservedInstanceAllocationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservedInstanceAllocationsResponse describeReservedInstanceAllocations(shared_ptr<DescribeReservedInstanceAllocationsRequest> request);
  DescribeReservedInstanceCategoriesResponse describeReservedInstanceCategoriesWithOptions(shared_ptr<DescribeReservedInstanceCategoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservedInstanceCategoriesResponse describeReservedInstanceCategories(shared_ptr<DescribeReservedInstanceCategoriesRequest> request);
  DescribeReservedInstancePriceResponse describeReservedInstancePriceWithOptions(shared_ptr<DescribeReservedInstancePriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservedInstancePriceResponse describeReservedInstancePrice(shared_ptr<DescribeReservedInstancePriceRequest> request);
  DescribeReservedInstancesResponse describeReservedInstancesWithOptions(shared_ptr<DescribeReservedInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservedInstancesResponse describeReservedInstances(shared_ptr<DescribeReservedInstancesRequest> request);
  DescribeResourceAggregationsResponse describeResourceAggregationsWithOptions(shared_ptr<DescribeResourceAggregationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceAggregationsResponse describeResourceAggregations(shared_ptr<DescribeResourceAggregationsRequest> request);
  DescribeResourceAllocationResponse describeResourceAllocationWithOptions(shared_ptr<DescribeResourceAllocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceAllocationResponse describeResourceAllocation(shared_ptr<DescribeResourceAllocationRequest> request);
  DescribeResourceDisplayResponse describeResourceDisplayWithOptions(shared_ptr<DescribeResourceDisplayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceDisplayResponse describeResourceDisplay(shared_ptr<DescribeResourceDisplayRequest> request);
  DescribeResourceFilterAttributesResponse describeResourceFilterAttributesWithOptions(shared_ptr<DescribeResourceFilterAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceFilterAttributesResponse describeResourceFilterAttributes(shared_ptr<DescribeResourceFilterAttributesRequest> request);
  DescribeResourceRecommendFiltersResponse describeResourceRecommendFiltersWithOptions(shared_ptr<DescribeResourceRecommendFiltersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceRecommendFiltersResponse describeResourceRecommendFilters(shared_ptr<DescribeResourceRecommendFiltersRequest> request);
  DescribeResourceSolutionsResponse describeResourceSolutionsWithOptions(shared_ptr<DescribeResourceSolutionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceSolutionsResponse describeResourceSolutions(shared_ptr<DescribeResourceSolutionsRequest> request);
  DescribeResourcesResponse describeResourcesWithOptions(shared_ptr<DescribeResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourcesResponse describeResources(shared_ptr<DescribeResourcesRequest> request);
  DescribeRiUtilizationResponse describeRiUtilizationWithOptions(shared_ptr<DescribeRiUtilizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiUtilizationResponse describeRiUtilization(shared_ptr<DescribeRiUtilizationRequest> request);
  DescribeScenePurchaseRecommendResponse describeScenePurchaseRecommendWithOptions(shared_ptr<DescribeScenePurchaseRecommendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScenePurchaseRecommendResponse describeScenePurchaseRecommend(shared_ptr<DescribeScenePurchaseRecommendRequest> request);
  DescribeSceneResourceRecommendResponse describeSceneResourceRecommendWithOptions(shared_ptr<DescribeSceneResourceRecommendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSceneResourceRecommendResponse describeSceneResourceRecommend(shared_ptr<DescribeSceneResourceRecommendRequest> request);
  DescribeSpotInstanceAdviceResponse describeSpotInstanceAdviceWithOptions(shared_ptr<DescribeSpotInstanceAdviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSpotInstanceAdviceResponse describeSpotInstanceAdvice(shared_ptr<DescribeSpotInstanceAdviceRequest> request);
  DescribeStorageCapacityUnitAllocationsResponse describeStorageCapacityUnitAllocationsWithOptions(shared_ptr<DescribeStorageCapacityUnitAllocationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageCapacityUnitAllocationsResponse describeStorageCapacityUnitAllocations(shared_ptr<DescribeStorageCapacityUnitAllocationsRequest> request);
  DescribeStorageCapacityUnitDeductFactorResponse describeStorageCapacityUnitDeductFactorWithOptions(shared_ptr<DescribeStorageCapacityUnitDeductFactorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageCapacityUnitDeductFactorResponse describeStorageCapacityUnitDeductFactor(shared_ptr<DescribeStorageCapacityUnitDeductFactorRequest> request);
  DescribeStorageSetDetailsResponse describeStorageSetDetailsWithOptions(shared_ptr<DescribeStorageSetDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageSetDetailsResponse describeStorageSetDetails(shared_ptr<DescribeStorageSetDetailsRequest> request);
  DescribeStorageSetsResponse describeStorageSetsWithOptions(shared_ptr<DescribeStorageSetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageSetsResponse describeStorageSets(shared_ptr<DescribeStorageSetsRequest> request);
  DescribeTransitionVSwitchesResponse describeTransitionVSwitchesWithOptions(shared_ptr<DescribeTransitionVSwitchesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTransitionVSwitchesResponse describeTransitionVSwitches(shared_ptr<DescribeTransitionVSwitchesRequest> request);
  DescribeTransitionVpcAndVSwitchResponse describeTransitionVpcAndVSwitchWithOptions(shared_ptr<DescribeTransitionVpcAndVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTransitionVpcAndVSwitchResponse describeTransitionVpcAndVSwitch(shared_ptr<DescribeTransitionVpcAndVSwitchRequest> request);
  DescribeTransitionVpcsResponse describeTransitionVpcsWithOptions(shared_ptr<DescribeTransitionVpcsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTransitionVpcsResponse describeTransitionVpcs(shared_ptr<DescribeTransitionVpcsRequest> request);
  DescribeUserAvailableIpServiceProvidersResponse describeUserAvailableIpServiceProvidersWithOptions(shared_ptr<DescribeUserAvailableIpServiceProvidersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserAvailableIpServiceProvidersResponse describeUserAvailableIpServiceProviders(shared_ptr<DescribeUserAvailableIpServiceProvidersRequest> request);
  DescribeUserQuotaApplicationsResponse describeUserQuotaApplicationsWithOptions(shared_ptr<DescribeUserQuotaApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserQuotaApplicationsResponse describeUserQuotaApplications(shared_ptr<DescribeUserQuotaApplicationsRequest> request);
  DescribeVpcHavsInstancesResponse describeVpcHavsInstancesWithOptions(shared_ptr<DescribeVpcHavsInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcHavsInstancesResponse describeVpcHavsInstances(shared_ptr<DescribeVpcHavsInstancesRequest> request);
  DescribeWaitingOrdersResponse describeWaitingOrdersWithOptions(shared_ptr<DescribeWaitingOrdersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWaitingOrdersResponse describeWaitingOrders(shared_ptr<DescribeWaitingOrdersRequest> request);
  FeedbackDiagnoseResponse feedbackDiagnoseWithOptions(shared_ptr<FeedbackDiagnoseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FeedbackDiagnoseResponse feedbackDiagnose(shared_ptr<FeedbackDiagnoseRequest> request);
  GetLaunchTemplateDataResponse getLaunchTemplateDataWithOptions(shared_ptr<GetLaunchTemplateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLaunchTemplateDataResponse getLaunchTemplateData(shared_ptr<GetLaunchTemplateDataRequest> request);
  InnerDescribeNetworkInterfaceInGroupResponse innerDescribeNetworkInterfaceInGroupWithOptions(shared_ptr<InnerDescribeNetworkInterfaceInGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InnerDescribeNetworkInterfaceInGroupResponse innerDescribeNetworkInterfaceInGroup(shared_ptr<InnerDescribeNetworkInterfaceInGroupRequest> request);
  JoinEniQosGroupResponse joinEniQosGroupWithOptions(shared_ptr<JoinEniQosGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinEniQosGroupResponse joinEniQosGroup(shared_ptr<JoinEniQosGroupRequest> request);
  LeaveEniQosGroupResponse leaveEniQosGroupWithOptions(shared_ptr<LeaveEniQosGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LeaveEniQosGroupResponse leaveEniQosGroup(shared_ptr<LeaveEniQosGroupRequest> request);
  ListAccountEcsQuotasResponse listAccountEcsQuotasWithOptions(shared_ptr<ListAccountEcsQuotasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAccountEcsQuotasResponse listAccountEcsQuotas(shared_ptr<ListAccountEcsQuotasRequest> request);
  ListServiceSettingsResponse listServiceSettingsWithOptions(shared_ptr<ListServiceSettingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceSettingsResponse listServiceSettings(shared_ptr<ListServiceSettingsRequest> request);
  ModifyCapacityReservationResponse modifyCapacityReservationWithOptions(shared_ptr<ModifyCapacityReservationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCapacityReservationResponse modifyCapacityReservation(shared_ptr<ModifyCapacityReservationRequest> request);
  ModifyDedicatedHostAttributeResponse modifyDedicatedHostAttributeWithOptions(shared_ptr<ModifyDedicatedHostAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostAttributeResponse modifyDedicatedHostAttribute(shared_ptr<ModifyDedicatedHostAttributeRequest> request);
  ModifyDedicatedHostAutoReleaseTimeResponse modifyDedicatedHostAutoReleaseTimeWithOptions(shared_ptr<ModifyDedicatedHostAutoReleaseTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostAutoReleaseTimeResponse modifyDedicatedHostAutoReleaseTime(shared_ptr<ModifyDedicatedHostAutoReleaseTimeRequest> request);
  ModifyDedicatedHostAutoRenewAttributeResponse modifyDedicatedHostAutoRenewAttributeWithOptions(shared_ptr<ModifyDedicatedHostAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostAutoRenewAttributeResponse modifyDedicatedHostAutoRenewAttribute(shared_ptr<ModifyDedicatedHostAutoRenewAttributeRequest> request);
  ModifyDedicatedHostClusterAttributeResponse modifyDedicatedHostClusterAttributeWithOptions(shared_ptr<ModifyDedicatedHostClusterAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostClusterAttributeResponse modifyDedicatedHostClusterAttribute(shared_ptr<ModifyDedicatedHostClusterAttributeRequest> request);
  ModifyDiagnoseResponse modifyDiagnoseWithOptions(shared_ptr<ModifyDiagnoseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDiagnoseResponse modifyDiagnose(shared_ptr<ModifyDiagnoseRequest> request);
  ModifyDiskSpecResponse modifyDiskSpecWithOptions(shared_ptr<ModifyDiskSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDiskSpecResponse modifyDiskSpec(shared_ptr<ModifyDiskSpecRequest> request);
  ModifyEniQosGroupResponse modifyEniQosGroupWithOptions(shared_ptr<ModifyEniQosGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEniQosGroupResponse modifyEniQosGroup(shared_ptr<ModifyEniQosGroupRequest> request);
  ModifyImageAdvancedAttributeResponse modifyImageAdvancedAttributeWithOptions(shared_ptr<ModifyImageAdvancedAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageAdvancedAttributeResponse modifyImageAdvancedAttribute(shared_ptr<ModifyImageAdvancedAttributeRequest> request);
  ModifyInstanceAutoRebootTimeResponse modifyInstanceAutoRebootTimeWithOptions(shared_ptr<ModifyInstanceAutoRebootTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAutoRebootTimeResponse modifyInstanceAutoRebootTime(shared_ptr<ModifyInstanceAutoRebootTimeRequest> request);
  ModifyInstanceCapacityReservationAttributesResponse modifyInstanceCapacityReservationAttributesWithOptions(shared_ptr<ModifyInstanceCapacityReservationAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceCapacityReservationAttributesResponse modifyInstanceCapacityReservationAttributes(shared_ptr<ModifyInstanceCapacityReservationAttributesRequest> request);
  ModifyInstanceChargeTypeResponse modifyInstanceChargeTypeWithOptions(shared_ptr<ModifyInstanceChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceChargeTypeResponse modifyInstanceChargeType(shared_ptr<ModifyInstanceChargeTypeRequest> request);
  ModifyInstanceDeploymentResponse modifyInstanceDeploymentWithOptions(shared_ptr<ModifyInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceDeploymentResponse modifyInstanceDeployment(shared_ptr<ModifyInstanceDeploymentRequest> request);
  ModifyInstanceMaintenanceAttributesResponse modifyInstanceMaintenanceAttributesWithOptions(shared_ptr<ModifyInstanceMaintenanceAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceMaintenanceAttributesResponse modifyInstanceMaintenanceAttributes(shared_ptr<ModifyInstanceMaintenanceAttributesRequest> request);
  ModifyMigratableInstancesResponse modifyMigratableInstancesWithOptions(shared_ptr<ModifyMigratableInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMigratableInstancesResponse modifyMigratableInstances(shared_ptr<ModifyMigratableInstancesRequest> request);
  ModifyMigrationInstancesResponse modifyMigrationInstancesWithOptions(shared_ptr<ModifyMigrationInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMigrationInstancesResponse modifyMigrationInstances(shared_ptr<ModifyMigrationInstancesRequest> request);
  ModifyMigrationPlanResponse modifyMigrationPlanWithOptions(shared_ptr<ModifyMigrationPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMigrationPlanResponse modifyMigrationPlan(shared_ptr<ModifyMigrationPlanRequest> request);
  ModifyOrderAutoRebootTimeResponse modifyOrderAutoRebootTimeWithOptions(shared_ptr<ModifyOrderAutoRebootTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOrderAutoRebootTimeResponse modifyOrderAutoRebootTime(shared_ptr<ModifyOrderAutoRebootTimeRequest> request);
  ModifyPrivatePoolResponse modifyPrivatePoolWithOptions(shared_ptr<ModifyPrivatePoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPrivatePoolResponse modifyPrivatePool(shared_ptr<ModifyPrivatePoolRequest> request);
  ModifyReservationDemandResponse modifyReservationDemandWithOptions(shared_ptr<ModifyReservationDemandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyReservationDemandResponse modifyReservationDemand(shared_ptr<ModifyReservationDemandRequest> request);
  ModifyReservedInstanceAttributeResponse modifyReservedInstanceAttributeWithOptions(shared_ptr<ModifyReservedInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyReservedInstanceAttributeResponse modifyReservedInstanceAttribute(shared_ptr<ModifyReservedInstanceAttributeRequest> request);
  ModifyReservedInstancesResponse modifyReservedInstancesWithOptions(shared_ptr<ModifyReservedInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyReservedInstancesResponse modifyReservedInstances(shared_ptr<ModifyReservedInstancesRequest> request);
  ModifyResourceDiagnosisStatusResponse modifyResourceDiagnosisStatusWithOptions(shared_ptr<ModifyResourceDiagnosisStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyResourceDiagnosisStatusResponse modifyResourceDiagnosisStatus(shared_ptr<ModifyResourceDiagnosisStatusRequest> request);
  ModifyResourceMetaResponse modifyResourceMetaWithOptions(shared_ptr<ModifyResourceMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyResourceMetaResponse modifyResourceMeta(shared_ptr<ModifyResourceMetaRequest> request);
  ModifyStorageSetAttributeResponse modifyStorageSetAttributeWithOptions(shared_ptr<ModifyStorageSetAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStorageSetAttributeResponse modifyStorageSetAttribute(shared_ptr<ModifyStorageSetAttributeRequest> request);
  ModifyWaitingOrderResponse modifyWaitingOrderWithOptions(shared_ptr<ModifyWaitingOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWaitingOrderResponse modifyWaitingOrder(shared_ptr<ModifyWaitingOrderRequest> request);
  PurchaseReservedInstancesOfferingResponse purchaseReservedInstancesOfferingWithOptions(shared_ptr<PurchaseReservedInstancesOfferingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PurchaseReservedInstancesOfferingResponse purchaseReservedInstancesOffering(shared_ptr<PurchaseReservedInstancesOfferingRequest> request);
  PurchaseSavingPlanOfferingResponse purchaseSavingPlanOfferingWithOptions(shared_ptr<PurchaseSavingPlanOfferingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PurchaseSavingPlanOfferingResponse purchaseSavingPlanOffering(shared_ptr<PurchaseSavingPlanOfferingRequest> request);
  PurchaseStorageCapacityUnitResponse purchaseStorageCapacityUnitWithOptions(shared_ptr<PurchaseStorageCapacityUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PurchaseStorageCapacityUnitResponse purchaseStorageCapacityUnit(shared_ptr<PurchaseStorageCapacityUnitRequest> request);
  QueryEniQosGroupByEniResponse queryEniQosGroupByEniWithOptions(shared_ptr<QueryEniQosGroupByEniRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEniQosGroupByEniResponse queryEniQosGroupByEni(shared_ptr<QueryEniQosGroupByEniRequest> request);
  QueryEniQosGroupByInstanceResponse queryEniQosGroupByInstanceWithOptions(shared_ptr<QueryEniQosGroupByInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEniQosGroupByInstanceResponse queryEniQosGroupByInstance(shared_ptr<QueryEniQosGroupByInstanceRequest> request);
  ReAddMigrationTaskInPlanResponse reAddMigrationTaskInPlanWithOptions(shared_ptr<ReAddMigrationTaskInPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReAddMigrationTaskInPlanResponse reAddMigrationTaskInPlan(shared_ptr<ReAddMigrationTaskInPlanRequest> request);
  ReleaseCapacityReservationResponse releaseCapacityReservationWithOptions(shared_ptr<ReleaseCapacityReservationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseCapacityReservationResponse releaseCapacityReservation(shared_ptr<ReleaseCapacityReservationRequest> request);
  ReleaseDedicatedHostResponse releaseDedicatedHostWithOptions(shared_ptr<ReleaseDedicatedHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseDedicatedHostResponse releaseDedicatedHost(shared_ptr<ReleaseDedicatedHostRequest> request);
  RenewDedicatedHostsResponse renewDedicatedHostsWithOptions(shared_ptr<RenewDedicatedHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewDedicatedHostsResponse renewDedicatedHosts(shared_ptr<RenewDedicatedHostsRequest> request);
  ReviewDiagnosticReportResponse reviewDiagnosticReportWithOptions(shared_ptr<ReviewDiagnosticReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReviewDiagnosticReportResponse reviewDiagnosticReport(shared_ptr<ReviewDiagnosticReportRequest> request);
  RunInstancesResponse runInstancesWithOptions(shared_ptr<RunInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunInstancesResponse runInstances(shared_ptr<RunInstancesRequest> request);
  SetInstanceAutoReleaseTimeResponse setInstanceAutoReleaseTimeWithOptions(shared_ptr<SetInstanceAutoReleaseTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetInstanceAutoReleaseTimeResponse setInstanceAutoReleaseTime(shared_ptr<SetInstanceAutoReleaseTimeRequest> request);
  StartNetworkInsightsAnalysisResponse startNetworkInsightsAnalysisWithOptions(shared_ptr<StartNetworkInsightsAnalysisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartNetworkInsightsAnalysisResponse startNetworkInsightsAnalysis(shared_ptr<StartNetworkInsightsAnalysisRequest> request);
  UpdateServiceSettingsResponse updateServiceSettingsWithOptions(shared_ptr<UpdateServiceSettingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateServiceSettingsResponse updateServiceSettings(shared_ptr<UpdateServiceSettingsRequest> request);
  UnmountPEDiskResponse unmountPEDiskWithOptions(shared_ptr<UnmountPEDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnmountPEDiskResponse unmountPEDisk(shared_ptr<UnmountPEDiskRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ecs20160314

#endif
