// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ESA20240910_H_
#define ALIBABACLOUD_ESA20240910_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_ESA20240910 {
class WafBatchRuleSharedActionsResponse : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> id{};

  WafBatchRuleSharedActionsResponse() {}

  explicit WafBatchRuleSharedActionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~WafBatchRuleSharedActionsResponse() = default;
};
class WafBatchRuleSharedActions : public Darabonba::Model {
public:
  shared_ptr<WafBatchRuleSharedActionsResponse> response{};

  WafBatchRuleSharedActions() {}

  explicit WafBatchRuleSharedActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (response) {
      res["Response"] = response ? boost::any(response->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Response") != m.end() && !m["Response"].empty()) {
      if (typeid(map<string, boost::any>) == m["Response"].type()) {
        WafBatchRuleSharedActionsResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Response"]));
        response = make_shared<WafBatchRuleSharedActionsResponse>(model1);
      }
    }
  }


  virtual ~WafBatchRuleSharedActions() = default;
};
class WafRuleMatch2CriteriaCriteriaCriteria : public Darabonba::Model {
public:
  shared_ptr<bool> convertToLower{};
  shared_ptr<string> matchOperator{};
  shared_ptr<string> matchType{};
  shared_ptr<boost::any> matchValue{};
  shared_ptr<bool> negate{};

  WafRuleMatch2CriteriaCriteriaCriteria() {}

  explicit WafRuleMatch2CriteriaCriteriaCriteria(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (convertToLower) {
      res["ConvertToLower"] = boost::any(*convertToLower);
    }
    if (matchOperator) {
      res["MatchOperator"] = boost::any(*matchOperator);
    }
    if (matchType) {
      res["MatchType"] = boost::any(*matchType);
    }
    if (matchValue) {
      res["MatchValue"] = boost::any(*matchValue);
    }
    if (negate) {
      res["Negate"] = boost::any(*negate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConvertToLower") != m.end() && !m["ConvertToLower"].empty()) {
      convertToLower = make_shared<bool>(boost::any_cast<bool>(m["ConvertToLower"]));
    }
    if (m.find("MatchOperator") != m.end() && !m["MatchOperator"].empty()) {
      matchOperator = make_shared<string>(boost::any_cast<string>(m["MatchOperator"]));
    }
    if (m.find("MatchType") != m.end() && !m["MatchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["MatchType"]));
    }
    if (m.find("MatchValue") != m.end() && !m["MatchValue"].empty()) {
      matchValue = make_shared<boost::any>(boost::any_cast<boost::any>(m["MatchValue"]));
    }
    if (m.find("Negate") != m.end() && !m["Negate"].empty()) {
      negate = make_shared<bool>(boost::any_cast<bool>(m["Negate"]));
    }
  }


  virtual ~WafRuleMatch2CriteriaCriteriaCriteria() = default;
};
class WafRuleMatch2CriteriaCriteria : public Darabonba::Model {
public:
  shared_ptr<bool> convertToLower{};
  shared_ptr<vector<WafRuleMatch2CriteriaCriteriaCriteria>> criteria{};
  shared_ptr<string> logic{};
  shared_ptr<string> matchOperator{};
  shared_ptr<string> matchType{};
  shared_ptr<boost::any> matchValue{};
  shared_ptr<bool> negate{};

  WafRuleMatch2CriteriaCriteria() {}

  explicit WafRuleMatch2CriteriaCriteria(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (convertToLower) {
      res["ConvertToLower"] = boost::any(*convertToLower);
    }
    if (criteria) {
      vector<boost::any> temp1;
      for(auto item1:*criteria){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Criteria"] = boost::any(temp1);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (matchOperator) {
      res["MatchOperator"] = boost::any(*matchOperator);
    }
    if (matchType) {
      res["MatchType"] = boost::any(*matchType);
    }
    if (matchValue) {
      res["MatchValue"] = boost::any(*matchValue);
    }
    if (negate) {
      res["Negate"] = boost::any(*negate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConvertToLower") != m.end() && !m["ConvertToLower"].empty()) {
      convertToLower = make_shared<bool>(boost::any_cast<bool>(m["ConvertToLower"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      if (typeid(vector<boost::any>) == m["Criteria"].type()) {
        vector<WafRuleMatch2CriteriaCriteriaCriteria> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Criteria"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleMatch2CriteriaCriteriaCriteria model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteria = make_shared<vector<WafRuleMatch2CriteriaCriteriaCriteria>>(expect1);
      }
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<string>(boost::any_cast<string>(m["Logic"]));
    }
    if (m.find("MatchOperator") != m.end() && !m["MatchOperator"].empty()) {
      matchOperator = make_shared<string>(boost::any_cast<string>(m["MatchOperator"]));
    }
    if (m.find("MatchType") != m.end() && !m["MatchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["MatchType"]));
    }
    if (m.find("MatchValue") != m.end() && !m["MatchValue"].empty()) {
      matchValue = make_shared<boost::any>(boost::any_cast<boost::any>(m["MatchValue"]));
    }
    if (m.find("Negate") != m.end() && !m["Negate"].empty()) {
      negate = make_shared<bool>(boost::any_cast<bool>(m["Negate"]));
    }
  }


  virtual ~WafRuleMatch2CriteriaCriteria() = default;
};
class WafRuleMatch2Criteria : public Darabonba::Model {
public:
  shared_ptr<bool> convertToLower{};
  shared_ptr<vector<WafRuleMatch2CriteriaCriteria>> criteria{};
  shared_ptr<string> logic{};
  shared_ptr<string> matchOperator{};
  shared_ptr<string> matchType{};
  shared_ptr<boost::any> matchValue{};
  shared_ptr<bool> negate{};

  WafRuleMatch2Criteria() {}

  explicit WafRuleMatch2Criteria(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (convertToLower) {
      res["ConvertToLower"] = boost::any(*convertToLower);
    }
    if (criteria) {
      vector<boost::any> temp1;
      for(auto item1:*criteria){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Criteria"] = boost::any(temp1);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (matchOperator) {
      res["MatchOperator"] = boost::any(*matchOperator);
    }
    if (matchType) {
      res["MatchType"] = boost::any(*matchType);
    }
    if (matchValue) {
      res["MatchValue"] = boost::any(*matchValue);
    }
    if (negate) {
      res["Negate"] = boost::any(*negate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConvertToLower") != m.end() && !m["ConvertToLower"].empty()) {
      convertToLower = make_shared<bool>(boost::any_cast<bool>(m["ConvertToLower"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      if (typeid(vector<boost::any>) == m["Criteria"].type()) {
        vector<WafRuleMatch2CriteriaCriteria> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Criteria"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleMatch2CriteriaCriteria model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteria = make_shared<vector<WafRuleMatch2CriteriaCriteria>>(expect1);
      }
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<string>(boost::any_cast<string>(m["Logic"]));
    }
    if (m.find("MatchOperator") != m.end() && !m["MatchOperator"].empty()) {
      matchOperator = make_shared<string>(boost::any_cast<string>(m["MatchOperator"]));
    }
    if (m.find("MatchType") != m.end() && !m["MatchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["MatchType"]));
    }
    if (m.find("MatchValue") != m.end() && !m["MatchValue"].empty()) {
      matchValue = make_shared<boost::any>(boost::any_cast<boost::any>(m["MatchValue"]));
    }
    if (m.find("Negate") != m.end() && !m["Negate"].empty()) {
      negate = make_shared<bool>(boost::any_cast<bool>(m["Negate"]));
    }
  }


  virtual ~WafRuleMatch2Criteria() = default;
};
class WafRuleMatch2 : public Darabonba::Model {
public:
  shared_ptr<bool> convertToLower{};
  shared_ptr<vector<WafRuleMatch2Criteria>> criteria{};
  shared_ptr<string> logic{};
  shared_ptr<string> matchOperator{};
  shared_ptr<string> matchType{};
  shared_ptr<boost::any> matchValue{};
  shared_ptr<bool> negate{};

  WafRuleMatch2() {}

  explicit WafRuleMatch2(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (convertToLower) {
      res["ConvertToLower"] = boost::any(*convertToLower);
    }
    if (criteria) {
      vector<boost::any> temp1;
      for(auto item1:*criteria){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Criteria"] = boost::any(temp1);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (matchOperator) {
      res["MatchOperator"] = boost::any(*matchOperator);
    }
    if (matchType) {
      res["MatchType"] = boost::any(*matchType);
    }
    if (matchValue) {
      res["MatchValue"] = boost::any(*matchValue);
    }
    if (negate) {
      res["Negate"] = boost::any(*negate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConvertToLower") != m.end() && !m["ConvertToLower"].empty()) {
      convertToLower = make_shared<bool>(boost::any_cast<bool>(m["ConvertToLower"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      if (typeid(vector<boost::any>) == m["Criteria"].type()) {
        vector<WafRuleMatch2Criteria> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Criteria"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleMatch2Criteria model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteria = make_shared<vector<WafRuleMatch2Criteria>>(expect1);
      }
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<string>(boost::any_cast<string>(m["Logic"]));
    }
    if (m.find("MatchOperator") != m.end() && !m["MatchOperator"].empty()) {
      matchOperator = make_shared<string>(boost::any_cast<string>(m["MatchOperator"]));
    }
    if (m.find("MatchType") != m.end() && !m["MatchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["MatchType"]));
    }
    if (m.find("MatchValue") != m.end() && !m["MatchValue"].empty()) {
      matchValue = make_shared<boost::any>(boost::any_cast<boost::any>(m["MatchValue"]));
    }
    if (m.find("Negate") != m.end() && !m["Negate"].empty()) {
      negate = make_shared<bool>(boost::any_cast<bool>(m["Negate"]));
    }
  }


  virtual ~WafRuleMatch2() = default;
};
class WafBatchRuleShared : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<WafBatchRuleSharedActions> actions{};
  shared_ptr<long> crossSiteId{};
  shared_ptr<string> expression{};
  shared_ptr<WafRuleMatch2> match{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<string> target{};

  WafBatchRuleShared() {}

  explicit WafBatchRuleShared(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (actions) {
      res["Actions"] = actions ? boost::any(actions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (crossSiteId) {
      res["CrossSiteId"] = boost::any(*crossSiteId);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (match) {
      res["Match"] = match ? boost::any(match->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Actions"].type()) {
        WafBatchRuleSharedActions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Actions"]));
        actions = make_shared<WafBatchRuleSharedActions>(model1);
      }
    }
    if (m.find("CrossSiteId") != m.end() && !m["CrossSiteId"].empty()) {
      crossSiteId = make_shared<long>(boost::any_cast<long>(m["CrossSiteId"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Match") != m.end() && !m["Match"].empty()) {
      if (typeid(map<string, boost::any>) == m["Match"].type()) {
        WafRuleMatch2 model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Match"]));
        match = make_shared<WafRuleMatch2>(model1);
      }
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~WafBatchRuleShared() = default;
};
class WafQuotaInteger : public Darabonba::Model {
public:
  shared_ptr<long> equal{};
  shared_ptr<long> greaterThan{};
  shared_ptr<long> greaterThanOrEqual{};
  shared_ptr<long> lessThan{};
  shared_ptr<long> lessThanOrEqual{};

  WafQuotaInteger() {}

  explicit WafQuotaInteger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (equal) {
      res["Equal"] = boost::any(*equal);
    }
    if (greaterThan) {
      res["GreaterThan"] = boost::any(*greaterThan);
    }
    if (greaterThanOrEqual) {
      res["GreaterThanOrEqual"] = boost::any(*greaterThanOrEqual);
    }
    if (lessThan) {
      res["LessThan"] = boost::any(*lessThan);
    }
    if (lessThanOrEqual) {
      res["LessThanOrEqual"] = boost::any(*lessThanOrEqual);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Equal") != m.end() && !m["Equal"].empty()) {
      equal = make_shared<long>(boost::any_cast<long>(m["Equal"]));
    }
    if (m.find("GreaterThan") != m.end() && !m["GreaterThan"].empty()) {
      greaterThan = make_shared<long>(boost::any_cast<long>(m["GreaterThan"]));
    }
    if (m.find("GreaterThanOrEqual") != m.end() && !m["GreaterThanOrEqual"].empty()) {
      greaterThanOrEqual = make_shared<long>(boost::any_cast<long>(m["GreaterThanOrEqual"]));
    }
    if (m.find("LessThan") != m.end() && !m["LessThan"].empty()) {
      lessThan = make_shared<long>(boost::any_cast<long>(m["LessThan"]));
    }
    if (m.find("LessThanOrEqual") != m.end() && !m["LessThanOrEqual"].empty()) {
      lessThanOrEqual = make_shared<long>(boost::any_cast<long>(m["LessThanOrEqual"]));
    }
  }


  virtual ~WafQuotaInteger() = default;
};
class WafQuotaString : public Darabonba::Model {
public:
  shared_ptr<string> regexp{};

  WafQuotaString() {}

  explicit WafQuotaString(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regexp) {
      res["Regexp"] = boost::any(*regexp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regexp") != m.end() && !m["Regexp"].empty()) {
      regexp = make_shared<string>(boost::any_cast<string>(m["Regexp"]));
    }
  }


  virtual ~WafQuotaString() = default;
};
class WafRuleConfigActionsBypass : public Darabonba::Model {
public:
  shared_ptr<vector<long>> customRules{};
  shared_ptr<vector<long>> regularRules{};
  shared_ptr<vector<string>> regularTypes{};
  shared_ptr<string> skip{};
  shared_ptr<vector<string>> tags{};

  WafRuleConfigActionsBypass() {}

  explicit WafRuleConfigActionsBypass(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customRules) {
      res["CustomRules"] = boost::any(*customRules);
    }
    if (regularRules) {
      res["RegularRules"] = boost::any(*regularRules);
    }
    if (regularTypes) {
      res["RegularTypes"] = boost::any(*regularTypes);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomRules") != m.end() && !m["CustomRules"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CustomRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      customRules = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegularRules") != m.end() && !m["RegularRules"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RegularRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegularRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      regularRules = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegularTypes") != m.end() && !m["RegularTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegularTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegularTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regularTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<string>(boost::any_cast<string>(m["Skip"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~WafRuleConfigActionsBypass() = default;
};
class WafRuleConfigActionsResponse : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> id{};

  WafRuleConfigActionsResponse() {}

  explicit WafRuleConfigActionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~WafRuleConfigActionsResponse() = default;
};
class WafRuleConfigActions : public Darabonba::Model {
public:
  shared_ptr<WafRuleConfigActionsBypass> bypass{};
  shared_ptr<WafRuleConfigActionsResponse> response{};

  WafRuleConfigActions() {}

  explicit WafRuleConfigActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bypass) {
      res["Bypass"] = bypass ? boost::any(bypass->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (response) {
      res["Response"] = response ? boost::any(response->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bypass") != m.end() && !m["Bypass"].empty()) {
      if (typeid(map<string, boost::any>) == m["Bypass"].type()) {
        WafRuleConfigActionsBypass model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Bypass"]));
        bypass = make_shared<WafRuleConfigActionsBypass>(model1);
      }
    }
    if (m.find("Response") != m.end() && !m["Response"].empty()) {
      if (typeid(map<string, boost::any>) == m["Response"].type()) {
        WafRuleConfigActionsResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Response"]));
        response = make_shared<WafRuleConfigActionsResponse>(model1);
      }
    }
  }


  virtual ~WafRuleConfigActions() = default;
};
class WafRuleConfigAppPackagePackageSigns : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> sign{};

  WafRuleConfigAppPackagePackageSigns() {}

  explicit WafRuleConfigAppPackagePackageSigns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
  }


  virtual ~WafRuleConfigAppPackagePackageSigns() = default;
};
class WafRuleConfigAppPackage : public Darabonba::Model {
public:
  shared_ptr<vector<WafRuleConfigAppPackagePackageSigns>> packageSigns{};

  WafRuleConfigAppPackage() {}

  explicit WafRuleConfigAppPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageSigns) {
      vector<boost::any> temp1;
      for(auto item1:*packageSigns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PackageSigns"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageSigns") != m.end() && !m["PackageSigns"].empty()) {
      if (typeid(vector<boost::any>) == m["PackageSigns"].type()) {
        vector<WafRuleConfigAppPackagePackageSigns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PackageSigns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleConfigAppPackagePackageSigns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packageSigns = make_shared<vector<WafRuleConfigAppPackagePackageSigns>>(expect1);
      }
    }
  }


  virtual ~WafRuleConfigAppPackage() = default;
};
class WafRuleConfigAppSdkCustomSign : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  WafRuleConfigAppSdkCustomSign() {}

  explicit WafRuleConfigAppSdkCustomSign(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~WafRuleConfigAppSdkCustomSign() = default;
};
class WafRuleConfigAppSdk : public Darabonba::Model {
public:
  shared_ptr<WafRuleConfigAppSdkCustomSign> customSign{};
  shared_ptr<string> customSignStatus{};
  shared_ptr<vector<string>> featureAbnormal{};

  WafRuleConfigAppSdk() {}

  explicit WafRuleConfigAppSdk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSign) {
      res["CustomSign"] = customSign ? boost::any(customSign->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customSignStatus) {
      res["CustomSignStatus"] = boost::any(*customSignStatus);
    }
    if (featureAbnormal) {
      res["FeatureAbnormal"] = boost::any(*featureAbnormal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSign") != m.end() && !m["CustomSign"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSign"].type()) {
        WafRuleConfigAppSdkCustomSign model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSign"]));
        customSign = make_shared<WafRuleConfigAppSdkCustomSign>(model1);
      }
    }
    if (m.find("CustomSignStatus") != m.end() && !m["CustomSignStatus"].empty()) {
      customSignStatus = make_shared<string>(boost::any_cast<string>(m["CustomSignStatus"]));
    }
    if (m.find("FeatureAbnormal") != m.end() && !m["FeatureAbnormal"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FeatureAbnormal"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FeatureAbnormal"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      featureAbnormal = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~WafRuleConfigAppSdk() = default;
};
class WafRuleConfigManagedRulesetsManagedRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<long> id{};
  shared_ptr<string> status{};

  WafRuleConfigManagedRulesetsManagedRules() {}

  explicit WafRuleConfigManagedRulesetsManagedRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~WafRuleConfigManagedRulesetsManagedRules() = default;
};
class WafRuleConfigManagedRulesets : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<long> attackType{};
  shared_ptr<vector<WafRuleConfigManagedRulesetsManagedRules>> managedRules{};
  shared_ptr<long> numberEnabled{};
  shared_ptr<long> numberTotal{};
  shared_ptr<long> protectionLevel{};

  WafRuleConfigManagedRulesets() {}

  explicit WafRuleConfigManagedRulesets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (attackType) {
      res["AttackType"] = boost::any(*attackType);
    }
    if (managedRules) {
      vector<boost::any> temp1;
      for(auto item1:*managedRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedRules"] = boost::any(temp1);
    }
    if (numberEnabled) {
      res["NumberEnabled"] = boost::any(*numberEnabled);
    }
    if (numberTotal) {
      res["NumberTotal"] = boost::any(*numberTotal);
    }
    if (protectionLevel) {
      res["ProtectionLevel"] = boost::any(*protectionLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("AttackType") != m.end() && !m["AttackType"].empty()) {
      attackType = make_shared<long>(boost::any_cast<long>(m["AttackType"]));
    }
    if (m.find("ManagedRules") != m.end() && !m["ManagedRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedRules"].type()) {
        vector<WafRuleConfigManagedRulesetsManagedRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleConfigManagedRulesetsManagedRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedRules = make_shared<vector<WafRuleConfigManagedRulesetsManagedRules>>(expect1);
      }
    }
    if (m.find("NumberEnabled") != m.end() && !m["NumberEnabled"].empty()) {
      numberEnabled = make_shared<long>(boost::any_cast<long>(m["NumberEnabled"]));
    }
    if (m.find("NumberTotal") != m.end() && !m["NumberTotal"].empty()) {
      numberTotal = make_shared<long>(boost::any_cast<long>(m["NumberTotal"]));
    }
    if (m.find("ProtectionLevel") != m.end() && !m["ProtectionLevel"].empty()) {
      protectionLevel = make_shared<long>(boost::any_cast<long>(m["ProtectionLevel"]));
    }
  }


  virtual ~WafRuleConfigManagedRulesets() = default;
};
class WafRuleConfigRateLimitThresholdResponseStatus : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> count{};
  shared_ptr<long> ratio{};

  WafRuleConfigRateLimitThresholdResponseStatus() {}

  explicit WafRuleConfigRateLimitThresholdResponseStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<long>(boost::any_cast<long>(m["Ratio"]));
    }
  }


  virtual ~WafRuleConfigRateLimitThresholdResponseStatus() = default;
};
class WafRuleConfigRateLimitThreshold : public Darabonba::Model {
public:
  shared_ptr<long> distinctManagedRules{};
  shared_ptr<long> managedRulesBlocked{};
  shared_ptr<long> request{};
  shared_ptr<WafRuleConfigRateLimitThresholdResponseStatus> responseStatus{};
  shared_ptr<string> traffic{};

  WafRuleConfigRateLimitThreshold() {}

  explicit WafRuleConfigRateLimitThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distinctManagedRules) {
      res["DistinctManagedRules"] = boost::any(*distinctManagedRules);
    }
    if (managedRulesBlocked) {
      res["ManagedRulesBlocked"] = boost::any(*managedRulesBlocked);
    }
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (responseStatus) {
      res["ResponseStatus"] = responseStatus ? boost::any(responseStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (traffic) {
      res["Traffic"] = boost::any(*traffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistinctManagedRules") != m.end() && !m["DistinctManagedRules"].empty()) {
      distinctManagedRules = make_shared<long>(boost::any_cast<long>(m["DistinctManagedRules"]));
    }
    if (m.find("ManagedRulesBlocked") != m.end() && !m["ManagedRulesBlocked"].empty()) {
      managedRulesBlocked = make_shared<long>(boost::any_cast<long>(m["ManagedRulesBlocked"]));
    }
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      request = make_shared<long>(boost::any_cast<long>(m["Request"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResponseStatus"].type()) {
        WafRuleConfigRateLimitThresholdResponseStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResponseStatus"]));
        responseStatus = make_shared<WafRuleConfigRateLimitThresholdResponseStatus>(model1);
      }
    }
    if (m.find("Traffic") != m.end() && !m["Traffic"].empty()) {
      traffic = make_shared<string>(boost::any_cast<string>(m["Traffic"]));
    }
  }


  virtual ~WafRuleConfigRateLimitThreshold() = default;
};
class WafRuleConfigRateLimit : public Darabonba::Model {
public:
  shared_ptr<WafRuleMatch2> characteristics{};
  shared_ptr<long> interval{};
  shared_ptr<bool> onHit{};
  shared_ptr<long> TTL{};
  shared_ptr<WafRuleConfigRateLimitThreshold> threshold{};

  WafRuleConfigRateLimit() {}

  explicit WafRuleConfigRateLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (characteristics) {
      res["Characteristics"] = characteristics ? boost::any(characteristics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (onHit) {
      res["OnHit"] = boost::any(*onHit);
    }
    if (TTL) {
      res["TTL"] = boost::any(*TTL);
    }
    if (threshold) {
      res["Threshold"] = threshold ? boost::any(threshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Characteristics") != m.end() && !m["Characteristics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Characteristics"].type()) {
        WafRuleMatch2 model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Characteristics"]));
        characteristics = make_shared<WafRuleMatch2>(model1);
      }
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OnHit") != m.end() && !m["OnHit"].empty()) {
      onHit = make_shared<bool>(boost::any_cast<bool>(m["OnHit"]));
    }
    if (m.find("TTL") != m.end() && !m["TTL"].empty()) {
      TTL = make_shared<long>(boost::any_cast<long>(m["TTL"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["Threshold"].type()) {
        WafRuleConfigRateLimitThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Threshold"]));
        threshold = make_shared<WafRuleConfigRateLimitThreshold>(model1);
      }
    }
  }


  virtual ~WafRuleConfigRateLimit() = default;
};
class WafRuleMatch : public Darabonba::Model {
public:
  shared_ptr<bool> convertToLower{};
  shared_ptr<vector<WafRuleMatch>> criteria{};
  shared_ptr<string> logic{};
  shared_ptr<string> matchOperator{};
  shared_ptr<string> matchType{};
  shared_ptr<boost::any> matchValue{};
  shared_ptr<bool> negate{};

  WafRuleMatch() {}

  explicit WafRuleMatch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (convertToLower) {
      res["ConvertToLower"] = boost::any(*convertToLower);
    }
    if (criteria) {
      vector<boost::any> temp1;
      for(auto item1:*criteria){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Criteria"] = boost::any(temp1);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (matchOperator) {
      res["MatchOperator"] = boost::any(*matchOperator);
    }
    if (matchType) {
      res["MatchType"] = boost::any(*matchType);
    }
    if (matchValue) {
      res["MatchValue"] = boost::any(*matchValue);
    }
    if (negate) {
      res["Negate"] = boost::any(*negate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConvertToLower") != m.end() && !m["ConvertToLower"].empty()) {
      convertToLower = make_shared<bool>(boost::any_cast<bool>(m["ConvertToLower"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      if (typeid(vector<boost::any>) == m["Criteria"].type()) {
        vector<WafRuleMatch> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Criteria"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleMatch model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteria = make_shared<vector<WafRuleMatch>>(expect1);
      }
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<string>(boost::any_cast<string>(m["Logic"]));
    }
    if (m.find("MatchOperator") != m.end() && !m["MatchOperator"].empty()) {
      matchOperator = make_shared<string>(boost::any_cast<string>(m["MatchOperator"]));
    }
    if (m.find("MatchType") != m.end() && !m["MatchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["MatchType"]));
    }
    if (m.find("MatchValue") != m.end() && !m["MatchValue"].empty()) {
      matchValue = make_shared<boost::any>(boost::any_cast<boost::any>(m["MatchValue"]));
    }
    if (m.find("Negate") != m.end() && !m["Negate"].empty()) {
      negate = make_shared<bool>(boost::any_cast<bool>(m["Negate"]));
    }
  }


  virtual ~WafRuleMatch() = default;
};
class WafTimerPeriods : public Darabonba::Model {
public:
  shared_ptr<string> end{};
  shared_ptr<string> start{};

  WafTimerPeriods() {}

  explicit WafTimerPeriods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~WafTimerPeriods() = default;
};
class WafTimerWeeklyPeriodsDailyPeriods : public Darabonba::Model {
public:
  shared_ptr<string> end{};
  shared_ptr<string> start{};

  WafTimerWeeklyPeriodsDailyPeriods() {}

  explicit WafTimerWeeklyPeriodsDailyPeriods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~WafTimerWeeklyPeriodsDailyPeriods() = default;
};
class WafTimerWeeklyPeriods : public Darabonba::Model {
public:
  shared_ptr<vector<WafTimerWeeklyPeriodsDailyPeriods>> dailyPeriods{};
  shared_ptr<string> days{};

  WafTimerWeeklyPeriods() {}

  explicit WafTimerWeeklyPeriods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dailyPeriods) {
      vector<boost::any> temp1;
      for(auto item1:*dailyPeriods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DailyPeriods"] = boost::any(temp1);
    }
    if (days) {
      res["Days"] = boost::any(*days);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DailyPeriods") != m.end() && !m["DailyPeriods"].empty()) {
      if (typeid(vector<boost::any>) == m["DailyPeriods"].type()) {
        vector<WafTimerWeeklyPeriodsDailyPeriods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DailyPeriods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafTimerWeeklyPeriodsDailyPeriods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dailyPeriods = make_shared<vector<WafTimerWeeklyPeriodsDailyPeriods>>(expect1);
      }
    }
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      days = make_shared<string>(boost::any_cast<string>(m["Days"]));
    }
  }


  virtual ~WafTimerWeeklyPeriods() = default;
};
class WafTimer : public Darabonba::Model {
public:
  shared_ptr<vector<WafTimerPeriods>> periods{};
  shared_ptr<string> scopes{};
  shared_ptr<vector<WafTimerWeeklyPeriods>> weeklyPeriods{};
  shared_ptr<long> zone{};

  WafTimer() {}

  explicit WafTimer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periods) {
      vector<boost::any> temp1;
      for(auto item1:*periods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Periods"] = boost::any(temp1);
    }
    if (scopes) {
      res["Scopes"] = boost::any(*scopes);
    }
    if (weeklyPeriods) {
      vector<boost::any> temp1;
      for(auto item1:*weeklyPeriods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WeeklyPeriods"] = boost::any(temp1);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Periods") != m.end() && !m["Periods"].empty()) {
      if (typeid(vector<boost::any>) == m["Periods"].type()) {
        vector<WafTimerPeriods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Periods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafTimerPeriods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        periods = make_shared<vector<WafTimerPeriods>>(expect1);
      }
    }
    if (m.find("Scopes") != m.end() && !m["Scopes"].empty()) {
      scopes = make_shared<string>(boost::any_cast<string>(m["Scopes"]));
    }
    if (m.find("WeeklyPeriods") != m.end() && !m["WeeklyPeriods"].empty()) {
      if (typeid(vector<boost::any>) == m["WeeklyPeriods"].type()) {
        vector<WafTimerWeeklyPeriods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WeeklyPeriods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafTimerWeeklyPeriods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        weeklyPeriods = make_shared<vector<WafTimerWeeklyPeriods>>(expect1);
      }
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<long>(boost::any_cast<long>(m["Zone"]));
    }
  }


  virtual ~WafTimer() = default;
};
class WafRuleConfig : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<WafRuleConfigActions> actions{};
  shared_ptr<WafRuleConfigAppPackage> appPackage{};
  shared_ptr<WafRuleConfigAppSdk> appSdk{};
  shared_ptr<string> expression{};
  shared_ptr<long> id{};
  shared_ptr<long> managedGroupId{};
  shared_ptr<string> managedList{};
  shared_ptr<vector<WafRuleConfigManagedRulesets>> managedRulesets{};
  shared_ptr<WafRuleMatch> match{};
  shared_ptr<string> name{};
  shared_ptr<WafRuleConfigRateLimit> rateLimit{};
  shared_ptr<vector<string>> sigchl{};
  shared_ptr<string> status{};
  shared_ptr<WafTimer> timer{};
  shared_ptr<string> type{};

  WafRuleConfig() {}

  explicit WafRuleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (actions) {
      res["Actions"] = actions ? boost::any(actions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appPackage) {
      res["AppPackage"] = appPackage ? boost::any(appPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appSdk) {
      res["AppSdk"] = appSdk ? boost::any(appSdk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (managedGroupId) {
      res["ManagedGroupId"] = boost::any(*managedGroupId);
    }
    if (managedList) {
      res["ManagedList"] = boost::any(*managedList);
    }
    if (managedRulesets) {
      vector<boost::any> temp1;
      for(auto item1:*managedRulesets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedRulesets"] = boost::any(temp1);
    }
    if (match) {
      res["Match"] = match ? boost::any(match->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rateLimit) {
      res["RateLimit"] = rateLimit ? boost::any(rateLimit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sigchl) {
      res["Sigchl"] = boost::any(*sigchl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timer) {
      res["Timer"] = timer ? boost::any(timer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Actions"].type()) {
        WafRuleConfigActions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Actions"]));
        actions = make_shared<WafRuleConfigActions>(model1);
      }
    }
    if (m.find("AppPackage") != m.end() && !m["AppPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppPackage"].type()) {
        WafRuleConfigAppPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppPackage"]));
        appPackage = make_shared<WafRuleConfigAppPackage>(model1);
      }
    }
    if (m.find("AppSdk") != m.end() && !m["AppSdk"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppSdk"].type()) {
        WafRuleConfigAppSdk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppSdk"]));
        appSdk = make_shared<WafRuleConfigAppSdk>(model1);
      }
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ManagedGroupId") != m.end() && !m["ManagedGroupId"].empty()) {
      managedGroupId = make_shared<long>(boost::any_cast<long>(m["ManagedGroupId"]));
    }
    if (m.find("ManagedList") != m.end() && !m["ManagedList"].empty()) {
      managedList = make_shared<string>(boost::any_cast<string>(m["ManagedList"]));
    }
    if (m.find("ManagedRulesets") != m.end() && !m["ManagedRulesets"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedRulesets"].type()) {
        vector<WafRuleConfigManagedRulesets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedRulesets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleConfigManagedRulesets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedRulesets = make_shared<vector<WafRuleConfigManagedRulesets>>(expect1);
      }
    }
    if (m.find("Match") != m.end() && !m["Match"].empty()) {
      if (typeid(map<string, boost::any>) == m["Match"].type()) {
        WafRuleMatch model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Match"]));
        match = make_shared<WafRuleMatch>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RateLimit") != m.end() && !m["RateLimit"].empty()) {
      if (typeid(map<string, boost::any>) == m["RateLimit"].type()) {
        WafRuleConfigRateLimit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RateLimit"]));
        rateLimit = make_shared<WafRuleConfigRateLimit>(model1);
      }
    }
    if (m.find("Sigchl") != m.end() && !m["Sigchl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sigchl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sigchl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sigchl = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Timer") != m.end() && !m["Timer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timer"].type()) {
        WafTimer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timer"]));
        timer = make_shared<WafTimer>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~WafRuleConfig() = default;
};
class WafSiteSettingsAddBotProtectionHeaders : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  WafSiteSettingsAddBotProtectionHeaders() {}

  explicit WafSiteSettingsAddBotProtectionHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~WafSiteSettingsAddBotProtectionHeaders() = default;
};
class WafSiteSettingsAddSecurityHeaders : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  WafSiteSettingsAddSecurityHeaders() {}

  explicit WafSiteSettingsAddSecurityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~WafSiteSettingsAddSecurityHeaders() = default;
};
class WafSiteSettingsClientIpIdentifier : public Darabonba::Model {
public:
  shared_ptr<vector<string>> headers{};
  shared_ptr<string> mode{};

  WafSiteSettingsClientIpIdentifier() {}

  explicit WafSiteSettingsClientIpIdentifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = boost::any(*headers);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Headers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Headers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      headers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~WafSiteSettingsClientIpIdentifier() = default;
};
class WafSiteSettingsSecurityLevel : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  WafSiteSettingsSecurityLevel() {}

  explicit WafSiteSettingsSecurityLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~WafSiteSettingsSecurityLevel() = default;
};
class WafSiteSettings : public Darabonba::Model {
public:
  shared_ptr<WafSiteSettingsAddBotProtectionHeaders> addBotProtectionHeaders{};
  shared_ptr<WafSiteSettingsAddSecurityHeaders> addSecurityHeaders{};
  shared_ptr<WafSiteSettingsClientIpIdentifier> clientIpIdentifier{};
  shared_ptr<WafSiteSettingsSecurityLevel> securityLevel{};

  WafSiteSettings() {}

  explicit WafSiteSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addBotProtectionHeaders) {
      res["AddBotProtectionHeaders"] = addBotProtectionHeaders ? boost::any(addBotProtectionHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (addSecurityHeaders) {
      res["AddSecurityHeaders"] = addSecurityHeaders ? boost::any(addSecurityHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clientIpIdentifier) {
      res["ClientIpIdentifier"] = clientIpIdentifier ? boost::any(clientIpIdentifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityLevel) {
      res["SecurityLevel"] = securityLevel ? boost::any(securityLevel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddBotProtectionHeaders") != m.end() && !m["AddBotProtectionHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddBotProtectionHeaders"].type()) {
        WafSiteSettingsAddBotProtectionHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddBotProtectionHeaders"]));
        addBotProtectionHeaders = make_shared<WafSiteSettingsAddBotProtectionHeaders>(model1);
      }
    }
    if (m.find("AddSecurityHeaders") != m.end() && !m["AddSecurityHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddSecurityHeaders"].type()) {
        WafSiteSettingsAddSecurityHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddSecurityHeaders"]));
        addSecurityHeaders = make_shared<WafSiteSettingsAddSecurityHeaders>(model1);
      }
    }
    if (m.find("ClientIpIdentifier") != m.end() && !m["ClientIpIdentifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientIpIdentifier"].type()) {
        WafSiteSettingsClientIpIdentifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientIpIdentifier"]));
        clientIpIdentifier = make_shared<WafSiteSettingsClientIpIdentifier>(model1);
      }
    }
    if (m.find("SecurityLevel") != m.end() && !m["SecurityLevel"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityLevel"].type()) {
        WafSiteSettingsSecurityLevel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityLevel"]));
        securityLevel = make_shared<WafSiteSettingsSecurityLevel>(model1);
      }
    }
  }


  virtual ~WafSiteSettings() = default;
};
class HttpDeliveryHeaderParamValue : public Darabonba::Model {
public:
  shared_ptr<string> staticValue{};

  HttpDeliveryHeaderParamValue() {}

  explicit HttpDeliveryHeaderParamValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (staticValue) {
      res["StaticValue"] = boost::any(*staticValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StaticValue") != m.end() && !m["StaticValue"].empty()) {
      staticValue = make_shared<string>(boost::any_cast<string>(m["StaticValue"]));
    }
  }


  virtual ~HttpDeliveryHeaderParamValue() = default;
};
class HttpDeliveryQueryParamValue : public Darabonba::Model {
public:
  shared_ptr<string> staticValue{};

  HttpDeliveryQueryParamValue() {}

  explicit HttpDeliveryQueryParamValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (staticValue) {
      res["StaticValue"] = boost::any(*staticValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StaticValue") != m.end() && !m["StaticValue"].empty()) {
      staticValue = make_shared<string>(boost::any_cast<string>(m["StaticValue"]));
    }
  }


  virtual ~HttpDeliveryQueryParamValue() = default;
};
class FieldContentValueFieldList : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> description{};
  shared_ptr<string> descriptionCn{};
  shared_ptr<string> category{};
  shared_ptr<string> dataType{};
  shared_ptr<long> sortOrder{};
  shared_ptr<bool> isDefault{};

  FieldContentValueFieldList() {}

  explicit FieldContentValueFieldList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (descriptionCn) {
      res["DescriptionCn"] = boost::any(*descriptionCn);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DescriptionCn") != m.end() && !m["DescriptionCn"].empty()) {
      descriptionCn = make_shared<string>(boost::any_cast<string>(m["DescriptionCn"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<long>(boost::any_cast<long>(m["SortOrder"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
  }


  virtual ~FieldContentValueFieldList() = default;
};
class FieldContentValue : public Darabonba::Model {
public:
  shared_ptr<long> sortOrder{};
  shared_ptr<vector<FieldContentValueFieldList>> fieldList{};

  FieldContentValue() {}

  explicit FieldContentValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (fieldList) {
      vector<boost::any> temp1;
      for(auto item1:*fieldList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FieldList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<long>(boost::any_cast<long>(m["SortOrder"]));
    }
    if (m.find("FieldList") != m.end() && !m["FieldList"].empty()) {
      if (typeid(vector<boost::any>) == m["FieldList"].type()) {
        vector<FieldContentValueFieldList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FieldList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FieldContentValueFieldList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fieldList = make_shared<vector<FieldContentValueFieldList>>(expect1);
      }
    }
  }


  virtual ~FieldContentValue() = default;
};
class QuotaListItemsValue : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<WafQuotaString> value{};

  QuotaListItemsValue() {}

  explicit QuotaListItemsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        WafQuotaString model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<WafQuotaString>(model1);
      }
    }
  }


  virtual ~QuotaListItemsValue() = default;
};
class QuotaPageContentTypesValue : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<WafQuotaInteger> contentLength{};

  QuotaPageContentTypesValue() {}

  explicit QuotaPageContentTypesValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (contentLength) {
      res["ContentLength"] = contentLength ? boost::any(contentLength->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("ContentLength") != m.end() && !m["ContentLength"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContentLength"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContentLength"]));
        contentLength = make_shared<WafQuotaInteger>(model1);
      }
    }
  }


  virtual ~QuotaPageContentTypesValue() = default;
};
class ActivateClientCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  ActivateClientCertificateRequest() {}

  explicit ActivateClientCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ActivateClientCertificateRequest() = default;
};
class ActivateClientCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  ActivateClientCertificateResponseBody() {}

  explicit ActivateClientCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~ActivateClientCertificateResponseBody() = default;
};
class ActivateClientCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActivateClientCertificateResponseBody> body{};

  ActivateClientCertificateResponse() {}

  explicit ActivateClientCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateClientCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateClientCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateClientCertificateResponse() = default;
};
class BatchCreateRecordsRequestRecordListAuthConf : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> authType{};
  shared_ptr<string> region{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> version{};

  BatchCreateRecordsRequestRecordListAuthConf() {}

  explicit BatchCreateRecordsRequestRecordListAuthConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~BatchCreateRecordsRequestRecordListAuthConf() = default;
};
class BatchCreateRecordsRequestRecordListData : public Darabonba::Model {
public:
  shared_ptr<long> algorithm{};
  shared_ptr<string> certificate{};
  shared_ptr<string> fingerprint{};
  shared_ptr<long> flag{};
  shared_ptr<long> keyTag{};
  shared_ptr<long> matchingType{};
  shared_ptr<long> port{};
  shared_ptr<long> priority{};
  shared_ptr<long> selector{};
  shared_ptr<string> tag{};
  shared_ptr<long> type{};
  shared_ptr<long> usage{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  BatchCreateRecordsRequestRecordListData() {}

  explicit BatchCreateRecordsRequestRecordListData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (keyTag) {
      res["KeyTag"] = boost::any(*keyTag);
    }
    if (matchingType) {
      res["MatchingType"] = boost::any(*matchingType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<long>(boost::any_cast<long>(m["Algorithm"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("KeyTag") != m.end() && !m["KeyTag"].empty()) {
      keyTag = make_shared<long>(boost::any_cast<long>(m["KeyTag"]));
    }
    if (m.find("MatchingType") != m.end() && !m["MatchingType"].empty()) {
      matchingType = make_shared<long>(boost::any_cast<long>(m["MatchingType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<long>(boost::any_cast<long>(m["Selector"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~BatchCreateRecordsRequestRecordListData() = default;
};
class BatchCreateRecordsRequestRecordList : public Darabonba::Model {
public:
  shared_ptr<BatchCreateRecordsRequestRecordListAuthConf> authConf{};
  shared_ptr<string> bizName{};
  shared_ptr<BatchCreateRecordsRequestRecordListData> data{};
  shared_ptr<bool> proxied{};
  shared_ptr<string> recordName{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> ttl{};
  shared_ptr<string> type{};

  BatchCreateRecordsRequestRecordList() {}

  explicit BatchCreateRecordsRequestRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConf) {
      res["AuthConf"] = authConf ? boost::any(authConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthConf") != m.end() && !m["AuthConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthConf"].type()) {
        BatchCreateRecordsRequestRecordListAuthConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthConf"]));
        authConf = make_shared<BatchCreateRecordsRequestRecordListAuthConf>(model1);
      }
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCreateRecordsRequestRecordListData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCreateRecordsRequestRecordListData>(model1);
      }
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BatchCreateRecordsRequestRecordList() = default;
};
class BatchCreateRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchCreateRecordsRequestRecordList>> recordList{};
  shared_ptr<long> siteId{};

  BatchCreateRecordsRequest() {}

  explicit BatchCreateRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordList) {
      vector<boost::any> temp1;
      for(auto item1:*recordList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordList"] = boost::any(temp1);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordList") != m.end() && !m["RecordList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordList"].type()) {
        vector<BatchCreateRecordsRequestRecordList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCreateRecordsRequestRecordList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordList = make_shared<vector<BatchCreateRecordsRequestRecordList>>(expect1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~BatchCreateRecordsRequest() = default;
};
class BatchCreateRecordsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> recordListShrink{};
  shared_ptr<long> siteId{};

  BatchCreateRecordsShrinkRequest() {}

  explicit BatchCreateRecordsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordListShrink) {
      res["RecordList"] = boost::any(*recordListShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordList") != m.end() && !m["RecordList"].empty()) {
      recordListShrink = make_shared<string>(boost::any_cast<string>(m["RecordList"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~BatchCreateRecordsShrinkRequest() = default;
};
class BatchCreateRecordsResponseBodyRecordResultListFailedData : public Darabonba::Model {
public:
  shared_ptr<long> algorithm{};
  shared_ptr<string> certificate{};
  shared_ptr<string> fingerprint{};
  shared_ptr<long> flag{};
  shared_ptr<long> keyTag{};
  shared_ptr<long> matchingType{};
  shared_ptr<long> port{};
  shared_ptr<long> priority{};
  shared_ptr<long> selector{};
  shared_ptr<string> tag{};
  shared_ptr<long> type{};
  shared_ptr<long> usage{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  BatchCreateRecordsResponseBodyRecordResultListFailedData() {}

  explicit BatchCreateRecordsResponseBodyRecordResultListFailedData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (keyTag) {
      res["KeyTag"] = boost::any(*keyTag);
    }
    if (matchingType) {
      res["MatchingType"] = boost::any(*matchingType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<long>(boost::any_cast<long>(m["Algorithm"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("KeyTag") != m.end() && !m["KeyTag"].empty()) {
      keyTag = make_shared<long>(boost::any_cast<long>(m["KeyTag"]));
    }
    if (m.find("MatchingType") != m.end() && !m["MatchingType"].empty()) {
      matchingType = make_shared<long>(boost::any_cast<long>(m["MatchingType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<long>(boost::any_cast<long>(m["Selector"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~BatchCreateRecordsResponseBodyRecordResultListFailedData() = default;
};
class BatchCreateRecordsResponseBodyRecordResultListFailed : public Darabonba::Model {
public:
  shared_ptr<string> bizName{};
  shared_ptr<BatchCreateRecordsResponseBodyRecordResultListFailedData> data{};
  shared_ptr<string> description{};
  shared_ptr<bool> proxied{};
  shared_ptr<long> recordId{};
  shared_ptr<string> recordName{};
  shared_ptr<string> recordType{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> ttl{};

  BatchCreateRecordsResponseBodyRecordResultListFailed() {}

  explicit BatchCreateRecordsResponseBodyRecordResultListFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (recordType) {
      res["RecordType"] = boost::any(*recordType);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCreateRecordsResponseBodyRecordResultListFailedData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCreateRecordsResponseBodyRecordResultListFailedData>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("RecordType") != m.end() && !m["RecordType"].empty()) {
      recordType = make_shared<string>(boost::any_cast<string>(m["RecordType"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~BatchCreateRecordsResponseBodyRecordResultListFailed() = default;
};
class BatchCreateRecordsResponseBodyRecordResultListSuccessData : public Darabonba::Model {
public:
  shared_ptr<long> algorithm{};
  shared_ptr<string> certificate{};
  shared_ptr<string> fingerprint{};
  shared_ptr<long> flag{};
  shared_ptr<long> keyTag{};
  shared_ptr<long> matchingType{};
  shared_ptr<long> port{};
  shared_ptr<long> priority{};
  shared_ptr<long> selector{};
  shared_ptr<string> tag{};
  shared_ptr<long> type{};
  shared_ptr<long> usage{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  BatchCreateRecordsResponseBodyRecordResultListSuccessData() {}

  explicit BatchCreateRecordsResponseBodyRecordResultListSuccessData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (keyTag) {
      res["KeyTag"] = boost::any(*keyTag);
    }
    if (matchingType) {
      res["MatchingType"] = boost::any(*matchingType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<long>(boost::any_cast<long>(m["Algorithm"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("KeyTag") != m.end() && !m["KeyTag"].empty()) {
      keyTag = make_shared<long>(boost::any_cast<long>(m["KeyTag"]));
    }
    if (m.find("MatchingType") != m.end() && !m["MatchingType"].empty()) {
      matchingType = make_shared<long>(boost::any_cast<long>(m["MatchingType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<long>(boost::any_cast<long>(m["Selector"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~BatchCreateRecordsResponseBodyRecordResultListSuccessData() = default;
};
class BatchCreateRecordsResponseBodyRecordResultListSuccess : public Darabonba::Model {
public:
  shared_ptr<string> bizName{};
  shared_ptr<BatchCreateRecordsResponseBodyRecordResultListSuccessData> data{};
  shared_ptr<string> description{};
  shared_ptr<bool> proxied{};
  shared_ptr<long> recordId{};
  shared_ptr<string> recordName{};
  shared_ptr<string> recordType{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> ttl{};

  BatchCreateRecordsResponseBodyRecordResultListSuccess() {}

  explicit BatchCreateRecordsResponseBodyRecordResultListSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (recordType) {
      res["RecordType"] = boost::any(*recordType);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCreateRecordsResponseBodyRecordResultListSuccessData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCreateRecordsResponseBodyRecordResultListSuccessData>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("RecordType") != m.end() && !m["RecordType"].empty()) {
      recordType = make_shared<string>(boost::any_cast<string>(m["RecordType"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~BatchCreateRecordsResponseBodyRecordResultListSuccess() = default;
};
class BatchCreateRecordsResponseBodyRecordResultList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchCreateRecordsResponseBodyRecordResultListFailed>> failed{};
  shared_ptr<vector<BatchCreateRecordsResponseBodyRecordResultListSuccess>> success{};
  shared_ptr<long> totalCount{};

  BatchCreateRecordsResponseBodyRecordResultList() {}

  explicit BatchCreateRecordsResponseBodyRecordResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      vector<boost::any> temp1;
      for(auto item1:*failed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Failed"] = boost::any(temp1);
    }
    if (success) {
      vector<boost::any> temp1;
      for(auto item1:*success){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Success"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      if (typeid(vector<boost::any>) == m["Failed"].type()) {
        vector<BatchCreateRecordsResponseBodyRecordResultListFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Failed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCreateRecordsResponseBodyRecordResultListFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failed = make_shared<vector<BatchCreateRecordsResponseBodyRecordResultListFailed>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      if (typeid(vector<boost::any>) == m["Success"].type()) {
        vector<BatchCreateRecordsResponseBodyRecordResultListSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Success"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCreateRecordsResponseBodyRecordResultListSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        success = make_shared<vector<BatchCreateRecordsResponseBodyRecordResultListSuccess>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~BatchCreateRecordsResponseBodyRecordResultList() = default;
};
class BatchCreateRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<BatchCreateRecordsResponseBodyRecordResultList> recordResultList{};
  shared_ptr<string> requestId{};

  BatchCreateRecordsResponseBody() {}

  explicit BatchCreateRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordResultList) {
      res["RecordResultList"] = recordResultList ? boost::any(recordResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordResultList") != m.end() && !m["RecordResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordResultList"].type()) {
        BatchCreateRecordsResponseBodyRecordResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordResultList"]));
        recordResultList = make_shared<BatchCreateRecordsResponseBodyRecordResultList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchCreateRecordsResponseBody() = default;
};
class BatchCreateRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCreateRecordsResponseBody> body{};

  BatchCreateRecordsResponse() {}

  explicit BatchCreateRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCreateRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCreateRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCreateRecordsResponse() = default;
};
class BatchCreateWafRulesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<WafRuleConfig>> configs{};
  shared_ptr<string> phase{};
  shared_ptr<WafBatchRuleShared> shared{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  BatchCreateWafRulesRequest() {}

  explicit BatchCreateWafRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (shared) {
      res["Shared"] = shared ? boost::any(shared->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<WafRuleConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<WafRuleConfig>>(expect1);
      }
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      if (typeid(map<string, boost::any>) == m["Shared"].type()) {
        WafBatchRuleShared model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Shared"]));
        shared = make_shared<WafBatchRuleShared>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~BatchCreateWafRulesRequest() = default;
};
class BatchCreateWafRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configsShrink{};
  shared_ptr<string> phase{};
  shared_ptr<string> sharedShrink{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  BatchCreateWafRulesShrinkRequest() {}

  explicit BatchCreateWafRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configsShrink) {
      res["Configs"] = boost::any(*configsShrink);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (sharedShrink) {
      res["Shared"] = boost::any(*sharedShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      configsShrink = make_shared<string>(boost::any_cast<string>(m["Configs"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      sharedShrink = make_shared<string>(boost::any_cast<string>(m["Shared"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~BatchCreateWafRulesShrinkRequest() = default;
};
class BatchCreateWafRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rulesetId{};

  BatchCreateWafRulesResponseBody() {}

  explicit BatchCreateWafRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rulesetId) {
      res["RulesetId"] = boost::any(*rulesetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RulesetId") != m.end() && !m["RulesetId"].empty()) {
      rulesetId = make_shared<long>(boost::any_cast<long>(m["RulesetId"]));
    }
  }


  virtual ~BatchCreateWafRulesResponseBody() = default;
};
class BatchCreateWafRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCreateWafRulesResponseBody> body{};

  BatchCreateWafRulesResponse() {}

  explicit BatchCreateWafRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCreateWafRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCreateWafRulesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCreateWafRulesResponse() = default;
};
class BatchDeleteKvRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keys{};
  shared_ptr<string> namespace_{};

  BatchDeleteKvRequest() {}

  explicit BatchDeleteKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keys) {
      res["Keys"] = boost::any(*keys);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~BatchDeleteKvRequest() = default;
};
class BatchDeleteKvShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> keysShrink{};
  shared_ptr<string> namespace_{};

  BatchDeleteKvShrinkRequest() {}

  explicit BatchDeleteKvShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keysShrink) {
      res["Keys"] = boost::any(*keysShrink);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      keysShrink = make_shared<string>(boost::any_cast<string>(m["Keys"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~BatchDeleteKvShrinkRequest() = default;
};
class BatchDeleteKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failKeys{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> successKeys{};

  BatchDeleteKvResponseBody() {}

  explicit BatchDeleteKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failKeys) {
      res["FailKeys"] = boost::any(*failKeys);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successKeys) {
      res["SuccessKeys"] = boost::any(*successKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailKeys") != m.end() && !m["FailKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessKeys") != m.end() && !m["SuccessKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchDeleteKvResponseBody() = default;
};
class BatchDeleteKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteKvResponseBody> body{};

  BatchDeleteKvResponse() {}

  explicit BatchDeleteKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteKvResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteKvResponse() = default;
};
class BatchDeleteKvWithHighCapacityRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> url{};

  BatchDeleteKvWithHighCapacityRequest() {}

  explicit BatchDeleteKvWithHighCapacityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~BatchDeleteKvWithHighCapacityRequest() = default;
};
class BatchDeleteKvWithHighCapacityAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<Darabonba::Stream> urlObject{};

  BatchDeleteKvWithHighCapacityAdvanceRequest() {}

  explicit BatchDeleteKvWithHighCapacityAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (urlObject) {
      res["Url"] = boost::any(*urlObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      urlObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["Url"]));
    }
  }


  virtual ~BatchDeleteKvWithHighCapacityAdvanceRequest() = default;
};
class BatchDeleteKvWithHighCapacityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failKeys{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> successKeys{};

  BatchDeleteKvWithHighCapacityResponseBody() {}

  explicit BatchDeleteKvWithHighCapacityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failKeys) {
      res["FailKeys"] = boost::any(*failKeys);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successKeys) {
      res["SuccessKeys"] = boost::any(*successKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailKeys") != m.end() && !m["FailKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessKeys") != m.end() && !m["SuccessKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchDeleteKvWithHighCapacityResponseBody() = default;
};
class BatchDeleteKvWithHighCapacityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteKvWithHighCapacityResponseBody> body{};

  BatchDeleteKvWithHighCapacityResponse() {}

  explicit BatchDeleteKvWithHighCapacityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteKvWithHighCapacityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteKvWithHighCapacityResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteKvWithHighCapacityResponse() = default;
};
class BatchGetExpressionFieldsRequestExpressions : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<long> id{};

  BatchGetExpressionFieldsRequestExpressions() {}

  explicit BatchGetExpressionFieldsRequestExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~BatchGetExpressionFieldsRequestExpressions() = default;
};
class BatchGetExpressionFieldsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetExpressionFieldsRequestExpressions>> expressions{};
  shared_ptr<string> phase{};
  shared_ptr<long> siteId{};

  BatchGetExpressionFieldsRequest() {}

  explicit BatchGetExpressionFieldsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressions) {
      vector<boost::any> temp1;
      for(auto item1:*expressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Expressions"] = boost::any(temp1);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      if (typeid(vector<boost::any>) == m["Expressions"].type()) {
        vector<BatchGetExpressionFieldsRequestExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Expressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetExpressionFieldsRequestExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressions = make_shared<vector<BatchGetExpressionFieldsRequestExpressions>>(expect1);
      }
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~BatchGetExpressionFieldsRequest() = default;
};
class BatchGetExpressionFieldsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> expressionsShrink{};
  shared_ptr<string> phase{};
  shared_ptr<long> siteId{};

  BatchGetExpressionFieldsShrinkRequest() {}

  explicit BatchGetExpressionFieldsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressionsShrink) {
      res["Expressions"] = boost::any(*expressionsShrink);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      expressionsShrink = make_shared<string>(boost::any_cast<string>(m["Expressions"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~BatchGetExpressionFieldsShrinkRequest() = default;
};
class BatchGetExpressionFieldsResponseBodyFields : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fields{};
  shared_ptr<string> id{};

  BatchGetExpressionFieldsResponseBodyFields() {}

  explicit BatchGetExpressionFieldsResponseBodyFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Fields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~BatchGetExpressionFieldsResponseBodyFields() = default;
};
class BatchGetExpressionFieldsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetExpressionFieldsResponseBodyFields>> fields{};
  shared_ptr<string> requestId{};

  BatchGetExpressionFieldsResponseBody() {}

  explicit BatchGetExpressionFieldsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fields"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<BatchGetExpressionFieldsResponseBodyFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetExpressionFieldsResponseBodyFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<BatchGetExpressionFieldsResponseBodyFields>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchGetExpressionFieldsResponseBody() = default;
};
class BatchGetExpressionFieldsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetExpressionFieldsResponseBody> body{};

  BatchGetExpressionFieldsResponse() {}

  explicit BatchGetExpressionFieldsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetExpressionFieldsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetExpressionFieldsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetExpressionFieldsResponse() = default;
};
class BatchPutKvRequestKvList : public Darabonba::Model {
public:
  shared_ptr<long> expiration{};
  shared_ptr<long> expirationTtl{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  BatchPutKvRequestKvList() {}

  explicit BatchPutKvRequestKvList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (expirationTtl) {
      res["ExpirationTtl"] = boost::any(*expirationTtl);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<long>(boost::any_cast<long>(m["Expiration"]));
    }
    if (m.find("ExpirationTtl") != m.end() && !m["ExpirationTtl"].empty()) {
      expirationTtl = make_shared<long>(boost::any_cast<long>(m["ExpirationTtl"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~BatchPutKvRequestKvList() = default;
};
class BatchPutKvRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchPutKvRequestKvList>> kvList{};
  shared_ptr<string> namespace_{};

  BatchPutKvRequest() {}

  explicit BatchPutKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kvList) {
      vector<boost::any> temp1;
      for(auto item1:*kvList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KvList"] = boost::any(temp1);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KvList") != m.end() && !m["KvList"].empty()) {
      if (typeid(vector<boost::any>) == m["KvList"].type()) {
        vector<BatchPutKvRequestKvList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KvList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchPutKvRequestKvList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        kvList = make_shared<vector<BatchPutKvRequestKvList>>(expect1);
      }
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~BatchPutKvRequest() = default;
};
class BatchPutKvShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> kvListShrink{};
  shared_ptr<string> namespace_{};

  BatchPutKvShrinkRequest() {}

  explicit BatchPutKvShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kvListShrink) {
      res["KvList"] = boost::any(*kvListShrink);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KvList") != m.end() && !m["KvList"].empty()) {
      kvListShrink = make_shared<string>(boost::any_cast<string>(m["KvList"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~BatchPutKvShrinkRequest() = default;
};
class BatchPutKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failKeys{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> successKeys{};

  BatchPutKvResponseBody() {}

  explicit BatchPutKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failKeys) {
      res["FailKeys"] = boost::any(*failKeys);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successKeys) {
      res["SuccessKeys"] = boost::any(*successKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailKeys") != m.end() && !m["FailKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessKeys") != m.end() && !m["SuccessKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchPutKvResponseBody() = default;
};
class BatchPutKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchPutKvResponseBody> body{};

  BatchPutKvResponse() {}

  explicit BatchPutKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchPutKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchPutKvResponseBody>(model1);
      }
    }
  }


  virtual ~BatchPutKvResponse() = default;
};
class BatchPutKvWithHighCapacityRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> url{};

  BatchPutKvWithHighCapacityRequest() {}

  explicit BatchPutKvWithHighCapacityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~BatchPutKvWithHighCapacityRequest() = default;
};
class BatchPutKvWithHighCapacityAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<Darabonba::Stream> urlObject{};

  BatchPutKvWithHighCapacityAdvanceRequest() {}

  explicit BatchPutKvWithHighCapacityAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (urlObject) {
      res["Url"] = boost::any(*urlObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      urlObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["Url"]));
    }
  }


  virtual ~BatchPutKvWithHighCapacityAdvanceRequest() = default;
};
class BatchPutKvWithHighCapacityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failKeys{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> successKeys{};

  BatchPutKvWithHighCapacityResponseBody() {}

  explicit BatchPutKvWithHighCapacityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failKeys) {
      res["FailKeys"] = boost::any(*failKeys);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successKeys) {
      res["SuccessKeys"] = boost::any(*successKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailKeys") != m.end() && !m["FailKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessKeys") != m.end() && !m["SuccessKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchPutKvWithHighCapacityResponseBody() = default;
};
class BatchPutKvWithHighCapacityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchPutKvWithHighCapacityResponseBody> body{};

  BatchPutKvWithHighCapacityResponse() {}

  explicit BatchPutKvWithHighCapacityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchPutKvWithHighCapacityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchPutKvWithHighCapacityResponseBody>(model1);
      }
    }
  }


  virtual ~BatchPutKvWithHighCapacityResponse() = default;
};
class BatchUpdateWafRulesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<WafRuleConfig>> configs{};
  shared_ptr<string> phase{};
  shared_ptr<long> rulesetId{};
  shared_ptr<WafBatchRuleShared> shared{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  BatchUpdateWafRulesRequest() {}

  explicit BatchUpdateWafRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (rulesetId) {
      res["RulesetId"] = boost::any(*rulesetId);
    }
    if (shared) {
      res["Shared"] = shared ? boost::any(shared->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<WafRuleConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<WafRuleConfig>>(expect1);
      }
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("RulesetId") != m.end() && !m["RulesetId"].empty()) {
      rulesetId = make_shared<long>(boost::any_cast<long>(m["RulesetId"]));
    }
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      if (typeid(map<string, boost::any>) == m["Shared"].type()) {
        WafBatchRuleShared model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Shared"]));
        shared = make_shared<WafBatchRuleShared>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~BatchUpdateWafRulesRequest() = default;
};
class BatchUpdateWafRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configsShrink{};
  shared_ptr<string> phase{};
  shared_ptr<long> rulesetId{};
  shared_ptr<string> sharedShrink{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  BatchUpdateWafRulesShrinkRequest() {}

  explicit BatchUpdateWafRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configsShrink) {
      res["Configs"] = boost::any(*configsShrink);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (rulesetId) {
      res["RulesetId"] = boost::any(*rulesetId);
    }
    if (sharedShrink) {
      res["Shared"] = boost::any(*sharedShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      configsShrink = make_shared<string>(boost::any_cast<string>(m["Configs"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("RulesetId") != m.end() && !m["RulesetId"].empty()) {
      rulesetId = make_shared<long>(boost::any_cast<long>(m["RulesetId"]));
    }
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      sharedShrink = make_shared<string>(boost::any_cast<string>(m["Shared"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~BatchUpdateWafRulesShrinkRequest() = default;
};
class BatchUpdateWafRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchUpdateWafRulesResponseBody() {}

  explicit BatchUpdateWafRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchUpdateWafRulesResponseBody() = default;
};
class BatchUpdateWafRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUpdateWafRulesResponseBody> body{};

  BatchUpdateWafRulesResponse() {}

  explicit BatchUpdateWafRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateWafRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateWafRulesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateWafRulesResponse() = default;
};
class BlockObjectRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> content{};
  shared_ptr<string> extension{};
  shared_ptr<long> maxage{};
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};

  BlockObjectRequest() {}

  explicit BlockObjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (maxage) {
      res["Maxage"] = boost::any(*maxage);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Content"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      content = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Maxage") != m.end() && !m["Maxage"].empty()) {
      maxage = make_shared<long>(boost::any_cast<long>(m["Maxage"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BlockObjectRequest() = default;
};
class BlockObjectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentShrink{};
  shared_ptr<string> extension{};
  shared_ptr<long> maxage{};
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};

  BlockObjectShrinkRequest() {}

  explicit BlockObjectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentShrink) {
      res["Content"] = boost::any(*contentShrink);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (maxage) {
      res["Maxage"] = boost::any(*maxage);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      contentShrink = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Maxage") != m.end() && !m["Maxage"].empty()) {
      maxage = make_shared<long>(boost::any_cast<long>(m["Maxage"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BlockObjectShrinkRequest() = default;
};
class BlockObjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  BlockObjectResponseBody() {}

  explicit BlockObjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~BlockObjectResponseBody() = default;
};
class BlockObjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BlockObjectResponseBody> body{};

  BlockObjectResponse() {}

  explicit BlockObjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BlockObjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BlockObjectResponseBody>(model1);
      }
    }
  }


  virtual ~BlockObjectResponse() = default;
};
class ChangeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<long> siteId{};

  ChangeResourceGroupRequest() {}

  explicit ChangeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ChangeResourceGroupRequest() = default;
};
class ChangeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ChangeResourceGroupResponseBody() {}

  explicit ChangeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBody() = default;
};
class ChangeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeResourceGroupResponseBody> body{};

  ChangeResourceGroupResponse() {}

  explicit ChangeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeResourceGroupResponse() = default;
};
class CheckSiteNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> siteName{};

  CheckSiteNameRequest() {}

  explicit CheckSiteNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~CheckSiteNameRequest() = default;
};
class CheckSiteNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> isSubSite{};
  shared_ptr<string> messeage{};
  shared_ptr<bool> passed{};
  shared_ptr<string> requestId{};

  CheckSiteNameResponseBody() {}

  explicit CheckSiteNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (isSubSite) {
      res["IsSubSite"] = boost::any(*isSubSite);
    }
    if (messeage) {
      res["Messeage"] = boost::any(*messeage);
    }
    if (passed) {
      res["Passed"] = boost::any(*passed);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IsSubSite") != m.end() && !m["IsSubSite"].empty()) {
      isSubSite = make_shared<bool>(boost::any_cast<bool>(m["IsSubSite"]));
    }
    if (m.find("Messeage") != m.end() && !m["Messeage"].empty()) {
      messeage = make_shared<string>(boost::any_cast<string>(m["Messeage"]));
    }
    if (m.find("Passed") != m.end() && !m["Passed"].empty()) {
      passed = make_shared<bool>(boost::any_cast<bool>(m["Passed"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckSiteNameResponseBody() = default;
};
class CheckSiteNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckSiteNameResponseBody> body{};

  CheckSiteNameResponse() {}

  explicit CheckSiteNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckSiteNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckSiteNameResponseBody>(model1);
      }
    }
  }


  virtual ~CheckSiteNameResponse() = default;
};
class CheckSiteProjectNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> siteId{};

  CheckSiteProjectNameRequest() {}

  explicit CheckSiteProjectNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~CheckSiteProjectNameRequest() = default;
};
class CheckSiteProjectNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> check{};
  shared_ptr<string> description{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};

  CheckSiteProjectNameResponseBody() {}

  explicit CheckSiteProjectNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (check) {
      res["Check"] = boost::any(*check);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Check") != m.end() && !m["Check"].empty()) {
      check = make_shared<bool>(boost::any_cast<bool>(m["Check"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckSiteProjectNameResponseBody() = default;
};
class CheckSiteProjectNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckSiteProjectNameResponseBody> body{};

  CheckSiteProjectNameResponse() {}

  explicit CheckSiteProjectNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckSiteProjectNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckSiteProjectNameResponseBody>(model1);
      }
    }
  }


  virtual ~CheckSiteProjectNameResponse() = default;
};
class CheckUserProjectNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};

  CheckUserProjectNameRequest() {}

  explicit CheckUserProjectNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~CheckUserProjectNameRequest() = default;
};
class CheckUserProjectNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> check{};
  shared_ptr<string> description{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};

  CheckUserProjectNameResponseBody() {}

  explicit CheckUserProjectNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (check) {
      res["Check"] = boost::any(*check);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Check") != m.end() && !m["Check"].empty()) {
      check = make_shared<bool>(boost::any_cast<bool>(m["Check"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckUserProjectNameResponseBody() = default;
};
class CheckUserProjectNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckUserProjectNameResponseBody> body{};

  CheckUserProjectNameResponse() {}

  explicit CheckUserProjectNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckUserProjectNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckUserProjectNameResponseBody>(model1);
      }
    }
  }


  virtual ~CheckUserProjectNameResponse() = default;
};
class CommitRoutineStagingCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> codeDescription{};
  shared_ptr<string> name{};

  CommitRoutineStagingCodeRequest() {}

  explicit CommitRoutineStagingCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CommitRoutineStagingCodeRequest() = default;
};
class CommitRoutineStagingCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> codeVersion{};
  shared_ptr<string> requestId{};

  CommitRoutineStagingCodeResponseBody() {}

  explicit CommitRoutineStagingCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CommitRoutineStagingCodeResponseBody() = default;
};
class CommitRoutineStagingCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommitRoutineStagingCodeResponseBody> body{};

  CommitRoutineStagingCodeResponse() {}

  explicit CommitRoutineStagingCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommitRoutineStagingCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommitRoutineStagingCodeResponseBody>(model1);
      }
    }
  }


  virtual ~CommitRoutineStagingCodeResponse() = default;
};
class CreateClientCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> CSR{};
  shared_ptr<string> pkeyType{};
  shared_ptr<long> siteId{};
  shared_ptr<long> validityDays{};

  CreateClientCertificateRequest() {}

  explicit CreateClientCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CSR) {
      res["CSR"] = boost::any(*CSR);
    }
    if (pkeyType) {
      res["PkeyType"] = boost::any(*pkeyType);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (validityDays) {
      res["ValidityDays"] = boost::any(*validityDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CSR") != m.end() && !m["CSR"].empty()) {
      CSR = make_shared<string>(boost::any_cast<string>(m["CSR"]));
    }
    if (m.find("PkeyType") != m.end() && !m["PkeyType"].empty()) {
      pkeyType = make_shared<string>(boost::any_cast<string>(m["PkeyType"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("ValidityDays") != m.end() && !m["ValidityDays"].empty()) {
      validityDays = make_shared<long>(boost::any_cast<long>(m["ValidityDays"]));
    }
  }


  virtual ~CreateClientCertificateRequest() = default;
};
class CreateClientCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> CACertificateId{};
  shared_ptr<string> certificate{};
  shared_ptr<string> commonName{};
  shared_ptr<string> fingerprintSha256{};
  shared_ptr<string> id{};
  shared_ptr<string> issuer{};
  shared_ptr<string> notAfter{};
  shared_ptr<string> notBefore{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> requestId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> signatureAlgorithm{};
  shared_ptr<string> status{};
  shared_ptr<string> validityDays{};

  CreateClientCertificateResponseBody() {}

  explicit CreateClientCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CACertificateId) {
      res["CACertificateId"] = boost::any(*CACertificateId);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (fingerprintSha256) {
      res["FingerprintSha256"] = boost::any(*fingerprintSha256);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (notAfter) {
      res["NotAfter"] = boost::any(*notAfter);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (signatureAlgorithm) {
      res["SignatureAlgorithm"] = boost::any(*signatureAlgorithm);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (validityDays) {
      res["ValidityDays"] = boost::any(*validityDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CACertificateId") != m.end() && !m["CACertificateId"].empty()) {
      CACertificateId = make_shared<string>(boost::any_cast<string>(m["CACertificateId"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("FingerprintSha256") != m.end() && !m["FingerprintSha256"].empty()) {
      fingerprintSha256 = make_shared<string>(boost::any_cast<string>(m["FingerprintSha256"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("NotAfter") != m.end() && !m["NotAfter"].empty()) {
      notAfter = make_shared<string>(boost::any_cast<string>(m["NotAfter"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("SignatureAlgorithm") != m.end() && !m["SignatureAlgorithm"].empty()) {
      signatureAlgorithm = make_shared<string>(boost::any_cast<string>(m["SignatureAlgorithm"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ValidityDays") != m.end() && !m["ValidityDays"].empty()) {
      validityDays = make_shared<string>(boost::any_cast<string>(m["ValidityDays"]));
    }
  }


  virtual ~CreateClientCertificateResponseBody() = default;
};
class CreateClientCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClientCertificateResponseBody> body{};

  CreateClientCertificateResponse() {}

  explicit CreateClientCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClientCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClientCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClientCertificateResponse() = default;
};
class CreateCustomScenePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> name{};
  shared_ptr<string> objects{};
  shared_ptr<string> startTime{};
  shared_ptr<string> template_{};

  CreateCustomScenePolicyRequest() {}

  explicit CreateCustomScenePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objects) {
      res["Objects"] = boost::any(*objects);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Objects") != m.end() && !m["Objects"].empty()) {
      objects = make_shared<string>(boost::any_cast<string>(m["Objects"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~CreateCustomScenePolicyRequest() = default;
};
class CreateCustomScenePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> objects{};
  shared_ptr<long> policyId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> template_{};

  CreateCustomScenePolicyResponseBody() {}

  explicit CreateCustomScenePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objects) {
      res["Objects"] = boost::any(*objects);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Objects") != m.end() && !m["Objects"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Objects"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Objects"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      objects = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~CreateCustomScenePolicyResponseBody() = default;
};
class CreateCustomScenePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomScenePolicyResponseBody> body{};

  CreateCustomScenePolicyResponse() {}

  explicit CreateCustomScenePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomScenePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomScenePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomScenePolicyResponse() = default;
};
class CreateEdgeContainerAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> healthCheckFailTimes{};
  shared_ptr<string> healthCheckHost{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<long> healthCheckSuccTimes{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<string> name{};
  shared_ptr<string> remarks{};
  shared_ptr<long> servicePort{};
  shared_ptr<long> targetPort{};

  CreateEdgeContainerAppRequest() {}

  explicit CreateEdgeContainerAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheckFailTimes) {
      res["HealthCheckFailTimes"] = boost::any(*healthCheckFailTimes);
    }
    if (healthCheckHost) {
      res["HealthCheckHost"] = boost::any(*healthCheckHost);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (healthCheckSuccTimes) {
      res["HealthCheckSuccTimes"] = boost::any(*healthCheckSuccTimes);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheckFailTimes") != m.end() && !m["HealthCheckFailTimes"].empty()) {
      healthCheckFailTimes = make_shared<long>(boost::any_cast<long>(m["HealthCheckFailTimes"]));
    }
    if (m.find("HealthCheckHost") != m.end() && !m["HealthCheckHost"].empty()) {
      healthCheckHost = make_shared<string>(boost::any_cast<string>(m["HealthCheckHost"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("HealthCheckSuccTimes") != m.end() && !m["HealthCheckSuccTimes"].empty()) {
      healthCheckSuccTimes = make_shared<long>(boost::any_cast<long>(m["HealthCheckSuccTimes"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
  }


  virtual ~CreateEdgeContainerAppRequest() = default;
};
class CreateEdgeContainerAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> requestId{};

  CreateEdgeContainerAppResponseBody() {}

  explicit CreateEdgeContainerAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEdgeContainerAppResponseBody() = default;
};
class CreateEdgeContainerAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeContainerAppResponseBody> body{};

  CreateEdgeContainerAppResponse() {}

  explicit CreateEdgeContainerAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeContainerAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeContainerAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeContainerAppResponse() = default;
};
class CreateEdgeContainerAppRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};

  CreateEdgeContainerAppRecordRequest() {}

  explicit CreateEdgeContainerAppRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~CreateEdgeContainerAppRecordRequest() = default;
};
class CreateEdgeContainerAppRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateEdgeContainerAppRecordResponseBody() {}

  explicit CreateEdgeContainerAppRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEdgeContainerAppRecordResponseBody() = default;
};
class CreateEdgeContainerAppRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeContainerAppRecordResponseBody> body{};

  CreateEdgeContainerAppRecordResponse() {}

  explicit CreateEdgeContainerAppRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeContainerAppRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeContainerAppRecordResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeContainerAppRecordResponse() = default;
};
class CreateEdgeContainerAppVersionRequestContainersACRImageInfo : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isEnterpriseRegistry{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> tag{};
  shared_ptr<string> tagUrl{};

  CreateEdgeContainerAppVersionRequestContainersACRImageInfo() {}

  explicit CreateEdgeContainerAppVersionRequestContainersACRImageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isEnterpriseRegistry) {
      res["IsEnterpriseRegistry"] = boost::any(*isEnterpriseRegistry);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagUrl) {
      res["TagUrl"] = boost::any(*tagUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsEnterpriseRegistry") != m.end() && !m["IsEnterpriseRegistry"].empty()) {
      isEnterpriseRegistry = make_shared<bool>(boost::any_cast<bool>(m["IsEnterpriseRegistry"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagUrl") != m.end() && !m["TagUrl"].empty()) {
      tagUrl = make_shared<string>(boost::any_cast<string>(m["TagUrl"]));
    }
  }


  virtual ~CreateEdgeContainerAppVersionRequestContainersACRImageInfo() = default;
};
class CreateEdgeContainerAppVersionRequestContainersProbeContent : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<long> failureThreshold{};
  shared_ptr<string> host{};
  shared_ptr<string> httpHeaders{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<string> path{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<long> port{};
  shared_ptr<string> scheme{};
  shared_ptr<long> successThreshold{};
  shared_ptr<long> timeoutSeconds{};

  CreateEdgeContainerAppVersionRequestContainersProbeContent() {}

  explicit CreateEdgeContainerAppVersionRequestContainersProbeContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (failureThreshold) {
      res["FailureThreshold"] = boost::any(*failureThreshold);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (httpHeaders) {
      res["HttpHeaders"] = boost::any(*httpHeaders);
    }
    if (initialDelaySeconds) {
      res["InitialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheme) {
      res["Scheme"] = boost::any(*scheme);
    }
    if (successThreshold) {
      res["SuccessThreshold"] = boost::any(*successThreshold);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("FailureThreshold") != m.end() && !m["FailureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["FailureThreshold"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("HttpHeaders") != m.end() && !m["HttpHeaders"].empty()) {
      httpHeaders = make_shared<string>(boost::any_cast<string>(m["HttpHeaders"]));
    }
    if (m.find("InitialDelaySeconds") != m.end() && !m["InitialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["InitialDelaySeconds"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Scheme") != m.end() && !m["Scheme"].empty()) {
      scheme = make_shared<string>(boost::any_cast<string>(m["Scheme"]));
    }
    if (m.find("SuccessThreshold") != m.end() && !m["SuccessThreshold"].empty()) {
      successThreshold = make_shared<long>(boost::any_cast<long>(m["SuccessThreshold"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~CreateEdgeContainerAppVersionRequestContainersProbeContent() = default;
};
class CreateEdgeContainerAppVersionRequestContainers : public Darabonba::Model {
public:
  shared_ptr<CreateEdgeContainerAppVersionRequestContainersACRImageInfo> ACRImageInfo{};
  shared_ptr<string> args{};
  shared_ptr<string> command{};
  shared_ptr<string> envVariables{};
  shared_ptr<string> image{};
  shared_ptr<bool> isACRImage{};
  shared_ptr<string> name{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<CreateEdgeContainerAppVersionRequestContainersProbeContent> probeContent{};
  shared_ptr<string> probeType{};
  shared_ptr<string> spec{};
  shared_ptr<string> storage{};

  CreateEdgeContainerAppVersionRequestContainers() {}

  explicit CreateEdgeContainerAppVersionRequestContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ACRImageInfo) {
      res["ACRImageInfo"] = ACRImageInfo ? boost::any(ACRImageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (envVariables) {
      res["EnvVariables"] = boost::any(*envVariables);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (isACRImage) {
      res["IsACRImage"] = boost::any(*isACRImage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (probeContent) {
      res["ProbeContent"] = probeContent ? boost::any(probeContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (probeType) {
      res["ProbeType"] = boost::any(*probeType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ACRImageInfo") != m.end() && !m["ACRImageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ACRImageInfo"].type()) {
        CreateEdgeContainerAppVersionRequestContainersACRImageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ACRImageInfo"]));
        ACRImageInfo = make_shared<CreateEdgeContainerAppVersionRequestContainersACRImageInfo>(model1);
      }
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("EnvVariables") != m.end() && !m["EnvVariables"].empty()) {
      envVariables = make_shared<string>(boost::any_cast<string>(m["EnvVariables"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("IsACRImage") != m.end() && !m["IsACRImage"].empty()) {
      isACRImage = make_shared<bool>(boost::any_cast<bool>(m["IsACRImage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProbeContent") != m.end() && !m["ProbeContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProbeContent"].type()) {
        CreateEdgeContainerAppVersionRequestContainersProbeContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProbeContent"]));
        probeContent = make_shared<CreateEdgeContainerAppVersionRequestContainersProbeContent>(model1);
      }
    }
    if (m.find("ProbeType") != m.end() && !m["ProbeType"].empty()) {
      probeType = make_shared<string>(boost::any_cast<string>(m["ProbeType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<string>(boost::any_cast<string>(m["Storage"]));
    }
  }


  virtual ~CreateEdgeContainerAppVersionRequestContainers() = default;
};
class CreateEdgeContainerAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<vector<CreateEdgeContainerAppVersionRequestContainers>> containers{};
  shared_ptr<string> name{};
  shared_ptr<string> remarks{};

  CreateEdgeContainerAppVersionRequest() {}

  explicit CreateEdgeContainerAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<CreateEdgeContainerAppVersionRequestContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEdgeContainerAppVersionRequestContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<CreateEdgeContainerAppVersionRequestContainers>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
  }


  virtual ~CreateEdgeContainerAppVersionRequest() = default;
};
class CreateEdgeContainerAppVersionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> containersShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> remarks{};

  CreateEdgeContainerAppVersionShrinkRequest() {}

  explicit CreateEdgeContainerAppVersionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (containersShrink) {
      res["Containers"] = boost::any(*containersShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      containersShrink = make_shared<string>(boost::any_cast<string>(m["Containers"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
  }


  virtual ~CreateEdgeContainerAppVersionShrinkRequest() = default;
};
class CreateEdgeContainerAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> versionId{};

  CreateEdgeContainerAppVersionResponseBody() {}

  explicit CreateEdgeContainerAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~CreateEdgeContainerAppVersionResponseBody() = default;
};
class CreateEdgeContainerAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeContainerAppVersionResponseBody> body{};

  CreateEdgeContainerAppVersionResponse() {}

  explicit CreateEdgeContainerAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeContainerAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeContainerAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeContainerAppVersionResponse() = default;
};
class CreateKvNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};

  CreateKvNamespaceRequest() {}

  explicit CreateKvNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~CreateKvNamespaceRequest() = default;
};
class CreateKvNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  CreateKvNamespaceResponseBody() {}

  explicit CreateKvNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateKvNamespaceResponseBody() = default;
};
class CreateKvNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateKvNamespaceResponseBody> body{};

  CreateKvNamespaceResponse() {}

  explicit CreateKvNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateKvNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateKvNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateKvNamespaceResponse() = default;
};
class CreateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<string>> items{};
  shared_ptr<string> kind{};
  shared_ptr<string> name{};

  CreateListRequest() {}

  explicit CreateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateListRequest() = default;
};
class CreateListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> itemsShrink{};
  shared_ptr<string> kind{};
  shared_ptr<string> name{};

  CreateListShrinkRequest() {}

  explicit CreateListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (itemsShrink) {
      res["Items"] = boost::any(*itemsShrink);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      itemsShrink = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateListShrinkRequest() = default;
};
class CreateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateListResponseBody() {}

  explicit CreateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateListResponseBody() = default;
};
class CreateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateListResponseBody> body{};

  CreateListResponse() {}

  explicit CreateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateListResponseBody>(model1);
      }
    }
  }


  virtual ~CreateListResponse() = default;
};
class CreateOriginProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  CreateOriginProtectionRequest() {}

  explicit CreateOriginProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~CreateOriginProtectionRequest() = default;
};
class CreateOriginProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateOriginProtectionResponseBody() {}

  explicit CreateOriginProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOriginProtectionResponseBody() = default;
};
class CreateOriginProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOriginProtectionResponseBody> body{};

  CreateOriginProtectionResponse() {}

  explicit CreateOriginProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOriginProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOriginProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOriginProtectionResponse() = default;
};
class CreatePageRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};

  CreatePageRequest() {}

  explicit CreatePageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreatePageRequest() = default;
};
class CreatePageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreatePageResponseBody() {}

  explicit CreatePageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePageResponseBody() = default;
};
class CreatePageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePageResponseBody> body{};

  CreatePageResponse() {}

  explicit CreatePageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePageResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePageResponse() = default;
};
class CreateRecordRequestAuthConf : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> authType{};
  shared_ptr<string> region{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> version{};

  CreateRecordRequestAuthConf() {}

  explicit CreateRecordRequestAuthConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateRecordRequestAuthConf() = default;
};
class CreateRecordRequestData : public Darabonba::Model {
public:
  shared_ptr<long> algorithm{};
  shared_ptr<string> certificate{};
  shared_ptr<string> fingerprint{};
  shared_ptr<long> flag{};
  shared_ptr<long> keyTag{};
  shared_ptr<long> matchingType{};
  shared_ptr<long> port{};
  shared_ptr<long> priority{};
  shared_ptr<long> selector{};
  shared_ptr<string> tag{};
  shared_ptr<long> type{};
  shared_ptr<long> usage{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  CreateRecordRequestData() {}

  explicit CreateRecordRequestData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (keyTag) {
      res["KeyTag"] = boost::any(*keyTag);
    }
    if (matchingType) {
      res["MatchingType"] = boost::any(*matchingType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<long>(boost::any_cast<long>(m["Algorithm"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("KeyTag") != m.end() && !m["KeyTag"].empty()) {
      keyTag = make_shared<long>(boost::any_cast<long>(m["KeyTag"]));
    }
    if (m.find("MatchingType") != m.end() && !m["MatchingType"].empty()) {
      matchingType = make_shared<long>(boost::any_cast<long>(m["MatchingType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<long>(boost::any_cast<long>(m["Selector"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateRecordRequestData() = default;
};
class CreateRecordRequest : public Darabonba::Model {
public:
  shared_ptr<CreateRecordRequestAuthConf> authConf{};
  shared_ptr<string> bizName{};
  shared_ptr<string> comment{};
  shared_ptr<CreateRecordRequestData> data{};
  shared_ptr<string> hostPolicy{};
  shared_ptr<bool> proxied{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> ttl{};
  shared_ptr<string> type{};

  CreateRecordRequest() {}

  explicit CreateRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConf) {
      res["AuthConf"] = authConf ? boost::any(authConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostPolicy) {
      res["HostPolicy"] = boost::any(*hostPolicy);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthConf") != m.end() && !m["AuthConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthConf"].type()) {
        CreateRecordRequestAuthConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthConf"]));
        authConf = make_shared<CreateRecordRequestAuthConf>(model1);
      }
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateRecordRequestData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateRecordRequestData>(model1);
      }
    }
    if (m.find("HostPolicy") != m.end() && !m["HostPolicy"].empty()) {
      hostPolicy = make_shared<string>(boost::any_cast<string>(m["HostPolicy"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateRecordRequest() = default;
};
class CreateRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> authConfShrink{};
  shared_ptr<string> bizName{};
  shared_ptr<string> comment{};
  shared_ptr<string> dataShrink{};
  shared_ptr<string> hostPolicy{};
  shared_ptr<bool> proxied{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> ttl{};
  shared_ptr<string> type{};

  CreateRecordShrinkRequest() {}

  explicit CreateRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConfShrink) {
      res["AuthConf"] = boost::any(*authConfShrink);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (dataShrink) {
      res["Data"] = boost::any(*dataShrink);
    }
    if (hostPolicy) {
      res["HostPolicy"] = boost::any(*hostPolicy);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthConf") != m.end() && !m["AuthConf"].empty()) {
      authConfShrink = make_shared<string>(boost::any_cast<string>(m["AuthConf"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      dataShrink = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HostPolicy") != m.end() && !m["HostPolicy"].empty()) {
      hostPolicy = make_shared<string>(boost::any_cast<string>(m["HostPolicy"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateRecordShrinkRequest() = default;
};
class CreateRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> recordId{};
  shared_ptr<string> requestId{};

  CreateRecordResponseBody() {}

  explicit CreateRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRecordResponseBody() = default;
};
class CreateRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRecordResponseBody> body{};

  CreateRecordResponse() {}

  explicit CreateRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRecordResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRecordResponse() = default;
};
class CreateRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> specName{};

  CreateRoutineRequest() {}

  explicit CreateRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
  }


  virtual ~CreateRoutineRequest() = default;
};
class CreateRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  CreateRoutineResponseBody() {}

  explicit CreateRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateRoutineResponseBody() = default;
};
class CreateRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRoutineResponseBody> body{};

  CreateRoutineResponse() {}

  explicit CreateRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRoutineResponse() = default;
};
class CreateRoutineRelatedRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};

  CreateRoutineRelatedRecordRequest() {}

  explicit CreateRoutineRelatedRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~CreateRoutineRelatedRecordRequest() = default;
};
class CreateRoutineRelatedRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  CreateRoutineRelatedRecordResponseBody() {}

  explicit CreateRoutineRelatedRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateRoutineRelatedRecordResponseBody() = default;
};
class CreateRoutineRelatedRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRoutineRelatedRecordResponseBody> body{};

  CreateRoutineRelatedRecordResponse() {}

  explicit CreateRoutineRelatedRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRoutineRelatedRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRoutineRelatedRecordResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRoutineRelatedRecordResponse() = default;
};
class CreateRoutineRelatedRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> route{};
  shared_ptr<long> siteId{};

  CreateRoutineRelatedRouteRequest() {}

  explicit CreateRoutineRelatedRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (route) {
      res["Route"] = boost::any(*route);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      route = make_shared<string>(boost::any_cast<string>(m["Route"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~CreateRoutineRelatedRouteRequest() = default;
};
class CreateRoutineRelatedRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  CreateRoutineRelatedRouteResponseBody() {}

  explicit CreateRoutineRelatedRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateRoutineRelatedRouteResponseBody() = default;
};
class CreateRoutineRelatedRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRoutineRelatedRouteResponseBody> body{};

  CreateRoutineRelatedRouteResponse() {}

  explicit CreateRoutineRelatedRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRoutineRelatedRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRoutineRelatedRouteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRoutineRelatedRouteResponse() = default;
};
class CreateScheduledPreloadExecutionsRequestExecutions : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> interval{};
  shared_ptr<long> sliceLen{};
  shared_ptr<string> startTime{};

  CreateScheduledPreloadExecutionsRequestExecutions() {}

  explicit CreateScheduledPreloadExecutionsRequestExecutions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (sliceLen) {
      res["SliceLen"] = boost::any(*sliceLen);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("SliceLen") != m.end() && !m["SliceLen"].empty()) {
      sliceLen = make_shared<long>(boost::any_cast<long>(m["SliceLen"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CreateScheduledPreloadExecutionsRequestExecutions() = default;
};
class CreateScheduledPreloadExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateScheduledPreloadExecutionsRequestExecutions>> executions{};
  shared_ptr<string> id{};

  CreateScheduledPreloadExecutionsRequest() {}

  explicit CreateScheduledPreloadExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executions) {
      vector<boost::any> temp1;
      for(auto item1:*executions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Executions"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      if (typeid(vector<boost::any>) == m["Executions"].type()) {
        vector<CreateScheduledPreloadExecutionsRequestExecutions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Executions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScheduledPreloadExecutionsRequestExecutions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        executions = make_shared<vector<CreateScheduledPreloadExecutionsRequestExecutions>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateScheduledPreloadExecutionsRequest() = default;
};
class CreateScheduledPreloadExecutionsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> executionsShrink{};
  shared_ptr<string> id{};

  CreateScheduledPreloadExecutionsShrinkRequest() {}

  explicit CreateScheduledPreloadExecutionsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionsShrink) {
      res["Executions"] = boost::any(*executionsShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executionsShrink = make_shared<string>(boost::any_cast<string>(m["Executions"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateScheduledPreloadExecutionsShrinkRequest() = default;
};
class CreateScheduledPreloadExecutionsResponseBodyFailedExecutions : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jobId{};
  shared_ptr<long> sliceLen{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  CreateScheduledPreloadExecutionsResponseBodyFailedExecutions() {}

  explicit CreateScheduledPreloadExecutionsResponseBodyFailedExecutions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (sliceLen) {
      res["SliceLen"] = boost::any(*sliceLen);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SliceLen") != m.end() && !m["SliceLen"].empty()) {
      sliceLen = make_shared<long>(boost::any_cast<long>(m["SliceLen"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateScheduledPreloadExecutionsResponseBodyFailedExecutions() = default;
};
class CreateScheduledPreloadExecutionsResponseBodySuccessExecutions : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jobId{};
  shared_ptr<long> sliceLen{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  CreateScheduledPreloadExecutionsResponseBodySuccessExecutions() {}

  explicit CreateScheduledPreloadExecutionsResponseBodySuccessExecutions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (sliceLen) {
      res["SliceLen"] = boost::any(*sliceLen);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SliceLen") != m.end() && !m["SliceLen"].empty()) {
      sliceLen = make_shared<long>(boost::any_cast<long>(m["SliceLen"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateScheduledPreloadExecutionsResponseBodySuccessExecutions() = default;
};
class CreateScheduledPreloadExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateScheduledPreloadExecutionsResponseBodyFailedExecutions>> failedExecutions{};
  shared_ptr<vector<string>> failedMessages{};
  shared_ptr<string> requestId{};
  shared_ptr<long> successCount{};
  shared_ptr<vector<CreateScheduledPreloadExecutionsResponseBodySuccessExecutions>> successExecutions{};
  shared_ptr<long> totalCount{};

  CreateScheduledPreloadExecutionsResponseBody() {}

  explicit CreateScheduledPreloadExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedExecutions) {
      vector<boost::any> temp1;
      for(auto item1:*failedExecutions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedExecutions"] = boost::any(temp1);
    }
    if (failedMessages) {
      res["FailedMessages"] = boost::any(*failedMessages);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (successExecutions) {
      vector<boost::any> temp1;
      for(auto item1:*successExecutions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuccessExecutions"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedExecutions") != m.end() && !m["FailedExecutions"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedExecutions"].type()) {
        vector<CreateScheduledPreloadExecutionsResponseBodyFailedExecutions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedExecutions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScheduledPreloadExecutionsResponseBodyFailedExecutions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedExecutions = make_shared<vector<CreateScheduledPreloadExecutionsResponseBodyFailedExecutions>>(expect1);
      }
    }
    if (m.find("FailedMessages") != m.end() && !m["FailedMessages"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedMessages"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedMessages"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedMessages = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("SuccessExecutions") != m.end() && !m["SuccessExecutions"].empty()) {
      if (typeid(vector<boost::any>) == m["SuccessExecutions"].type()) {
        vector<CreateScheduledPreloadExecutionsResponseBodySuccessExecutions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuccessExecutions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScheduledPreloadExecutionsResponseBodySuccessExecutions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        successExecutions = make_shared<vector<CreateScheduledPreloadExecutionsResponseBodySuccessExecutions>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateScheduledPreloadExecutionsResponseBody() = default;
};
class CreateScheduledPreloadExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScheduledPreloadExecutionsResponseBody> body{};

  CreateScheduledPreloadExecutionsResponse() {}

  explicit CreateScheduledPreloadExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScheduledPreloadExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScheduledPreloadExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScheduledPreloadExecutionsResponse() = default;
};
class CreateScheduledPreloadJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> insertWay{};
  shared_ptr<string> name{};
  shared_ptr<string> ossUrl{};
  shared_ptr<long> siteId{};
  shared_ptr<string> urlList{};

  CreateScheduledPreloadJobRequest() {}

  explicit CreateScheduledPreloadJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insertWay) {
      res["InsertWay"] = boost::any(*insertWay);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (urlList) {
      res["UrlList"] = boost::any(*urlList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InsertWay") != m.end() && !m["InsertWay"].empty()) {
      insertWay = make_shared<string>(boost::any_cast<string>(m["InsertWay"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      urlList = make_shared<string>(boost::any_cast<string>(m["UrlList"]));
    }
  }


  virtual ~CreateScheduledPreloadJobRequest() = default;
};
class CreateScheduledPreloadJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> domains{};
  shared_ptr<string> errorInfo{};
  shared_ptr<string> failedFileOss{};
  shared_ptr<string> fileId{};
  shared_ptr<string> id{};
  shared_ptr<string> insertWay{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<long> taskSubmitted{};
  shared_ptr<string> taskType{};
  shared_ptr<long> urlCount{};
  shared_ptr<long> urlSubmitted{};

  CreateScheduledPreloadJobResponseBody() {}

  explicit CreateScheduledPreloadJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (createdAt) {
      res["CreatedAt"] = boost::any(*createdAt);
    }
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (failedFileOss) {
      res["FailedFileOss"] = boost::any(*failedFileOss);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (insertWay) {
      res["InsertWay"] = boost::any(*insertWay);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskSubmitted) {
      res["TaskSubmitted"] = boost::any(*taskSubmitted);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (urlCount) {
      res["UrlCount"] = boost::any(*urlCount);
    }
    if (urlSubmitted) {
      res["UrlSubmitted"] = boost::any(*urlSubmitted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("CreatedAt") != m.end() && !m["CreatedAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["CreatedAt"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      domains = make_shared<string>(boost::any_cast<string>(m["Domains"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("FailedFileOss") != m.end() && !m["FailedFileOss"].empty()) {
      failedFileOss = make_shared<string>(boost::any_cast<string>(m["FailedFileOss"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InsertWay") != m.end() && !m["InsertWay"].empty()) {
      insertWay = make_shared<string>(boost::any_cast<string>(m["InsertWay"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TaskSubmitted") != m.end() && !m["TaskSubmitted"].empty()) {
      taskSubmitted = make_shared<long>(boost::any_cast<long>(m["TaskSubmitted"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UrlCount") != m.end() && !m["UrlCount"].empty()) {
      urlCount = make_shared<long>(boost::any_cast<long>(m["UrlCount"]));
    }
    if (m.find("UrlSubmitted") != m.end() && !m["UrlSubmitted"].empty()) {
      urlSubmitted = make_shared<long>(boost::any_cast<long>(m["UrlSubmitted"]));
    }
  }


  virtual ~CreateScheduledPreloadJobResponseBody() = default;
};
class CreateScheduledPreloadJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScheduledPreloadJobResponseBody> body{};

  CreateScheduledPreloadJobResponse() {}

  explicit CreateScheduledPreloadJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScheduledPreloadJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScheduledPreloadJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScheduledPreloadJobResponse() = default;
};
class CreateSiteRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> coverage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> siteName{};

  CreateSiteRequest() {}

  explicit CreateSiteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~CreateSiteRequest() = default;
};
class CreateSiteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nameServerList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> verifyCode{};

  CreateSiteResponseBody() {}

  explicit CreateSiteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameServerList) {
      res["NameServerList"] = boost::any(*nameServerList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (verifyCode) {
      res["VerifyCode"] = boost::any(*verifyCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameServerList") != m.end() && !m["NameServerList"].empty()) {
      nameServerList = make_shared<string>(boost::any_cast<string>(m["NameServerList"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("VerifyCode") != m.end() && !m["VerifyCode"].empty()) {
      verifyCode = make_shared<string>(boost::any_cast<string>(m["VerifyCode"]));
    }
  }


  virtual ~CreateSiteResponseBody() = default;
};
class CreateSiteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSiteResponseBody> body{};

  CreateSiteResponse() {}

  explicit CreateSiteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSiteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSiteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSiteResponse() = default;
};
class CreateSiteCustomLogRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cookies{};
  shared_ptr<vector<string>> requestHeaders{};
  shared_ptr<vector<string>> responseHeaders{};
  shared_ptr<long> siteId{};

  CreateSiteCustomLogRequest() {}

  explicit CreateSiteCustomLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookies) {
      res["Cookies"] = boost::any(*cookies);
    }
    if (requestHeaders) {
      res["RequestHeaders"] = boost::any(*requestHeaders);
    }
    if (responseHeaders) {
      res["ResponseHeaders"] = boost::any(*responseHeaders);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookies") != m.end() && !m["Cookies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Cookies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Cookies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cookies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResponseHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResponseHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      responseHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~CreateSiteCustomLogRequest() = default;
};
class CreateSiteCustomLogShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cookiesShrink{};
  shared_ptr<string> requestHeadersShrink{};
  shared_ptr<string> responseHeadersShrink{};
  shared_ptr<long> siteId{};

  CreateSiteCustomLogShrinkRequest() {}

  explicit CreateSiteCustomLogShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookiesShrink) {
      res["Cookies"] = boost::any(*cookiesShrink);
    }
    if (requestHeadersShrink) {
      res["RequestHeaders"] = boost::any(*requestHeadersShrink);
    }
    if (responseHeadersShrink) {
      res["ResponseHeaders"] = boost::any(*responseHeadersShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookies") != m.end() && !m["Cookies"].empty()) {
      cookiesShrink = make_shared<string>(boost::any_cast<string>(m["Cookies"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      requestHeadersShrink = make_shared<string>(boost::any_cast<string>(m["RequestHeaders"]));
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      responseHeadersShrink = make_shared<string>(boost::any_cast<string>(m["ResponseHeaders"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~CreateSiteCustomLogShrinkRequest() = default;
};
class CreateSiteCustomLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateSiteCustomLogResponseBody() {}

  explicit CreateSiteCustomLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSiteCustomLogResponseBody() = default;
};
class CreateSiteCustomLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSiteCustomLogResponseBody> body{};

  CreateSiteCustomLogResponse() {}

  explicit CreateSiteCustomLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSiteCustomLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSiteCustomLogResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSiteCustomLogResponse() = default;
};
class CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam : public Darabonba::Model {
public:
  shared_ptr<long> expiredTime{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> urlPath{};

  CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam() {}

  explicit CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (urlPath) {
      res["UrlPath"] = boost::any(*urlPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("UrlPath") != m.end() && !m["UrlPath"].empty()) {
      urlPath = make_shared<string>(boost::any_cast<string>(m["UrlPath"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam() = default;
};
class CreateSiteDeliveryTaskRequestHttpDelivery : public Darabonba::Model {
public:
  shared_ptr<string> compress{};
  shared_ptr<string> destUrl{};
  shared_ptr<map<string, HttpDeliveryHeaderParamValue>> headerParam{};
  shared_ptr<string> logBodyPrefix{};
  shared_ptr<string> logBodySuffix{};
  shared_ptr<long> maxBatchMB{};
  shared_ptr<long> maxBatchSize{};
  shared_ptr<long> maxRetry{};
  shared_ptr<map<string, HttpDeliveryQueryParamValue>> queryParam{};
  shared_ptr<bool> standardAuthOn{};
  shared_ptr<CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam> standardAuthParam{};
  shared_ptr<long> transformTimeout{};

  CreateSiteDeliveryTaskRequestHttpDelivery() {}

  explicit CreateSiteDeliveryTaskRequestHttpDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compress) {
      res["Compress"] = boost::any(*compress);
    }
    if (destUrl) {
      res["DestUrl"] = boost::any(*destUrl);
    }
    if (headerParam) {
      map<string, boost::any> temp1;
      for(auto item1:*headerParam){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["HeaderParam"] = boost::any(temp1);
    }
    if (logBodyPrefix) {
      res["LogBodyPrefix"] = boost::any(*logBodyPrefix);
    }
    if (logBodySuffix) {
      res["LogBodySuffix"] = boost::any(*logBodySuffix);
    }
    if (maxBatchMB) {
      res["MaxBatchMB"] = boost::any(*maxBatchMB);
    }
    if (maxBatchSize) {
      res["MaxBatchSize"] = boost::any(*maxBatchSize);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (queryParam) {
      map<string, boost::any> temp1;
      for(auto item1:*queryParam){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["QueryParam"] = boost::any(temp1);
    }
    if (standardAuthOn) {
      res["StandardAuthOn"] = boost::any(*standardAuthOn);
    }
    if (standardAuthParam) {
      res["StandardAuthParam"] = standardAuthParam ? boost::any(standardAuthParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transformTimeout) {
      res["TransformTimeout"] = boost::any(*transformTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compress") != m.end() && !m["Compress"].empty()) {
      compress = make_shared<string>(boost::any_cast<string>(m["Compress"]));
    }
    if (m.find("DestUrl") != m.end() && !m["DestUrl"].empty()) {
      destUrl = make_shared<string>(boost::any_cast<string>(m["DestUrl"]));
    }
    if (m.find("HeaderParam") != m.end() && !m["HeaderParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeaderParam"].type()) {
        map<string, HttpDeliveryHeaderParamValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["HeaderParam"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            HttpDeliveryHeaderParamValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        headerParam = make_shared<map<string, HttpDeliveryHeaderParamValue>>(expect1);
      }
    }
    if (m.find("LogBodyPrefix") != m.end() && !m["LogBodyPrefix"].empty()) {
      logBodyPrefix = make_shared<string>(boost::any_cast<string>(m["LogBodyPrefix"]));
    }
    if (m.find("LogBodySuffix") != m.end() && !m["LogBodySuffix"].empty()) {
      logBodySuffix = make_shared<string>(boost::any_cast<string>(m["LogBodySuffix"]));
    }
    if (m.find("MaxBatchMB") != m.end() && !m["MaxBatchMB"].empty()) {
      maxBatchMB = make_shared<long>(boost::any_cast<long>(m["MaxBatchMB"]));
    }
    if (m.find("MaxBatchSize") != m.end() && !m["MaxBatchSize"].empty()) {
      maxBatchSize = make_shared<long>(boost::any_cast<long>(m["MaxBatchSize"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("QueryParam") != m.end() && !m["QueryParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryParam"].type()) {
        map<string, HttpDeliveryQueryParamValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["QueryParam"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            HttpDeliveryQueryParamValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        queryParam = make_shared<map<string, HttpDeliveryQueryParamValue>>(expect1);
      }
    }
    if (m.find("StandardAuthOn") != m.end() && !m["StandardAuthOn"].empty()) {
      standardAuthOn = make_shared<bool>(boost::any_cast<bool>(m["StandardAuthOn"]));
    }
    if (m.find("StandardAuthParam") != m.end() && !m["StandardAuthParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardAuthParam"].type()) {
        CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardAuthParam"]));
        standardAuthParam = make_shared<CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam>(model1);
      }
    }
    if (m.find("TransformTimeout") != m.end() && !m["TransformTimeout"].empty()) {
      transformTimeout = make_shared<long>(boost::any_cast<long>(m["TransformTimeout"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskRequestHttpDelivery() = default;
};
class CreateSiteDeliveryTaskRequestKafkaDelivery : public Darabonba::Model {
public:
  shared_ptr<string> balancer{};
  shared_ptr<vector<string>> brokers{};
  shared_ptr<string> compress{};
  shared_ptr<string> machanismType{};
  shared_ptr<string> password{};
  shared_ptr<string> topic{};
  shared_ptr<bool> userAuth{};
  shared_ptr<string> userName{};

  CreateSiteDeliveryTaskRequestKafkaDelivery() {}

  explicit CreateSiteDeliveryTaskRequestKafkaDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (balancer) {
      res["Balancer"] = boost::any(*balancer);
    }
    if (brokers) {
      res["Brokers"] = boost::any(*brokers);
    }
    if (compress) {
      res["Compress"] = boost::any(*compress);
    }
    if (machanismType) {
      res["MachanismType"] = boost::any(*machanismType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (userAuth) {
      res["UserAuth"] = boost::any(*userAuth);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Balancer") != m.end() && !m["Balancer"].empty()) {
      balancer = make_shared<string>(boost::any_cast<string>(m["Balancer"]));
    }
    if (m.find("Brokers") != m.end() && !m["Brokers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Brokers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Brokers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      brokers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Compress") != m.end() && !m["Compress"].empty()) {
      compress = make_shared<string>(boost::any_cast<string>(m["Compress"]));
    }
    if (m.find("MachanismType") != m.end() && !m["MachanismType"].empty()) {
      machanismType = make_shared<string>(boost::any_cast<string>(m["MachanismType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("UserAuth") != m.end() && !m["UserAuth"].empty()) {
      userAuth = make_shared<bool>(boost::any_cast<bool>(m["UserAuth"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskRequestKafkaDelivery() = default;
};
class CreateSiteDeliveryTaskRequestOssDelivery : public Darabonba::Model {
public:
  shared_ptr<string> aliuid{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> prefixPath{};
  shared_ptr<string> region{};

  CreateSiteDeliveryTaskRequestOssDelivery() {}

  explicit CreateSiteDeliveryTaskRequestOssDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliuid) {
      res["Aliuid"] = boost::any(*aliuid);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (prefixPath) {
      res["PrefixPath"] = boost::any(*prefixPath);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aliuid") != m.end() && !m["Aliuid"].empty()) {
      aliuid = make_shared<string>(boost::any_cast<string>(m["Aliuid"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("PrefixPath") != m.end() && !m["PrefixPath"].empty()) {
      prefixPath = make_shared<string>(boost::any_cast<string>(m["PrefixPath"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskRequestOssDelivery() = default;
};
class CreateSiteDeliveryTaskRequestS3Delivery : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> bucketPath{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> prefixPath{};
  shared_ptr<string> region{};
  shared_ptr<bool> s3Cmpt{};
  shared_ptr<string> secretKey{};
  shared_ptr<bool> serverSideEncryption{};
  shared_ptr<string> vertifyType{};

  CreateSiteDeliveryTaskRequestS3Delivery() {}

  explicit CreateSiteDeliveryTaskRequestS3Delivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (bucketPath) {
      res["BucketPath"] = boost::any(*bucketPath);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (prefixPath) {
      res["PrefixPath"] = boost::any(*prefixPath);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (s3Cmpt) {
      res["S3Cmpt"] = boost::any(*s3Cmpt);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (serverSideEncryption) {
      res["ServerSideEncryption"] = boost::any(*serverSideEncryption);
    }
    if (vertifyType) {
      res["VertifyType"] = boost::any(*vertifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("BucketPath") != m.end() && !m["BucketPath"].empty()) {
      bucketPath = make_shared<string>(boost::any_cast<string>(m["BucketPath"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("PrefixPath") != m.end() && !m["PrefixPath"].empty()) {
      prefixPath = make_shared<string>(boost::any_cast<string>(m["PrefixPath"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("S3Cmpt") != m.end() && !m["S3Cmpt"].empty()) {
      s3Cmpt = make_shared<bool>(boost::any_cast<bool>(m["S3Cmpt"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("ServerSideEncryption") != m.end() && !m["ServerSideEncryption"].empty()) {
      serverSideEncryption = make_shared<bool>(boost::any_cast<bool>(m["ServerSideEncryption"]));
    }
    if (m.find("VertifyType") != m.end() && !m["VertifyType"].empty()) {
      vertifyType = make_shared<string>(boost::any_cast<string>(m["VertifyType"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskRequestS3Delivery() = default;
};
class CreateSiteDeliveryTaskRequestSlsDelivery : public Darabonba::Model {
public:
  shared_ptr<string> SLSLogStore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};

  CreateSiteDeliveryTaskRequestSlsDelivery() {}

  explicit CreateSiteDeliveryTaskRequestSlsDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SLSLogStore) {
      res["SLSLogStore"] = boost::any(*SLSLogStore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SLSLogStore") != m.end() && !m["SLSLogStore"].empty()) {
      SLSLogStore = make_shared<string>(boost::any_cast<string>(m["SLSLogStore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskRequestSlsDelivery() = default;
};
class CreateSiteDeliveryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deliveryType{};
  shared_ptr<double> discardRate{};
  shared_ptr<string> fieldName{};
  shared_ptr<CreateSiteDeliveryTaskRequestHttpDelivery> httpDelivery{};
  shared_ptr<CreateSiteDeliveryTaskRequestKafkaDelivery> kafkaDelivery{};
  shared_ptr<CreateSiteDeliveryTaskRequestOssDelivery> ossDelivery{};
  shared_ptr<CreateSiteDeliveryTaskRequestS3Delivery> s3Delivery{};
  shared_ptr<long> siteId{};
  shared_ptr<CreateSiteDeliveryTaskRequestSlsDelivery> slsDelivery{};
  shared_ptr<string> taskName{};

  CreateSiteDeliveryTaskRequest() {}

  explicit CreateSiteDeliveryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (discardRate) {
      res["DiscardRate"] = boost::any(*discardRate);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (httpDelivery) {
      res["HttpDelivery"] = httpDelivery ? boost::any(httpDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kafkaDelivery) {
      res["KafkaDelivery"] = kafkaDelivery ? boost::any(kafkaDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ossDelivery) {
      res["OssDelivery"] = ossDelivery ? boost::any(ossDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (s3Delivery) {
      res["S3Delivery"] = s3Delivery ? boost::any(s3Delivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (slsDelivery) {
      res["SlsDelivery"] = slsDelivery ? boost::any(slsDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<string>(boost::any_cast<string>(m["DeliveryType"]));
    }
    if (m.find("DiscardRate") != m.end() && !m["DiscardRate"].empty()) {
      discardRate = make_shared<double>(boost::any_cast<double>(m["DiscardRate"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("HttpDelivery") != m.end() && !m["HttpDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpDelivery"].type()) {
        CreateSiteDeliveryTaskRequestHttpDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpDelivery"]));
        httpDelivery = make_shared<CreateSiteDeliveryTaskRequestHttpDelivery>(model1);
      }
    }
    if (m.find("KafkaDelivery") != m.end() && !m["KafkaDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["KafkaDelivery"].type()) {
        CreateSiteDeliveryTaskRequestKafkaDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KafkaDelivery"]));
        kafkaDelivery = make_shared<CreateSiteDeliveryTaskRequestKafkaDelivery>(model1);
      }
    }
    if (m.find("OssDelivery") != m.end() && !m["OssDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssDelivery"].type()) {
        CreateSiteDeliveryTaskRequestOssDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssDelivery"]));
        ossDelivery = make_shared<CreateSiteDeliveryTaskRequestOssDelivery>(model1);
      }
    }
    if (m.find("S3Delivery") != m.end() && !m["S3Delivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["S3Delivery"].type()) {
        CreateSiteDeliveryTaskRequestS3Delivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["S3Delivery"]));
        s3Delivery = make_shared<CreateSiteDeliveryTaskRequestS3Delivery>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SlsDelivery") != m.end() && !m["SlsDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlsDelivery"].type()) {
        CreateSiteDeliveryTaskRequestSlsDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlsDelivery"]));
        slsDelivery = make_shared<CreateSiteDeliveryTaskRequestSlsDelivery>(model1);
      }
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskRequest() = default;
};
class CreateSiteDeliveryTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deliveryType{};
  shared_ptr<double> discardRate{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> httpDeliveryShrink{};
  shared_ptr<string> kafkaDeliveryShrink{};
  shared_ptr<string> ossDeliveryShrink{};
  shared_ptr<string> s3DeliveryShrink{};
  shared_ptr<long> siteId{};
  shared_ptr<string> slsDeliveryShrink{};
  shared_ptr<string> taskName{};

  CreateSiteDeliveryTaskShrinkRequest() {}

  explicit CreateSiteDeliveryTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (discardRate) {
      res["DiscardRate"] = boost::any(*discardRate);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (httpDeliveryShrink) {
      res["HttpDelivery"] = boost::any(*httpDeliveryShrink);
    }
    if (kafkaDeliveryShrink) {
      res["KafkaDelivery"] = boost::any(*kafkaDeliveryShrink);
    }
    if (ossDeliveryShrink) {
      res["OssDelivery"] = boost::any(*ossDeliveryShrink);
    }
    if (s3DeliveryShrink) {
      res["S3Delivery"] = boost::any(*s3DeliveryShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (slsDeliveryShrink) {
      res["SlsDelivery"] = boost::any(*slsDeliveryShrink);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<string>(boost::any_cast<string>(m["DeliveryType"]));
    }
    if (m.find("DiscardRate") != m.end() && !m["DiscardRate"].empty()) {
      discardRate = make_shared<double>(boost::any_cast<double>(m["DiscardRate"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("HttpDelivery") != m.end() && !m["HttpDelivery"].empty()) {
      httpDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["HttpDelivery"]));
    }
    if (m.find("KafkaDelivery") != m.end() && !m["KafkaDelivery"].empty()) {
      kafkaDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["KafkaDelivery"]));
    }
    if (m.find("OssDelivery") != m.end() && !m["OssDelivery"].empty()) {
      ossDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["OssDelivery"]));
    }
    if (m.find("S3Delivery") != m.end() && !m["S3Delivery"].empty()) {
      s3DeliveryShrink = make_shared<string>(boost::any_cast<string>(m["S3Delivery"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SlsDelivery") != m.end() && !m["SlsDelivery"].empty()) {
      slsDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["SlsDelivery"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskShrinkRequest() = default;
};
class CreateSiteDeliveryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataCenter{};
  shared_ptr<string> requestId{};
  shared_ptr<string> siteId{};
  shared_ptr<string> taskName{};

  CreateSiteDeliveryTaskResponseBody() {}

  explicit CreateSiteDeliveryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<string>(boost::any_cast<string>(m["SiteId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateSiteDeliveryTaskResponseBody() = default;
};
class CreateSiteDeliveryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSiteDeliveryTaskResponseBody> body{};

  CreateSiteDeliveryTaskResponse() {}

  explicit CreateSiteDeliveryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSiteDeliveryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSiteDeliveryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSiteDeliveryTaskResponse() = default;
};
class CreateSiteFunctionRequestCacheReserve : public Darabonba::Model {
public:
  shared_ptr<string> enable{};
  shared_ptr<string> instanceId{};

  CreateSiteFunctionRequestCacheReserve() {}

  explicit CreateSiteFunctionRequestCacheReserve(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateSiteFunctionRequestCacheReserve() = default;
};
class CreateSiteFunctionRequestCacheRules : public Darabonba::Model {
public:
  shared_ptr<string> additionalCacheablePorts{};
  shared_ptr<string> browserCacheMode{};
  shared_ptr<string> browserCacheTtl{};
  shared_ptr<string> bypassCache{};
  shared_ptr<string> cacheDeceptionArmor{};
  shared_ptr<string> cacheReserveEligibility{};
  shared_ptr<string> checkPresenceCookie{};
  shared_ptr<string> checkPresenceHeader{};
  shared_ptr<string> edgeCacheMode{};
  shared_ptr<string> edgeCacheTtl{};
  shared_ptr<string> edgeStatusCodeCacheTtl{};
  shared_ptr<string> includeCookie{};
  shared_ptr<string> includeHeader{};
  shared_ptr<string> queryString{};
  shared_ptr<string> queryStringMode{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> serveStale{};
  shared_ptr<string> sortQueryStringForCache{};
  shared_ptr<string> userDeviceType{};
  shared_ptr<string> userGeo{};
  shared_ptr<string> userLanguage{};

  CreateSiteFunctionRequestCacheRules() {}

  explicit CreateSiteFunctionRequestCacheRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalCacheablePorts) {
      res["AdditionalCacheablePorts"] = boost::any(*additionalCacheablePorts);
    }
    if (browserCacheMode) {
      res["BrowserCacheMode"] = boost::any(*browserCacheMode);
    }
    if (browserCacheTtl) {
      res["BrowserCacheTtl"] = boost::any(*browserCacheTtl);
    }
    if (bypassCache) {
      res["BypassCache"] = boost::any(*bypassCache);
    }
    if (cacheDeceptionArmor) {
      res["CacheDeceptionArmor"] = boost::any(*cacheDeceptionArmor);
    }
    if (cacheReserveEligibility) {
      res["CacheReserveEligibility"] = boost::any(*cacheReserveEligibility);
    }
    if (checkPresenceCookie) {
      res["CheckPresenceCookie"] = boost::any(*checkPresenceCookie);
    }
    if (checkPresenceHeader) {
      res["CheckPresenceHeader"] = boost::any(*checkPresenceHeader);
    }
    if (edgeCacheMode) {
      res["EdgeCacheMode"] = boost::any(*edgeCacheMode);
    }
    if (edgeCacheTtl) {
      res["EdgeCacheTtl"] = boost::any(*edgeCacheTtl);
    }
    if (edgeStatusCodeCacheTtl) {
      res["EdgeStatusCodeCacheTtl"] = boost::any(*edgeStatusCodeCacheTtl);
    }
    if (includeCookie) {
      res["IncludeCookie"] = boost::any(*includeCookie);
    }
    if (includeHeader) {
      res["IncludeHeader"] = boost::any(*includeHeader);
    }
    if (queryString) {
      res["QueryString"] = boost::any(*queryString);
    }
    if (queryStringMode) {
      res["QueryStringMode"] = boost::any(*queryStringMode);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (serveStale) {
      res["ServeStale"] = boost::any(*serveStale);
    }
    if (sortQueryStringForCache) {
      res["SortQueryStringForCache"] = boost::any(*sortQueryStringForCache);
    }
    if (userDeviceType) {
      res["UserDeviceType"] = boost::any(*userDeviceType);
    }
    if (userGeo) {
      res["UserGeo"] = boost::any(*userGeo);
    }
    if (userLanguage) {
      res["UserLanguage"] = boost::any(*userLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalCacheablePorts") != m.end() && !m["AdditionalCacheablePorts"].empty()) {
      additionalCacheablePorts = make_shared<string>(boost::any_cast<string>(m["AdditionalCacheablePorts"]));
    }
    if (m.find("BrowserCacheMode") != m.end() && !m["BrowserCacheMode"].empty()) {
      browserCacheMode = make_shared<string>(boost::any_cast<string>(m["BrowserCacheMode"]));
    }
    if (m.find("BrowserCacheTtl") != m.end() && !m["BrowserCacheTtl"].empty()) {
      browserCacheTtl = make_shared<string>(boost::any_cast<string>(m["BrowserCacheTtl"]));
    }
    if (m.find("BypassCache") != m.end() && !m["BypassCache"].empty()) {
      bypassCache = make_shared<string>(boost::any_cast<string>(m["BypassCache"]));
    }
    if (m.find("CacheDeceptionArmor") != m.end() && !m["CacheDeceptionArmor"].empty()) {
      cacheDeceptionArmor = make_shared<string>(boost::any_cast<string>(m["CacheDeceptionArmor"]));
    }
    if (m.find("CacheReserveEligibility") != m.end() && !m["CacheReserveEligibility"].empty()) {
      cacheReserveEligibility = make_shared<string>(boost::any_cast<string>(m["CacheReserveEligibility"]));
    }
    if (m.find("CheckPresenceCookie") != m.end() && !m["CheckPresenceCookie"].empty()) {
      checkPresenceCookie = make_shared<string>(boost::any_cast<string>(m["CheckPresenceCookie"]));
    }
    if (m.find("CheckPresenceHeader") != m.end() && !m["CheckPresenceHeader"].empty()) {
      checkPresenceHeader = make_shared<string>(boost::any_cast<string>(m["CheckPresenceHeader"]));
    }
    if (m.find("EdgeCacheMode") != m.end() && !m["EdgeCacheMode"].empty()) {
      edgeCacheMode = make_shared<string>(boost::any_cast<string>(m["EdgeCacheMode"]));
    }
    if (m.find("EdgeCacheTtl") != m.end() && !m["EdgeCacheTtl"].empty()) {
      edgeCacheTtl = make_shared<string>(boost::any_cast<string>(m["EdgeCacheTtl"]));
    }
    if (m.find("EdgeStatusCodeCacheTtl") != m.end() && !m["EdgeStatusCodeCacheTtl"].empty()) {
      edgeStatusCodeCacheTtl = make_shared<string>(boost::any_cast<string>(m["EdgeStatusCodeCacheTtl"]));
    }
    if (m.find("IncludeCookie") != m.end() && !m["IncludeCookie"].empty()) {
      includeCookie = make_shared<string>(boost::any_cast<string>(m["IncludeCookie"]));
    }
    if (m.find("IncludeHeader") != m.end() && !m["IncludeHeader"].empty()) {
      includeHeader = make_shared<string>(boost::any_cast<string>(m["IncludeHeader"]));
    }
    if (m.find("QueryString") != m.end() && !m["QueryString"].empty()) {
      queryString = make_shared<string>(boost::any_cast<string>(m["QueryString"]));
    }
    if (m.find("QueryStringMode") != m.end() && !m["QueryStringMode"].empty()) {
      queryStringMode = make_shared<string>(boost::any_cast<string>(m["QueryStringMode"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("ServeStale") != m.end() && !m["ServeStale"].empty()) {
      serveStale = make_shared<string>(boost::any_cast<string>(m["ServeStale"]));
    }
    if (m.find("SortQueryStringForCache") != m.end() && !m["SortQueryStringForCache"].empty()) {
      sortQueryStringForCache = make_shared<string>(boost::any_cast<string>(m["SortQueryStringForCache"]));
    }
    if (m.find("UserDeviceType") != m.end() && !m["UserDeviceType"].empty()) {
      userDeviceType = make_shared<string>(boost::any_cast<string>(m["UserDeviceType"]));
    }
    if (m.find("UserGeo") != m.end() && !m["UserGeo"].empty()) {
      userGeo = make_shared<string>(boost::any_cast<string>(m["UserGeo"]));
    }
    if (m.find("UserLanguage") != m.end() && !m["UserLanguage"].empty()) {
      userLanguage = make_shared<string>(boost::any_cast<string>(m["UserLanguage"]));
    }
  }


  virtual ~CreateSiteFunctionRequestCacheRules() = default;
};
class CreateSiteFunctionRequestCacheTags : public Darabonba::Model {
public:
  shared_ptr<string> caseInsensitive{};
  shared_ptr<string> tagName{};

  CreateSiteFunctionRequestCacheTags() {}

  explicit CreateSiteFunctionRequestCacheTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caseInsensitive) {
      res["CaseInsensitive"] = boost::any(*caseInsensitive);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaseInsensitive") != m.end() && !m["CaseInsensitive"].empty()) {
      caseInsensitive = make_shared<string>(boost::any_cast<string>(m["CaseInsensitive"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~CreateSiteFunctionRequestCacheTags() = default;
};
class CreateSiteFunctionRequestCnameFlattening : public Darabonba::Model {
public:
  shared_ptr<string> flattenMode{};

  CreateSiteFunctionRequestCnameFlattening() {}

  explicit CreateSiteFunctionRequestCnameFlattening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flattenMode) {
      res["FlattenMode"] = boost::any(*flattenMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlattenMode") != m.end() && !m["FlattenMode"].empty()) {
      flattenMode = make_shared<string>(boost::any_cast<string>(m["FlattenMode"]));
    }
  }


  virtual ~CreateSiteFunctionRequestCnameFlattening() = default;
};
class CreateSiteFunctionRequestCompressionRules : public Darabonba::Model {
public:
  shared_ptr<string> brotli{};
  shared_ptr<string> gzip{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  CreateSiteFunctionRequestCompressionRules() {}

  explicit CreateSiteFunctionRequestCompressionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (brotli) {
      res["Brotli"] = boost::any(*brotli);
    }
    if (gzip) {
      res["Gzip"] = boost::any(*gzip);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Brotli") != m.end() && !m["Brotli"].empty()) {
      brotli = make_shared<string>(boost::any_cast<string>(m["Brotli"]));
    }
    if (m.find("Gzip") != m.end() && !m["Gzip"].empty()) {
      gzip = make_shared<string>(boost::any_cast<string>(m["Gzip"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~CreateSiteFunctionRequestCompressionRules() = default;
};
class CreateSiteFunctionRequestCrossBorderOptimization : public Darabonba::Model {
public:
  shared_ptr<string> enable{};

  CreateSiteFunctionRequestCrossBorderOptimization() {}

  explicit CreateSiteFunctionRequestCrossBorderOptimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~CreateSiteFunctionRequestCrossBorderOptimization() = default;
};
class CreateSiteFunctionRequestDevelopmentMode : public Darabonba::Model {
public:
  shared_ptr<string> enable{};

  CreateSiteFunctionRequestDevelopmentMode() {}

  explicit CreateSiteFunctionRequestDevelopmentMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~CreateSiteFunctionRequestDevelopmentMode() = default;
};
class CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification() {}

  explicit CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification() = default;
};
class CreateSiteFunctionRequestHttpRequestHeaderModificationRules : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification>> requestHeaderModification{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  CreateSiteFunctionRequestHttpRequestHeaderModificationRules() {}

  explicit CreateSiteFunctionRequestHttpRequestHeaderModificationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestHeaderModification) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaderModification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaderModification"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestHeaderModification") != m.end() && !m["RequestHeaderModification"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaderModification"].type()) {
        vector<CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaderModification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaderModification = make_shared<vector<CreateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~CreateSiteFunctionRequestHttpRequestHeaderModificationRules() = default;
};
class CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification() {}

  explicit CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification() = default;
};
class CreateSiteFunctionRequestHttpResponseHeaderModificationRules : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification>> responseHeaderModification{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  CreateSiteFunctionRequestHttpResponseHeaderModificationRules() {}

  explicit CreateSiteFunctionRequestHttpResponseHeaderModificationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responseHeaderModification) {
      vector<boost::any> temp1;
      for(auto item1:*responseHeaderModification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseHeaderModification"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResponseHeaderModification") != m.end() && !m["ResponseHeaderModification"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseHeaderModification"].type()) {
        vector<CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseHeaderModification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseHeaderModification = make_shared<vector<CreateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~CreateSiteFunctionRequestHttpResponseHeaderModificationRules() = default;
};
class CreateSiteFunctionRequestHttpsApplicationConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> altSvc{};
  shared_ptr<string> altSvcClear{};
  shared_ptr<string> altSvcMa{};
  shared_ptr<string> altSvcPersist{};
  shared_ptr<string> hsts{};
  shared_ptr<string> hstsIncludeSubdomains{};
  shared_ptr<string> hstsMaxAge{};
  shared_ptr<string> hstsPreload{};
  shared_ptr<string> httpsForce{};
  shared_ptr<string> httpsForceCode{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  CreateSiteFunctionRequestHttpsApplicationConfiguration() {}

  explicit CreateSiteFunctionRequestHttpsApplicationConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (altSvc) {
      res["AltSvc"] = boost::any(*altSvc);
    }
    if (altSvcClear) {
      res["AltSvcClear"] = boost::any(*altSvcClear);
    }
    if (altSvcMa) {
      res["AltSvcMa"] = boost::any(*altSvcMa);
    }
    if (altSvcPersist) {
      res["AltSvcPersist"] = boost::any(*altSvcPersist);
    }
    if (hsts) {
      res["Hsts"] = boost::any(*hsts);
    }
    if (hstsIncludeSubdomains) {
      res["HstsIncludeSubdomains"] = boost::any(*hstsIncludeSubdomains);
    }
    if (hstsMaxAge) {
      res["HstsMaxAge"] = boost::any(*hstsMaxAge);
    }
    if (hstsPreload) {
      res["HstsPreload"] = boost::any(*hstsPreload);
    }
    if (httpsForce) {
      res["HttpsForce"] = boost::any(*httpsForce);
    }
    if (httpsForceCode) {
      res["HttpsForceCode"] = boost::any(*httpsForceCode);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AltSvc") != m.end() && !m["AltSvc"].empty()) {
      altSvc = make_shared<string>(boost::any_cast<string>(m["AltSvc"]));
    }
    if (m.find("AltSvcClear") != m.end() && !m["AltSvcClear"].empty()) {
      altSvcClear = make_shared<string>(boost::any_cast<string>(m["AltSvcClear"]));
    }
    if (m.find("AltSvcMa") != m.end() && !m["AltSvcMa"].empty()) {
      altSvcMa = make_shared<string>(boost::any_cast<string>(m["AltSvcMa"]));
    }
    if (m.find("AltSvcPersist") != m.end() && !m["AltSvcPersist"].empty()) {
      altSvcPersist = make_shared<string>(boost::any_cast<string>(m["AltSvcPersist"]));
    }
    if (m.find("Hsts") != m.end() && !m["Hsts"].empty()) {
      hsts = make_shared<string>(boost::any_cast<string>(m["Hsts"]));
    }
    if (m.find("HstsIncludeSubdomains") != m.end() && !m["HstsIncludeSubdomains"].empty()) {
      hstsIncludeSubdomains = make_shared<string>(boost::any_cast<string>(m["HstsIncludeSubdomains"]));
    }
    if (m.find("HstsMaxAge") != m.end() && !m["HstsMaxAge"].empty()) {
      hstsMaxAge = make_shared<string>(boost::any_cast<string>(m["HstsMaxAge"]));
    }
    if (m.find("HstsPreload") != m.end() && !m["HstsPreload"].empty()) {
      hstsPreload = make_shared<string>(boost::any_cast<string>(m["HstsPreload"]));
    }
    if (m.find("HttpsForce") != m.end() && !m["HttpsForce"].empty()) {
      httpsForce = make_shared<string>(boost::any_cast<string>(m["HttpsForce"]));
    }
    if (m.find("HttpsForceCode") != m.end() && !m["HttpsForceCode"].empty()) {
      httpsForceCode = make_shared<string>(boost::any_cast<string>(m["HttpsForceCode"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~CreateSiteFunctionRequestHttpsApplicationConfiguration() = default;
};
class CreateSiteFunctionRequestHttpsBasicConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> ciphersuite{};
  shared_ptr<string> ciphersuiteGroup{};
  shared_ptr<string> http2{};
  shared_ptr<string> http3{};
  shared_ptr<string> https{};
  shared_ptr<string> ocspStapling{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> tls10{};
  shared_ptr<string> tls11{};
  shared_ptr<string> tls12{};
  shared_ptr<string> tls13{};

  CreateSiteFunctionRequestHttpsBasicConfiguration() {}

  explicit CreateSiteFunctionRequestHttpsBasicConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphersuite) {
      res["Ciphersuite"] = boost::any(*ciphersuite);
    }
    if (ciphersuiteGroup) {
      res["CiphersuiteGroup"] = boost::any(*ciphersuiteGroup);
    }
    if (http2) {
      res["Http2"] = boost::any(*http2);
    }
    if (http3) {
      res["Http3"] = boost::any(*http3);
    }
    if (https) {
      res["Https"] = boost::any(*https);
    }
    if (ocspStapling) {
      res["OcspStapling"] = boost::any(*ocspStapling);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (tls10) {
      res["Tls10"] = boost::any(*tls10);
    }
    if (tls11) {
      res["Tls11"] = boost::any(*tls11);
    }
    if (tls12) {
      res["Tls12"] = boost::any(*tls12);
    }
    if (tls13) {
      res["Tls13"] = boost::any(*tls13);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ciphersuite") != m.end() && !m["Ciphersuite"].empty()) {
      ciphersuite = make_shared<string>(boost::any_cast<string>(m["Ciphersuite"]));
    }
    if (m.find("CiphersuiteGroup") != m.end() && !m["CiphersuiteGroup"].empty()) {
      ciphersuiteGroup = make_shared<string>(boost::any_cast<string>(m["CiphersuiteGroup"]));
    }
    if (m.find("Http2") != m.end() && !m["Http2"].empty()) {
      http2 = make_shared<string>(boost::any_cast<string>(m["Http2"]));
    }
    if (m.find("Http3") != m.end() && !m["Http3"].empty()) {
      http3 = make_shared<string>(boost::any_cast<string>(m["Http3"]));
    }
    if (m.find("Https") != m.end() && !m["Https"].empty()) {
      https = make_shared<string>(boost::any_cast<string>(m["Https"]));
    }
    if (m.find("OcspStapling") != m.end() && !m["OcspStapling"].empty()) {
      ocspStapling = make_shared<string>(boost::any_cast<string>(m["OcspStapling"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Tls10") != m.end() && !m["Tls10"].empty()) {
      tls10 = make_shared<string>(boost::any_cast<string>(m["Tls10"]));
    }
    if (m.find("Tls11") != m.end() && !m["Tls11"].empty()) {
      tls11 = make_shared<string>(boost::any_cast<string>(m["Tls11"]));
    }
    if (m.find("Tls12") != m.end() && !m["Tls12"].empty()) {
      tls12 = make_shared<string>(boost::any_cast<string>(m["Tls12"]));
    }
    if (m.find("Tls13") != m.end() && !m["Tls13"].empty()) {
      tls13 = make_shared<string>(boost::any_cast<string>(m["Tls13"]));
    }
  }


  virtual ~CreateSiteFunctionRequestHttpsBasicConfiguration() = default;
};
class CreateSiteFunctionRequestImageTransform : public Darabonba::Model {
public:
  shared_ptr<string> enable{};

  CreateSiteFunctionRequestImageTransform() {}

  explicit CreateSiteFunctionRequestImageTransform(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~CreateSiteFunctionRequestImageTransform() = default;
};
class CreateSiteFunctionRequestIpv6 : public Darabonba::Model {
public:
  shared_ptr<string> enable{};

  CreateSiteFunctionRequestIpv6() {}

  explicit CreateSiteFunctionRequestIpv6(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~CreateSiteFunctionRequestIpv6() = default;
};
class CreateSiteFunctionRequestManagedTransforms : public Darabonba::Model {
public:
  shared_ptr<string> addClientGeolocationHeaders{};
  shared_ptr<string> addRealClientIpHeader{};

  CreateSiteFunctionRequestManagedTransforms() {}

  explicit CreateSiteFunctionRequestManagedTransforms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addClientGeolocationHeaders) {
      res["AddClientGeolocationHeaders"] = boost::any(*addClientGeolocationHeaders);
    }
    if (addRealClientIpHeader) {
      res["AddRealClientIpHeader"] = boost::any(*addRealClientIpHeader);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddClientGeolocationHeaders") != m.end() && !m["AddClientGeolocationHeaders"].empty()) {
      addClientGeolocationHeaders = make_shared<string>(boost::any_cast<string>(m["AddClientGeolocationHeaders"]));
    }
    if (m.find("AddRealClientIpHeader") != m.end() && !m["AddRealClientIpHeader"].empty()) {
      addRealClientIpHeader = make_shared<string>(boost::any_cast<string>(m["AddRealClientIpHeader"]));
    }
  }


  virtual ~CreateSiteFunctionRequestManagedTransforms() = default;
};
class CreateSiteFunctionRequestNetworkOptimization : public Darabonba::Model {
public:
  shared_ptr<string> grpc{};
  shared_ptr<string> http2Origin{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> smartRouting{};
  shared_ptr<string> uploadMaxFilesize{};
  shared_ptr<string> websocket{};

  CreateSiteFunctionRequestNetworkOptimization() {}

  explicit CreateSiteFunctionRequestNetworkOptimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grpc) {
      res["Grpc"] = boost::any(*grpc);
    }
    if (http2Origin) {
      res["Http2Origin"] = boost::any(*http2Origin);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (smartRouting) {
      res["SmartRouting"] = boost::any(*smartRouting);
    }
    if (uploadMaxFilesize) {
      res["UploadMaxFilesize"] = boost::any(*uploadMaxFilesize);
    }
    if (websocket) {
      res["Websocket"] = boost::any(*websocket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Grpc") != m.end() && !m["Grpc"].empty()) {
      grpc = make_shared<string>(boost::any_cast<string>(m["Grpc"]));
    }
    if (m.find("Http2Origin") != m.end() && !m["Http2Origin"].empty()) {
      http2Origin = make_shared<string>(boost::any_cast<string>(m["Http2Origin"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SmartRouting") != m.end() && !m["SmartRouting"].empty()) {
      smartRouting = make_shared<string>(boost::any_cast<string>(m["SmartRouting"]));
    }
    if (m.find("UploadMaxFilesize") != m.end() && !m["UploadMaxFilesize"].empty()) {
      uploadMaxFilesize = make_shared<string>(boost::any_cast<string>(m["UploadMaxFilesize"]));
    }
    if (m.find("Websocket") != m.end() && !m["Websocket"].empty()) {
      websocket = make_shared<string>(boost::any_cast<string>(m["Websocket"]));
    }
  }


  virtual ~CreateSiteFunctionRequestNetworkOptimization() = default;
};
class CreateSiteFunctionRequestOriginProtection : public Darabonba::Model {
public:
  shared_ptr<string> enable{};

  CreateSiteFunctionRequestOriginProtection() {}

  explicit CreateSiteFunctionRequestOriginProtection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~CreateSiteFunctionRequestOriginProtection() = default;
};
class CreateSiteFunctionRequestOriginRules : public Darabonba::Model {
public:
  shared_ptr<string> dnsRecord{};
  shared_ptr<string> originHost{};
  shared_ptr<string> originHttpPort{};
  shared_ptr<string> originHttpsPort{};
  shared_ptr<string> originScheme{};
  shared_ptr<string> originSni{};
  shared_ptr<string> range{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  CreateSiteFunctionRequestOriginRules() {}

  explicit CreateSiteFunctionRequestOriginRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsRecord) {
      res["DnsRecord"] = boost::any(*dnsRecord);
    }
    if (originHost) {
      res["OriginHost"] = boost::any(*originHost);
    }
    if (originHttpPort) {
      res["OriginHttpPort"] = boost::any(*originHttpPort);
    }
    if (originHttpsPort) {
      res["OriginHttpsPort"] = boost::any(*originHttpsPort);
    }
    if (originScheme) {
      res["OriginScheme"] = boost::any(*originScheme);
    }
    if (originSni) {
      res["OriginSni"] = boost::any(*originSni);
    }
    if (range) {
      res["Range"] = boost::any(*range);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsRecord") != m.end() && !m["DnsRecord"].empty()) {
      dnsRecord = make_shared<string>(boost::any_cast<string>(m["DnsRecord"]));
    }
    if (m.find("OriginHost") != m.end() && !m["OriginHost"].empty()) {
      originHost = make_shared<string>(boost::any_cast<string>(m["OriginHost"]));
    }
    if (m.find("OriginHttpPort") != m.end() && !m["OriginHttpPort"].empty()) {
      originHttpPort = make_shared<string>(boost::any_cast<string>(m["OriginHttpPort"]));
    }
    if (m.find("OriginHttpsPort") != m.end() && !m["OriginHttpsPort"].empty()) {
      originHttpsPort = make_shared<string>(boost::any_cast<string>(m["OriginHttpsPort"]));
    }
    if (m.find("OriginScheme") != m.end() && !m["OriginScheme"].empty()) {
      originScheme = make_shared<string>(boost::any_cast<string>(m["OriginScheme"]));
    }
    if (m.find("OriginSni") != m.end() && !m["OriginSni"].empty()) {
      originSni = make_shared<string>(boost::any_cast<string>(m["OriginSni"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      range = make_shared<string>(boost::any_cast<string>(m["Range"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~CreateSiteFunctionRequestOriginRules() = default;
};
class CreateSiteFunctionRequestRedirectRules : public Darabonba::Model {
public:
  shared_ptr<string> reserveQueryString{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> type{};

  CreateSiteFunctionRequestRedirectRules() {}

  explicit CreateSiteFunctionRequestRedirectRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reserveQueryString) {
      res["ReserveQueryString"] = boost::any(*reserveQueryString);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReserveQueryString") != m.end() && !m["ReserveQueryString"].empty()) {
      reserveQueryString = make_shared<string>(boost::any_cast<string>(m["ReserveQueryString"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateSiteFunctionRequestRedirectRules() = default;
};
class CreateSiteFunctionRequestRewriteUrlRules : public Darabonba::Model {
public:
  shared_ptr<string> queryString{};
  shared_ptr<string> rewriteQueryStringType{};
  shared_ptr<string> rewriteUriType{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> uri{};

  CreateSiteFunctionRequestRewriteUrlRules() {}

  explicit CreateSiteFunctionRequestRewriteUrlRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryString) {
      res["QueryString"] = boost::any(*queryString);
    }
    if (rewriteQueryStringType) {
      res["RewriteQueryStringType"] = boost::any(*rewriteQueryStringType);
    }
    if (rewriteUriType) {
      res["RewriteUriType"] = boost::any(*rewriteUriType);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryString") != m.end() && !m["QueryString"].empty()) {
      queryString = make_shared<string>(boost::any_cast<string>(m["QueryString"]));
    }
    if (m.find("RewriteQueryStringType") != m.end() && !m["RewriteQueryStringType"].empty()) {
      rewriteQueryStringType = make_shared<string>(boost::any_cast<string>(m["RewriteQueryStringType"]));
    }
    if (m.find("RewriteUriType") != m.end() && !m["RewriteUriType"].empty()) {
      rewriteUriType = make_shared<string>(boost::any_cast<string>(m["RewriteUriType"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~CreateSiteFunctionRequestRewriteUrlRules() = default;
};
class CreateSiteFunctionRequestSeoBypass : public Darabonba::Model {
public:
  shared_ptr<string> enable{};

  CreateSiteFunctionRequestSeoBypass() {}

  explicit CreateSiteFunctionRequestSeoBypass(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~CreateSiteFunctionRequestSeoBypass() = default;
};
class CreateSiteFunctionRequestSiteNameExclusive : public Darabonba::Model {
public:
  shared_ptr<string> enable{};

  CreateSiteFunctionRequestSiteNameExclusive() {}

  explicit CreateSiteFunctionRequestSiteNameExclusive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~CreateSiteFunctionRequestSiteNameExclusive() = default;
};
class CreateSiteFunctionRequestSitePause : public Darabonba::Model {
public:
  shared_ptr<string> paused{};

  CreateSiteFunctionRequestSitePause() {}

  explicit CreateSiteFunctionRequestSitePause(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paused) {
      res["Paused"] = boost::any(*paused);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Paused") != m.end() && !m["Paused"].empty()) {
      paused = make_shared<string>(boost::any_cast<string>(m["Paused"]));
    }
  }


  virtual ~CreateSiteFunctionRequestSitePause() = default;
};
class CreateSiteFunctionRequestTieredCache : public Darabonba::Model {
public:
  shared_ptr<string> cacheArchitectureMode{};

  CreateSiteFunctionRequestTieredCache() {}

  explicit CreateSiteFunctionRequestTieredCache(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheArchitectureMode) {
      res["CacheArchitectureMode"] = boost::any(*cacheArchitectureMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheArchitectureMode") != m.end() && !m["CacheArchitectureMode"].empty()) {
      cacheArchitectureMode = make_shared<string>(boost::any_cast<string>(m["CacheArchitectureMode"]));
    }
  }


  virtual ~CreateSiteFunctionRequestTieredCache() = default;
};
class CreateSiteFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSiteFunctionRequestCacheReserve>> cacheReserve{};
  shared_ptr<vector<CreateSiteFunctionRequestCacheRules>> cacheRules{};
  shared_ptr<vector<CreateSiteFunctionRequestCacheTags>> cacheTags{};
  shared_ptr<vector<CreateSiteFunctionRequestCnameFlattening>> cnameFlattening{};
  shared_ptr<vector<CreateSiteFunctionRequestCompressionRules>> compressionRules{};
  shared_ptr<vector<CreateSiteFunctionRequestCrossBorderOptimization>> crossBorderOptimization{};
  shared_ptr<vector<CreateSiteFunctionRequestDevelopmentMode>> developmentMode{};
  shared_ptr<vector<CreateSiteFunctionRequestHttpRequestHeaderModificationRules>> httpRequestHeaderModificationRules{};
  shared_ptr<vector<CreateSiteFunctionRequestHttpResponseHeaderModificationRules>> httpResponseHeaderModificationRules{};
  shared_ptr<vector<CreateSiteFunctionRequestHttpsApplicationConfiguration>> httpsApplicationConfiguration{};
  shared_ptr<vector<CreateSiteFunctionRequestHttpsBasicConfiguration>> httpsBasicConfiguration{};
  shared_ptr<vector<CreateSiteFunctionRequestImageTransform>> imageTransform{};
  shared_ptr<vector<CreateSiteFunctionRequestIpv6>> ipv6{};
  shared_ptr<vector<CreateSiteFunctionRequestManagedTransforms>> managedTransforms{};
  shared_ptr<vector<CreateSiteFunctionRequestNetworkOptimization>> networkOptimization{};
  shared_ptr<vector<CreateSiteFunctionRequestOriginProtection>> originProtection{};
  shared_ptr<vector<CreateSiteFunctionRequestOriginRules>> originRules{};
  shared_ptr<vector<CreateSiteFunctionRequestRedirectRules>> redirectRules{};
  shared_ptr<vector<CreateSiteFunctionRequestRewriteUrlRules>> rewriteUrlRules{};
  shared_ptr<vector<CreateSiteFunctionRequestSeoBypass>> seoBypass{};
  shared_ptr<long> siteId{};
  shared_ptr<vector<CreateSiteFunctionRequestSiteNameExclusive>> siteNameExclusive{};
  shared_ptr<vector<CreateSiteFunctionRequestSitePause>> sitePause{};
  shared_ptr<long> siteVersion{};
  shared_ptr<vector<CreateSiteFunctionRequestTieredCache>> tieredCache{};

  CreateSiteFunctionRequest() {}

  explicit CreateSiteFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheReserve) {
      vector<boost::any> temp1;
      for(auto item1:*cacheReserve){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheReserve"] = boost::any(temp1);
    }
    if (cacheRules) {
      vector<boost::any> temp1;
      for(auto item1:*cacheRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheRules"] = boost::any(temp1);
    }
    if (cacheTags) {
      vector<boost::any> temp1;
      for(auto item1:*cacheTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheTags"] = boost::any(temp1);
    }
    if (cnameFlattening) {
      vector<boost::any> temp1;
      for(auto item1:*cnameFlattening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CnameFlattening"] = boost::any(temp1);
    }
    if (compressionRules) {
      vector<boost::any> temp1;
      for(auto item1:*compressionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CompressionRules"] = boost::any(temp1);
    }
    if (crossBorderOptimization) {
      vector<boost::any> temp1;
      for(auto item1:*crossBorderOptimization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CrossBorderOptimization"] = boost::any(temp1);
    }
    if (developmentMode) {
      vector<boost::any> temp1;
      for(auto item1:*developmentMode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DevelopmentMode"] = boost::any(temp1);
    }
    if (httpRequestHeaderModificationRules) {
      vector<boost::any> temp1;
      for(auto item1:*httpRequestHeaderModificationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpRequestHeaderModificationRules"] = boost::any(temp1);
    }
    if (httpResponseHeaderModificationRules) {
      vector<boost::any> temp1;
      for(auto item1:*httpResponseHeaderModificationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpResponseHeaderModificationRules"] = boost::any(temp1);
    }
    if (httpsApplicationConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*httpsApplicationConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpsApplicationConfiguration"] = boost::any(temp1);
    }
    if (httpsBasicConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*httpsBasicConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpsBasicConfiguration"] = boost::any(temp1);
    }
    if (imageTransform) {
      vector<boost::any> temp1;
      for(auto item1:*imageTransform){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageTransform"] = boost::any(temp1);
    }
    if (ipv6) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6"] = boost::any(temp1);
    }
    if (managedTransforms) {
      vector<boost::any> temp1;
      for(auto item1:*managedTransforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedTransforms"] = boost::any(temp1);
    }
    if (networkOptimization) {
      vector<boost::any> temp1;
      for(auto item1:*networkOptimization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkOptimization"] = boost::any(temp1);
    }
    if (originProtection) {
      vector<boost::any> temp1;
      for(auto item1:*originProtection){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OriginProtection"] = boost::any(temp1);
    }
    if (originRules) {
      vector<boost::any> temp1;
      for(auto item1:*originRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OriginRules"] = boost::any(temp1);
    }
    if (redirectRules) {
      vector<boost::any> temp1;
      for(auto item1:*redirectRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RedirectRules"] = boost::any(temp1);
    }
    if (rewriteUrlRules) {
      vector<boost::any> temp1;
      for(auto item1:*rewriteUrlRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RewriteUrlRules"] = boost::any(temp1);
    }
    if (seoBypass) {
      vector<boost::any> temp1;
      for(auto item1:*seoBypass){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SeoBypass"] = boost::any(temp1);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteNameExclusive) {
      vector<boost::any> temp1;
      for(auto item1:*siteNameExclusive){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SiteNameExclusive"] = boost::any(temp1);
    }
    if (sitePause) {
      vector<boost::any> temp1;
      for(auto item1:*sitePause){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SitePause"] = boost::any(temp1);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    if (tieredCache) {
      vector<boost::any> temp1;
      for(auto item1:*tieredCache){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TieredCache"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheReserve") != m.end() && !m["CacheReserve"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheReserve"].type()) {
        vector<CreateSiteFunctionRequestCacheReserve> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheReserve"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestCacheReserve model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheReserve = make_shared<vector<CreateSiteFunctionRequestCacheReserve>>(expect1);
      }
    }
    if (m.find("CacheRules") != m.end() && !m["CacheRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheRules"].type()) {
        vector<CreateSiteFunctionRequestCacheRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestCacheRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheRules = make_shared<vector<CreateSiteFunctionRequestCacheRules>>(expect1);
      }
    }
    if (m.find("CacheTags") != m.end() && !m["CacheTags"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheTags"].type()) {
        vector<CreateSiteFunctionRequestCacheTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestCacheTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheTags = make_shared<vector<CreateSiteFunctionRequestCacheTags>>(expect1);
      }
    }
    if (m.find("CnameFlattening") != m.end() && !m["CnameFlattening"].empty()) {
      if (typeid(vector<boost::any>) == m["CnameFlattening"].type()) {
        vector<CreateSiteFunctionRequestCnameFlattening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CnameFlattening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestCnameFlattening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cnameFlattening = make_shared<vector<CreateSiteFunctionRequestCnameFlattening>>(expect1);
      }
    }
    if (m.find("CompressionRules") != m.end() && !m["CompressionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CompressionRules"].type()) {
        vector<CreateSiteFunctionRequestCompressionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CompressionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestCompressionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compressionRules = make_shared<vector<CreateSiteFunctionRequestCompressionRules>>(expect1);
      }
    }
    if (m.find("CrossBorderOptimization") != m.end() && !m["CrossBorderOptimization"].empty()) {
      if (typeid(vector<boost::any>) == m["CrossBorderOptimization"].type()) {
        vector<CreateSiteFunctionRequestCrossBorderOptimization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CrossBorderOptimization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestCrossBorderOptimization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        crossBorderOptimization = make_shared<vector<CreateSiteFunctionRequestCrossBorderOptimization>>(expect1);
      }
    }
    if (m.find("DevelopmentMode") != m.end() && !m["DevelopmentMode"].empty()) {
      if (typeid(vector<boost::any>) == m["DevelopmentMode"].type()) {
        vector<CreateSiteFunctionRequestDevelopmentMode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DevelopmentMode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestDevelopmentMode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        developmentMode = make_shared<vector<CreateSiteFunctionRequestDevelopmentMode>>(expect1);
      }
    }
    if (m.find("HttpRequestHeaderModificationRules") != m.end() && !m["HttpRequestHeaderModificationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpRequestHeaderModificationRules"].type()) {
        vector<CreateSiteFunctionRequestHttpRequestHeaderModificationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpRequestHeaderModificationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestHttpRequestHeaderModificationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpRequestHeaderModificationRules = make_shared<vector<CreateSiteFunctionRequestHttpRequestHeaderModificationRules>>(expect1);
      }
    }
    if (m.find("HttpResponseHeaderModificationRules") != m.end() && !m["HttpResponseHeaderModificationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpResponseHeaderModificationRules"].type()) {
        vector<CreateSiteFunctionRequestHttpResponseHeaderModificationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpResponseHeaderModificationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestHttpResponseHeaderModificationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpResponseHeaderModificationRules = make_shared<vector<CreateSiteFunctionRequestHttpResponseHeaderModificationRules>>(expect1);
      }
    }
    if (m.find("HttpsApplicationConfiguration") != m.end() && !m["HttpsApplicationConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpsApplicationConfiguration"].type()) {
        vector<CreateSiteFunctionRequestHttpsApplicationConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpsApplicationConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestHttpsApplicationConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpsApplicationConfiguration = make_shared<vector<CreateSiteFunctionRequestHttpsApplicationConfiguration>>(expect1);
      }
    }
    if (m.find("HttpsBasicConfiguration") != m.end() && !m["HttpsBasicConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpsBasicConfiguration"].type()) {
        vector<CreateSiteFunctionRequestHttpsBasicConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpsBasicConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestHttpsBasicConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpsBasicConfiguration = make_shared<vector<CreateSiteFunctionRequestHttpsBasicConfiguration>>(expect1);
      }
    }
    if (m.find("ImageTransform") != m.end() && !m["ImageTransform"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageTransform"].type()) {
        vector<CreateSiteFunctionRequestImageTransform> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageTransform"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestImageTransform model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageTransform = make_shared<vector<CreateSiteFunctionRequestImageTransform>>(expect1);
      }
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6"].type()) {
        vector<CreateSiteFunctionRequestIpv6> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestIpv6 model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6 = make_shared<vector<CreateSiteFunctionRequestIpv6>>(expect1);
      }
    }
    if (m.find("ManagedTransforms") != m.end() && !m["ManagedTransforms"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedTransforms"].type()) {
        vector<CreateSiteFunctionRequestManagedTransforms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedTransforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestManagedTransforms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedTransforms = make_shared<vector<CreateSiteFunctionRequestManagedTransforms>>(expect1);
      }
    }
    if (m.find("NetworkOptimization") != m.end() && !m["NetworkOptimization"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkOptimization"].type()) {
        vector<CreateSiteFunctionRequestNetworkOptimization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkOptimization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestNetworkOptimization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkOptimization = make_shared<vector<CreateSiteFunctionRequestNetworkOptimization>>(expect1);
      }
    }
    if (m.find("OriginProtection") != m.end() && !m["OriginProtection"].empty()) {
      if (typeid(vector<boost::any>) == m["OriginProtection"].type()) {
        vector<CreateSiteFunctionRequestOriginProtection> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OriginProtection"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestOriginProtection model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        originProtection = make_shared<vector<CreateSiteFunctionRequestOriginProtection>>(expect1);
      }
    }
    if (m.find("OriginRules") != m.end() && !m["OriginRules"].empty()) {
      if (typeid(vector<boost::any>) == m["OriginRules"].type()) {
        vector<CreateSiteFunctionRequestOriginRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OriginRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestOriginRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        originRules = make_shared<vector<CreateSiteFunctionRequestOriginRules>>(expect1);
      }
    }
    if (m.find("RedirectRules") != m.end() && !m["RedirectRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RedirectRules"].type()) {
        vector<CreateSiteFunctionRequestRedirectRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RedirectRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestRedirectRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        redirectRules = make_shared<vector<CreateSiteFunctionRequestRedirectRules>>(expect1);
      }
    }
    if (m.find("RewriteUrlRules") != m.end() && !m["RewriteUrlRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RewriteUrlRules"].type()) {
        vector<CreateSiteFunctionRequestRewriteUrlRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RewriteUrlRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestRewriteUrlRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rewriteUrlRules = make_shared<vector<CreateSiteFunctionRequestRewriteUrlRules>>(expect1);
      }
    }
    if (m.find("SeoBypass") != m.end() && !m["SeoBypass"].empty()) {
      if (typeid(vector<boost::any>) == m["SeoBypass"].type()) {
        vector<CreateSiteFunctionRequestSeoBypass> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SeoBypass"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestSeoBypass model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        seoBypass = make_shared<vector<CreateSiteFunctionRequestSeoBypass>>(expect1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteNameExclusive") != m.end() && !m["SiteNameExclusive"].empty()) {
      if (typeid(vector<boost::any>) == m["SiteNameExclusive"].type()) {
        vector<CreateSiteFunctionRequestSiteNameExclusive> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SiteNameExclusive"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestSiteNameExclusive model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        siteNameExclusive = make_shared<vector<CreateSiteFunctionRequestSiteNameExclusive>>(expect1);
      }
    }
    if (m.find("SitePause") != m.end() && !m["SitePause"].empty()) {
      if (typeid(vector<boost::any>) == m["SitePause"].type()) {
        vector<CreateSiteFunctionRequestSitePause> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SitePause"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestSitePause model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sitePause = make_shared<vector<CreateSiteFunctionRequestSitePause>>(expect1);
      }
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
    if (m.find("TieredCache") != m.end() && !m["TieredCache"].empty()) {
      if (typeid(vector<boost::any>) == m["TieredCache"].type()) {
        vector<CreateSiteFunctionRequestTieredCache> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TieredCache"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionRequestTieredCache model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tieredCache = make_shared<vector<CreateSiteFunctionRequestTieredCache>>(expect1);
      }
    }
  }


  virtual ~CreateSiteFunctionRequest() = default;
};
class CreateSiteFunctionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cacheReserveShrink{};
  shared_ptr<string> cacheRulesShrink{};
  shared_ptr<string> cacheTagsShrink{};
  shared_ptr<string> cnameFlatteningShrink{};
  shared_ptr<string> compressionRulesShrink{};
  shared_ptr<string> crossBorderOptimizationShrink{};
  shared_ptr<string> developmentModeShrink{};
  shared_ptr<string> httpRequestHeaderModificationRulesShrink{};
  shared_ptr<string> httpResponseHeaderModificationRulesShrink{};
  shared_ptr<string> httpsApplicationConfigurationShrink{};
  shared_ptr<string> httpsBasicConfigurationShrink{};
  shared_ptr<string> imageTransformShrink{};
  shared_ptr<string> ipv6Shrink{};
  shared_ptr<string> managedTransformsShrink{};
  shared_ptr<string> networkOptimizationShrink{};
  shared_ptr<string> originProtectionShrink{};
  shared_ptr<string> originRulesShrink{};
  shared_ptr<string> redirectRulesShrink{};
  shared_ptr<string> rewriteUrlRulesShrink{};
  shared_ptr<string> seoBypassShrink{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteNameExclusiveShrink{};
  shared_ptr<string> sitePauseShrink{};
  shared_ptr<long> siteVersion{};
  shared_ptr<string> tieredCacheShrink{};

  CreateSiteFunctionShrinkRequest() {}

  explicit CreateSiteFunctionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheReserveShrink) {
      res["CacheReserve"] = boost::any(*cacheReserveShrink);
    }
    if (cacheRulesShrink) {
      res["CacheRules"] = boost::any(*cacheRulesShrink);
    }
    if (cacheTagsShrink) {
      res["CacheTags"] = boost::any(*cacheTagsShrink);
    }
    if (cnameFlatteningShrink) {
      res["CnameFlattening"] = boost::any(*cnameFlatteningShrink);
    }
    if (compressionRulesShrink) {
      res["CompressionRules"] = boost::any(*compressionRulesShrink);
    }
    if (crossBorderOptimizationShrink) {
      res["CrossBorderOptimization"] = boost::any(*crossBorderOptimizationShrink);
    }
    if (developmentModeShrink) {
      res["DevelopmentMode"] = boost::any(*developmentModeShrink);
    }
    if (httpRequestHeaderModificationRulesShrink) {
      res["HttpRequestHeaderModificationRules"] = boost::any(*httpRequestHeaderModificationRulesShrink);
    }
    if (httpResponseHeaderModificationRulesShrink) {
      res["HttpResponseHeaderModificationRules"] = boost::any(*httpResponseHeaderModificationRulesShrink);
    }
    if (httpsApplicationConfigurationShrink) {
      res["HttpsApplicationConfiguration"] = boost::any(*httpsApplicationConfigurationShrink);
    }
    if (httpsBasicConfigurationShrink) {
      res["HttpsBasicConfiguration"] = boost::any(*httpsBasicConfigurationShrink);
    }
    if (imageTransformShrink) {
      res["ImageTransform"] = boost::any(*imageTransformShrink);
    }
    if (ipv6Shrink) {
      res["Ipv6"] = boost::any(*ipv6Shrink);
    }
    if (managedTransformsShrink) {
      res["ManagedTransforms"] = boost::any(*managedTransformsShrink);
    }
    if (networkOptimizationShrink) {
      res["NetworkOptimization"] = boost::any(*networkOptimizationShrink);
    }
    if (originProtectionShrink) {
      res["OriginProtection"] = boost::any(*originProtectionShrink);
    }
    if (originRulesShrink) {
      res["OriginRules"] = boost::any(*originRulesShrink);
    }
    if (redirectRulesShrink) {
      res["RedirectRules"] = boost::any(*redirectRulesShrink);
    }
    if (rewriteUrlRulesShrink) {
      res["RewriteUrlRules"] = boost::any(*rewriteUrlRulesShrink);
    }
    if (seoBypassShrink) {
      res["SeoBypass"] = boost::any(*seoBypassShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteNameExclusiveShrink) {
      res["SiteNameExclusive"] = boost::any(*siteNameExclusiveShrink);
    }
    if (sitePauseShrink) {
      res["SitePause"] = boost::any(*sitePauseShrink);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    if (tieredCacheShrink) {
      res["TieredCache"] = boost::any(*tieredCacheShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheReserve") != m.end() && !m["CacheReserve"].empty()) {
      cacheReserveShrink = make_shared<string>(boost::any_cast<string>(m["CacheReserve"]));
    }
    if (m.find("CacheRules") != m.end() && !m["CacheRules"].empty()) {
      cacheRulesShrink = make_shared<string>(boost::any_cast<string>(m["CacheRules"]));
    }
    if (m.find("CacheTags") != m.end() && !m["CacheTags"].empty()) {
      cacheTagsShrink = make_shared<string>(boost::any_cast<string>(m["CacheTags"]));
    }
    if (m.find("CnameFlattening") != m.end() && !m["CnameFlattening"].empty()) {
      cnameFlatteningShrink = make_shared<string>(boost::any_cast<string>(m["CnameFlattening"]));
    }
    if (m.find("CompressionRules") != m.end() && !m["CompressionRules"].empty()) {
      compressionRulesShrink = make_shared<string>(boost::any_cast<string>(m["CompressionRules"]));
    }
    if (m.find("CrossBorderOptimization") != m.end() && !m["CrossBorderOptimization"].empty()) {
      crossBorderOptimizationShrink = make_shared<string>(boost::any_cast<string>(m["CrossBorderOptimization"]));
    }
    if (m.find("DevelopmentMode") != m.end() && !m["DevelopmentMode"].empty()) {
      developmentModeShrink = make_shared<string>(boost::any_cast<string>(m["DevelopmentMode"]));
    }
    if (m.find("HttpRequestHeaderModificationRules") != m.end() && !m["HttpRequestHeaderModificationRules"].empty()) {
      httpRequestHeaderModificationRulesShrink = make_shared<string>(boost::any_cast<string>(m["HttpRequestHeaderModificationRules"]));
    }
    if (m.find("HttpResponseHeaderModificationRules") != m.end() && !m["HttpResponseHeaderModificationRules"].empty()) {
      httpResponseHeaderModificationRulesShrink = make_shared<string>(boost::any_cast<string>(m["HttpResponseHeaderModificationRules"]));
    }
    if (m.find("HttpsApplicationConfiguration") != m.end() && !m["HttpsApplicationConfiguration"].empty()) {
      httpsApplicationConfigurationShrink = make_shared<string>(boost::any_cast<string>(m["HttpsApplicationConfiguration"]));
    }
    if (m.find("HttpsBasicConfiguration") != m.end() && !m["HttpsBasicConfiguration"].empty()) {
      httpsBasicConfigurationShrink = make_shared<string>(boost::any_cast<string>(m["HttpsBasicConfiguration"]));
    }
    if (m.find("ImageTransform") != m.end() && !m["ImageTransform"].empty()) {
      imageTransformShrink = make_shared<string>(boost::any_cast<string>(m["ImageTransform"]));
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      ipv6Shrink = make_shared<string>(boost::any_cast<string>(m["Ipv6"]));
    }
    if (m.find("ManagedTransforms") != m.end() && !m["ManagedTransforms"].empty()) {
      managedTransformsShrink = make_shared<string>(boost::any_cast<string>(m["ManagedTransforms"]));
    }
    if (m.find("NetworkOptimization") != m.end() && !m["NetworkOptimization"].empty()) {
      networkOptimizationShrink = make_shared<string>(boost::any_cast<string>(m["NetworkOptimization"]));
    }
    if (m.find("OriginProtection") != m.end() && !m["OriginProtection"].empty()) {
      originProtectionShrink = make_shared<string>(boost::any_cast<string>(m["OriginProtection"]));
    }
    if (m.find("OriginRules") != m.end() && !m["OriginRules"].empty()) {
      originRulesShrink = make_shared<string>(boost::any_cast<string>(m["OriginRules"]));
    }
    if (m.find("RedirectRules") != m.end() && !m["RedirectRules"].empty()) {
      redirectRulesShrink = make_shared<string>(boost::any_cast<string>(m["RedirectRules"]));
    }
    if (m.find("RewriteUrlRules") != m.end() && !m["RewriteUrlRules"].empty()) {
      rewriteUrlRulesShrink = make_shared<string>(boost::any_cast<string>(m["RewriteUrlRules"]));
    }
    if (m.find("SeoBypass") != m.end() && !m["SeoBypass"].empty()) {
      seoBypassShrink = make_shared<string>(boost::any_cast<string>(m["SeoBypass"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteNameExclusive") != m.end() && !m["SiteNameExclusive"].empty()) {
      siteNameExclusiveShrink = make_shared<string>(boost::any_cast<string>(m["SiteNameExclusive"]));
    }
    if (m.find("SitePause") != m.end() && !m["SitePause"].empty()) {
      sitePauseShrink = make_shared<string>(boost::any_cast<string>(m["SitePause"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
    if (m.find("TieredCache") != m.end() && !m["TieredCache"].empty()) {
      tieredCacheShrink = make_shared<string>(boost::any_cast<string>(m["TieredCache"]));
    }
  }


  virtual ~CreateSiteFunctionShrinkRequest() = default;
};
class CreateSiteFunctionResponseBodyConfigsCacheReserve : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> instanceId{};

  CreateSiteFunctionResponseBodyConfigsCacheReserve() {}

  explicit CreateSiteFunctionResponseBodyConfigsCacheReserve(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsCacheReserve() = default;
};
class CreateSiteFunctionResponseBodyConfigsCacheRules : public Darabonba::Model {
public:
  shared_ptr<string> additionalCacheablePorts{};
  shared_ptr<string> browserCacheMode{};
  shared_ptr<string> browserCacheTtl{};
  shared_ptr<string> bypassCache{};
  shared_ptr<string> cacheDeceptionArmor{};
  shared_ptr<string> cacheReserveEligibility{};
  shared_ptr<string> checkPresenceCookie{};
  shared_ptr<string> checkPresenceHeader{};
  shared_ptr<long> configId{};
  shared_ptr<string> edgeCacheMode{};
  shared_ptr<string> edgeCacheTtl{};
  shared_ptr<string> edgeStatusCodeCacheTtl{};
  shared_ptr<string> includeCookie{};
  shared_ptr<string> includeHeader{};
  shared_ptr<string> queryString{};
  shared_ptr<string> queryStringMode{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> serveStale{};
  shared_ptr<string> sortQueryStringForCache{};
  shared_ptr<string> userDeviceType{};
  shared_ptr<string> userGeo{};
  shared_ptr<string> userLanguage{};

  CreateSiteFunctionResponseBodyConfigsCacheRules() {}

  explicit CreateSiteFunctionResponseBodyConfigsCacheRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalCacheablePorts) {
      res["AdditionalCacheablePorts"] = boost::any(*additionalCacheablePorts);
    }
    if (browserCacheMode) {
      res["BrowserCacheMode"] = boost::any(*browserCacheMode);
    }
    if (browserCacheTtl) {
      res["BrowserCacheTtl"] = boost::any(*browserCacheTtl);
    }
    if (bypassCache) {
      res["BypassCache"] = boost::any(*bypassCache);
    }
    if (cacheDeceptionArmor) {
      res["CacheDeceptionArmor"] = boost::any(*cacheDeceptionArmor);
    }
    if (cacheReserveEligibility) {
      res["CacheReserveEligibility"] = boost::any(*cacheReserveEligibility);
    }
    if (checkPresenceCookie) {
      res["CheckPresenceCookie"] = boost::any(*checkPresenceCookie);
    }
    if (checkPresenceHeader) {
      res["CheckPresenceHeader"] = boost::any(*checkPresenceHeader);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (edgeCacheMode) {
      res["EdgeCacheMode"] = boost::any(*edgeCacheMode);
    }
    if (edgeCacheTtl) {
      res["EdgeCacheTtl"] = boost::any(*edgeCacheTtl);
    }
    if (edgeStatusCodeCacheTtl) {
      res["EdgeStatusCodeCacheTtl"] = boost::any(*edgeStatusCodeCacheTtl);
    }
    if (includeCookie) {
      res["IncludeCookie"] = boost::any(*includeCookie);
    }
    if (includeHeader) {
      res["IncludeHeader"] = boost::any(*includeHeader);
    }
    if (queryString) {
      res["QueryString"] = boost::any(*queryString);
    }
    if (queryStringMode) {
      res["QueryStringMode"] = boost::any(*queryStringMode);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (serveStale) {
      res["ServeStale"] = boost::any(*serveStale);
    }
    if (sortQueryStringForCache) {
      res["SortQueryStringForCache"] = boost::any(*sortQueryStringForCache);
    }
    if (userDeviceType) {
      res["UserDeviceType"] = boost::any(*userDeviceType);
    }
    if (userGeo) {
      res["UserGeo"] = boost::any(*userGeo);
    }
    if (userLanguage) {
      res["UserLanguage"] = boost::any(*userLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalCacheablePorts") != m.end() && !m["AdditionalCacheablePorts"].empty()) {
      additionalCacheablePorts = make_shared<string>(boost::any_cast<string>(m["AdditionalCacheablePorts"]));
    }
    if (m.find("BrowserCacheMode") != m.end() && !m["BrowserCacheMode"].empty()) {
      browserCacheMode = make_shared<string>(boost::any_cast<string>(m["BrowserCacheMode"]));
    }
    if (m.find("BrowserCacheTtl") != m.end() && !m["BrowserCacheTtl"].empty()) {
      browserCacheTtl = make_shared<string>(boost::any_cast<string>(m["BrowserCacheTtl"]));
    }
    if (m.find("BypassCache") != m.end() && !m["BypassCache"].empty()) {
      bypassCache = make_shared<string>(boost::any_cast<string>(m["BypassCache"]));
    }
    if (m.find("CacheDeceptionArmor") != m.end() && !m["CacheDeceptionArmor"].empty()) {
      cacheDeceptionArmor = make_shared<string>(boost::any_cast<string>(m["CacheDeceptionArmor"]));
    }
    if (m.find("CacheReserveEligibility") != m.end() && !m["CacheReserveEligibility"].empty()) {
      cacheReserveEligibility = make_shared<string>(boost::any_cast<string>(m["CacheReserveEligibility"]));
    }
    if (m.find("CheckPresenceCookie") != m.end() && !m["CheckPresenceCookie"].empty()) {
      checkPresenceCookie = make_shared<string>(boost::any_cast<string>(m["CheckPresenceCookie"]));
    }
    if (m.find("CheckPresenceHeader") != m.end() && !m["CheckPresenceHeader"].empty()) {
      checkPresenceHeader = make_shared<string>(boost::any_cast<string>(m["CheckPresenceHeader"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("EdgeCacheMode") != m.end() && !m["EdgeCacheMode"].empty()) {
      edgeCacheMode = make_shared<string>(boost::any_cast<string>(m["EdgeCacheMode"]));
    }
    if (m.find("EdgeCacheTtl") != m.end() && !m["EdgeCacheTtl"].empty()) {
      edgeCacheTtl = make_shared<string>(boost::any_cast<string>(m["EdgeCacheTtl"]));
    }
    if (m.find("EdgeStatusCodeCacheTtl") != m.end() && !m["EdgeStatusCodeCacheTtl"].empty()) {
      edgeStatusCodeCacheTtl = make_shared<string>(boost::any_cast<string>(m["EdgeStatusCodeCacheTtl"]));
    }
    if (m.find("IncludeCookie") != m.end() && !m["IncludeCookie"].empty()) {
      includeCookie = make_shared<string>(boost::any_cast<string>(m["IncludeCookie"]));
    }
    if (m.find("IncludeHeader") != m.end() && !m["IncludeHeader"].empty()) {
      includeHeader = make_shared<string>(boost::any_cast<string>(m["IncludeHeader"]));
    }
    if (m.find("QueryString") != m.end() && !m["QueryString"].empty()) {
      queryString = make_shared<string>(boost::any_cast<string>(m["QueryString"]));
    }
    if (m.find("QueryStringMode") != m.end() && !m["QueryStringMode"].empty()) {
      queryStringMode = make_shared<string>(boost::any_cast<string>(m["QueryStringMode"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("ServeStale") != m.end() && !m["ServeStale"].empty()) {
      serveStale = make_shared<string>(boost::any_cast<string>(m["ServeStale"]));
    }
    if (m.find("SortQueryStringForCache") != m.end() && !m["SortQueryStringForCache"].empty()) {
      sortQueryStringForCache = make_shared<string>(boost::any_cast<string>(m["SortQueryStringForCache"]));
    }
    if (m.find("UserDeviceType") != m.end() && !m["UserDeviceType"].empty()) {
      userDeviceType = make_shared<string>(boost::any_cast<string>(m["UserDeviceType"]));
    }
    if (m.find("UserGeo") != m.end() && !m["UserGeo"].empty()) {
      userGeo = make_shared<string>(boost::any_cast<string>(m["UserGeo"]));
    }
    if (m.find("UserLanguage") != m.end() && !m["UserLanguage"].empty()) {
      userLanguage = make_shared<string>(boost::any_cast<string>(m["UserLanguage"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsCacheRules() = default;
};
class CreateSiteFunctionResponseBodyConfigsCacheTags : public Darabonba::Model {
public:
  shared_ptr<string> caseInsensitive{};
  shared_ptr<long> configId{};
  shared_ptr<string> sequence{};
  shared_ptr<string> tagName{};

  CreateSiteFunctionResponseBodyConfigsCacheTags() {}

  explicit CreateSiteFunctionResponseBodyConfigsCacheTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caseInsensitive) {
      res["CaseInsensitive"] = boost::any(*caseInsensitive);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaseInsensitive") != m.end() && !m["CaseInsensitive"].empty()) {
      caseInsensitive = make_shared<string>(boost::any_cast<string>(m["CaseInsensitive"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsCacheTags() = default;
};
class CreateSiteFunctionResponseBodyConfigsCnameFlattening : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> flattenMode{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsCnameFlattening() {}

  explicit CreateSiteFunctionResponseBodyConfigsCnameFlattening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (flattenMode) {
      res["FlattenMode"] = boost::any(*flattenMode);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("FlattenMode") != m.end() && !m["FlattenMode"].empty()) {
      flattenMode = make_shared<string>(boost::any_cast<string>(m["FlattenMode"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsCnameFlattening() = default;
};
class CreateSiteFunctionResponseBodyConfigsCompressionRules : public Darabonba::Model {
public:
  shared_ptr<string> brotli{};
  shared_ptr<long> configId{};
  shared_ptr<string> gzip{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsCompressionRules() {}

  explicit CreateSiteFunctionResponseBodyConfigsCompressionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (brotli) {
      res["Brotli"] = boost::any(*brotli);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (gzip) {
      res["Gzip"] = boost::any(*gzip);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Brotli") != m.end() && !m["Brotli"].empty()) {
      brotli = make_shared<string>(boost::any_cast<string>(m["Brotli"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Gzip") != m.end() && !m["Gzip"].empty()) {
      gzip = make_shared<string>(boost::any_cast<string>(m["Gzip"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsCompressionRules() = default;
};
class CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};

  CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization() {}

  explicit CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization() = default;
};
class CreateSiteFunctionResponseBodyConfigsDevelopmentMode : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsDevelopmentMode() {}

  explicit CreateSiteFunctionResponseBodyConfigsDevelopmentMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsDevelopmentMode() = default;
};
class CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification() {}

  explicit CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification() = default;
};
class CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification>> requestHeaderModification{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules() {}

  explicit CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (requestHeaderModification) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaderModification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaderModification"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("RequestHeaderModification") != m.end() && !m["RequestHeaderModification"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaderModification"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaderModification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaderModification = make_shared<vector<CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules() = default;
};
class CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification() {}

  explicit CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification() = default;
};
class CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification>> responseHeaderModification{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules() {}

  explicit CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (responseHeaderModification) {
      vector<boost::any> temp1;
      for(auto item1:*responseHeaderModification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseHeaderModification"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("ResponseHeaderModification") != m.end() && !m["ResponseHeaderModification"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseHeaderModification"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseHeaderModification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseHeaderModification = make_shared<vector<CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules() = default;
};
class CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> altSvc{};
  shared_ptr<string> altSvcClear{};
  shared_ptr<string> altSvcMa{};
  shared_ptr<string> altSvcPersist{};
  shared_ptr<long> configId{};
  shared_ptr<string> hsts{};
  shared_ptr<string> hstsIncludeSubdomains{};
  shared_ptr<string> hstsMaxAge{};
  shared_ptr<string> hstsPreload{};
  shared_ptr<string> httpsForce{};
  shared_ptr<string> httpsForceCode{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration() {}

  explicit CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (altSvc) {
      res["AltSvc"] = boost::any(*altSvc);
    }
    if (altSvcClear) {
      res["AltSvcClear"] = boost::any(*altSvcClear);
    }
    if (altSvcMa) {
      res["AltSvcMa"] = boost::any(*altSvcMa);
    }
    if (altSvcPersist) {
      res["AltSvcPersist"] = boost::any(*altSvcPersist);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (hsts) {
      res["Hsts"] = boost::any(*hsts);
    }
    if (hstsIncludeSubdomains) {
      res["HstsIncludeSubdomains"] = boost::any(*hstsIncludeSubdomains);
    }
    if (hstsMaxAge) {
      res["HstsMaxAge"] = boost::any(*hstsMaxAge);
    }
    if (hstsPreload) {
      res["HstsPreload"] = boost::any(*hstsPreload);
    }
    if (httpsForce) {
      res["HttpsForce"] = boost::any(*httpsForce);
    }
    if (httpsForceCode) {
      res["HttpsForceCode"] = boost::any(*httpsForceCode);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AltSvc") != m.end() && !m["AltSvc"].empty()) {
      altSvc = make_shared<string>(boost::any_cast<string>(m["AltSvc"]));
    }
    if (m.find("AltSvcClear") != m.end() && !m["AltSvcClear"].empty()) {
      altSvcClear = make_shared<string>(boost::any_cast<string>(m["AltSvcClear"]));
    }
    if (m.find("AltSvcMa") != m.end() && !m["AltSvcMa"].empty()) {
      altSvcMa = make_shared<string>(boost::any_cast<string>(m["AltSvcMa"]));
    }
    if (m.find("AltSvcPersist") != m.end() && !m["AltSvcPersist"].empty()) {
      altSvcPersist = make_shared<string>(boost::any_cast<string>(m["AltSvcPersist"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Hsts") != m.end() && !m["Hsts"].empty()) {
      hsts = make_shared<string>(boost::any_cast<string>(m["Hsts"]));
    }
    if (m.find("HstsIncludeSubdomains") != m.end() && !m["HstsIncludeSubdomains"].empty()) {
      hstsIncludeSubdomains = make_shared<string>(boost::any_cast<string>(m["HstsIncludeSubdomains"]));
    }
    if (m.find("HstsMaxAge") != m.end() && !m["HstsMaxAge"].empty()) {
      hstsMaxAge = make_shared<string>(boost::any_cast<string>(m["HstsMaxAge"]));
    }
    if (m.find("HstsPreload") != m.end() && !m["HstsPreload"].empty()) {
      hstsPreload = make_shared<string>(boost::any_cast<string>(m["HstsPreload"]));
    }
    if (m.find("HttpsForce") != m.end() && !m["HttpsForce"].empty()) {
      httpsForce = make_shared<string>(boost::any_cast<string>(m["HttpsForce"]));
    }
    if (m.find("HttpsForceCode") != m.end() && !m["HttpsForceCode"].empty()) {
      httpsForceCode = make_shared<string>(boost::any_cast<string>(m["HttpsForceCode"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration() = default;
};
class CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> ciphersuite{};
  shared_ptr<string> ciphersuiteGroup{};
  shared_ptr<long> configId{};
  shared_ptr<string> http2{};
  shared_ptr<string> http3{};
  shared_ptr<string> https{};
  shared_ptr<string> ocspStapling{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> tls10{};
  shared_ptr<string> tls11{};
  shared_ptr<string> tls12{};
  shared_ptr<string> tls13{};

  CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration() {}

  explicit CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphersuite) {
      res["Ciphersuite"] = boost::any(*ciphersuite);
    }
    if (ciphersuiteGroup) {
      res["CiphersuiteGroup"] = boost::any(*ciphersuiteGroup);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (http2) {
      res["Http2"] = boost::any(*http2);
    }
    if (http3) {
      res["Http3"] = boost::any(*http3);
    }
    if (https) {
      res["Https"] = boost::any(*https);
    }
    if (ocspStapling) {
      res["OcspStapling"] = boost::any(*ocspStapling);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (tls10) {
      res["Tls10"] = boost::any(*tls10);
    }
    if (tls11) {
      res["Tls11"] = boost::any(*tls11);
    }
    if (tls12) {
      res["Tls12"] = boost::any(*tls12);
    }
    if (tls13) {
      res["Tls13"] = boost::any(*tls13);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ciphersuite") != m.end() && !m["Ciphersuite"].empty()) {
      ciphersuite = make_shared<string>(boost::any_cast<string>(m["Ciphersuite"]));
    }
    if (m.find("CiphersuiteGroup") != m.end() && !m["CiphersuiteGroup"].empty()) {
      ciphersuiteGroup = make_shared<string>(boost::any_cast<string>(m["CiphersuiteGroup"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Http2") != m.end() && !m["Http2"].empty()) {
      http2 = make_shared<string>(boost::any_cast<string>(m["Http2"]));
    }
    if (m.find("Http3") != m.end() && !m["Http3"].empty()) {
      http3 = make_shared<string>(boost::any_cast<string>(m["Http3"]));
    }
    if (m.find("Https") != m.end() && !m["Https"].empty()) {
      https = make_shared<string>(boost::any_cast<string>(m["Https"]));
    }
    if (m.find("OcspStapling") != m.end() && !m["OcspStapling"].empty()) {
      ocspStapling = make_shared<string>(boost::any_cast<string>(m["OcspStapling"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("Tls10") != m.end() && !m["Tls10"].empty()) {
      tls10 = make_shared<string>(boost::any_cast<string>(m["Tls10"]));
    }
    if (m.find("Tls11") != m.end() && !m["Tls11"].empty()) {
      tls11 = make_shared<string>(boost::any_cast<string>(m["Tls11"]));
    }
    if (m.find("Tls12") != m.end() && !m["Tls12"].empty()) {
      tls12 = make_shared<string>(boost::any_cast<string>(m["Tls12"]));
    }
    if (m.find("Tls13") != m.end() && !m["Tls13"].empty()) {
      tls13 = make_shared<string>(boost::any_cast<string>(m["Tls13"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration() = default;
};
class CreateSiteFunctionResponseBodyConfigsImageTransform : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsImageTransform() {}

  explicit CreateSiteFunctionResponseBodyConfigsImageTransform(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsImageTransform() = default;
};
class CreateSiteFunctionResponseBodyConfigsIpv6 : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsIpv6() {}

  explicit CreateSiteFunctionResponseBodyConfigsIpv6(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsIpv6() = default;
};
class CreateSiteFunctionResponseBodyConfigsManagedTransforms : public Darabonba::Model {
public:
  shared_ptr<string> addClientGeolocationHeaders{};
  shared_ptr<string> addRealClientIpHeader{};
  shared_ptr<long> configId{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsManagedTransforms() {}

  explicit CreateSiteFunctionResponseBodyConfigsManagedTransforms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addClientGeolocationHeaders) {
      res["AddClientGeolocationHeaders"] = boost::any(*addClientGeolocationHeaders);
    }
    if (addRealClientIpHeader) {
      res["AddRealClientIpHeader"] = boost::any(*addRealClientIpHeader);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddClientGeolocationHeaders") != m.end() && !m["AddClientGeolocationHeaders"].empty()) {
      addClientGeolocationHeaders = make_shared<string>(boost::any_cast<string>(m["AddClientGeolocationHeaders"]));
    }
    if (m.find("AddRealClientIpHeader") != m.end() && !m["AddRealClientIpHeader"].empty()) {
      addRealClientIpHeader = make_shared<string>(boost::any_cast<string>(m["AddRealClientIpHeader"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsManagedTransforms() = default;
};
class CreateSiteFunctionResponseBodyConfigsNetworkOptimization : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> grpc{};
  shared_ptr<string> http2Origin{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> smartRouting{};
  shared_ptr<string> uploadMaxFilesize{};
  shared_ptr<string> websocket{};

  CreateSiteFunctionResponseBodyConfigsNetworkOptimization() {}

  explicit CreateSiteFunctionResponseBodyConfigsNetworkOptimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (grpc) {
      res["Grpc"] = boost::any(*grpc);
    }
    if (http2Origin) {
      res["Http2Origin"] = boost::any(*http2Origin);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (smartRouting) {
      res["SmartRouting"] = boost::any(*smartRouting);
    }
    if (uploadMaxFilesize) {
      res["UploadMaxFilesize"] = boost::any(*uploadMaxFilesize);
    }
    if (websocket) {
      res["Websocket"] = boost::any(*websocket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Grpc") != m.end() && !m["Grpc"].empty()) {
      grpc = make_shared<string>(boost::any_cast<string>(m["Grpc"]));
    }
    if (m.find("Http2Origin") != m.end() && !m["Http2Origin"].empty()) {
      http2Origin = make_shared<string>(boost::any_cast<string>(m["Http2Origin"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("SmartRouting") != m.end() && !m["SmartRouting"].empty()) {
      smartRouting = make_shared<string>(boost::any_cast<string>(m["SmartRouting"]));
    }
    if (m.find("UploadMaxFilesize") != m.end() && !m["UploadMaxFilesize"].empty()) {
      uploadMaxFilesize = make_shared<string>(boost::any_cast<string>(m["UploadMaxFilesize"]));
    }
    if (m.find("Websocket") != m.end() && !m["Websocket"].empty()) {
      websocket = make_shared<string>(boost::any_cast<string>(m["Websocket"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsNetworkOptimization() = default;
};
class CreateSiteFunctionResponseBodyConfigsOriginRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> dnsRecord{};
  shared_ptr<string> originHost{};
  shared_ptr<string> originHttpPort{};
  shared_ptr<string> originHttpsPort{};
  shared_ptr<string> originScheme{};
  shared_ptr<string> originSni{};
  shared_ptr<string> range{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsOriginRules() {}

  explicit CreateSiteFunctionResponseBodyConfigsOriginRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (dnsRecord) {
      res["DnsRecord"] = boost::any(*dnsRecord);
    }
    if (originHost) {
      res["OriginHost"] = boost::any(*originHost);
    }
    if (originHttpPort) {
      res["OriginHttpPort"] = boost::any(*originHttpPort);
    }
    if (originHttpsPort) {
      res["OriginHttpsPort"] = boost::any(*originHttpsPort);
    }
    if (originScheme) {
      res["OriginScheme"] = boost::any(*originScheme);
    }
    if (originSni) {
      res["OriginSni"] = boost::any(*originSni);
    }
    if (range) {
      res["Range"] = boost::any(*range);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("DnsRecord") != m.end() && !m["DnsRecord"].empty()) {
      dnsRecord = make_shared<string>(boost::any_cast<string>(m["DnsRecord"]));
    }
    if (m.find("OriginHost") != m.end() && !m["OriginHost"].empty()) {
      originHost = make_shared<string>(boost::any_cast<string>(m["OriginHost"]));
    }
    if (m.find("OriginHttpPort") != m.end() && !m["OriginHttpPort"].empty()) {
      originHttpPort = make_shared<string>(boost::any_cast<string>(m["OriginHttpPort"]));
    }
    if (m.find("OriginHttpsPort") != m.end() && !m["OriginHttpsPort"].empty()) {
      originHttpsPort = make_shared<string>(boost::any_cast<string>(m["OriginHttpsPort"]));
    }
    if (m.find("OriginScheme") != m.end() && !m["OriginScheme"].empty()) {
      originScheme = make_shared<string>(boost::any_cast<string>(m["OriginScheme"]));
    }
    if (m.find("OriginSni") != m.end() && !m["OriginSni"].empty()) {
      originSni = make_shared<string>(boost::any_cast<string>(m["OriginSni"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      range = make_shared<string>(boost::any_cast<string>(m["Range"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsOriginRules() = default;
};
class CreateSiteFunctionResponseBodyConfigsRedirectRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> reserveQueryString{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> type{};

  CreateSiteFunctionResponseBodyConfigsRedirectRules() {}

  explicit CreateSiteFunctionResponseBodyConfigsRedirectRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (reserveQueryString) {
      res["ReserveQueryString"] = boost::any(*reserveQueryString);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("ReserveQueryString") != m.end() && !m["ReserveQueryString"].empty()) {
      reserveQueryString = make_shared<string>(boost::any_cast<string>(m["ReserveQueryString"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsRedirectRules() = default;
};
class CreateSiteFunctionResponseBodyConfigsRewriteUrlRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> queryString{};
  shared_ptr<string> rewriteQueryStringType{};
  shared_ptr<string> rewriteUriType{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> uri{};

  CreateSiteFunctionResponseBodyConfigsRewriteUrlRules() {}

  explicit CreateSiteFunctionResponseBodyConfigsRewriteUrlRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (queryString) {
      res["QueryString"] = boost::any(*queryString);
    }
    if (rewriteQueryStringType) {
      res["RewriteQueryStringType"] = boost::any(*rewriteQueryStringType);
    }
    if (rewriteUriType) {
      res["RewriteUriType"] = boost::any(*rewriteUriType);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("QueryString") != m.end() && !m["QueryString"].empty()) {
      queryString = make_shared<string>(boost::any_cast<string>(m["QueryString"]));
    }
    if (m.find("RewriteQueryStringType") != m.end() && !m["RewriteQueryStringType"].empty()) {
      rewriteQueryStringType = make_shared<string>(boost::any_cast<string>(m["RewriteQueryStringType"]));
    }
    if (m.find("RewriteUriType") != m.end() && !m["RewriteUriType"].empty()) {
      rewriteUriType = make_shared<string>(boost::any_cast<string>(m["RewriteUriType"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsRewriteUrlRules() = default;
};
class CreateSiteFunctionResponseBodyConfigsSeoBypass : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsSeoBypass() {}

  explicit CreateSiteFunctionResponseBodyConfigsSeoBypass(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsSeoBypass() = default;
};
class CreateSiteFunctionResponseBodyConfigsSiteNameExclusive : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsSiteNameExclusive() {}

  explicit CreateSiteFunctionResponseBodyConfigsSiteNameExclusive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsSiteNameExclusive() = default;
};
class CreateSiteFunctionResponseBodyConfigsSitePause : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> paused{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsSitePause() {}

  explicit CreateSiteFunctionResponseBodyConfigsSitePause(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (paused) {
      res["Paused"] = boost::any(*paused);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Paused") != m.end() && !m["Paused"].empty()) {
      paused = make_shared<string>(boost::any_cast<string>(m["Paused"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsSitePause() = default;
};
class CreateSiteFunctionResponseBodyConfigsTieredCache : public Darabonba::Model {
public:
  shared_ptr<string> cacheArchitectureMode{};
  shared_ptr<long> configId{};
  shared_ptr<string> sequence{};

  CreateSiteFunctionResponseBodyConfigsTieredCache() {}

  explicit CreateSiteFunctionResponseBodyConfigsTieredCache(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheArchitectureMode) {
      res["CacheArchitectureMode"] = boost::any(*cacheArchitectureMode);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheArchitectureMode") != m.end() && !m["CacheArchitectureMode"].empty()) {
      cacheArchitectureMode = make_shared<string>(boost::any_cast<string>(m["CacheArchitectureMode"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigsTieredCache() = default;
};
class CreateSiteFunctionResponseBodyConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsCacheReserve>> cacheReserve{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsCacheRules>> cacheRules{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsCacheTags>> cacheTags{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsCnameFlattening>> cnameFlattening{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsCompressionRules>> compressionRules{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization>> crossBorderOptimization{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsDevelopmentMode>> developmentMode{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules>> httpRequestHeaderModificationRules{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules>> httpResponseHeaderModificationRules{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration>> httpsApplicationConfiguration{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration>> httpsBasicConfiguration{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsImageTransform>> imageTransform{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsIpv6>> ipv6{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsManagedTransforms>> managedTransforms{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsNetworkOptimization>> networkOptimization{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsOriginRules>> originRules{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsRedirectRules>> redirectRules{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsRewriteUrlRules>> rewriteUrlRules{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsSeoBypass>> seoBypass{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsSiteNameExclusive>> siteNameExclusive{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsSitePause>> sitePause{};
  shared_ptr<vector<CreateSiteFunctionResponseBodyConfigsTieredCache>> tieredCache{};

  CreateSiteFunctionResponseBodyConfigs() {}

  explicit CreateSiteFunctionResponseBodyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheReserve) {
      vector<boost::any> temp1;
      for(auto item1:*cacheReserve){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheReserve"] = boost::any(temp1);
    }
    if (cacheRules) {
      vector<boost::any> temp1;
      for(auto item1:*cacheRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheRules"] = boost::any(temp1);
    }
    if (cacheTags) {
      vector<boost::any> temp1;
      for(auto item1:*cacheTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheTags"] = boost::any(temp1);
    }
    if (cnameFlattening) {
      vector<boost::any> temp1;
      for(auto item1:*cnameFlattening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CnameFlattening"] = boost::any(temp1);
    }
    if (compressionRules) {
      vector<boost::any> temp1;
      for(auto item1:*compressionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CompressionRules"] = boost::any(temp1);
    }
    if (crossBorderOptimization) {
      vector<boost::any> temp1;
      for(auto item1:*crossBorderOptimization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CrossBorderOptimization"] = boost::any(temp1);
    }
    if (developmentMode) {
      vector<boost::any> temp1;
      for(auto item1:*developmentMode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DevelopmentMode"] = boost::any(temp1);
    }
    if (httpRequestHeaderModificationRules) {
      vector<boost::any> temp1;
      for(auto item1:*httpRequestHeaderModificationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpRequestHeaderModificationRules"] = boost::any(temp1);
    }
    if (httpResponseHeaderModificationRules) {
      vector<boost::any> temp1;
      for(auto item1:*httpResponseHeaderModificationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpResponseHeaderModificationRules"] = boost::any(temp1);
    }
    if (httpsApplicationConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*httpsApplicationConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpsApplicationConfiguration"] = boost::any(temp1);
    }
    if (httpsBasicConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*httpsBasicConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpsBasicConfiguration"] = boost::any(temp1);
    }
    if (imageTransform) {
      vector<boost::any> temp1;
      for(auto item1:*imageTransform){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageTransform"] = boost::any(temp1);
    }
    if (ipv6) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6"] = boost::any(temp1);
    }
    if (managedTransforms) {
      vector<boost::any> temp1;
      for(auto item1:*managedTransforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedTransforms"] = boost::any(temp1);
    }
    if (networkOptimization) {
      vector<boost::any> temp1;
      for(auto item1:*networkOptimization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkOptimization"] = boost::any(temp1);
    }
    if (originRules) {
      vector<boost::any> temp1;
      for(auto item1:*originRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OriginRules"] = boost::any(temp1);
    }
    if (redirectRules) {
      vector<boost::any> temp1;
      for(auto item1:*redirectRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RedirectRules"] = boost::any(temp1);
    }
    if (rewriteUrlRules) {
      vector<boost::any> temp1;
      for(auto item1:*rewriteUrlRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RewriteUrlRules"] = boost::any(temp1);
    }
    if (seoBypass) {
      vector<boost::any> temp1;
      for(auto item1:*seoBypass){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SeoBypass"] = boost::any(temp1);
    }
    if (siteNameExclusive) {
      vector<boost::any> temp1;
      for(auto item1:*siteNameExclusive){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SiteNameExclusive"] = boost::any(temp1);
    }
    if (sitePause) {
      vector<boost::any> temp1;
      for(auto item1:*sitePause){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SitePause"] = boost::any(temp1);
    }
    if (tieredCache) {
      vector<boost::any> temp1;
      for(auto item1:*tieredCache){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TieredCache"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheReserve") != m.end() && !m["CacheReserve"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheReserve"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsCacheReserve> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheReserve"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsCacheReserve model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheReserve = make_shared<vector<CreateSiteFunctionResponseBodyConfigsCacheReserve>>(expect1);
      }
    }
    if (m.find("CacheRules") != m.end() && !m["CacheRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheRules"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsCacheRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsCacheRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheRules = make_shared<vector<CreateSiteFunctionResponseBodyConfigsCacheRules>>(expect1);
      }
    }
    if (m.find("CacheTags") != m.end() && !m["CacheTags"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheTags"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsCacheTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsCacheTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheTags = make_shared<vector<CreateSiteFunctionResponseBodyConfigsCacheTags>>(expect1);
      }
    }
    if (m.find("CnameFlattening") != m.end() && !m["CnameFlattening"].empty()) {
      if (typeid(vector<boost::any>) == m["CnameFlattening"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsCnameFlattening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CnameFlattening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsCnameFlattening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cnameFlattening = make_shared<vector<CreateSiteFunctionResponseBodyConfigsCnameFlattening>>(expect1);
      }
    }
    if (m.find("CompressionRules") != m.end() && !m["CompressionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CompressionRules"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsCompressionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CompressionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsCompressionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compressionRules = make_shared<vector<CreateSiteFunctionResponseBodyConfigsCompressionRules>>(expect1);
      }
    }
    if (m.find("CrossBorderOptimization") != m.end() && !m["CrossBorderOptimization"].empty()) {
      if (typeid(vector<boost::any>) == m["CrossBorderOptimization"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CrossBorderOptimization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        crossBorderOptimization = make_shared<vector<CreateSiteFunctionResponseBodyConfigsCrossBorderOptimization>>(expect1);
      }
    }
    if (m.find("DevelopmentMode") != m.end() && !m["DevelopmentMode"].empty()) {
      if (typeid(vector<boost::any>) == m["DevelopmentMode"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsDevelopmentMode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DevelopmentMode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsDevelopmentMode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        developmentMode = make_shared<vector<CreateSiteFunctionResponseBodyConfigsDevelopmentMode>>(expect1);
      }
    }
    if (m.find("HttpRequestHeaderModificationRules") != m.end() && !m["HttpRequestHeaderModificationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpRequestHeaderModificationRules"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpRequestHeaderModificationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpRequestHeaderModificationRules = make_shared<vector<CreateSiteFunctionResponseBodyConfigsHttpRequestHeaderModificationRules>>(expect1);
      }
    }
    if (m.find("HttpResponseHeaderModificationRules") != m.end() && !m["HttpResponseHeaderModificationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpResponseHeaderModificationRules"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpResponseHeaderModificationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpResponseHeaderModificationRules = make_shared<vector<CreateSiteFunctionResponseBodyConfigsHttpResponseHeaderModificationRules>>(expect1);
      }
    }
    if (m.find("HttpsApplicationConfiguration") != m.end() && !m["HttpsApplicationConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpsApplicationConfiguration"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpsApplicationConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpsApplicationConfiguration = make_shared<vector<CreateSiteFunctionResponseBodyConfigsHttpsApplicationConfiguration>>(expect1);
      }
    }
    if (m.find("HttpsBasicConfiguration") != m.end() && !m["HttpsBasicConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpsBasicConfiguration"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpsBasicConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpsBasicConfiguration = make_shared<vector<CreateSiteFunctionResponseBodyConfigsHttpsBasicConfiguration>>(expect1);
      }
    }
    if (m.find("ImageTransform") != m.end() && !m["ImageTransform"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageTransform"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsImageTransform> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageTransform"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsImageTransform model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageTransform = make_shared<vector<CreateSiteFunctionResponseBodyConfigsImageTransform>>(expect1);
      }
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsIpv6> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsIpv6 model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6 = make_shared<vector<CreateSiteFunctionResponseBodyConfigsIpv6>>(expect1);
      }
    }
    if (m.find("ManagedTransforms") != m.end() && !m["ManagedTransforms"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedTransforms"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsManagedTransforms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedTransforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsManagedTransforms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedTransforms = make_shared<vector<CreateSiteFunctionResponseBodyConfigsManagedTransforms>>(expect1);
      }
    }
    if (m.find("NetworkOptimization") != m.end() && !m["NetworkOptimization"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkOptimization"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsNetworkOptimization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkOptimization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsNetworkOptimization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkOptimization = make_shared<vector<CreateSiteFunctionResponseBodyConfigsNetworkOptimization>>(expect1);
      }
    }
    if (m.find("OriginRules") != m.end() && !m["OriginRules"].empty()) {
      if (typeid(vector<boost::any>) == m["OriginRules"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsOriginRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OriginRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsOriginRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        originRules = make_shared<vector<CreateSiteFunctionResponseBodyConfigsOriginRules>>(expect1);
      }
    }
    if (m.find("RedirectRules") != m.end() && !m["RedirectRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RedirectRules"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsRedirectRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RedirectRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsRedirectRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        redirectRules = make_shared<vector<CreateSiteFunctionResponseBodyConfigsRedirectRules>>(expect1);
      }
    }
    if (m.find("RewriteUrlRules") != m.end() && !m["RewriteUrlRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RewriteUrlRules"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsRewriteUrlRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RewriteUrlRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsRewriteUrlRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rewriteUrlRules = make_shared<vector<CreateSiteFunctionResponseBodyConfigsRewriteUrlRules>>(expect1);
      }
    }
    if (m.find("SeoBypass") != m.end() && !m["SeoBypass"].empty()) {
      if (typeid(vector<boost::any>) == m["SeoBypass"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsSeoBypass> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SeoBypass"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsSeoBypass model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        seoBypass = make_shared<vector<CreateSiteFunctionResponseBodyConfigsSeoBypass>>(expect1);
      }
    }
    if (m.find("SiteNameExclusive") != m.end() && !m["SiteNameExclusive"].empty()) {
      if (typeid(vector<boost::any>) == m["SiteNameExclusive"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsSiteNameExclusive> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SiteNameExclusive"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsSiteNameExclusive model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        siteNameExclusive = make_shared<vector<CreateSiteFunctionResponseBodyConfigsSiteNameExclusive>>(expect1);
      }
    }
    if (m.find("SitePause") != m.end() && !m["SitePause"].empty()) {
      if (typeid(vector<boost::any>) == m["SitePause"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsSitePause> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SitePause"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsSitePause model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sitePause = make_shared<vector<CreateSiteFunctionResponseBodyConfigsSitePause>>(expect1);
      }
    }
    if (m.find("TieredCache") != m.end() && !m["TieredCache"].empty()) {
      if (typeid(vector<boost::any>) == m["TieredCache"].type()) {
        vector<CreateSiteFunctionResponseBodyConfigsTieredCache> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TieredCache"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteFunctionResponseBodyConfigsTieredCache model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tieredCache = make_shared<vector<CreateSiteFunctionResponseBodyConfigsTieredCache>>(expect1);
      }
    }
  }


  virtual ~CreateSiteFunctionResponseBodyConfigs() = default;
};
class CreateSiteFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateSiteFunctionResponseBodyConfigs> configs{};
  shared_ptr<string> requestId{};

  CreateSiteFunctionResponseBody() {}

  explicit CreateSiteFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      res["Configs"] = configs ? boost::any(configs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Configs"].type()) {
        CreateSiteFunctionResponseBodyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Configs"]));
        configs = make_shared<CreateSiteFunctionResponseBodyConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSiteFunctionResponseBody() = default;
};
class CreateSiteFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSiteFunctionResponseBody> body{};

  CreateSiteFunctionResponse() {}

  explicit CreateSiteFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSiteFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSiteFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSiteFunctionResponse() = default;
};
class CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam : public Darabonba::Model {
public:
  shared_ptr<long> expiredTime{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> urlPath{};

  CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam() {}

  explicit CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (urlPath) {
      res["UrlPath"] = boost::any(*urlPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("UrlPath") != m.end() && !m["UrlPath"].empty()) {
      urlPath = make_shared<string>(boost::any_cast<string>(m["UrlPath"]));
    }
  }


  virtual ~CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam() = default;
};
class CreateUserDeliveryTaskRequestHttpDelivery : public Darabonba::Model {
public:
  shared_ptr<string> compress{};
  shared_ptr<string> destUrl{};
  shared_ptr<map<string, HttpDeliveryHeaderParamValue>> headerParam{};
  shared_ptr<string> lastLogSplit{};
  shared_ptr<string> logBodyPrefix{};
  shared_ptr<string> logBodySuffix{};
  shared_ptr<string> logSplit{};
  shared_ptr<string> logSplitWords{};
  shared_ptr<long> maxBackoffMS{};
  shared_ptr<long> maxBatchMB{};
  shared_ptr<long> maxBatchSize{};
  shared_ptr<long> maxRetry{};
  shared_ptr<long> minBackoffMS{};
  shared_ptr<map<string, HttpDeliveryQueryParamValue>> queryParam{};
  shared_ptr<string> responseBodyKey{};
  shared_ptr<bool> standardAuthOn{};
  shared_ptr<CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam> standardAuthParam{};
  shared_ptr<long> successCode{};
  shared_ptr<long> transformTimeout{};

  CreateUserDeliveryTaskRequestHttpDelivery() {}

  explicit CreateUserDeliveryTaskRequestHttpDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compress) {
      res["Compress"] = boost::any(*compress);
    }
    if (destUrl) {
      res["DestUrl"] = boost::any(*destUrl);
    }
    if (headerParam) {
      map<string, boost::any> temp1;
      for(auto item1:*headerParam){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["HeaderParam"] = boost::any(temp1);
    }
    if (lastLogSplit) {
      res["LastLogSplit"] = boost::any(*lastLogSplit);
    }
    if (logBodyPrefix) {
      res["LogBodyPrefix"] = boost::any(*logBodyPrefix);
    }
    if (logBodySuffix) {
      res["LogBodySuffix"] = boost::any(*logBodySuffix);
    }
    if (logSplit) {
      res["LogSplit"] = boost::any(*logSplit);
    }
    if (logSplitWords) {
      res["LogSplitWords"] = boost::any(*logSplitWords);
    }
    if (maxBackoffMS) {
      res["MaxBackoffMS"] = boost::any(*maxBackoffMS);
    }
    if (maxBatchMB) {
      res["MaxBatchMB"] = boost::any(*maxBatchMB);
    }
    if (maxBatchSize) {
      res["MaxBatchSize"] = boost::any(*maxBatchSize);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (minBackoffMS) {
      res["MinBackoffMS"] = boost::any(*minBackoffMS);
    }
    if (queryParam) {
      map<string, boost::any> temp1;
      for(auto item1:*queryParam){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["QueryParam"] = boost::any(temp1);
    }
    if (responseBodyKey) {
      res["ResponseBodyKey"] = boost::any(*responseBodyKey);
    }
    if (standardAuthOn) {
      res["StandardAuthOn"] = boost::any(*standardAuthOn);
    }
    if (standardAuthParam) {
      res["StandardAuthParam"] = standardAuthParam ? boost::any(standardAuthParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (successCode) {
      res["SuccessCode"] = boost::any(*successCode);
    }
    if (transformTimeout) {
      res["TransformTimeout"] = boost::any(*transformTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compress") != m.end() && !m["Compress"].empty()) {
      compress = make_shared<string>(boost::any_cast<string>(m["Compress"]));
    }
    if (m.find("DestUrl") != m.end() && !m["DestUrl"].empty()) {
      destUrl = make_shared<string>(boost::any_cast<string>(m["DestUrl"]));
    }
    if (m.find("HeaderParam") != m.end() && !m["HeaderParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeaderParam"].type()) {
        map<string, HttpDeliveryHeaderParamValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["HeaderParam"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            HttpDeliveryHeaderParamValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        headerParam = make_shared<map<string, HttpDeliveryHeaderParamValue>>(expect1);
      }
    }
    if (m.find("LastLogSplit") != m.end() && !m["LastLogSplit"].empty()) {
      lastLogSplit = make_shared<string>(boost::any_cast<string>(m["LastLogSplit"]));
    }
    if (m.find("LogBodyPrefix") != m.end() && !m["LogBodyPrefix"].empty()) {
      logBodyPrefix = make_shared<string>(boost::any_cast<string>(m["LogBodyPrefix"]));
    }
    if (m.find("LogBodySuffix") != m.end() && !m["LogBodySuffix"].empty()) {
      logBodySuffix = make_shared<string>(boost::any_cast<string>(m["LogBodySuffix"]));
    }
    if (m.find("LogSplit") != m.end() && !m["LogSplit"].empty()) {
      logSplit = make_shared<string>(boost::any_cast<string>(m["LogSplit"]));
    }
    if (m.find("LogSplitWords") != m.end() && !m["LogSplitWords"].empty()) {
      logSplitWords = make_shared<string>(boost::any_cast<string>(m["LogSplitWords"]));
    }
    if (m.find("MaxBackoffMS") != m.end() && !m["MaxBackoffMS"].empty()) {
      maxBackoffMS = make_shared<long>(boost::any_cast<long>(m["MaxBackoffMS"]));
    }
    if (m.find("MaxBatchMB") != m.end() && !m["MaxBatchMB"].empty()) {
      maxBatchMB = make_shared<long>(boost::any_cast<long>(m["MaxBatchMB"]));
    }
    if (m.find("MaxBatchSize") != m.end() && !m["MaxBatchSize"].empty()) {
      maxBatchSize = make_shared<long>(boost::any_cast<long>(m["MaxBatchSize"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("MinBackoffMS") != m.end() && !m["MinBackoffMS"].empty()) {
      minBackoffMS = make_shared<long>(boost::any_cast<long>(m["MinBackoffMS"]));
    }
    if (m.find("QueryParam") != m.end() && !m["QueryParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryParam"].type()) {
        map<string, HttpDeliveryQueryParamValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["QueryParam"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            HttpDeliveryQueryParamValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        queryParam = make_shared<map<string, HttpDeliveryQueryParamValue>>(expect1);
      }
    }
    if (m.find("ResponseBodyKey") != m.end() && !m["ResponseBodyKey"].empty()) {
      responseBodyKey = make_shared<string>(boost::any_cast<string>(m["ResponseBodyKey"]));
    }
    if (m.find("StandardAuthOn") != m.end() && !m["StandardAuthOn"].empty()) {
      standardAuthOn = make_shared<bool>(boost::any_cast<bool>(m["StandardAuthOn"]));
    }
    if (m.find("StandardAuthParam") != m.end() && !m["StandardAuthParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardAuthParam"].type()) {
        CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardAuthParam"]));
        standardAuthParam = make_shared<CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam>(model1);
      }
    }
    if (m.find("SuccessCode") != m.end() && !m["SuccessCode"].empty()) {
      successCode = make_shared<long>(boost::any_cast<long>(m["SuccessCode"]));
    }
    if (m.find("TransformTimeout") != m.end() && !m["TransformTimeout"].empty()) {
      transformTimeout = make_shared<long>(boost::any_cast<long>(m["TransformTimeout"]));
    }
  }


  virtual ~CreateUserDeliveryTaskRequestHttpDelivery() = default;
};
class CreateUserDeliveryTaskRequestKafkaDelivery : public Darabonba::Model {
public:
  shared_ptr<string> balancer{};
  shared_ptr<vector<string>> brokers{};
  shared_ptr<string> compress{};
  shared_ptr<string> machanismType{};
  shared_ptr<string> password{};
  shared_ptr<string> topic{};
  shared_ptr<bool> userAuth{};
  shared_ptr<string> userName{};

  CreateUserDeliveryTaskRequestKafkaDelivery() {}

  explicit CreateUserDeliveryTaskRequestKafkaDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (balancer) {
      res["Balancer"] = boost::any(*balancer);
    }
    if (brokers) {
      res["Brokers"] = boost::any(*brokers);
    }
    if (compress) {
      res["Compress"] = boost::any(*compress);
    }
    if (machanismType) {
      res["MachanismType"] = boost::any(*machanismType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (userAuth) {
      res["UserAuth"] = boost::any(*userAuth);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Balancer") != m.end() && !m["Balancer"].empty()) {
      balancer = make_shared<string>(boost::any_cast<string>(m["Balancer"]));
    }
    if (m.find("Brokers") != m.end() && !m["Brokers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Brokers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Brokers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      brokers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Compress") != m.end() && !m["Compress"].empty()) {
      compress = make_shared<string>(boost::any_cast<string>(m["Compress"]));
    }
    if (m.find("MachanismType") != m.end() && !m["MachanismType"].empty()) {
      machanismType = make_shared<string>(boost::any_cast<string>(m["MachanismType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("UserAuth") != m.end() && !m["UserAuth"].empty()) {
      userAuth = make_shared<bool>(boost::any_cast<bool>(m["UserAuth"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateUserDeliveryTaskRequestKafkaDelivery() = default;
};
class CreateUserDeliveryTaskRequestOssDelivery : public Darabonba::Model {
public:
  shared_ptr<string> aliuid{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> prefixPath{};
  shared_ptr<string> region{};

  CreateUserDeliveryTaskRequestOssDelivery() {}

  explicit CreateUserDeliveryTaskRequestOssDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliuid) {
      res["Aliuid"] = boost::any(*aliuid);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (prefixPath) {
      res["PrefixPath"] = boost::any(*prefixPath);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aliuid") != m.end() && !m["Aliuid"].empty()) {
      aliuid = make_shared<string>(boost::any_cast<string>(m["Aliuid"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("PrefixPath") != m.end() && !m["PrefixPath"].empty()) {
      prefixPath = make_shared<string>(boost::any_cast<string>(m["PrefixPath"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~CreateUserDeliveryTaskRequestOssDelivery() = default;
};
class CreateUserDeliveryTaskRequestS3Delivery : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> bucketPath{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> prefixPath{};
  shared_ptr<string> region{};
  shared_ptr<bool> s3Cmpt{};
  shared_ptr<string> secretKey{};
  shared_ptr<bool> serverSideEncryption{};
  shared_ptr<string> vertifyType{};

  CreateUserDeliveryTaskRequestS3Delivery() {}

  explicit CreateUserDeliveryTaskRequestS3Delivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (bucketPath) {
      res["BucketPath"] = boost::any(*bucketPath);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (prefixPath) {
      res["PrefixPath"] = boost::any(*prefixPath);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (s3Cmpt) {
      res["S3Cmpt"] = boost::any(*s3Cmpt);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (serverSideEncryption) {
      res["ServerSideEncryption"] = boost::any(*serverSideEncryption);
    }
    if (vertifyType) {
      res["VertifyType"] = boost::any(*vertifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("BucketPath") != m.end() && !m["BucketPath"].empty()) {
      bucketPath = make_shared<string>(boost::any_cast<string>(m["BucketPath"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("PrefixPath") != m.end() && !m["PrefixPath"].empty()) {
      prefixPath = make_shared<string>(boost::any_cast<string>(m["PrefixPath"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("S3Cmpt") != m.end() && !m["S3Cmpt"].empty()) {
      s3Cmpt = make_shared<bool>(boost::any_cast<bool>(m["S3Cmpt"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("ServerSideEncryption") != m.end() && !m["ServerSideEncryption"].empty()) {
      serverSideEncryption = make_shared<bool>(boost::any_cast<bool>(m["ServerSideEncryption"]));
    }
    if (m.find("VertifyType") != m.end() && !m["VertifyType"].empty()) {
      vertifyType = make_shared<string>(boost::any_cast<string>(m["VertifyType"]));
    }
  }


  virtual ~CreateUserDeliveryTaskRequestS3Delivery() = default;
};
class CreateUserDeliveryTaskRequestSlsDelivery : public Darabonba::Model {
public:
  shared_ptr<string> SLSLogStore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};

  CreateUserDeliveryTaskRequestSlsDelivery() {}

  explicit CreateUserDeliveryTaskRequestSlsDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SLSLogStore) {
      res["SLSLogStore"] = boost::any(*SLSLogStore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SLSLogStore") != m.end() && !m["SLSLogStore"].empty()) {
      SLSLogStore = make_shared<string>(boost::any_cast<string>(m["SLSLogStore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
  }


  virtual ~CreateUserDeliveryTaskRequestSlsDelivery() = default;
};
class CreateUserDeliveryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deliveryType{};
  shared_ptr<double> discardRate{};
  shared_ptr<string> fieldName{};
  shared_ptr<CreateUserDeliveryTaskRequestHttpDelivery> httpDelivery{};
  shared_ptr<CreateUserDeliveryTaskRequestKafkaDelivery> kafkaDelivery{};
  shared_ptr<CreateUserDeliveryTaskRequestOssDelivery> ossDelivery{};
  shared_ptr<CreateUserDeliveryTaskRequestS3Delivery> s3Delivery{};
  shared_ptr<CreateUserDeliveryTaskRequestSlsDelivery> slsDelivery{};
  shared_ptr<string> taskName{};

  CreateUserDeliveryTaskRequest() {}

  explicit CreateUserDeliveryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (discardRate) {
      res["DiscardRate"] = boost::any(*discardRate);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (httpDelivery) {
      res["HttpDelivery"] = httpDelivery ? boost::any(httpDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kafkaDelivery) {
      res["KafkaDelivery"] = kafkaDelivery ? boost::any(kafkaDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ossDelivery) {
      res["OssDelivery"] = ossDelivery ? boost::any(ossDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (s3Delivery) {
      res["S3Delivery"] = s3Delivery ? boost::any(s3Delivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (slsDelivery) {
      res["SlsDelivery"] = slsDelivery ? boost::any(slsDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<string>(boost::any_cast<string>(m["DeliveryType"]));
    }
    if (m.find("DiscardRate") != m.end() && !m["DiscardRate"].empty()) {
      discardRate = make_shared<double>(boost::any_cast<double>(m["DiscardRate"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("HttpDelivery") != m.end() && !m["HttpDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpDelivery"].type()) {
        CreateUserDeliveryTaskRequestHttpDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpDelivery"]));
        httpDelivery = make_shared<CreateUserDeliveryTaskRequestHttpDelivery>(model1);
      }
    }
    if (m.find("KafkaDelivery") != m.end() && !m["KafkaDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["KafkaDelivery"].type()) {
        CreateUserDeliveryTaskRequestKafkaDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KafkaDelivery"]));
        kafkaDelivery = make_shared<CreateUserDeliveryTaskRequestKafkaDelivery>(model1);
      }
    }
    if (m.find("OssDelivery") != m.end() && !m["OssDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssDelivery"].type()) {
        CreateUserDeliveryTaskRequestOssDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssDelivery"]));
        ossDelivery = make_shared<CreateUserDeliveryTaskRequestOssDelivery>(model1);
      }
    }
    if (m.find("S3Delivery") != m.end() && !m["S3Delivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["S3Delivery"].type()) {
        CreateUserDeliveryTaskRequestS3Delivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["S3Delivery"]));
        s3Delivery = make_shared<CreateUserDeliveryTaskRequestS3Delivery>(model1);
      }
    }
    if (m.find("SlsDelivery") != m.end() && !m["SlsDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlsDelivery"].type()) {
        CreateUserDeliveryTaskRequestSlsDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlsDelivery"]));
        slsDelivery = make_shared<CreateUserDeliveryTaskRequestSlsDelivery>(model1);
      }
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateUserDeliveryTaskRequest() = default;
};
class CreateUserDeliveryTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deliveryType{};
  shared_ptr<double> discardRate{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> httpDeliveryShrink{};
  shared_ptr<string> kafkaDeliveryShrink{};
  shared_ptr<string> ossDeliveryShrink{};
  shared_ptr<string> s3DeliveryShrink{};
  shared_ptr<string> slsDeliveryShrink{};
  shared_ptr<string> taskName{};

  CreateUserDeliveryTaskShrinkRequest() {}

  explicit CreateUserDeliveryTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (discardRate) {
      res["DiscardRate"] = boost::any(*discardRate);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (httpDeliveryShrink) {
      res["HttpDelivery"] = boost::any(*httpDeliveryShrink);
    }
    if (kafkaDeliveryShrink) {
      res["KafkaDelivery"] = boost::any(*kafkaDeliveryShrink);
    }
    if (ossDeliveryShrink) {
      res["OssDelivery"] = boost::any(*ossDeliveryShrink);
    }
    if (s3DeliveryShrink) {
      res["S3Delivery"] = boost::any(*s3DeliveryShrink);
    }
    if (slsDeliveryShrink) {
      res["SlsDelivery"] = boost::any(*slsDeliveryShrink);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<string>(boost::any_cast<string>(m["DeliveryType"]));
    }
    if (m.find("DiscardRate") != m.end() && !m["DiscardRate"].empty()) {
      discardRate = make_shared<double>(boost::any_cast<double>(m["DiscardRate"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("HttpDelivery") != m.end() && !m["HttpDelivery"].empty()) {
      httpDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["HttpDelivery"]));
    }
    if (m.find("KafkaDelivery") != m.end() && !m["KafkaDelivery"].empty()) {
      kafkaDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["KafkaDelivery"]));
    }
    if (m.find("OssDelivery") != m.end() && !m["OssDelivery"].empty()) {
      ossDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["OssDelivery"]));
    }
    if (m.find("S3Delivery") != m.end() && !m["S3Delivery"].empty()) {
      s3DeliveryShrink = make_shared<string>(boost::any_cast<string>(m["S3Delivery"]));
    }
    if (m.find("SlsDelivery") != m.end() && !m["SlsDelivery"].empty()) {
      slsDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["SlsDelivery"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateUserDeliveryTaskShrinkRequest() = default;
};
class CreateUserDeliveryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataCenter{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  CreateUserDeliveryTaskResponseBody() {}

  explicit CreateUserDeliveryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateUserDeliveryTaskResponseBody() = default;
};
class CreateUserDeliveryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserDeliveryTaskResponseBody> body{};

  CreateUserDeliveryTaskResponse() {}

  explicit CreateUserDeliveryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserDeliveryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserDeliveryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserDeliveryTaskResponse() = default;
};
class CreateWafRuleRequest : public Darabonba::Model {
public:
  shared_ptr<WafRuleConfig> config{};
  shared_ptr<string> phase{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  CreateWafRuleRequest() {}

  explicit CreateWafRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        WafRuleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<WafRuleConfig>(model1);
      }
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~CreateWafRuleRequest() = default;
};
class CreateWafRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configShrink{};
  shared_ptr<string> phase{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  CreateWafRuleShrinkRequest() {}

  explicit CreateWafRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configShrink) {
      res["Config"] = boost::any(*configShrink);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      configShrink = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~CreateWafRuleShrinkRequest() = default;
};
class CreateWafRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rulesetId{};

  CreateWafRuleResponseBody() {}

  explicit CreateWafRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rulesetId) {
      res["RulesetId"] = boost::any(*rulesetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RulesetId") != m.end() && !m["RulesetId"].empty()) {
      rulesetId = make_shared<long>(boost::any_cast<long>(m["RulesetId"]));
    }
  }


  virtual ~CreateWafRuleResponseBody() = default;
};
class CreateWafRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWafRuleResponseBody> body{};

  CreateWafRuleResponse() {}

  explicit CreateWafRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWafRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWafRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWafRuleResponse() = default;
};
class CreateWaitingRoomRequestHostNameAndPath : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> path{};
  shared_ptr<string> subdomain{};

  CreateWaitingRoomRequestHostNameAndPath() {}

  explicit CreateWaitingRoomRequestHostNameAndPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (subdomain) {
      res["Subdomain"] = boost::any(*subdomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Subdomain") != m.end() && !m["Subdomain"].empty()) {
      subdomain = make_shared<string>(boost::any_cast<string>(m["Subdomain"]));
    }
  }


  virtual ~CreateWaitingRoomRequestHostNameAndPath() = default;
};
class CreateWaitingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<string> cookieName{};
  shared_ptr<string> customPageHtml{};
  shared_ptr<string> description{};
  shared_ptr<string> disableSessionRenewalEnable{};
  shared_ptr<string> enable{};
  shared_ptr<vector<CreateWaitingRoomRequestHostNameAndPath>> hostNameAndPath{};
  shared_ptr<string> jsonResponseEnable{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<string> newUsersPerMinute{};
  shared_ptr<string> queueAllEnable{};
  shared_ptr<string> queuingMethod{};
  shared_ptr<string> queuingStatusCode{};
  shared_ptr<string> sessionDuration{};
  shared_ptr<long> siteId{};
  shared_ptr<string> totalActiveUsers{};
  shared_ptr<string> waitingRoomType{};

  CreateWaitingRoomRequest() {}

  explicit CreateWaitingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookieName) {
      res["CookieName"] = boost::any(*cookieName);
    }
    if (customPageHtml) {
      res["CustomPageHtml"] = boost::any(*customPageHtml);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableSessionRenewalEnable) {
      res["DisableSessionRenewalEnable"] = boost::any(*disableSessionRenewalEnable);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (hostNameAndPath) {
      vector<boost::any> temp1;
      for(auto item1:*hostNameAndPath){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostNameAndPath"] = boost::any(temp1);
    }
    if (jsonResponseEnable) {
      res["JsonResponseEnable"] = boost::any(*jsonResponseEnable);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newUsersPerMinute) {
      res["NewUsersPerMinute"] = boost::any(*newUsersPerMinute);
    }
    if (queueAllEnable) {
      res["QueueAllEnable"] = boost::any(*queueAllEnable);
    }
    if (queuingMethod) {
      res["QueuingMethod"] = boost::any(*queuingMethod);
    }
    if (queuingStatusCode) {
      res["QueuingStatusCode"] = boost::any(*queuingStatusCode);
    }
    if (sessionDuration) {
      res["SessionDuration"] = boost::any(*sessionDuration);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (totalActiveUsers) {
      res["TotalActiveUsers"] = boost::any(*totalActiveUsers);
    }
    if (waitingRoomType) {
      res["WaitingRoomType"] = boost::any(*waitingRoomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CookieName") != m.end() && !m["CookieName"].empty()) {
      cookieName = make_shared<string>(boost::any_cast<string>(m["CookieName"]));
    }
    if (m.find("CustomPageHtml") != m.end() && !m["CustomPageHtml"].empty()) {
      customPageHtml = make_shared<string>(boost::any_cast<string>(m["CustomPageHtml"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableSessionRenewalEnable") != m.end() && !m["DisableSessionRenewalEnable"].empty()) {
      disableSessionRenewalEnable = make_shared<string>(boost::any_cast<string>(m["DisableSessionRenewalEnable"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("HostNameAndPath") != m.end() && !m["HostNameAndPath"].empty()) {
      if (typeid(vector<boost::any>) == m["HostNameAndPath"].type()) {
        vector<CreateWaitingRoomRequestHostNameAndPath> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostNameAndPath"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWaitingRoomRequestHostNameAndPath model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostNameAndPath = make_shared<vector<CreateWaitingRoomRequestHostNameAndPath>>(expect1);
      }
    }
    if (m.find("JsonResponseEnable") != m.end() && !m["JsonResponseEnable"].empty()) {
      jsonResponseEnable = make_shared<string>(boost::any_cast<string>(m["JsonResponseEnable"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewUsersPerMinute") != m.end() && !m["NewUsersPerMinute"].empty()) {
      newUsersPerMinute = make_shared<string>(boost::any_cast<string>(m["NewUsersPerMinute"]));
    }
    if (m.find("QueueAllEnable") != m.end() && !m["QueueAllEnable"].empty()) {
      queueAllEnable = make_shared<string>(boost::any_cast<string>(m["QueueAllEnable"]));
    }
    if (m.find("QueuingMethod") != m.end() && !m["QueuingMethod"].empty()) {
      queuingMethod = make_shared<string>(boost::any_cast<string>(m["QueuingMethod"]));
    }
    if (m.find("QueuingStatusCode") != m.end() && !m["QueuingStatusCode"].empty()) {
      queuingStatusCode = make_shared<string>(boost::any_cast<string>(m["QueuingStatusCode"]));
    }
    if (m.find("SessionDuration") != m.end() && !m["SessionDuration"].empty()) {
      sessionDuration = make_shared<string>(boost::any_cast<string>(m["SessionDuration"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TotalActiveUsers") != m.end() && !m["TotalActiveUsers"].empty()) {
      totalActiveUsers = make_shared<string>(boost::any_cast<string>(m["TotalActiveUsers"]));
    }
    if (m.find("WaitingRoomType") != m.end() && !m["WaitingRoomType"].empty()) {
      waitingRoomType = make_shared<string>(boost::any_cast<string>(m["WaitingRoomType"]));
    }
  }


  virtual ~CreateWaitingRoomRequest() = default;
};
class CreateWaitingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cookieName{};
  shared_ptr<string> customPageHtml{};
  shared_ptr<string> description{};
  shared_ptr<string> disableSessionRenewalEnable{};
  shared_ptr<string> enable{};
  shared_ptr<string> hostNameAndPathShrink{};
  shared_ptr<string> jsonResponseEnable{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<string> newUsersPerMinute{};
  shared_ptr<string> queueAllEnable{};
  shared_ptr<string> queuingMethod{};
  shared_ptr<string> queuingStatusCode{};
  shared_ptr<string> sessionDuration{};
  shared_ptr<long> siteId{};
  shared_ptr<string> totalActiveUsers{};
  shared_ptr<string> waitingRoomType{};

  CreateWaitingRoomShrinkRequest() {}

  explicit CreateWaitingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookieName) {
      res["CookieName"] = boost::any(*cookieName);
    }
    if (customPageHtml) {
      res["CustomPageHtml"] = boost::any(*customPageHtml);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableSessionRenewalEnable) {
      res["DisableSessionRenewalEnable"] = boost::any(*disableSessionRenewalEnable);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (hostNameAndPathShrink) {
      res["HostNameAndPath"] = boost::any(*hostNameAndPathShrink);
    }
    if (jsonResponseEnable) {
      res["JsonResponseEnable"] = boost::any(*jsonResponseEnable);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newUsersPerMinute) {
      res["NewUsersPerMinute"] = boost::any(*newUsersPerMinute);
    }
    if (queueAllEnable) {
      res["QueueAllEnable"] = boost::any(*queueAllEnable);
    }
    if (queuingMethod) {
      res["QueuingMethod"] = boost::any(*queuingMethod);
    }
    if (queuingStatusCode) {
      res["QueuingStatusCode"] = boost::any(*queuingStatusCode);
    }
    if (sessionDuration) {
      res["SessionDuration"] = boost::any(*sessionDuration);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (totalActiveUsers) {
      res["TotalActiveUsers"] = boost::any(*totalActiveUsers);
    }
    if (waitingRoomType) {
      res["WaitingRoomType"] = boost::any(*waitingRoomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CookieName") != m.end() && !m["CookieName"].empty()) {
      cookieName = make_shared<string>(boost::any_cast<string>(m["CookieName"]));
    }
    if (m.find("CustomPageHtml") != m.end() && !m["CustomPageHtml"].empty()) {
      customPageHtml = make_shared<string>(boost::any_cast<string>(m["CustomPageHtml"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableSessionRenewalEnable") != m.end() && !m["DisableSessionRenewalEnable"].empty()) {
      disableSessionRenewalEnable = make_shared<string>(boost::any_cast<string>(m["DisableSessionRenewalEnable"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("HostNameAndPath") != m.end() && !m["HostNameAndPath"].empty()) {
      hostNameAndPathShrink = make_shared<string>(boost::any_cast<string>(m["HostNameAndPath"]));
    }
    if (m.find("JsonResponseEnable") != m.end() && !m["JsonResponseEnable"].empty()) {
      jsonResponseEnable = make_shared<string>(boost::any_cast<string>(m["JsonResponseEnable"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewUsersPerMinute") != m.end() && !m["NewUsersPerMinute"].empty()) {
      newUsersPerMinute = make_shared<string>(boost::any_cast<string>(m["NewUsersPerMinute"]));
    }
    if (m.find("QueueAllEnable") != m.end() && !m["QueueAllEnable"].empty()) {
      queueAllEnable = make_shared<string>(boost::any_cast<string>(m["QueueAllEnable"]));
    }
    if (m.find("QueuingMethod") != m.end() && !m["QueuingMethod"].empty()) {
      queuingMethod = make_shared<string>(boost::any_cast<string>(m["QueuingMethod"]));
    }
    if (m.find("QueuingStatusCode") != m.end() && !m["QueuingStatusCode"].empty()) {
      queuingStatusCode = make_shared<string>(boost::any_cast<string>(m["QueuingStatusCode"]));
    }
    if (m.find("SessionDuration") != m.end() && !m["SessionDuration"].empty()) {
      sessionDuration = make_shared<string>(boost::any_cast<string>(m["SessionDuration"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TotalActiveUsers") != m.end() && !m["TotalActiveUsers"].empty()) {
      totalActiveUsers = make_shared<string>(boost::any_cast<string>(m["TotalActiveUsers"]));
    }
    if (m.find("WaitingRoomType") != m.end() && !m["WaitingRoomType"].empty()) {
      waitingRoomType = make_shared<string>(boost::any_cast<string>(m["WaitingRoomType"]));
    }
  }


  virtual ~CreateWaitingRoomShrinkRequest() = default;
};
class CreateWaitingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateWaitingRoomResponseBody() {}

  explicit CreateWaitingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWaitingRoomResponseBody() = default;
};
class CreateWaitingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWaitingRoomResponseBody> body{};

  CreateWaitingRoomResponse() {}

  explicit CreateWaitingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWaitingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWaitingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWaitingRoomResponse() = default;
};
class CreateWaitingRoomEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> customPageHtml{};
  shared_ptr<string> description{};
  shared_ptr<string> disableSessionRenewalEnable{};
  shared_ptr<string> enable{};
  shared_ptr<string> endTime{};
  shared_ptr<string> jsonResponseEnable{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<string> newUsersPerMinute{};
  shared_ptr<string> preQueueEnable{};
  shared_ptr<string> preQueueStartTime{};
  shared_ptr<string> queuingMethod{};
  shared_ptr<string> queuingStatusCode{};
  shared_ptr<string> randomPreQueueEnable{};
  shared_ptr<string> sessionDuration{};
  shared_ptr<long> siteId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> totalActiveUsers{};
  shared_ptr<string> waitingRoomId{};
  shared_ptr<string> waitingRoomType{};

  CreateWaitingRoomEventRequest() {}

  explicit CreateWaitingRoomEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customPageHtml) {
      res["CustomPageHtml"] = boost::any(*customPageHtml);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableSessionRenewalEnable) {
      res["DisableSessionRenewalEnable"] = boost::any(*disableSessionRenewalEnable);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jsonResponseEnable) {
      res["JsonResponseEnable"] = boost::any(*jsonResponseEnable);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newUsersPerMinute) {
      res["NewUsersPerMinute"] = boost::any(*newUsersPerMinute);
    }
    if (preQueueEnable) {
      res["PreQueueEnable"] = boost::any(*preQueueEnable);
    }
    if (preQueueStartTime) {
      res["PreQueueStartTime"] = boost::any(*preQueueStartTime);
    }
    if (queuingMethod) {
      res["QueuingMethod"] = boost::any(*queuingMethod);
    }
    if (queuingStatusCode) {
      res["QueuingStatusCode"] = boost::any(*queuingStatusCode);
    }
    if (randomPreQueueEnable) {
      res["RandomPreQueueEnable"] = boost::any(*randomPreQueueEnable);
    }
    if (sessionDuration) {
      res["SessionDuration"] = boost::any(*sessionDuration);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalActiveUsers) {
      res["TotalActiveUsers"] = boost::any(*totalActiveUsers);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    if (waitingRoomType) {
      res["WaitingRoomType"] = boost::any(*waitingRoomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomPageHtml") != m.end() && !m["CustomPageHtml"].empty()) {
      customPageHtml = make_shared<string>(boost::any_cast<string>(m["CustomPageHtml"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableSessionRenewalEnable") != m.end() && !m["DisableSessionRenewalEnable"].empty()) {
      disableSessionRenewalEnable = make_shared<string>(boost::any_cast<string>(m["DisableSessionRenewalEnable"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JsonResponseEnable") != m.end() && !m["JsonResponseEnable"].empty()) {
      jsonResponseEnable = make_shared<string>(boost::any_cast<string>(m["JsonResponseEnable"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewUsersPerMinute") != m.end() && !m["NewUsersPerMinute"].empty()) {
      newUsersPerMinute = make_shared<string>(boost::any_cast<string>(m["NewUsersPerMinute"]));
    }
    if (m.find("PreQueueEnable") != m.end() && !m["PreQueueEnable"].empty()) {
      preQueueEnable = make_shared<string>(boost::any_cast<string>(m["PreQueueEnable"]));
    }
    if (m.find("PreQueueStartTime") != m.end() && !m["PreQueueStartTime"].empty()) {
      preQueueStartTime = make_shared<string>(boost::any_cast<string>(m["PreQueueStartTime"]));
    }
    if (m.find("QueuingMethod") != m.end() && !m["QueuingMethod"].empty()) {
      queuingMethod = make_shared<string>(boost::any_cast<string>(m["QueuingMethod"]));
    }
    if (m.find("QueuingStatusCode") != m.end() && !m["QueuingStatusCode"].empty()) {
      queuingStatusCode = make_shared<string>(boost::any_cast<string>(m["QueuingStatusCode"]));
    }
    if (m.find("RandomPreQueueEnable") != m.end() && !m["RandomPreQueueEnable"].empty()) {
      randomPreQueueEnable = make_shared<string>(boost::any_cast<string>(m["RandomPreQueueEnable"]));
    }
    if (m.find("SessionDuration") != m.end() && !m["SessionDuration"].empty()) {
      sessionDuration = make_shared<string>(boost::any_cast<string>(m["SessionDuration"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TotalActiveUsers") != m.end() && !m["TotalActiveUsers"].empty()) {
      totalActiveUsers = make_shared<string>(boost::any_cast<string>(m["TotalActiveUsers"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
    if (m.find("WaitingRoomType") != m.end() && !m["WaitingRoomType"].empty()) {
      waitingRoomType = make_shared<string>(boost::any_cast<string>(m["WaitingRoomType"]));
    }
  }


  virtual ~CreateWaitingRoomEventRequest() = default;
};
class CreateWaitingRoomEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateWaitingRoomEventResponseBody() {}

  explicit CreateWaitingRoomEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWaitingRoomEventResponseBody() = default;
};
class CreateWaitingRoomEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWaitingRoomEventResponseBody> body{};

  CreateWaitingRoomEventResponse() {}

  explicit CreateWaitingRoomEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWaitingRoomEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWaitingRoomEventResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWaitingRoomEventResponse() = default;
};
class CreateWaitingRoomRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> waitingRoomId{};

  CreateWaitingRoomRuleRequest() {}

  explicit CreateWaitingRoomRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
  }


  virtual ~CreateWaitingRoomRuleRequest() = default;
};
class CreateWaitingRoomRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateWaitingRoomRuleResponseBody() {}

  explicit CreateWaitingRoomRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWaitingRoomRuleResponseBody() = default;
};
class CreateWaitingRoomRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWaitingRoomRuleResponseBody> body{};

  CreateWaitingRoomRuleResponse() {}

  explicit CreateWaitingRoomRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWaitingRoomRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWaitingRoomRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWaitingRoomRuleResponse() = default;
};
class DeleteCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  DeleteCertificateRequest() {}

  explicit DeleteCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteCertificateRequest() = default;
};
class DeleteCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  DeleteCertificateResponseBody() {}

  explicit DeleteCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~DeleteCertificateResponseBody() = default;
};
class DeleteCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCertificateResponseBody> body{};

  DeleteCertificateResponse() {}

  explicit DeleteCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCertificateResponse() = default;
};
class DeleteClientCaCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  DeleteClientCaCertificateRequest() {}

  explicit DeleteClientCaCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteClientCaCertificateRequest() = default;
};
class DeleteClientCaCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  DeleteClientCaCertificateResponseBody() {}

  explicit DeleteClientCaCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~DeleteClientCaCertificateResponseBody() = default;
};
class DeleteClientCaCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClientCaCertificateResponseBody> body{};

  DeleteClientCaCertificateResponse() {}

  explicit DeleteClientCaCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClientCaCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClientCaCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClientCaCertificateResponse() = default;
};
class DeleteClientCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  DeleteClientCertificateRequest() {}

  explicit DeleteClientCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteClientCertificateRequest() = default;
};
class DeleteClientCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  DeleteClientCertificateResponseBody() {}

  explicit DeleteClientCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~DeleteClientCertificateResponseBody() = default;
};
class DeleteClientCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClientCertificateResponseBody> body{};

  DeleteClientCertificateResponse() {}

  explicit DeleteClientCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClientCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClientCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClientCertificateResponse() = default;
};
class DeleteCustomScenePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};

  DeleteCustomScenePolicyRequest() {}

  explicit DeleteCustomScenePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~DeleteCustomScenePolicyRequest() = default;
};
class DeleteCustomScenePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> requestId{};

  DeleteCustomScenePolicyResponseBody() {}

  explicit DeleteCustomScenePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomScenePolicyResponseBody() = default;
};
class DeleteCustomScenePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomScenePolicyResponseBody> body{};

  DeleteCustomScenePolicyResponse() {}

  explicit DeleteCustomScenePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomScenePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomScenePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomScenePolicyResponse() = default;
};
class DeleteEdgeContainerAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteEdgeContainerAppRequest() {}

  explicit DeleteEdgeContainerAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteEdgeContainerAppRequest() = default;
};
class DeleteEdgeContainerAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  DeleteEdgeContainerAppResponseBody() {}

  explicit DeleteEdgeContainerAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DeleteEdgeContainerAppResponseBody() = default;
};
class DeleteEdgeContainerAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEdgeContainerAppResponseBody> body{};

  DeleteEdgeContainerAppResponse() {}

  explicit DeleteEdgeContainerAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeContainerAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeContainerAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeContainerAppResponse() = default;
};
class DeleteEdgeContainerAppRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};

  DeleteEdgeContainerAppRecordRequest() {}

  explicit DeleteEdgeContainerAppRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteEdgeContainerAppRecordRequest() = default;
};
class DeleteEdgeContainerAppRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEdgeContainerAppRecordResponseBody() {}

  explicit DeleteEdgeContainerAppRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEdgeContainerAppRecordResponseBody() = default;
};
class DeleteEdgeContainerAppRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEdgeContainerAppRecordResponseBody> body{};

  DeleteEdgeContainerAppRecordResponse() {}

  explicit DeleteEdgeContainerAppRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeContainerAppRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeContainerAppRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeContainerAppRecordResponse() = default;
};
class DeleteEdgeContainerAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> versionId{};

  DeleteEdgeContainerAppVersionRequest() {}

  explicit DeleteEdgeContainerAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DeleteEdgeContainerAppVersionRequest() = default;
};
class DeleteEdgeContainerAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEdgeContainerAppVersionResponseBody() {}

  explicit DeleteEdgeContainerAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEdgeContainerAppVersionResponseBody() = default;
};
class DeleteEdgeContainerAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEdgeContainerAppVersionResponseBody> body{};

  DeleteEdgeContainerAppVersionResponse() {}

  explicit DeleteEdgeContainerAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeContainerAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeContainerAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeContainerAppVersionResponse() = default;
};
class DeleteKvRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> namespace_{};

  DeleteKvRequest() {}

  explicit DeleteKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteKvRequest() = default;
};
class DeleteKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteKvResponseBody() {}

  explicit DeleteKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteKvResponseBody() = default;
};
class DeleteKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteKvResponseBody> body{};

  DeleteKvResponse() {}

  explicit DeleteKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteKvResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteKvResponse() = default;
};
class DeleteKvNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};

  DeleteKvNamespaceRequest() {}

  explicit DeleteKvNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteKvNamespaceRequest() = default;
};
class DeleteKvNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteKvNamespaceResponseBody() {}

  explicit DeleteKvNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteKvNamespaceResponseBody() = default;
};
class DeleteKvNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteKvNamespaceResponseBody> body{};

  DeleteKvNamespaceResponse() {}

  explicit DeleteKvNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteKvNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteKvNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteKvNamespaceResponse() = default;
};
class DeleteListRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteListRequest() {}

  explicit DeleteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteListRequest() = default;
};
class DeleteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteListResponseBody() {}

  explicit DeleteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteListResponseBody() = default;
};
class DeleteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteListResponseBody> body{};

  DeleteListResponse() {}

  explicit DeleteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteListResponse() = default;
};
class DeleteOriginProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  DeleteOriginProtectionRequest() {}

  explicit DeleteOriginProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteOriginProtectionRequest() = default;
};
class DeleteOriginProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteOriginProtectionResponseBody() {}

  explicit DeleteOriginProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteOriginProtectionResponseBody() = default;
};
class DeleteOriginProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOriginProtectionResponseBody> body{};

  DeleteOriginProtectionResponse() {}

  explicit DeleteOriginProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOriginProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOriginProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOriginProtectionResponse() = default;
};
class DeletePageRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeletePageRequest() {}

  explicit DeletePageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeletePageRequest() = default;
};
class DeletePageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  DeletePageResponseBody() {}

  explicit DeletePageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePageResponseBody() = default;
};
class DeletePageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePageResponseBody> body{};

  DeletePageResponse() {}

  explicit DeletePageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePageResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePageResponse() = default;
};
class DeleteRecordRequest : public Darabonba::Model {
public:
  shared_ptr<long> recordId{};

  DeleteRecordRequest() {}

  explicit DeleteRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
  }


  virtual ~DeleteRecordRequest() = default;
};
class DeleteRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRecordResponseBody() {}

  explicit DeleteRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRecordResponseBody() = default;
};
class DeleteRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRecordResponseBody> body{};

  DeleteRecordResponse() {}

  explicit DeleteRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRecordResponse() = default;
};
class DeleteRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DeleteRoutineRequest() {}

  explicit DeleteRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteRoutineRequest() = default;
};
class DeleteRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DeleteRoutineResponseBody() {}

  explicit DeleteRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DeleteRoutineResponseBody() = default;
};
class DeleteRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoutineResponseBody> body{};

  DeleteRoutineResponse() {}

  explicit DeleteRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineResponse() = default;
};
class DeleteRoutineCodeVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> codeVersion{};
  shared_ptr<string> name{};

  DeleteRoutineCodeVersionRequest() {}

  explicit DeleteRoutineCodeVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteRoutineCodeVersionRequest() = default;
};
class DeleteRoutineCodeVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DeleteRoutineCodeVersionResponseBody() {}

  explicit DeleteRoutineCodeVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DeleteRoutineCodeVersionResponseBody() = default;
};
class DeleteRoutineCodeVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoutineCodeVersionResponseBody> body{};

  DeleteRoutineCodeVersionResponse() {}

  explicit DeleteRoutineCodeVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineCodeVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineCodeVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineCodeVersionResponse() = default;
};
class DeleteRoutineRelatedRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> recordId{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};

  DeleteRoutineRelatedRecordRequest() {}

  explicit DeleteRoutineRelatedRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteRoutineRelatedRecordRequest() = default;
};
class DeleteRoutineRelatedRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DeleteRoutineRelatedRecordResponseBody() {}

  explicit DeleteRoutineRelatedRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DeleteRoutineRelatedRecordResponseBody() = default;
};
class DeleteRoutineRelatedRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoutineRelatedRecordResponseBody> body{};

  DeleteRoutineRelatedRecordResponse() {}

  explicit DeleteRoutineRelatedRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineRelatedRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineRelatedRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineRelatedRecordResponse() = default;
};
class DeleteRoutineRelatedRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> route{};
  shared_ptr<string> routeId{};
  shared_ptr<long> siteId{};

  DeleteRoutineRelatedRouteRequest() {}

  explicit DeleteRoutineRelatedRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (route) {
      res["Route"] = boost::any(*route);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      route = make_shared<string>(boost::any_cast<string>(m["Route"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteRoutineRelatedRouteRequest() = default;
};
class DeleteRoutineRelatedRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DeleteRoutineRelatedRouteResponseBody() {}

  explicit DeleteRoutineRelatedRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DeleteRoutineRelatedRouteResponseBody() = default;
};
class DeleteRoutineRelatedRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoutineRelatedRouteResponseBody> body{};

  DeleteRoutineRelatedRouteResponse() {}

  explicit DeleteRoutineRelatedRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineRelatedRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineRelatedRouteResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineRelatedRouteResponse() = default;
};
class DeleteScheduledPreloadExecutionRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteScheduledPreloadExecutionRequest() {}

  explicit DeleteScheduledPreloadExecutionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteScheduledPreloadExecutionRequest() = default;
};
class DeleteScheduledPreloadExecutionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteScheduledPreloadExecutionResponseBody() {}

  explicit DeleteScheduledPreloadExecutionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteScheduledPreloadExecutionResponseBody() = default;
};
class DeleteScheduledPreloadExecutionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScheduledPreloadExecutionResponseBody> body{};

  DeleteScheduledPreloadExecutionResponse() {}

  explicit DeleteScheduledPreloadExecutionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScheduledPreloadExecutionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScheduledPreloadExecutionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScheduledPreloadExecutionResponse() = default;
};
class DeleteScheduledPreloadJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteScheduledPreloadJobRequest() {}

  explicit DeleteScheduledPreloadJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteScheduledPreloadJobRequest() = default;
};
class DeleteScheduledPreloadJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteScheduledPreloadJobResponseBody() {}

  explicit DeleteScheduledPreloadJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteScheduledPreloadJobResponseBody() = default;
};
class DeleteScheduledPreloadJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScheduledPreloadJobResponseBody> body{};

  DeleteScheduledPreloadJobResponse() {}

  explicit DeleteScheduledPreloadJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScheduledPreloadJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScheduledPreloadJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScheduledPreloadJobResponse() = default;
};
class DeleteSiteRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<long> siteId{};

  DeleteSiteRequest() {}

  explicit DeleteSiteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteSiteRequest() = default;
};
class DeleteSiteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSiteResponseBody() {}

  explicit DeleteSiteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSiteResponseBody() = default;
};
class DeleteSiteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSiteResponseBody> body{};

  DeleteSiteResponse() {}

  explicit DeleteSiteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSiteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSiteResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSiteResponse() = default;
};
class DeleteSiteDeliveryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> taskName{};

  DeleteSiteDeliveryTaskRequest() {}

  explicit DeleteSiteDeliveryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DeleteSiteDeliveryTaskRequest() = default;
};
class DeleteSiteDeliveryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSiteDeliveryTaskResponseBody() {}

  explicit DeleteSiteDeliveryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSiteDeliveryTaskResponseBody() = default;
};
class DeleteSiteDeliveryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSiteDeliveryTaskResponseBody> body{};

  DeleteSiteDeliveryTaskResponse() {}

  explicit DeleteSiteDeliveryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSiteDeliveryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSiteDeliveryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSiteDeliveryTaskResponse() = default;
};
class DeleteSiteFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<string> configIds{};
  shared_ptr<long> siteId{};

  DeleteSiteFunctionRequest() {}

  explicit DeleteSiteFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configIds) {
      res["ConfigIds"] = boost::any(*configIds);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigIds") != m.end() && !m["ConfigIds"].empty()) {
      configIds = make_shared<string>(boost::any_cast<string>(m["ConfigIds"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DeleteSiteFunctionRequest() = default;
};
class DeleteSiteFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSiteFunctionResponseBody() {}

  explicit DeleteSiteFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSiteFunctionResponseBody() = default;
};
class DeleteSiteFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSiteFunctionResponseBody> body{};

  DeleteSiteFunctionResponse() {}

  explicit DeleteSiteFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSiteFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSiteFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSiteFunctionResponse() = default;
};
class DeleteUserDeliveryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskName{};

  DeleteUserDeliveryTaskRequest() {}

  explicit DeleteUserDeliveryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DeleteUserDeliveryTaskRequest() = default;
};
class DeleteUserDeliveryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserDeliveryTaskResponseBody() {}

  explicit DeleteUserDeliveryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserDeliveryTaskResponseBody() = default;
};
class DeleteUserDeliveryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserDeliveryTaskResponseBody> body{};

  DeleteUserDeliveryTaskResponse() {}

  explicit DeleteUserDeliveryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserDeliveryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserDeliveryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserDeliveryTaskResponse() = default;
};
class DeleteWafRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  DeleteWafRuleRequest() {}

  explicit DeleteWafRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~DeleteWafRuleRequest() = default;
};
class DeleteWafRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWafRuleResponseBody() {}

  explicit DeleteWafRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWafRuleResponseBody() = default;
};
class DeleteWafRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWafRuleResponseBody> body{};

  DeleteWafRuleResponse() {}

  explicit DeleteWafRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWafRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWafRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWafRuleResponse() = default;
};
class DeleteWafRulesetRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  DeleteWafRulesetRequest() {}

  explicit DeleteWafRulesetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~DeleteWafRulesetRequest() = default;
};
class DeleteWafRulesetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWafRulesetResponseBody() {}

  explicit DeleteWafRulesetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWafRulesetResponseBody() = default;
};
class DeleteWafRulesetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWafRulesetResponseBody> body{};

  DeleteWafRulesetResponse() {}

  explicit DeleteWafRulesetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWafRulesetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWafRulesetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWafRulesetResponse() = default;
};
class DeleteWaitingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> waitingRoomId{};

  DeleteWaitingRoomRequest() {}

  explicit DeleteWaitingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
  }


  virtual ~DeleteWaitingRoomRequest() = default;
};
class DeleteWaitingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWaitingRoomResponseBody() {}

  explicit DeleteWaitingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWaitingRoomResponseBody() = default;
};
class DeleteWaitingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWaitingRoomResponseBody> body{};

  DeleteWaitingRoomResponse() {}

  explicit DeleteWaitingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWaitingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWaitingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWaitingRoomResponse() = default;
};
class DeleteWaitingRoomEventRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<long> waitingRoomEventId{};

  DeleteWaitingRoomEventRequest() {}

  explicit DeleteWaitingRoomEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (waitingRoomEventId) {
      res["WaitingRoomEventId"] = boost::any(*waitingRoomEventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("WaitingRoomEventId") != m.end() && !m["WaitingRoomEventId"].empty()) {
      waitingRoomEventId = make_shared<long>(boost::any_cast<long>(m["WaitingRoomEventId"]));
    }
  }


  virtual ~DeleteWaitingRoomEventRequest() = default;
};
class DeleteWaitingRoomEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWaitingRoomEventResponseBody() {}

  explicit DeleteWaitingRoomEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWaitingRoomEventResponseBody() = default;
};
class DeleteWaitingRoomEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWaitingRoomEventResponseBody> body{};

  DeleteWaitingRoomEventResponse() {}

  explicit DeleteWaitingRoomEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWaitingRoomEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWaitingRoomEventResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWaitingRoomEventResponse() = default;
};
class DeleteWaitingRoomRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<long> waitingRoomRuleId{};

  DeleteWaitingRoomRuleRequest() {}

  explicit DeleteWaitingRoomRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (waitingRoomRuleId) {
      res["WaitingRoomRuleId"] = boost::any(*waitingRoomRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("WaitingRoomRuleId") != m.end() && !m["WaitingRoomRuleId"].empty()) {
      waitingRoomRuleId = make_shared<long>(boost::any_cast<long>(m["WaitingRoomRuleId"]));
    }
  }


  virtual ~DeleteWaitingRoomRuleRequest() = default;
};
class DeleteWaitingRoomRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWaitingRoomRuleResponseBody() {}

  explicit DeleteWaitingRoomRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWaitingRoomRuleResponseBody() = default;
};
class DeleteWaitingRoomRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWaitingRoomRuleResponseBody> body{};

  DeleteWaitingRoomRuleResponse() {}

  explicit DeleteWaitingRoomRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWaitingRoomRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWaitingRoomRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWaitingRoomRuleResponse() = default;
};
class DescribeCustomScenePoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> policyId{};

  DescribeCustomScenePoliciesRequest() {}

  explicit DescribeCustomScenePoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~DescribeCustomScenePoliciesRequest() = default;
};
class DescribeCustomScenePoliciesResponseBodyDataModule : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> objects{};
  shared_ptr<long> policyId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> template_{};

  DescribeCustomScenePoliciesResponseBodyDataModule() {}

  explicit DescribeCustomScenePoliciesResponseBodyDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objects) {
      res["Objects"] = boost::any(*objects);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Objects") != m.end() && !m["Objects"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Objects"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Objects"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      objects = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~DescribeCustomScenePoliciesResponseBodyDataModule() = default;
};
class DescribeCustomScenePoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomScenePoliciesResponseBodyDataModule>> dataModule{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> quota{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCustomScenePoliciesResponseBody() {}

  explicit DescribeCustomScenePoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeCustomScenePoliciesResponseBodyDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomScenePoliciesResponseBodyDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeCustomScenePoliciesResponseBodyDataModule>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCustomScenePoliciesResponseBody() = default;
};
class DescribeCustomScenePoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomScenePoliciesResponseBody> body{};

  DescribeCustomScenePoliciesResponse() {}

  explicit DescribeCustomScenePoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomScenePoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomScenePoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomScenePoliciesResponse() = default;
};
class DescribeDDoSAllEventListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> siteId{};
  shared_ptr<string> startTime{};

  DescribeDDoSAllEventListRequest() {}

  explicit DescribeDDoSAllEventListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDoSAllEventListRequest() = default;
};
class DescribeDDoSAllEventListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> bps{};
  shared_ptr<string> coverage{};
  shared_ptr<long> cps{};
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventResult{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pps{};
  shared_ptr<long> qps{};
  shared_ptr<string> startTime{};
  shared_ptr<string> target{};
  shared_ptr<string> targetId{};

  DescribeDDoSAllEventListResponseBodyDataList() {}

  explicit DescribeDDoSAllEventListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (cps) {
      res["Cps"] = boost::any(*cps);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventResult) {
      res["EventResult"] = boost::any(*eventResult);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pps) {
      res["Pps"] = boost::any(*pps);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<long>(boost::any_cast<long>(m["Bps"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("Cps") != m.end() && !m["Cps"].empty()) {
      cps = make_shared<long>(boost::any_cast<long>(m["Cps"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventResult") != m.end() && !m["EventResult"].empty()) {
      eventResult = make_shared<string>(boost::any_cast<string>(m["EventResult"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Pps") != m.end() && !m["Pps"].empty()) {
      pps = make_shared<long>(boost::any_cast<long>(m["Pps"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<long>(boost::any_cast<long>(m["Qps"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
  }


  virtual ~DescribeDDoSAllEventListResponseBodyDataList() = default;
};
class DescribeDDoSAllEventListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDDoSAllEventListResponseBodyDataList>> dataList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<long> totalCount{};

  DescribeDDoSAllEventListResponseBody() {}

  explicit DescribeDDoSAllEventListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataList") != m.end() && !m["DataList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataList"].type()) {
        vector<DescribeDDoSAllEventListResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDDoSAllEventListResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<DescribeDDoSAllEventListResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDDoSAllEventListResponseBody() = default;
};
class DescribeDDoSAllEventListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDoSAllEventListResponseBody> body{};

  DescribeDDoSAllEventListResponse() {}

  explicit DescribeDDoSAllEventListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDoSAllEventListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDoSAllEventListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDoSAllEventListResponse() = default;
};
class DescribeHttpDDoSAttackIntelligentProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  DescribeHttpDDoSAttackIntelligentProtectionRequest() {}

  explicit DescribeHttpDDoSAttackIntelligentProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DescribeHttpDDoSAttackIntelligentProtectionRequest() = default;
};
class DescribeHttpDDoSAttackIntelligentProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aiMode{};
  shared_ptr<string> aiTemplate{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};

  DescribeHttpDDoSAttackIntelligentProtectionResponseBody() {}

  explicit DescribeHttpDDoSAttackIntelligentProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiMode) {
      res["AiMode"] = boost::any(*aiMode);
    }
    if (aiTemplate) {
      res["AiTemplate"] = boost::any(*aiTemplate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiMode") != m.end() && !m["AiMode"].empty()) {
      aiMode = make_shared<string>(boost::any_cast<string>(m["AiMode"]));
    }
    if (m.find("AiTemplate") != m.end() && !m["AiTemplate"].empty()) {
      aiTemplate = make_shared<string>(boost::any_cast<string>(m["AiTemplate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DescribeHttpDDoSAttackIntelligentProtectionResponseBody() = default;
};
class DescribeHttpDDoSAttackIntelligentProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHttpDDoSAttackIntelligentProtectionResponseBody> body{};

  DescribeHttpDDoSAttackIntelligentProtectionResponse() {}

  explicit DescribeHttpDDoSAttackIntelligentProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHttpDDoSAttackIntelligentProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHttpDDoSAttackIntelligentProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHttpDDoSAttackIntelligentProtectionResponse() = default;
};
class DescribeHttpDDoSAttackProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  DescribeHttpDDoSAttackProtectionRequest() {}

  explicit DescribeHttpDDoSAttackProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DescribeHttpDDoSAttackProtectionRequest() = default;
};
class DescribeHttpDDoSAttackProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> globalMode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};

  DescribeHttpDDoSAttackProtectionResponseBody() {}

  explicit DescribeHttpDDoSAttackProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalMode) {
      res["GlobalMode"] = boost::any(*globalMode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalMode") != m.end() && !m["GlobalMode"].empty()) {
      globalMode = make_shared<string>(boost::any_cast<string>(m["GlobalMode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~DescribeHttpDDoSAttackProtectionResponseBody() = default;
};
class DescribeHttpDDoSAttackProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHttpDDoSAttackProtectionResponseBody> body{};

  DescribeHttpDDoSAttackProtectionResponse() {}

  explicit DescribeHttpDDoSAttackProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHttpDDoSAttackProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHttpDDoSAttackProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHttpDDoSAttackProtectionResponse() = default;
};
class DescribeKvAccountStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeKvAccountStatusResponseBody() {}

  explicit DescribeKvAccountStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeKvAccountStatusResponseBody() = default;
};
class DescribeKvAccountStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeKvAccountStatusResponseBody> body{};

  DescribeKvAccountStatusResponse() {}

  explicit DescribeKvAccountStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeKvAccountStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeKvAccountStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeKvAccountStatusResponse() = default;
};
class DescribePreloadTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> siteId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DescribePreloadTasksRequest() {}

  explicit DescribePreloadTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribePreloadTasksRequest() = default;
};
class DescribePreloadTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> process{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribePreloadTasksResponseBodyTasks() {}

  explicit DescribePreloadTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribePreloadTasksResponseBodyTasks() = default;
};
class DescribePreloadTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribePreloadTasksResponseBodyTasks>> tasks{};
  shared_ptr<long> totalCount{};

  DescribePreloadTasksResponseBody() {}

  explicit DescribePreloadTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<DescribePreloadTasksResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreloadTasksResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<DescribePreloadTasksResponseBodyTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePreloadTasksResponseBody() = default;
};
class DescribePreloadTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePreloadTasksResponseBody> body{};

  DescribePreloadTasksResponse() {}

  explicit DescribePreloadTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePreloadTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePreloadTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePreloadTasksResponse() = default;
};
class DescribePurgeTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> siteId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribePurgeTasksRequest() {}

  explicit DescribePurgeTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePurgeTasksRequest() = default;
};
class DescribePurgeTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> process{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  DescribePurgeTasksResponseBodyTasks() {}

  explicit DescribePurgeTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePurgeTasksResponseBodyTasks() = default;
};
class DescribePurgeTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribePurgeTasksResponseBodyTasks>> tasks{};
  shared_ptr<long> totalCount{};

  DescribePurgeTasksResponseBody() {}

  explicit DescribePurgeTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<DescribePurgeTasksResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurgeTasksResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<DescribePurgeTasksResponseBodyTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePurgeTasksResponseBody() = default;
};
class DescribePurgeTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurgeTasksResponseBody> body{};

  DescribePurgeTasksResponse() {}

  explicit DescribePurgeTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurgeTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurgeTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurgeTasksResponse() = default;
};
class DisableCustomScenePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};

  DisableCustomScenePolicyRequest() {}

  explicit DisableCustomScenePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~DisableCustomScenePolicyRequest() = default;
};
class DisableCustomScenePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> requestId{};

  DisableCustomScenePolicyResponseBody() {}

  explicit DisableCustomScenePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableCustomScenePolicyResponseBody() = default;
};
class DisableCustomScenePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableCustomScenePolicyResponseBody> body{};

  DisableCustomScenePolicyResponse() {}

  explicit DisableCustomScenePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableCustomScenePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableCustomScenePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DisableCustomScenePolicyResponse() = default;
};
class EditSiteWafSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<WafSiteSettings> settings{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  EditSiteWafSettingsRequest() {}

  explicit EditSiteWafSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (settings) {
      res["Settings"] = settings ? boost::any(settings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Settings") != m.end() && !m["Settings"].empty()) {
      if (typeid(map<string, boost::any>) == m["Settings"].type()) {
        WafSiteSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Settings"]));
        settings = make_shared<WafSiteSettings>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~EditSiteWafSettingsRequest() = default;
};
class EditSiteWafSettingsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> settingsShrink{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  EditSiteWafSettingsShrinkRequest() {}

  explicit EditSiteWafSettingsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (settingsShrink) {
      res["Settings"] = boost::any(*settingsShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Settings") != m.end() && !m["Settings"].empty()) {
      settingsShrink = make_shared<string>(boost::any_cast<string>(m["Settings"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~EditSiteWafSettingsShrinkRequest() = default;
};
class EditSiteWafSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EditSiteWafSettingsResponseBody() {}

  explicit EditSiteWafSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EditSiteWafSettingsResponseBody() = default;
};
class EditSiteWafSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EditSiteWafSettingsResponseBody> body{};

  EditSiteWafSettingsResponse() {}

  explicit EditSiteWafSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EditSiteWafSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EditSiteWafSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~EditSiteWafSettingsResponse() = default;
};
class EnableCustomScenePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};

  EnableCustomScenePolicyRequest() {}

  explicit EnableCustomScenePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~EnableCustomScenePolicyRequest() = default;
};
class EnableCustomScenePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> requestId{};

  EnableCustomScenePolicyResponseBody() {}

  explicit EnableCustomScenePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableCustomScenePolicyResponseBody() = default;
};
class EnableCustomScenePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableCustomScenePolicyResponseBody> body{};

  EnableCustomScenePolicyResponse() {}

  explicit EnableCustomScenePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableCustomScenePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableCustomScenePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~EnableCustomScenePolicyResponse() = default;
};
class ExportRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  ExportRecordsRequest() {}

  explicit ExportRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ExportRecordsRequest() = default;
};
class ExportRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  ExportRecordsResponseBody() {}

  explicit ExportRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportRecordsResponseBody() = default;
};
class ExportRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportRecordsResponseBody> body{};

  ExportRecordsResponse() {}

  explicit ExportRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ExportRecordsResponse() = default;
};
class GetCacheReserveSpecificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cacheReserveCapacity{};
  shared_ptr<vector<string>> cacheReserveRegion{};
  shared_ptr<string> requestId{};

  GetCacheReserveSpecificationResponseBody() {}

  explicit GetCacheReserveSpecificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheReserveCapacity) {
      res["CacheReserveCapacity"] = boost::any(*cacheReserveCapacity);
    }
    if (cacheReserveRegion) {
      res["CacheReserveRegion"] = boost::any(*cacheReserveRegion);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheReserveCapacity") != m.end() && !m["CacheReserveCapacity"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CacheReserveCapacity"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CacheReserveCapacity"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cacheReserveCapacity = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CacheReserveRegion") != m.end() && !m["CacheReserveRegion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CacheReserveRegion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CacheReserveRegion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cacheReserveRegion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCacheReserveSpecificationResponseBody() = default;
};
class GetCacheReserveSpecificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCacheReserveSpecificationResponseBody> body{};

  GetCacheReserveSpecificationResponse() {}

  explicit GetCacheReserveSpecificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCacheReserveSpecificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCacheReserveSpecificationResponseBody>(model1);
      }
    }
  }


  virtual ~GetCacheReserveSpecificationResponse() = default;
};
class GetCertificateQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};

  GetCertificateQuotaRequest() {}

  explicit GetCertificateQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCertificateQuotaRequest() = default;
};
class GetCertificateQuotaResponseBodySiteUsage : public Darabonba::Model {
public:
  shared_ptr<string> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<long> siteUsage{};

  GetCertificateQuotaResponseBodySiteUsage() {}

  explicit GetCertificateQuotaResponseBodySiteUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (siteUsage) {
      res["SiteUsage"] = boost::any(*siteUsage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<string>(boost::any_cast<string>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("SiteUsage") != m.end() && !m["SiteUsage"].empty()) {
      siteUsage = make_shared<long>(boost::any_cast<long>(m["SiteUsage"]));
    }
  }


  virtual ~GetCertificateQuotaResponseBodySiteUsage() = default;
};
class GetCertificateQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> quota{};
  shared_ptr<long> quotaUsage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteCount{};
  shared_ptr<vector<GetCertificateQuotaResponseBodySiteUsage>> siteUsage{};
  shared_ptr<string> type{};

  GetCertificateQuotaResponseBody() {}

  explicit GetCertificateQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (quotaUsage) {
      res["QuotaUsage"] = boost::any(*quotaUsage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteCount) {
      res["SiteCount"] = boost::any(*siteCount);
    }
    if (siteUsage) {
      vector<boost::any> temp1;
      for(auto item1:*siteUsage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SiteUsage"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("QuotaUsage") != m.end() && !m["QuotaUsage"].empty()) {
      quotaUsage = make_shared<long>(boost::any_cast<long>(m["QuotaUsage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteCount") != m.end() && !m["SiteCount"].empty()) {
      siteCount = make_shared<long>(boost::any_cast<long>(m["SiteCount"]));
    }
    if (m.find("SiteUsage") != m.end() && !m["SiteUsage"].empty()) {
      if (typeid(vector<boost::any>) == m["SiteUsage"].type()) {
        vector<GetCertificateQuotaResponseBodySiteUsage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SiteUsage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCertificateQuotaResponseBodySiteUsage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        siteUsage = make_shared<vector<GetCertificateQuotaResponseBodySiteUsage>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCertificateQuotaResponseBody() = default;
};
class GetCertificateQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCertificateQuotaResponseBody> body{};

  GetCertificateQuotaResponse() {}

  explicit GetCertificateQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCertificateQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCertificateQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~GetCertificateQuotaResponse() = default;
};
class GetClientCaCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  GetClientCaCertificateRequest() {}

  explicit GetClientCaCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetClientCaCertificateRequest() = default;
};
class GetClientCaCertificateResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> commonName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> issuer{};
  shared_ptr<string> name{};
  shared_ptr<string> notAfter{};
  shared_ptr<string> notBefore{};
  shared_ptr<string> pubkeyAlgorithm{};
  shared_ptr<string> SAN{};
  shared_ptr<string> signatureAlgorithm{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};

  GetClientCaCertificateResponseBodyResult() {}

  explicit GetClientCaCertificateResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notAfter) {
      res["NotAfter"] = boost::any(*notAfter);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    if (pubkeyAlgorithm) {
      res["PubkeyAlgorithm"] = boost::any(*pubkeyAlgorithm);
    }
    if (SAN) {
      res["SAN"] = boost::any(*SAN);
    }
    if (signatureAlgorithm) {
      res["SignatureAlgorithm"] = boost::any(*signatureAlgorithm);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotAfter") != m.end() && !m["NotAfter"].empty()) {
      notAfter = make_shared<string>(boost::any_cast<string>(m["NotAfter"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
    if (m.find("PubkeyAlgorithm") != m.end() && !m["PubkeyAlgorithm"].empty()) {
      pubkeyAlgorithm = make_shared<string>(boost::any_cast<string>(m["PubkeyAlgorithm"]));
    }
    if (m.find("SAN") != m.end() && !m["SAN"].empty()) {
      SAN = make_shared<string>(boost::any_cast<string>(m["SAN"]));
    }
    if (m.find("SignatureAlgorithm") != m.end() && !m["SignatureAlgorithm"].empty()) {
      signatureAlgorithm = make_shared<string>(boost::any_cast<string>(m["SignatureAlgorithm"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetClientCaCertificateResponseBodyResult() = default;
};
class GetClientCaCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certificate{};
  shared_ptr<string> requestId{};
  shared_ptr<GetClientCaCertificateResponseBodyResult> result{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> status{};

  GetClientCaCertificateResponseBody() {}

  explicit GetClientCaCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetClientCaCertificateResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetClientCaCertificateResponseBodyResult>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetClientCaCertificateResponseBody() = default;
};
class GetClientCaCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClientCaCertificateResponseBody> body{};

  GetClientCaCertificateResponse() {}

  explicit GetClientCaCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClientCaCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClientCaCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~GetClientCaCertificateResponse() = default;
};
class GetClientCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  GetClientCertificateRequest() {}

  explicit GetClientCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetClientCertificateRequest() = default;
};
class GetClientCertificateResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> CACertificateId{};
  shared_ptr<string> commonName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> issuer{};
  shared_ptr<string> name{};
  shared_ptr<string> notAfter{};
  shared_ptr<string> notBefore{};
  shared_ptr<string> pubkeyAlgorithm{};
  shared_ptr<string> SAN{};
  shared_ptr<string> signatureAlgorithm{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};

  GetClientCertificateResponseBodyResult() {}

  explicit GetClientCertificateResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CACertificateId) {
      res["CACertificateId"] = boost::any(*CACertificateId);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notAfter) {
      res["NotAfter"] = boost::any(*notAfter);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    if (pubkeyAlgorithm) {
      res["PubkeyAlgorithm"] = boost::any(*pubkeyAlgorithm);
    }
    if (SAN) {
      res["SAN"] = boost::any(*SAN);
    }
    if (signatureAlgorithm) {
      res["SignatureAlgorithm"] = boost::any(*signatureAlgorithm);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CACertificateId") != m.end() && !m["CACertificateId"].empty()) {
      CACertificateId = make_shared<string>(boost::any_cast<string>(m["CACertificateId"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotAfter") != m.end() && !m["NotAfter"].empty()) {
      notAfter = make_shared<string>(boost::any_cast<string>(m["NotAfter"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
    if (m.find("PubkeyAlgorithm") != m.end() && !m["PubkeyAlgorithm"].empty()) {
      pubkeyAlgorithm = make_shared<string>(boost::any_cast<string>(m["PubkeyAlgorithm"]));
    }
    if (m.find("SAN") != m.end() && !m["SAN"].empty()) {
      SAN = make_shared<string>(boost::any_cast<string>(m["SAN"]));
    }
    if (m.find("SignatureAlgorithm") != m.end() && !m["SignatureAlgorithm"].empty()) {
      signatureAlgorithm = make_shared<string>(boost::any_cast<string>(m["SignatureAlgorithm"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetClientCertificateResponseBodyResult() = default;
};
class GetClientCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certificate{};
  shared_ptr<string> requestId{};
  shared_ptr<GetClientCertificateResponseBodyResult> result{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> status{};

  GetClientCertificateResponseBody() {}

  explicit GetClientCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetClientCertificateResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetClientCertificateResponseBodyResult>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetClientCertificateResponseBody() = default;
};
class GetClientCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClientCertificateResponseBody> body{};

  GetClientCertificateResponse() {}

  explicit GetClientCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClientCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClientCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~GetClientCertificateResponse() = default;
};
class GetClientCertificateHostnamesRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  GetClientCertificateHostnamesRequest() {}

  explicit GetClientCertificateHostnamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetClientCertificateHostnamesRequest() = default;
};
class GetClientCertificateHostnamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostnames{};
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  GetClientCertificateHostnamesResponseBody() {}

  explicit GetClientCertificateHostnamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostnames) {
      res["Hostnames"] = boost::any(*hostnames);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hostnames") != m.end() && !m["Hostnames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Hostnames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hostnames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostnames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~GetClientCertificateHostnamesResponseBody() = default;
};
class GetClientCertificateHostnamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClientCertificateHostnamesResponseBody> body{};

  GetClientCertificateHostnamesResponse() {}

  explicit GetClientCertificateHostnamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClientCertificateHostnamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClientCertificateHostnamesResponseBody>(model1);
      }
    }
  }


  virtual ~GetClientCertificateHostnamesResponse() = default;
};
class GetEdgeContainerAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetEdgeContainerAppRequest() {}

  explicit GetEdgeContainerAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetEdgeContainerAppRequest() = default;
};
class GetEdgeContainerAppResponseBodyAppHealthCheck : public Darabonba::Model {
public:
  shared_ptr<long> failTimes{};
  shared_ptr<string> host{};
  shared_ptr<string> httpCode{};
  shared_ptr<long> interval{};
  shared_ptr<string> method{};
  shared_ptr<long> port{};
  shared_ptr<long> succTimes{};
  shared_ptr<long> timeout{};
  shared_ptr<string> type{};
  shared_ptr<string> uri{};

  GetEdgeContainerAppResponseBodyAppHealthCheck() {}

  explicit GetEdgeContainerAppResponseBodyAppHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failTimes) {
      res["FailTimes"] = boost::any(*failTimes);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (succTimes) {
      res["SuccTimes"] = boost::any(*succTimes);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailTimes") != m.end() && !m["FailTimes"].empty()) {
      failTimes = make_shared<long>(boost::any_cast<long>(m["FailTimes"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SuccTimes") != m.end() && !m["SuccTimes"].empty()) {
      succTimes = make_shared<long>(boost::any_cast<long>(m["SuccTimes"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~GetEdgeContainerAppResponseBodyAppHealthCheck() = default;
};
class GetEdgeContainerAppResponseBodyApp : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<string> gatewayType{};
  shared_ptr<GetEdgeContainerAppResponseBodyAppHealthCheck> healthCheck{};
  shared_ptr<string> name{};
  shared_ptr<string> quicCid{};
  shared_ptr<string> remarks{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> status{};
  shared_ptr<long> targetPort{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> versionCount{};

  GetEdgeContainerAppResponseBodyApp() {}

  explicit GetEdgeContainerAppResponseBodyApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (healthCheck) {
      res["HealthCheck"] = healthCheck ? boost::any(healthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (quicCid) {
      res["QuicCid"] = boost::any(*quicCid);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (versionCount) {
      res["VersionCount"] = boost::any(*versionCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthCheck"].type()) {
        GetEdgeContainerAppResponseBodyAppHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthCheck"]));
        healthCheck = make_shared<GetEdgeContainerAppResponseBodyAppHealthCheck>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("QuicCid") != m.end() && !m["QuicCid"].empty()) {
      quicCid = make_shared<string>(boost::any_cast<string>(m["QuicCid"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VersionCount") != m.end() && !m["VersionCount"].empty()) {
      versionCount = make_shared<long>(boost::any_cast<long>(m["VersionCount"]));
    }
  }


  virtual ~GetEdgeContainerAppResponseBodyApp() = default;
};
class GetEdgeContainerAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEdgeContainerAppResponseBodyApp> app{};
  shared_ptr<string> requestId{};

  GetEdgeContainerAppResponseBody() {}

  explicit GetEdgeContainerAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = app ? boost::any(app->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      if (typeid(map<string, boost::any>) == m["App"].type()) {
        GetEdgeContainerAppResponseBodyApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["App"]));
        app = make_shared<GetEdgeContainerAppResponseBodyApp>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEdgeContainerAppResponseBody() = default;
};
class GetEdgeContainerAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeContainerAppResponseBody> body{};

  GetEdgeContainerAppResponse() {}

  explicit GetEdgeContainerAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeContainerAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeContainerAppResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeContainerAppResponse() = default;
};
class GetEdgeContainerAppStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> publishEnv{};

  GetEdgeContainerAppStatusRequest() {}

  explicit GetEdgeContainerAppStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (publishEnv) {
      res["PublishEnv"] = boost::any(*publishEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PublishEnv") != m.end() && !m["PublishEnv"].empty()) {
      publishEnv = make_shared<string>(boost::any_cast<string>(m["PublishEnv"]));
    }
  }


  virtual ~GetEdgeContainerAppStatusRequest() = default;
};
class GetEdgeContainerAppStatusResponseBodyAppStatusRegions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> region{};

  GetEdgeContainerAppStatusResponseBodyAppStatusRegions() {}

  explicit GetEdgeContainerAppStatusResponseBodyAppStatusRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Region"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      region = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetEdgeContainerAppStatusResponseBodyAppStatusRegions() = default;
};
class GetEdgeContainerAppStatusResponseBodyAppStatus : public Darabonba::Model {
public:
  shared_ptr<string> baseLineVersion{};
  shared_ptr<string> deployStatus{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> deployedVersion{};
  shared_ptr<long> expectPercentage{};
  shared_ptr<bool> fullRelease{};
  shared_ptr<string> publishEnv{};
  shared_ptr<long> publishPercentage{};
  shared_ptr<string> publishStatus{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> publishType{};
  shared_ptr<string> publishingVersion{};
  shared_ptr<GetEdgeContainerAppStatusResponseBodyAppStatusRegions> regions{};
  shared_ptr<string> rollbackTime{};
  shared_ptr<string> unDeployTime{};

  GetEdgeContainerAppStatusResponseBodyAppStatus() {}

  explicit GetEdgeContainerAppStatusResponseBodyAppStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseLineVersion) {
      res["BaseLineVersion"] = boost::any(*baseLineVersion);
    }
    if (deployStatus) {
      res["DeployStatus"] = boost::any(*deployStatus);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (deployedVersion) {
      res["DeployedVersion"] = boost::any(*deployedVersion);
    }
    if (expectPercentage) {
      res["ExpectPercentage"] = boost::any(*expectPercentage);
    }
    if (fullRelease) {
      res["FullRelease"] = boost::any(*fullRelease);
    }
    if (publishEnv) {
      res["PublishEnv"] = boost::any(*publishEnv);
    }
    if (publishPercentage) {
      res["PublishPercentage"] = boost::any(*publishPercentage);
    }
    if (publishStatus) {
      res["PublishStatus"] = boost::any(*publishStatus);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (publishingVersion) {
      res["PublishingVersion"] = boost::any(*publishingVersion);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rollbackTime) {
      res["RollbackTime"] = boost::any(*rollbackTime);
    }
    if (unDeployTime) {
      res["UnDeployTime"] = boost::any(*unDeployTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseLineVersion") != m.end() && !m["BaseLineVersion"].empty()) {
      baseLineVersion = make_shared<string>(boost::any_cast<string>(m["BaseLineVersion"]));
    }
    if (m.find("DeployStatus") != m.end() && !m["DeployStatus"].empty()) {
      deployStatus = make_shared<string>(boost::any_cast<string>(m["DeployStatus"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("DeployedVersion") != m.end() && !m["DeployedVersion"].empty()) {
      deployedVersion = make_shared<string>(boost::any_cast<string>(m["DeployedVersion"]));
    }
    if (m.find("ExpectPercentage") != m.end() && !m["ExpectPercentage"].empty()) {
      expectPercentage = make_shared<long>(boost::any_cast<long>(m["ExpectPercentage"]));
    }
    if (m.find("FullRelease") != m.end() && !m["FullRelease"].empty()) {
      fullRelease = make_shared<bool>(boost::any_cast<bool>(m["FullRelease"]));
    }
    if (m.find("PublishEnv") != m.end() && !m["PublishEnv"].empty()) {
      publishEnv = make_shared<string>(boost::any_cast<string>(m["PublishEnv"]));
    }
    if (m.find("PublishPercentage") != m.end() && !m["PublishPercentage"].empty()) {
      publishPercentage = make_shared<long>(boost::any_cast<long>(m["PublishPercentage"]));
    }
    if (m.find("PublishStatus") != m.end() && !m["PublishStatus"].empty()) {
      publishStatus = make_shared<string>(boost::any_cast<string>(m["PublishStatus"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("PublishingVersion") != m.end() && !m["PublishingVersion"].empty()) {
      publishingVersion = make_shared<string>(boost::any_cast<string>(m["PublishingVersion"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        GetEdgeContainerAppStatusResponseBodyAppStatusRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<GetEdgeContainerAppStatusResponseBodyAppStatusRegions>(model1);
      }
    }
    if (m.find("RollbackTime") != m.end() && !m["RollbackTime"].empty()) {
      rollbackTime = make_shared<string>(boost::any_cast<string>(m["RollbackTime"]));
    }
    if (m.find("UnDeployTime") != m.end() && !m["UnDeployTime"].empty()) {
      unDeployTime = make_shared<string>(boost::any_cast<string>(m["UnDeployTime"]));
    }
  }


  virtual ~GetEdgeContainerAppStatusResponseBodyAppStatus() = default;
};
class GetEdgeContainerAppStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEdgeContainerAppStatusResponseBodyAppStatus> appStatus{};
  shared_ptr<string> requestId{};

  GetEdgeContainerAppStatusResponseBody() {}

  explicit GetEdgeContainerAppStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appStatus) {
      res["AppStatus"] = appStatus ? boost::any(appStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppStatus") != m.end() && !m["AppStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppStatus"].type()) {
        GetEdgeContainerAppStatusResponseBodyAppStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppStatus"]));
        appStatus = make_shared<GetEdgeContainerAppStatusResponseBodyAppStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEdgeContainerAppStatusResponseBody() = default;
};
class GetEdgeContainerAppStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeContainerAppStatusResponseBody> body{};

  GetEdgeContainerAppStatusResponse() {}

  explicit GetEdgeContainerAppStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeContainerAppStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeContainerAppStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeContainerAppStatusResponse() = default;
};
class GetEdgeContainerAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> versionId{};

  GetEdgeContainerAppVersionRequest() {}

  explicit GetEdgeContainerAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~GetEdgeContainerAppVersionRequest() = default;
};
class GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isEnterpriseRegistry{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> tag{};
  shared_ptr<string> tagUrl{};

  GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo() {}

  explicit GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isEnterpriseRegistry) {
      res["IsEnterpriseRegistry"] = boost::any(*isEnterpriseRegistry);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagUrl) {
      res["TagUrl"] = boost::any(*tagUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsEnterpriseRegistry") != m.end() && !m["IsEnterpriseRegistry"].empty()) {
      isEnterpriseRegistry = make_shared<bool>(boost::any_cast<bool>(m["IsEnterpriseRegistry"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagUrl") != m.end() && !m["TagUrl"].empty()) {
      tagUrl = make_shared<string>(boost::any_cast<string>(m["TagUrl"]));
    }
  }


  virtual ~GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo() = default;
};
class GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<long> failureThreshold{};
  shared_ptr<string> host{};
  shared_ptr<string> httpHeaders{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<string> path{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<long> port{};
  shared_ptr<string> scheme{};
  shared_ptr<long> successThreshold{};
  shared_ptr<long> timeoutSeconds{};

  GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent() {}

  explicit GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (failureThreshold) {
      res["FailureThreshold"] = boost::any(*failureThreshold);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (httpHeaders) {
      res["HttpHeaders"] = boost::any(*httpHeaders);
    }
    if (initialDelaySeconds) {
      res["InitialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheme) {
      res["Scheme"] = boost::any(*scheme);
    }
    if (successThreshold) {
      res["SuccessThreshold"] = boost::any(*successThreshold);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("FailureThreshold") != m.end() && !m["FailureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["FailureThreshold"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("HttpHeaders") != m.end() && !m["HttpHeaders"].empty()) {
      httpHeaders = make_shared<string>(boost::any_cast<string>(m["HttpHeaders"]));
    }
    if (m.find("InitialDelaySeconds") != m.end() && !m["InitialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["InitialDelaySeconds"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Scheme") != m.end() && !m["Scheme"].empty()) {
      scheme = make_shared<string>(boost::any_cast<string>(m["Scheme"]));
    }
    if (m.find("SuccessThreshold") != m.end() && !m["SuccessThreshold"].empty()) {
      successThreshold = make_shared<long>(boost::any_cast<long>(m["SuccessThreshold"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent() = default;
};
class GetEdgeContainerAppVersionResponseBodyVersionContainers : public Darabonba::Model {
public:
  shared_ptr<GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo> ACRImageInfo{};
  shared_ptr<string> args{};
  shared_ptr<string> command{};
  shared_ptr<string> envVariables{};
  shared_ptr<string> image{};
  shared_ptr<bool> isACRImage{};
  shared_ptr<string> name{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent> probeContent{};
  shared_ptr<string> probeType{};
  shared_ptr<string> spec{};
  shared_ptr<string> storage{};

  GetEdgeContainerAppVersionResponseBodyVersionContainers() {}

  explicit GetEdgeContainerAppVersionResponseBodyVersionContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ACRImageInfo) {
      res["ACRImageInfo"] = ACRImageInfo ? boost::any(ACRImageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (envVariables) {
      res["EnvVariables"] = boost::any(*envVariables);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (isACRImage) {
      res["IsACRImage"] = boost::any(*isACRImage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (probeContent) {
      res["ProbeContent"] = probeContent ? boost::any(probeContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (probeType) {
      res["ProbeType"] = boost::any(*probeType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ACRImageInfo") != m.end() && !m["ACRImageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ACRImageInfo"].type()) {
        GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ACRImageInfo"]));
        ACRImageInfo = make_shared<GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo>(model1);
      }
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("EnvVariables") != m.end() && !m["EnvVariables"].empty()) {
      envVariables = make_shared<string>(boost::any_cast<string>(m["EnvVariables"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("IsACRImage") != m.end() && !m["IsACRImage"].empty()) {
      isACRImage = make_shared<bool>(boost::any_cast<bool>(m["IsACRImage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProbeContent") != m.end() && !m["ProbeContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProbeContent"].type()) {
        GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProbeContent"]));
        probeContent = make_shared<GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent>(model1);
      }
    }
    if (m.find("ProbeType") != m.end() && !m["ProbeType"].empty()) {
      probeType = make_shared<string>(boost::any_cast<string>(m["ProbeType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<string>(boost::any_cast<string>(m["Storage"]));
    }
  }


  virtual ~GetEdgeContainerAppVersionResponseBodyVersionContainers() = default;
};
class GetEdgeContainerAppVersionResponseBodyVersion : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<vector<GetEdgeContainerAppVersionResponseBodyVersionContainers>> containers{};
  shared_ptr<string> createTime{};
  shared_ptr<string> lastPublishTime{};
  shared_ptr<string> name{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> remarks{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> versionId{};

  GetEdgeContainerAppVersionResponseBodyVersion() {}

  explicit GetEdgeContainerAppVersionResponseBodyVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastPublishTime) {
      res["LastPublishTime"] = boost::any(*lastPublishTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<GetEdgeContainerAppVersionResponseBodyVersionContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEdgeContainerAppVersionResponseBodyVersionContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<GetEdgeContainerAppVersionResponseBodyVersionContainers>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastPublishTime") != m.end() && !m["LastPublishTime"].empty()) {
      lastPublishTime = make_shared<string>(boost::any_cast<string>(m["LastPublishTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~GetEdgeContainerAppVersionResponseBodyVersion() = default;
};
class GetEdgeContainerAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetEdgeContainerAppVersionResponseBodyVersion> version{};

  GetEdgeContainerAppVersionResponseBody() {}

  explicit GetEdgeContainerAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (version) {
      res["Version"] = version ? boost::any(version->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      if (typeid(map<string, boost::any>) == m["Version"].type()) {
        GetEdgeContainerAppVersionResponseBodyVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Version"]));
        version = make_shared<GetEdgeContainerAppVersionResponseBodyVersion>(model1);
      }
    }
  }


  virtual ~GetEdgeContainerAppVersionResponseBody() = default;
};
class GetEdgeContainerAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeContainerAppVersionResponseBody> body{};

  GetEdgeContainerAppVersionResponse() {}

  explicit GetEdgeContainerAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeContainerAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeContainerAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeContainerAppVersionResponse() = default;
};
class GetEdgeContainerDeployRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetEdgeContainerDeployRegionsRequest() {}

  explicit GetEdgeContainerDeployRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetEdgeContainerDeployRegionsRequest() = default;
};
class GetEdgeContainerDeployRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> regions{};
  shared_ptr<string> requestId{};

  GetEdgeContainerDeployRegionsResponseBody() {}

  explicit GetEdgeContainerDeployRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Regions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEdgeContainerDeployRegionsResponseBody() = default;
};
class GetEdgeContainerDeployRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeContainerDeployRegionsResponseBody> body{};

  GetEdgeContainerDeployRegionsResponse() {}

  explicit GetEdgeContainerDeployRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeContainerDeployRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeContainerDeployRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeContainerDeployRegionsResponse() = default;
};
class GetEdgeContainerLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> lines{};

  GetEdgeContainerLogsRequest() {}

  explicit GetEdgeContainerLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<long>(boost::any_cast<long>(m["Lines"]));
    }
  }


  virtual ~GetEdgeContainerLogsRequest() = default;
};
class GetEdgeContainerLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> items{};
  shared_ptr<string> requestId{};

  GetEdgeContainerLogsResponseBody() {}

  explicit GetEdgeContainerLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEdgeContainerLogsResponseBody() = default;
};
class GetEdgeContainerLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeContainerLogsResponseBody> body{};

  GetEdgeContainerLogsResponse() {}

  explicit GetEdgeContainerLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeContainerLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeContainerLogsResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeContainerLogsResponse() = default;
};
class GetEdgeContainerStagingDeployStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetEdgeContainerStagingDeployStatusRequest() {}

  explicit GetEdgeContainerStagingDeployStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetEdgeContainerStagingDeployStatusRequest() = default;
};
class GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState : public Darabonba::Model {
public:
  shared_ptr<string> lastTerminatedReason{};
  shared_ptr<long> restartCount{};

  GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState() {}

  explicit GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastTerminatedReason) {
      res["LastTerminatedReason"] = boost::any(*lastTerminatedReason);
    }
    if (restartCount) {
      res["RestartCount"] = boost::any(*restartCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastTerminatedReason") != m.end() && !m["LastTerminatedReason"].empty()) {
      lastTerminatedReason = make_shared<string>(boost::any_cast<string>(m["LastTerminatedReason"]));
    }
    if (m.find("RestartCount") != m.end() && !m["RestartCount"].empty()) {
      restartCount = make_shared<long>(boost::any_cast<long>(m["RestartCount"]));
    }
  }


  virtual ~GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState() = default;
};
class GetEdgeContainerStagingDeployStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> containersReady{};
  shared_ptr<string> creationTimestamp{};
  shared_ptr<string> initialized{};
  shared_ptr<string> phase{};
  shared_ptr<GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState> podRestartState{};
  shared_ptr<string> ready{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scheduled{};
  shared_ptr<vector<string>> VIPs{};

  GetEdgeContainerStagingDeployStatusResponseBody() {}

  explicit GetEdgeContainerStagingDeployStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containersReady) {
      res["ContainersReady"] = boost::any(*containersReady);
    }
    if (creationTimestamp) {
      res["CreationTimestamp"] = boost::any(*creationTimestamp);
    }
    if (initialized) {
      res["Initialized"] = boost::any(*initialized);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (podRestartState) {
      res["PodRestartState"] = podRestartState ? boost::any(podRestartState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ready) {
      res["Ready"] = boost::any(*ready);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduled) {
      res["Scheduled"] = boost::any(*scheduled);
    }
    if (VIPs) {
      res["VIPs"] = boost::any(*VIPs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainersReady") != m.end() && !m["ContainersReady"].empty()) {
      containersReady = make_shared<string>(boost::any_cast<string>(m["ContainersReady"]));
    }
    if (m.find("CreationTimestamp") != m.end() && !m["CreationTimestamp"].empty()) {
      creationTimestamp = make_shared<string>(boost::any_cast<string>(m["CreationTimestamp"]));
    }
    if (m.find("Initialized") != m.end() && !m["Initialized"].empty()) {
      initialized = make_shared<string>(boost::any_cast<string>(m["Initialized"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("PodRestartState") != m.end() && !m["PodRestartState"].empty()) {
      if (typeid(map<string, boost::any>) == m["PodRestartState"].type()) {
        GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PodRestartState"]));
        podRestartState = make_shared<GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState>(model1);
      }
    }
    if (m.find("Ready") != m.end() && !m["Ready"].empty()) {
      ready = make_shared<string>(boost::any_cast<string>(m["Ready"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scheduled") != m.end() && !m["Scheduled"].empty()) {
      scheduled = make_shared<string>(boost::any_cast<string>(m["Scheduled"]));
    }
    if (m.find("VIPs") != m.end() && !m["VIPs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VIPs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VIPs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      VIPs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetEdgeContainerStagingDeployStatusResponseBody() = default;
};
class GetEdgeContainerStagingDeployStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeContainerStagingDeployStatusResponseBody> body{};

  GetEdgeContainerStagingDeployStatusResponse() {}

  explicit GetEdgeContainerStagingDeployStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeContainerStagingDeployStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeContainerStagingDeployStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeContainerStagingDeployStatusResponse() = default;
};
class GetEdgeContainerTerminalRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetEdgeContainerTerminalRequest() {}

  explicit GetEdgeContainerTerminalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetEdgeContainerTerminalRequest() = default;
};
class GetEdgeContainerTerminalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cluster{};
  shared_ptr<string> container{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> pod{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> token{};

  GetEdgeContainerTerminalResponseBody() {}

  explicit GetEdgeContainerTerminalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      res["Cluster"] = boost::any(*cluster);
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["Cluster"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetEdgeContainerTerminalResponseBody() = default;
};
class GetEdgeContainerTerminalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeContainerTerminalResponseBody> body{};

  GetEdgeContainerTerminalResponse() {}

  explicit GetEdgeContainerTerminalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeContainerTerminalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeContainerTerminalResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeContainerTerminalResponse() = default;
};
class GetErServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  GetErServiceRequest() {}

  explicit GetErServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~GetErServiceRequest() = default;
};
class GetErServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> planName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  GetErServiceResponseBody() {}

  explicit GetErServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (planName) {
      res["PlanName"] = boost::any(*planName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlanName") != m.end() && !m["PlanName"].empty()) {
      planName = make_shared<string>(boost::any_cast<string>(m["PlanName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetErServiceResponseBody() = default;
};
class GetErServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetErServiceResponseBody> body{};

  GetErServiceResponse() {}

  explicit GetErServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetErServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetErServiceResponseBody>(model1);
      }
    }
  }


  virtual ~GetErServiceResponse() = default;
};
class GetKvRequest : public Darabonba::Model {
public:
  shared_ptr<bool> base64{};
  shared_ptr<string> key{};
  shared_ptr<string> namespace_{};

  GetKvRequest() {}

  explicit GetKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (base64) {
      res["Base64"] = boost::any(*base64);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Base64") != m.end() && !m["Base64"].empty()) {
      base64 = make_shared<bool>(boost::any_cast<bool>(m["Base64"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~GetKvRequest() = default;
};
class GetKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> value{};

  GetKvResponseBody() {}

  explicit GetKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetKvResponseBody() = default;
};
class GetKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetKvResponseBody> body{};

  GetKvResponse() {}

  explicit GetKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetKvResponseBody>(model1);
      }
    }
  }


  virtual ~GetKvResponse() = default;
};
class GetKvAccountResponseBodyNamespaceList : public Darabonba::Model {
public:
  shared_ptr<long> capacity{};
  shared_ptr<string> capacityString{};
  shared_ptr<long> capacityUsed{};
  shared_ptr<string> capacityUsedString{};
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> status{};

  GetKvAccountResponseBodyNamespaceList() {}

  explicit GetKvAccountResponseBodyNamespaceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (capacityString) {
      res["CapacityString"] = boost::any(*capacityString);
    }
    if (capacityUsed) {
      res["CapacityUsed"] = boost::any(*capacityUsed);
    }
    if (capacityUsedString) {
      res["CapacityUsedString"] = boost::any(*capacityUsedString);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("CapacityString") != m.end() && !m["CapacityString"].empty()) {
      capacityString = make_shared<string>(boost::any_cast<string>(m["CapacityString"]));
    }
    if (m.find("CapacityUsed") != m.end() && !m["CapacityUsed"].empty()) {
      capacityUsed = make_shared<long>(boost::any_cast<long>(m["CapacityUsed"]));
    }
    if (m.find("CapacityUsedString") != m.end() && !m["CapacityUsedString"].empty()) {
      capacityUsedString = make_shared<string>(boost::any_cast<string>(m["CapacityUsedString"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetKvAccountResponseBodyNamespaceList() = default;
};
class GetKvAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> capacity{};
  shared_ptr<string> capacityString{};
  shared_ptr<long> capacityUsed{};
  shared_ptr<string> capacityUsedString{};
  shared_ptr<vector<GetKvAccountResponseBodyNamespaceList>> namespaceList{};
  shared_ptr<long> namespaceQuota{};
  shared_ptr<long> namespaceUsed{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  GetKvAccountResponseBody() {}

  explicit GetKvAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (capacityString) {
      res["CapacityString"] = boost::any(*capacityString);
    }
    if (capacityUsed) {
      res["CapacityUsed"] = boost::any(*capacityUsed);
    }
    if (capacityUsedString) {
      res["CapacityUsedString"] = boost::any(*capacityUsedString);
    }
    if (namespaceList) {
      vector<boost::any> temp1;
      for(auto item1:*namespaceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NamespaceList"] = boost::any(temp1);
    }
    if (namespaceQuota) {
      res["NamespaceQuota"] = boost::any(*namespaceQuota);
    }
    if (namespaceUsed) {
      res["NamespaceUsed"] = boost::any(*namespaceUsed);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("CapacityString") != m.end() && !m["CapacityString"].empty()) {
      capacityString = make_shared<string>(boost::any_cast<string>(m["CapacityString"]));
    }
    if (m.find("CapacityUsed") != m.end() && !m["CapacityUsed"].empty()) {
      capacityUsed = make_shared<long>(boost::any_cast<long>(m["CapacityUsed"]));
    }
    if (m.find("CapacityUsedString") != m.end() && !m["CapacityUsedString"].empty()) {
      capacityUsedString = make_shared<string>(boost::any_cast<string>(m["CapacityUsedString"]));
    }
    if (m.find("NamespaceList") != m.end() && !m["NamespaceList"].empty()) {
      if (typeid(vector<boost::any>) == m["NamespaceList"].type()) {
        vector<GetKvAccountResponseBodyNamespaceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NamespaceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetKvAccountResponseBodyNamespaceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        namespaceList = make_shared<vector<GetKvAccountResponseBodyNamespaceList>>(expect1);
      }
    }
    if (m.find("NamespaceQuota") != m.end() && !m["NamespaceQuota"].empty()) {
      namespaceQuota = make_shared<long>(boost::any_cast<long>(m["NamespaceQuota"]));
    }
    if (m.find("NamespaceUsed") != m.end() && !m["NamespaceUsed"].empty()) {
      namespaceUsed = make_shared<long>(boost::any_cast<long>(m["NamespaceUsed"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetKvAccountResponseBody() = default;
};
class GetKvAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetKvAccountResponseBody> body{};

  GetKvAccountResponse() {}

  explicit GetKvAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetKvAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetKvAccountResponseBody>(model1);
      }
    }
  }


  virtual ~GetKvAccountResponse() = default;
};
class GetKvNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};

  GetKvNamespaceRequest() {}

  explicit GetKvNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~GetKvNamespaceRequest() = default;
};
class GetKvNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> capacity{};
  shared_ptr<string> capacityString{};
  shared_ptr<long> capacityUsed{};
  shared_ptr<string> capacityUsedString{};
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  GetKvNamespaceResponseBody() {}

  explicit GetKvNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (capacityString) {
      res["CapacityString"] = boost::any(*capacityString);
    }
    if (capacityUsed) {
      res["CapacityUsed"] = boost::any(*capacityUsed);
    }
    if (capacityUsedString) {
      res["CapacityUsedString"] = boost::any(*capacityUsedString);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("CapacityString") != m.end() && !m["CapacityString"].empty()) {
      capacityString = make_shared<string>(boost::any_cast<string>(m["CapacityString"]));
    }
    if (m.find("CapacityUsed") != m.end() && !m["CapacityUsed"].empty()) {
      capacityUsed = make_shared<long>(boost::any_cast<long>(m["CapacityUsed"]));
    }
    if (m.find("CapacityUsedString") != m.end() && !m["CapacityUsedString"].empty()) {
      capacityUsedString = make_shared<string>(boost::any_cast<string>(m["CapacityUsedString"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetKvNamespaceResponseBody() = default;
};
class GetKvNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetKvNamespaceResponseBody> body{};

  GetKvNamespaceResponse() {}

  explicit GetKvNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetKvNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetKvNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetKvNamespaceResponse() = default;
};
class GetListRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetListRequest() {}

  explicit GetListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetListRequest() = default;
};
class GetListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> items{};
  shared_ptr<string> kind{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> updateTime{};

  GetListResponseBody() {}

  explicit GetListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetListResponseBody() = default;
};
class GetListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetListResponseBody> body{};

  GetListResponse() {}

  explicit GetListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetListResponseBody>(model1);
      }
    }
  }


  virtual ~GetListResponse() = default;
};
class GetOriginProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  GetOriginProtectionRequest() {}

  explicit GetOriginProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetOriginProtectionRequest() = default;
};
class GetOriginProtectionResponseBodyCurrentIPWhitelist : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPv4{};
  shared_ptr<vector<string>> IPv6{};

  GetOriginProtectionResponseBodyCurrentIPWhitelist() {}

  explicit GetOriginProtectionResponseBodyCurrentIPWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv4) {
      res["IPv4"] = boost::any(*IPv4);
    }
    if (IPv6) {
      res["IPv6"] = boost::any(*IPv6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv4") != m.end() && !m["IPv4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv4 = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IPv6") != m.end() && !m["IPv6"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv6"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv6"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv6 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetOriginProtectionResponseBodyCurrentIPWhitelist() = default;
};
class GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPv4{};
  shared_ptr<vector<string>> IPv6{};

  GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist() {}

  explicit GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv4) {
      res["IPv4"] = boost::any(*IPv4);
    }
    if (IPv6) {
      res["IPv6"] = boost::any(*IPv6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv4") != m.end() && !m["IPv4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv4 = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IPv6") != m.end() && !m["IPv6"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv6"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv6"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv6 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist() = default;
};
class GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPv4{};
  shared_ptr<vector<string>> IPv6{};

  GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist() {}

  explicit GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv4) {
      res["IPv4"] = boost::any(*IPv4);
    }
    if (IPv6) {
      res["IPv6"] = boost::any(*IPv6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv4") != m.end() && !m["IPv4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv4 = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IPv6") != m.end() && !m["IPv6"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv6"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv6"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv6 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist() = default;
};
class GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPv4{};
  shared_ptr<vector<string>> IPv6{};

  GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist() {}

  explicit GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv4) {
      res["IPv4"] = boost::any(*IPv4);
    }
    if (IPv6) {
      res["IPv6"] = boost::any(*IPv6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv4") != m.end() && !m["IPv4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv4 = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IPv6") != m.end() && !m["IPv6"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv6"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv6"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv6 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist() = default;
};
class GetOriginProtectionResponseBodyDiffIPWhitelist : public Darabonba::Model {
public:
  shared_ptr<GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist> addedIPWhitelist{};
  shared_ptr<GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist> noChangeIpWhitelist{};
  shared_ptr<GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist> removedIPWhitelist{};

  GetOriginProtectionResponseBodyDiffIPWhitelist() {}

  explicit GetOriginProtectionResponseBodyDiffIPWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addedIPWhitelist) {
      res["AddedIPWhitelist"] = addedIPWhitelist ? boost::any(addedIPWhitelist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (noChangeIpWhitelist) {
      res["NoChangeIpWhitelist"] = noChangeIpWhitelist ? boost::any(noChangeIpWhitelist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (removedIPWhitelist) {
      res["RemovedIPWhitelist"] = removedIPWhitelist ? boost::any(removedIPWhitelist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddedIPWhitelist") != m.end() && !m["AddedIPWhitelist"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddedIPWhitelist"].type()) {
        GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddedIPWhitelist"]));
        addedIPWhitelist = make_shared<GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist>(model1);
      }
    }
    if (m.find("NoChangeIpWhitelist") != m.end() && !m["NoChangeIpWhitelist"].empty()) {
      if (typeid(map<string, boost::any>) == m["NoChangeIpWhitelist"].type()) {
        GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NoChangeIpWhitelist"]));
        noChangeIpWhitelist = make_shared<GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist>(model1);
      }
    }
    if (m.find("RemovedIPWhitelist") != m.end() && !m["RemovedIPWhitelist"].empty()) {
      if (typeid(map<string, boost::any>) == m["RemovedIPWhitelist"].type()) {
        GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RemovedIPWhitelist"]));
        removedIPWhitelist = make_shared<GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist>(model1);
      }
    }
  }


  virtual ~GetOriginProtectionResponseBodyDiffIPWhitelist() = default;
};
class GetOriginProtectionResponseBodyLatestIPWhitelist : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPv4{};
  shared_ptr<vector<string>> IPv6{};

  GetOriginProtectionResponseBodyLatestIPWhitelist() {}

  explicit GetOriginProtectionResponseBodyLatestIPWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv4) {
      res["IPv4"] = boost::any(*IPv4);
    }
    if (IPv6) {
      res["IPv6"] = boost::any(*IPv6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv4") != m.end() && !m["IPv4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv4 = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IPv6") != m.end() && !m["IPv6"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv6"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv6"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv6 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetOriginProtectionResponseBodyLatestIPWhitelist() = default;
};
class GetOriginProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetOriginProtectionResponseBodyCurrentIPWhitelist> currentIPWhitelist{};
  shared_ptr<GetOriginProtectionResponseBodyDiffIPWhitelist> diffIPWhitelist{};
  shared_ptr<GetOriginProtectionResponseBodyLatestIPWhitelist> latestIPWhitelist{};
  shared_ptr<bool> needUpdate{};
  shared_ptr<string> originConverge{};
  shared_ptr<string> originProtection{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};

  GetOriginProtectionResponseBody() {}

  explicit GetOriginProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentIPWhitelist) {
      res["CurrentIPWhitelist"] = currentIPWhitelist ? boost::any(currentIPWhitelist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diffIPWhitelist) {
      res["DiffIPWhitelist"] = diffIPWhitelist ? boost::any(diffIPWhitelist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (latestIPWhitelist) {
      res["LatestIPWhitelist"] = latestIPWhitelist ? boost::any(latestIPWhitelist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needUpdate) {
      res["NeedUpdate"] = boost::any(*needUpdate);
    }
    if (originConverge) {
      res["OriginConverge"] = boost::any(*originConverge);
    }
    if (originProtection) {
      res["OriginProtection"] = boost::any(*originProtection);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentIPWhitelist") != m.end() && !m["CurrentIPWhitelist"].empty()) {
      if (typeid(map<string, boost::any>) == m["CurrentIPWhitelist"].type()) {
        GetOriginProtectionResponseBodyCurrentIPWhitelist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CurrentIPWhitelist"]));
        currentIPWhitelist = make_shared<GetOriginProtectionResponseBodyCurrentIPWhitelist>(model1);
      }
    }
    if (m.find("DiffIPWhitelist") != m.end() && !m["DiffIPWhitelist"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiffIPWhitelist"].type()) {
        GetOriginProtectionResponseBodyDiffIPWhitelist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiffIPWhitelist"]));
        diffIPWhitelist = make_shared<GetOriginProtectionResponseBodyDiffIPWhitelist>(model1);
      }
    }
    if (m.find("LatestIPWhitelist") != m.end() && !m["LatestIPWhitelist"].empty()) {
      if (typeid(map<string, boost::any>) == m["LatestIPWhitelist"].type()) {
        GetOriginProtectionResponseBodyLatestIPWhitelist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LatestIPWhitelist"]));
        latestIPWhitelist = make_shared<GetOriginProtectionResponseBodyLatestIPWhitelist>(model1);
      }
    }
    if (m.find("NeedUpdate") != m.end() && !m["NeedUpdate"].empty()) {
      needUpdate = make_shared<bool>(boost::any_cast<bool>(m["NeedUpdate"]));
    }
    if (m.find("OriginConverge") != m.end() && !m["OriginConverge"].empty()) {
      originConverge = make_shared<string>(boost::any_cast<string>(m["OriginConverge"]));
    }
    if (m.find("OriginProtection") != m.end() && !m["OriginProtection"].empty()) {
      originProtection = make_shared<string>(boost::any_cast<string>(m["OriginProtection"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetOriginProtectionResponseBody() = default;
};
class GetOriginProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOriginProtectionResponseBody> body{};

  GetOriginProtectionResponse() {}

  explicit GetOriginProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOriginProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOriginProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~GetOriginProtectionResponse() = default;
};
class GetPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetPageRequest() {}

  explicit GetPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetPageRequest() = default;
};
class GetPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> kind{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> updateTime{};

  GetPageResponseBody() {}

  explicit GetPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetPageResponseBody() = default;
};
class GetPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPageResponseBody> body{};

  GetPageResponse() {}

  explicit GetPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetPageResponse() = default;
};
class GetPurgeQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};

  GetPurgeQuotaRequest() {}

  explicit GetPurgeQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPurgeQuotaRequest() = default;
};
class GetPurgeQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> quota{};
  shared_ptr<string> requestId{};
  shared_ptr<string> usage{};

  GetPurgeQuotaResponseBody() {}

  explicit GetPurgeQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<string>(boost::any_cast<string>(m["Quota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~GetPurgeQuotaResponseBody() = default;
};
class GetPurgeQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPurgeQuotaResponseBody> body{};

  GetPurgeQuotaResponse() {}

  explicit GetPurgeQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPurgeQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPurgeQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~GetPurgeQuotaResponse() = default;
};
class GetRealtimeDeliveryFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};

  GetRealtimeDeliveryFieldRequest() {}

  explicit GetRealtimeDeliveryFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
  }


  virtual ~GetRealtimeDeliveryFieldRequest() = default;
};
class GetRealtimeDeliveryFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, FieldContentValue>> fieldContent{};
  shared_ptr<string> requestId{};

  GetRealtimeDeliveryFieldResponseBody() {}

  explicit GetRealtimeDeliveryFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldContent) {
      map<string, boost::any> temp1;
      for(auto item1:*fieldContent){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["FieldContent"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldContent") != m.end() && !m["FieldContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["FieldContent"].type()) {
        map<string, FieldContentValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["FieldContent"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            FieldContentValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        fieldContent = make_shared<map<string, FieldContentValue>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRealtimeDeliveryFieldResponseBody() = default;
};
class GetRealtimeDeliveryFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRealtimeDeliveryFieldResponseBody> body{};

  GetRealtimeDeliveryFieldResponse() {}

  explicit GetRealtimeDeliveryFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRealtimeDeliveryFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRealtimeDeliveryFieldResponseBody>(model1);
      }
    }
  }


  virtual ~GetRealtimeDeliveryFieldResponse() = default;
};
class GetRecordRequest : public Darabonba::Model {
public:
  shared_ptr<long> recordId{};

  GetRecordRequest() {}

  explicit GetRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
  }


  virtual ~GetRecordRequest() = default;
};
class GetRecordResponseBodyRecordModelAuthConf : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> authType{};
  shared_ptr<string> region{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> version{};

  GetRecordResponseBodyRecordModelAuthConf() {}

  explicit GetRecordResponseBodyRecordModelAuthConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetRecordResponseBodyRecordModelAuthConf() = default;
};
class GetRecordResponseBodyRecordModelData : public Darabonba::Model {
public:
  shared_ptr<long> algorithm{};
  shared_ptr<string> certificate{};
  shared_ptr<string> fingerprint{};
  shared_ptr<long> flag{};
  shared_ptr<long> keyTag{};
  shared_ptr<long> matchingType{};
  shared_ptr<long> port{};
  shared_ptr<long> priority{};
  shared_ptr<long> selector{};
  shared_ptr<string> tag{};
  shared_ptr<long> type{};
  shared_ptr<long> usage{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  GetRecordResponseBodyRecordModelData() {}

  explicit GetRecordResponseBodyRecordModelData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (keyTag) {
      res["KeyTag"] = boost::any(*keyTag);
    }
    if (matchingType) {
      res["MatchingType"] = boost::any(*matchingType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<long>(boost::any_cast<long>(m["Algorithm"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("KeyTag") != m.end() && !m["KeyTag"].empty()) {
      keyTag = make_shared<long>(boost::any_cast<long>(m["KeyTag"]));
    }
    if (m.find("MatchingType") != m.end() && !m["MatchingType"].empty()) {
      matchingType = make_shared<long>(boost::any_cast<long>(m["MatchingType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<long>(boost::any_cast<long>(m["Selector"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~GetRecordResponseBodyRecordModelData() = default;
};
class GetRecordResponseBodyRecordModel : public Darabonba::Model {
public:
  shared_ptr<GetRecordResponseBodyRecordModelAuthConf> authConf{};
  shared_ptr<string> bizName{};
  shared_ptr<string> comment{};
  shared_ptr<string> createTime{};
  shared_ptr<GetRecordResponseBodyRecordModelData> data{};
  shared_ptr<string> hostPolicy{};
  shared_ptr<bool> proxied{};
  shared_ptr<string> recordCname{};
  shared_ptr<long> recordId{};
  shared_ptr<string> recordName{};
  shared_ptr<string> recordSourceType{};
  shared_ptr<string> recordType{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<long> ttl{};
  shared_ptr<string> updateTime{};

  GetRecordResponseBodyRecordModel() {}

  explicit GetRecordResponseBodyRecordModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConf) {
      res["AuthConf"] = authConf ? boost::any(authConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostPolicy) {
      res["HostPolicy"] = boost::any(*hostPolicy);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordCname) {
      res["RecordCname"] = boost::any(*recordCname);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (recordSourceType) {
      res["RecordSourceType"] = boost::any(*recordSourceType);
    }
    if (recordType) {
      res["RecordType"] = boost::any(*recordType);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthConf") != m.end() && !m["AuthConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthConf"].type()) {
        GetRecordResponseBodyRecordModelAuthConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthConf"]));
        authConf = make_shared<GetRecordResponseBodyRecordModelAuthConf>(model1);
      }
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRecordResponseBodyRecordModelData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRecordResponseBodyRecordModelData>(model1);
      }
    }
    if (m.find("HostPolicy") != m.end() && !m["HostPolicy"].empty()) {
      hostPolicy = make_shared<string>(boost::any_cast<string>(m["HostPolicy"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordCname") != m.end() && !m["RecordCname"].empty()) {
      recordCname = make_shared<string>(boost::any_cast<string>(m["RecordCname"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("RecordSourceType") != m.end() && !m["RecordSourceType"].empty()) {
      recordSourceType = make_shared<string>(boost::any_cast<string>(m["RecordSourceType"]));
    }
    if (m.find("RecordType") != m.end() && !m["RecordType"].empty()) {
      recordType = make_shared<string>(boost::any_cast<string>(m["RecordType"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetRecordResponseBodyRecordModel() = default;
};
class GetRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetRecordResponseBodyRecordModel> recordModel{};
  shared_ptr<string> requestId{};

  GetRecordResponseBody() {}

  explicit GetRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordModel) {
      res["RecordModel"] = recordModel ? boost::any(recordModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordModel") != m.end() && !m["RecordModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordModel"].type()) {
        GetRecordResponseBodyRecordModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordModel"]));
        recordModel = make_shared<GetRecordResponseBodyRecordModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRecordResponseBody() = default;
};
class GetRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRecordResponseBody> body{};

  GetRecordResponse() {}

  explicit GetRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRecordResponseBody>(model1);
      }
    }
  }


  virtual ~GetRecordResponse() = default;
};
class GetRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetRoutineRequest() {}

  explicit GetRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetRoutineRequest() = default;
};
class GetRoutineResponseBodyCodeVersions : public Darabonba::Model {
public:
  shared_ptr<string> codeDescription{};
  shared_ptr<string> codeVersion{};
  shared_ptr<string> createTime{};

  GetRoutineResponseBodyCodeVersions() {}

  explicit GetRoutineResponseBodyCodeVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~GetRoutineResponseBodyCodeVersions() = default;
};
class GetRoutineResponseBodyEnvs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> canaryAreaList{};
  shared_ptr<string> canaryCodeVersion{};
  shared_ptr<string> codeVersion{};
  shared_ptr<string> env{};
  shared_ptr<string> specName{};

  GetRoutineResponseBodyEnvs() {}

  explicit GetRoutineResponseBodyEnvs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canaryAreaList) {
      res["CanaryAreaList"] = boost::any(*canaryAreaList);
    }
    if (canaryCodeVersion) {
      res["CanaryCodeVersion"] = boost::any(*canaryCodeVersion);
    }
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanaryAreaList") != m.end() && !m["CanaryAreaList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CanaryAreaList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CanaryAreaList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      canaryAreaList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CanaryCodeVersion") != m.end() && !m["CanaryCodeVersion"].empty()) {
      canaryCodeVersion = make_shared<string>(boost::any_cast<string>(m["CanaryCodeVersion"]));
    }
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
  }


  virtual ~GetRoutineResponseBodyEnvs() = default;
};
class GetRoutineResponseBodyRelatedRecords : public Darabonba::Model {
public:
  shared_ptr<long> recordId{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  GetRoutineResponseBodyRelatedRecords() {}

  explicit GetRoutineResponseBodyRelatedRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~GetRoutineResponseBodyRelatedRecords() = default;
};
class GetRoutineResponseBodyRelatedRoutes : public Darabonba::Model {
public:
  shared_ptr<string> route{};
  shared_ptr<string> routeId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  GetRoutineResponseBodyRelatedRoutes() {}

  explicit GetRoutineResponseBodyRelatedRoutes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (route) {
      res["Route"] = boost::any(*route);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      route = make_shared<string>(boost::any_cast<string>(m["Route"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~GetRoutineResponseBodyRelatedRoutes() = default;
};
class GetRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetRoutineResponseBodyCodeVersions>> codeVersions{};
  shared_ptr<string> createTime{};
  shared_ptr<string> defaultRelatedRecord{};
  shared_ptr<string> description{};
  shared_ptr<vector<GetRoutineResponseBodyEnvs>> envs{};
  shared_ptr<vector<GetRoutineResponseBodyRelatedRecords>> relatedRecords{};
  shared_ptr<vector<GetRoutineResponseBodyRelatedRoutes>> relatedRoutes{};
  shared_ptr<string> requestId{};

  GetRoutineResponseBody() {}

  explicit GetRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeVersions) {
      vector<boost::any> temp1;
      for(auto item1:*codeVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CodeVersions"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (defaultRelatedRecord) {
      res["DefaultRelatedRecord"] = boost::any(*defaultRelatedRecord);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envs) {
      vector<boost::any> temp1;
      for(auto item1:*envs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Envs"] = boost::any(temp1);
    }
    if (relatedRecords) {
      vector<boost::any> temp1;
      for(auto item1:*relatedRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedRecords"] = boost::any(temp1);
    }
    if (relatedRoutes) {
      vector<boost::any> temp1;
      for(auto item1:*relatedRoutes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedRoutes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeVersions") != m.end() && !m["CodeVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["CodeVersions"].type()) {
        vector<GetRoutineResponseBodyCodeVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CodeVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRoutineResponseBodyCodeVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        codeVersions = make_shared<vector<GetRoutineResponseBodyCodeVersions>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DefaultRelatedRecord") != m.end() && !m["DefaultRelatedRecord"].empty()) {
      defaultRelatedRecord = make_shared<string>(boost::any_cast<string>(m["DefaultRelatedRecord"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      if (typeid(vector<boost::any>) == m["Envs"].type()) {
        vector<GetRoutineResponseBodyEnvs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Envs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRoutineResponseBodyEnvs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        envs = make_shared<vector<GetRoutineResponseBodyEnvs>>(expect1);
      }
    }
    if (m.find("RelatedRecords") != m.end() && !m["RelatedRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedRecords"].type()) {
        vector<GetRoutineResponseBodyRelatedRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRoutineResponseBodyRelatedRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedRecords = make_shared<vector<GetRoutineResponseBodyRelatedRecords>>(expect1);
      }
    }
    if (m.find("RelatedRoutes") != m.end() && !m["RelatedRoutes"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedRoutes"].type()) {
        vector<GetRoutineResponseBodyRelatedRoutes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedRoutes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRoutineResponseBodyRelatedRoutes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedRoutes = make_shared<vector<GetRoutineResponseBodyRelatedRoutes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRoutineResponseBody() = default;
};
class GetRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRoutineResponseBody> body{};

  GetRoutineResponse() {}

  explicit GetRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~GetRoutineResponse() = default;
};
class GetRoutineStagingCodeUploadInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> codeDescription{};
  shared_ptr<string> name{};

  GetRoutineStagingCodeUploadInfoRequest() {}

  explicit GetRoutineStagingCodeUploadInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetRoutineStagingCodeUploadInfoRequest() = default;
};
class GetRoutineStagingCodeUploadInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> codeVersion{};
  shared_ptr<map<string, boost::any>> ossPostConfig{};
  shared_ptr<string> requestId{};

  GetRoutineStagingCodeUploadInfoResponseBody() {}

  explicit GetRoutineStagingCodeUploadInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (ossPostConfig) {
      res["OssPostConfig"] = boost::any(*ossPostConfig);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("OssPostConfig") != m.end() && !m["OssPostConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["OssPostConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      ossPostConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRoutineStagingCodeUploadInfoResponseBody() = default;
};
class GetRoutineStagingCodeUploadInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRoutineStagingCodeUploadInfoResponseBody> body{};

  GetRoutineStagingCodeUploadInfoResponse() {}

  explicit GetRoutineStagingCodeUploadInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRoutineStagingCodeUploadInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRoutineStagingCodeUploadInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetRoutineStagingCodeUploadInfoResponse() = default;
};
class GetRoutineStagingEnvIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPV4{};
  shared_ptr<string> requestId{};

  GetRoutineStagingEnvIpResponseBody() {}

  explicit GetRoutineStagingEnvIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPV4) {
      res["IPV4"] = boost::any(*IPV4);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPV4") != m.end() && !m["IPV4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPV4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPV4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPV4 = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRoutineStagingEnvIpResponseBody() = default;
};
class GetRoutineStagingEnvIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRoutineStagingEnvIpResponseBody> body{};

  GetRoutineStagingEnvIpResponse() {}

  explicit GetRoutineStagingEnvIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRoutineStagingEnvIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRoutineStagingEnvIpResponseBody>(model1);
      }
    }
  }


  virtual ~GetRoutineStagingEnvIpResponse() = default;
};
class GetRoutineUserInfoResponseBodyRoutines : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> routineName{};

  GetRoutineUserInfoResponseBodyRoutines() {}

  explicit GetRoutineUserInfoResponseBodyRoutines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (routineName) {
      res["RoutineName"] = boost::any(*routineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RoutineName") != m.end() && !m["RoutineName"].empty()) {
      routineName = make_shared<string>(boost::any_cast<string>(m["RoutineName"]));
    }
  }


  virtual ~GetRoutineUserInfoResponseBodyRoutines() = default;
};
class GetRoutineUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetRoutineUserInfoResponseBodyRoutines>> routines{};
  shared_ptr<vector<string>> subdomains{};

  GetRoutineUserInfoResponseBody() {}

  explicit GetRoutineUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routines) {
      vector<boost::any> temp1;
      for(auto item1:*routines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Routines"] = boost::any(temp1);
    }
    if (subdomains) {
      res["Subdomains"] = boost::any(*subdomains);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Routines") != m.end() && !m["Routines"].empty()) {
      if (typeid(vector<boost::any>) == m["Routines"].type()) {
        vector<GetRoutineUserInfoResponseBodyRoutines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Routines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRoutineUserInfoResponseBodyRoutines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routines = make_shared<vector<GetRoutineUserInfoResponseBodyRoutines>>(expect1);
      }
    }
    if (m.find("Subdomains") != m.end() && !m["Subdomains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Subdomains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Subdomains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subdomains = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRoutineUserInfoResponseBody() = default;
};
class GetRoutineUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRoutineUserInfoResponseBody> body{};

  GetRoutineUserInfoResponse() {}

  explicit GetRoutineUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRoutineUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRoutineUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetRoutineUserInfoResponse() = default;
};
class GetScheduledPreloadJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetScheduledPreloadJobRequest() {}

  explicit GetScheduledPreloadJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetScheduledPreloadJobRequest() = default;
};
class GetScheduledPreloadJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> domains{};
  shared_ptr<string> errorInfo{};
  shared_ptr<string> failedFileOss{};
  shared_ptr<string> fileId{};
  shared_ptr<string> id{};
  shared_ptr<string> insertWay{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<long> taskSubmitted{};
  shared_ptr<string> taskType{};
  shared_ptr<long> urlCount{};
  shared_ptr<long> urlSubmitted{};

  GetScheduledPreloadJobResponseBody() {}

  explicit GetScheduledPreloadJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (createdAt) {
      res["CreatedAt"] = boost::any(*createdAt);
    }
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (failedFileOss) {
      res["FailedFileOss"] = boost::any(*failedFileOss);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (insertWay) {
      res["InsertWay"] = boost::any(*insertWay);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskSubmitted) {
      res["TaskSubmitted"] = boost::any(*taskSubmitted);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (urlCount) {
      res["UrlCount"] = boost::any(*urlCount);
    }
    if (urlSubmitted) {
      res["UrlSubmitted"] = boost::any(*urlSubmitted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("CreatedAt") != m.end() && !m["CreatedAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["CreatedAt"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      domains = make_shared<string>(boost::any_cast<string>(m["Domains"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("FailedFileOss") != m.end() && !m["FailedFileOss"].empty()) {
      failedFileOss = make_shared<string>(boost::any_cast<string>(m["FailedFileOss"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InsertWay") != m.end() && !m["InsertWay"].empty()) {
      insertWay = make_shared<string>(boost::any_cast<string>(m["InsertWay"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TaskSubmitted") != m.end() && !m["TaskSubmitted"].empty()) {
      taskSubmitted = make_shared<long>(boost::any_cast<long>(m["TaskSubmitted"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UrlCount") != m.end() && !m["UrlCount"].empty()) {
      urlCount = make_shared<long>(boost::any_cast<long>(m["UrlCount"]));
    }
    if (m.find("UrlSubmitted") != m.end() && !m["UrlSubmitted"].empty()) {
      urlSubmitted = make_shared<long>(boost::any_cast<long>(m["UrlSubmitted"]));
    }
  }


  virtual ~GetScheduledPreloadJobResponseBody() = default;
};
class GetScheduledPreloadJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetScheduledPreloadJobResponseBody> body{};

  GetScheduledPreloadJobResponse() {}

  explicit GetScheduledPreloadJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetScheduledPreloadJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetScheduledPreloadJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetScheduledPreloadJobResponse() = default;
};
class GetSiteRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  GetSiteRequest() {}

  explicit GetSiteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetSiteRequest() = default;
};
class GetSiteResponseBodySiteModel : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> cnameZone{};
  shared_ptr<string> coverage{};
  shared_ptr<string> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nameServerList{};
  shared_ptr<string> planName{};
  shared_ptr<string> planSpecName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> updateTime{};
  shared_ptr<map<string, string>> vanityNSList{};
  shared_ptr<string> verifyCode{};
  shared_ptr<bool> versionManagement{};

  GetSiteResponseBodySiteModel() {}

  explicit GetSiteResponseBodySiteModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (cnameZone) {
      res["CnameZone"] = boost::any(*cnameZone);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nameServerList) {
      res["NameServerList"] = boost::any(*nameServerList);
    }
    if (planName) {
      res["PlanName"] = boost::any(*planName);
    }
    if (planSpecName) {
      res["PlanSpecName"] = boost::any(*planSpecName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vanityNSList) {
      res["VanityNSList"] = boost::any(*vanityNSList);
    }
    if (verifyCode) {
      res["VerifyCode"] = boost::any(*verifyCode);
    }
    if (versionManagement) {
      res["VersionManagement"] = boost::any(*versionManagement);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("CnameZone") != m.end() && !m["CnameZone"].empty()) {
      cnameZone = make_shared<string>(boost::any_cast<string>(m["CnameZone"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NameServerList") != m.end() && !m["NameServerList"].empty()) {
      nameServerList = make_shared<string>(boost::any_cast<string>(m["NameServerList"]));
    }
    if (m.find("PlanName") != m.end() && !m["PlanName"].empty()) {
      planName = make_shared<string>(boost::any_cast<string>(m["PlanName"]));
    }
    if (m.find("PlanSpecName") != m.end() && !m["PlanSpecName"].empty()) {
      planSpecName = make_shared<string>(boost::any_cast<string>(m["PlanSpecName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VanityNSList") != m.end() && !m["VanityNSList"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["VanityNSList"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      vanityNSList = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("VerifyCode") != m.end() && !m["VerifyCode"].empty()) {
      verifyCode = make_shared<string>(boost::any_cast<string>(m["VerifyCode"]));
    }
    if (m.find("VersionManagement") != m.end() && !m["VersionManagement"].empty()) {
      versionManagement = make_shared<bool>(boost::any_cast<bool>(m["VersionManagement"]));
    }
  }


  virtual ~GetSiteResponseBodySiteModel() = default;
};
class GetSiteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSiteResponseBodySiteModel> siteModel{};

  GetSiteResponseBody() {}

  explicit GetSiteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteModel) {
      res["SiteModel"] = siteModel ? boost::any(siteModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteModel") != m.end() && !m["SiteModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["SiteModel"].type()) {
        GetSiteResponseBodySiteModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SiteModel"]));
        siteModel = make_shared<GetSiteResponseBodySiteModel>(model1);
      }
    }
  }


  virtual ~GetSiteResponseBody() = default;
};
class GetSiteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSiteResponseBody> body{};

  GetSiteResponse() {}

  explicit GetSiteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSiteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSiteResponseBody>(model1);
      }
    }
  }


  virtual ~GetSiteResponse() = default;
};
class GetSiteCurrentNSRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  GetSiteCurrentNSRequest() {}

  explicit GetSiteCurrentNSRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetSiteCurrentNSRequest() = default;
};
class GetSiteCurrentNSResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> NSList{};
  shared_ptr<string> requestId{};

  GetSiteCurrentNSResponseBody() {}

  explicit GetSiteCurrentNSResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (NSList) {
      res["NSList"] = boost::any(*NSList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NSList") != m.end() && !m["NSList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NSList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NSList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      NSList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSiteCurrentNSResponseBody() = default;
};
class GetSiteCurrentNSResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSiteCurrentNSResponseBody> body{};

  GetSiteCurrentNSResponse() {}

  explicit GetSiteCurrentNSResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSiteCurrentNSResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSiteCurrentNSResponseBody>(model1);
      }
    }
  }


  virtual ~GetSiteCurrentNSResponse() = default;
};
class GetSiteCustomLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  GetSiteCustomLogRequest() {}

  explicit GetSiteCustomLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetSiteCustomLogRequest() = default;
};
class GetSiteCustomLogResponseBodyLogCustomField : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cookies{};
  shared_ptr<vector<string>> requestHeaders{};
  shared_ptr<vector<string>> responseHeaders{};

  GetSiteCustomLogResponseBodyLogCustomField() {}

  explicit GetSiteCustomLogResponseBodyLogCustomField(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookies) {
      res["Cookies"] = boost::any(*cookies);
    }
    if (requestHeaders) {
      res["RequestHeaders"] = boost::any(*requestHeaders);
    }
    if (responseHeaders) {
      res["ResponseHeaders"] = boost::any(*responseHeaders);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookies") != m.end() && !m["Cookies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Cookies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Cookies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cookies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResponseHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResponseHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      responseHeaders = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSiteCustomLogResponseBodyLogCustomField() = default;
};
class GetSiteCustomLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<bool> isExist{};
  shared_ptr<GetSiteCustomLogResponseBodyLogCustomField> logCustomField{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};

  GetSiteCustomLogResponseBody() {}

  explicit GetSiteCustomLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (isExist) {
      res["IsExist"] = boost::any(*isExist);
    }
    if (logCustomField) {
      res["LogCustomField"] = logCustomField ? boost::any(logCustomField->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("IsExist") != m.end() && !m["IsExist"].empty()) {
      isExist = make_shared<bool>(boost::any_cast<bool>(m["IsExist"]));
    }
    if (m.find("LogCustomField") != m.end() && !m["LogCustomField"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogCustomField"].type()) {
        GetSiteCustomLogResponseBodyLogCustomField model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogCustomField"]));
        logCustomField = make_shared<GetSiteCustomLogResponseBodyLogCustomField>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetSiteCustomLogResponseBody() = default;
};
class GetSiteCustomLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSiteCustomLogResponseBody> body{};

  GetSiteCustomLogResponse() {}

  explicit GetSiteCustomLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSiteCustomLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSiteCustomLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetSiteCustomLogResponse() = default;
};
class GetSiteDeliveryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> taskName{};

  GetSiteDeliveryTaskRequest() {}

  explicit GetSiteDeliveryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~GetSiteDeliveryTaskRequest() = default;
};
class GetSiteDeliveryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deliveryType{};
  shared_ptr<double> discardRate{};
  shared_ptr<string> fieldList{};
  shared_ptr<string> filterRules{};
  shared_ptr<string> requestId{};
  shared_ptr<boost::any> sinkConfig{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  GetSiteDeliveryTaskResponseBody() {}

  explicit GetSiteDeliveryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (discardRate) {
      res["DiscardRate"] = boost::any(*discardRate);
    }
    if (fieldList) {
      res["FieldList"] = boost::any(*fieldList);
    }
    if (filterRules) {
      res["FilterRules"] = boost::any(*filterRules);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sinkConfig) {
      res["SinkConfig"] = boost::any(*sinkConfig);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<string>(boost::any_cast<string>(m["DeliveryType"]));
    }
    if (m.find("DiscardRate") != m.end() && !m["DiscardRate"].empty()) {
      discardRate = make_shared<double>(boost::any_cast<double>(m["DiscardRate"]));
    }
    if (m.find("FieldList") != m.end() && !m["FieldList"].empty()) {
      fieldList = make_shared<string>(boost::any_cast<string>(m["FieldList"]));
    }
    if (m.find("FilterRules") != m.end() && !m["FilterRules"].empty()) {
      filterRules = make_shared<string>(boost::any_cast<string>(m["FilterRules"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SinkConfig") != m.end() && !m["SinkConfig"].empty()) {
      sinkConfig = make_shared<boost::any>(boost::any_cast<boost::any>(m["SinkConfig"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~GetSiteDeliveryTaskResponseBody() = default;
};
class GetSiteDeliveryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSiteDeliveryTaskResponseBody> body{};

  GetSiteDeliveryTaskResponse() {}

  explicit GetSiteDeliveryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSiteDeliveryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSiteDeliveryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetSiteDeliveryTaskResponse() = default;
};
class GetSiteLogDeliveryQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<long> siteId{};

  GetSiteLogDeliveryQuotaRequest() {}

  explicit GetSiteLogDeliveryQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetSiteLogDeliveryQuotaRequest() = default;
};
class GetSiteLogDeliveryQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<long> freeQuota{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};

  GetSiteLogDeliveryQuotaResponseBody() {}

  explicit GetSiteLogDeliveryQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (freeQuota) {
      res["FreeQuota"] = boost::any(*freeQuota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("FreeQuota") != m.end() && !m["FreeQuota"].empty()) {
      freeQuota = make_shared<long>(boost::any_cast<long>(m["FreeQuota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetSiteLogDeliveryQuotaResponseBody() = default;
};
class GetSiteLogDeliveryQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSiteLogDeliveryQuotaResponseBody> body{};

  GetSiteLogDeliveryQuotaResponse() {}

  explicit GetSiteLogDeliveryQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSiteLogDeliveryQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSiteLogDeliveryQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~GetSiteLogDeliveryQuotaResponse() = default;
};
class GetSiteWafSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  GetSiteWafSettingsRequest() {}

  explicit GetSiteWafSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~GetSiteWafSettingsRequest() = default;
};
class GetSiteWafSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<WafSiteSettings> settings{};

  GetSiteWafSettingsResponseBody() {}

  explicit GetSiteWafSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (settings) {
      res["Settings"] = settings ? boost::any(settings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Settings") != m.end() && !m["Settings"].empty()) {
      if (typeid(map<string, boost::any>) == m["Settings"].type()) {
        WafSiteSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Settings"]));
        settings = make_shared<WafSiteSettings>(model1);
      }
    }
  }


  virtual ~GetSiteWafSettingsResponseBody() = default;
};
class GetSiteWafSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSiteWafSettingsResponseBody> body{};

  GetSiteWafSettingsResponse() {}

  explicit GetSiteWafSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSiteWafSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSiteWafSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSiteWafSettingsResponse() = default;
};
class GetUploadTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<long> uploadId{};

  GetUploadTaskRequest() {}

  explicit GetUploadTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (uploadId) {
      res["UploadId"] = boost::any(*uploadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("UploadId") != m.end() && !m["UploadId"].empty()) {
      uploadId = make_shared<long>(boost::any_cast<long>(m["UploadId"]));
    }
  }


  virtual ~GetUploadTaskRequest() = default;
};
class GetUploadTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  GetUploadTaskResponseBody() {}

  explicit GetUploadTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetUploadTaskResponseBody() = default;
};
class GetUploadTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUploadTaskResponseBody> body{};

  GetUploadTaskResponse() {}

  explicit GetUploadTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUploadTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUploadTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetUploadTaskResponse() = default;
};
class GetUserDeliveryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskName{};

  GetUserDeliveryTaskRequest() {}

  explicit GetUserDeliveryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~GetUserDeliveryTaskRequest() = default;
};
class GetUserDeliveryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deliveryType{};
  shared_ptr<double> discardRate{};
  shared_ptr<string> fieldList{};
  shared_ptr<string> filterRules{};
  shared_ptr<string> requestId{};
  shared_ptr<boost::any> sinkConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  GetUserDeliveryTaskResponseBody() {}

  explicit GetUserDeliveryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (discardRate) {
      res["DiscardRate"] = boost::any(*discardRate);
    }
    if (fieldList) {
      res["FieldList"] = boost::any(*fieldList);
    }
    if (filterRules) {
      res["FilterRules"] = boost::any(*filterRules);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sinkConfig) {
      res["SinkConfig"] = boost::any(*sinkConfig);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<string>(boost::any_cast<string>(m["DeliveryType"]));
    }
    if (m.find("DiscardRate") != m.end() && !m["DiscardRate"].empty()) {
      discardRate = make_shared<double>(boost::any_cast<double>(m["DiscardRate"]));
    }
    if (m.find("FieldList") != m.end() && !m["FieldList"].empty()) {
      fieldList = make_shared<string>(boost::any_cast<string>(m["FieldList"]));
    }
    if (m.find("FilterRules") != m.end() && !m["FilterRules"].empty()) {
      filterRules = make_shared<string>(boost::any_cast<string>(m["FilterRules"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SinkConfig") != m.end() && !m["SinkConfig"].empty()) {
      sinkConfig = make_shared<boost::any>(boost::any_cast<boost::any>(m["SinkConfig"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~GetUserDeliveryTaskResponseBody() = default;
};
class GetUserDeliveryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserDeliveryTaskResponseBody> body{};

  GetUserDeliveryTaskResponse() {}

  explicit GetUserDeliveryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserDeliveryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserDeliveryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserDeliveryTaskResponse() = default;
};
class GetUserLogDeliveryQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};

  GetUserLogDeliveryQuotaRequest() {}

  explicit GetUserLogDeliveryQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
  }


  virtual ~GetUserLogDeliveryQuotaRequest() = default;
};
class GetUserLogDeliveryQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<long> freeQuota{};
  shared_ptr<string> requestId{};

  GetUserLogDeliveryQuotaResponseBody() {}

  explicit GetUserLogDeliveryQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (freeQuota) {
      res["FreeQuota"] = boost::any(*freeQuota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("FreeQuota") != m.end() && !m["FreeQuota"].empty()) {
      freeQuota = make_shared<long>(boost::any_cast<long>(m["FreeQuota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetUserLogDeliveryQuotaResponseBody() = default;
};
class GetUserLogDeliveryQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserLogDeliveryQuotaResponseBody> body{};

  GetUserLogDeliveryQuotaResponse() {}

  explicit GetUserLogDeliveryQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserLogDeliveryQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserLogDeliveryQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserLogDeliveryQuotaResponse() = default;
};
class GetWafBotAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> requestId{};

  GetWafBotAppKeyResponseBody() {}

  explicit GetWafBotAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetWafBotAppKeyResponseBody() = default;
};
class GetWafBotAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWafBotAppKeyResponseBody> body{};

  GetWafBotAppKeyResponse() {}

  explicit GetWafBotAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWafBotAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWafBotAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~GetWafBotAppKeyResponse() = default;
};
class GetWafFilterRequest : public Darabonba::Model {
public:
  shared_ptr<string> phase{};
  shared_ptr<long> siteId{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  GetWafFilterRequest() {}

  explicit GetWafFilterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetWafFilterRequest() = default;
};
class GetWafFilterResponseBodyFilterFieldsLogicsValidator : public Darabonba::Model {
public:
  shared_ptr<string> errMsg{};
  shared_ptr<WafQuotaInteger> length{};
  shared_ptr<string> pattern{};
  shared_ptr<WafQuotaInteger> range{};

  GetWafFilterResponseBodyFilterFieldsLogicsValidator() {}

  explicit GetWafFilterResponseBodyFilterFieldsLogicsValidator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (length) {
      res["Length"] = length ? boost::any(length->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      if (typeid(map<string, boost::any>) == m["Length"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Length"]));
        length = make_shared<WafQuotaInteger>(model1);
      }
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<WafQuotaInteger>(model1);
      }
    }
  }


  virtual ~GetWafFilterResponseBodyFilterFieldsLogicsValidator() = default;
};
class GetWafFilterResponseBodyFilterFieldsLogics : public Darabonba::Model {
public:
  shared_ptr<long> attributes{};
  shared_ptr<string> kind{};
  shared_ptr<bool> negative{};
  shared_ptr<string> operator_{};
  shared_ptr<string> symbol{};
  shared_ptr<string> tip{};
  shared_ptr<string> type{};
  shared_ptr<GetWafFilterResponseBodyFilterFieldsLogicsValidator> validator{};

  GetWafFilterResponseBodyFilterFieldsLogics() {}

  explicit GetWafFilterResponseBodyFilterFieldsLogics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (negative) {
      res["Negative"] = boost::any(*negative);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (symbol) {
      res["Symbol"] = boost::any(*symbol);
    }
    if (tip) {
      res["Tip"] = boost::any(*tip);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (validator) {
      res["Validator"] = validator ? boost::any(validator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<long>(boost::any_cast<long>(m["Attributes"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Negative") != m.end() && !m["Negative"].empty()) {
      negative = make_shared<bool>(boost::any_cast<bool>(m["Negative"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Symbol") != m.end() && !m["Symbol"].empty()) {
      symbol = make_shared<string>(boost::any_cast<string>(m["Symbol"]));
    }
    if (m.find("Tip") != m.end() && !m["Tip"].empty()) {
      tip = make_shared<string>(boost::any_cast<string>(m["Tip"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Validator") != m.end() && !m["Validator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Validator"].type()) {
        GetWafFilterResponseBodyFilterFieldsLogicsValidator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Validator"]));
        validator = make_shared<GetWafFilterResponseBodyFilterFieldsLogicsValidator>(model1);
      }
    }
  }


  virtual ~GetWafFilterResponseBodyFilterFieldsLogics() = default;
};
class GetWafFilterResponseBodyFilterFieldsSelectorData : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> value{};

  GetWafFilterResponseBodyFilterFieldsSelectorData() {}

  explicit GetWafFilterResponseBodyFilterFieldsSelectorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetWafFilterResponseBodyFilterFieldsSelectorData() = default;
};
class GetWafFilterResponseBodyFilterFieldsSelector : public Darabonba::Model {
public:
  shared_ptr<vector<GetWafFilterResponseBodyFilterFieldsSelectorData>> data{};
  shared_ptr<string> kind{};

  GetWafFilterResponseBodyFilterFieldsSelector() {}

  explicit GetWafFilterResponseBodyFilterFieldsSelector(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetWafFilterResponseBodyFilterFieldsSelectorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWafFilterResponseBodyFilterFieldsSelectorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetWafFilterResponseBodyFilterFieldsSelectorData>>(expect1);
      }
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
  }


  virtual ~GetWafFilterResponseBodyFilterFieldsSelector() = default;
};
class GetWafFilterResponseBodyFilterFields : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> label{};
  shared_ptr<vector<GetWafFilterResponseBodyFilterFieldsLogics>> logics{};
  shared_ptr<GetWafFilterResponseBodyFilterFieldsSelector> selector{};
  shared_ptr<bool> sub{};
  shared_ptr<string> subTip{};

  GetWafFilterResponseBodyFilterFields() {}

  explicit GetWafFilterResponseBodyFilterFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (logics) {
      vector<boost::any> temp1;
      for(auto item1:*logics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logics"] = boost::any(temp1);
    }
    if (selector) {
      res["Selector"] = selector ? boost::any(selector->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sub) {
      res["Sub"] = boost::any(*sub);
    }
    if (subTip) {
      res["SubTip"] = boost::any(*subTip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Logics") != m.end() && !m["Logics"].empty()) {
      if (typeid(vector<boost::any>) == m["Logics"].type()) {
        vector<GetWafFilterResponseBodyFilterFieldsLogics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWafFilterResponseBodyFilterFieldsLogics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logics = make_shared<vector<GetWafFilterResponseBodyFilterFieldsLogics>>(expect1);
      }
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      if (typeid(map<string, boost::any>) == m["Selector"].type()) {
        GetWafFilterResponseBodyFilterFieldsSelector model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Selector"]));
        selector = make_shared<GetWafFilterResponseBodyFilterFieldsSelector>(model1);
      }
    }
    if (m.find("Sub") != m.end() && !m["Sub"].empty()) {
      sub = make_shared<bool>(boost::any_cast<bool>(m["Sub"]));
    }
    if (m.find("SubTip") != m.end() && !m["SubTip"].empty()) {
      subTip = make_shared<string>(boost::any_cast<string>(m["SubTip"]));
    }
  }


  virtual ~GetWafFilterResponseBodyFilterFields() = default;
};
class GetWafFilterResponseBodyFilter : public Darabonba::Model {
public:
  shared_ptr<vector<GetWafFilterResponseBodyFilterFields>> fields{};
  shared_ptr<string> phase{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  GetWafFilterResponseBodyFilter() {}

  explicit GetWafFilterResponseBodyFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fields"] = boost::any(temp1);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<GetWafFilterResponseBodyFilterFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWafFilterResponseBodyFilterFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<GetWafFilterResponseBodyFilterFields>>(expect1);
      }
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetWafFilterResponseBodyFilter() = default;
};
class GetWafFilterResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetWafFilterResponseBodyFilter> filter{};
  shared_ptr<string> requestId{};

  GetWafFilterResponseBody() {}

  explicit GetWafFilterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        GetWafFilterResponseBodyFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<GetWafFilterResponseBodyFilter>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetWafFilterResponseBody() = default;
};
class GetWafFilterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWafFilterResponseBody> body{};

  GetWafFilterResponse() {}

  explicit GetWafFilterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWafFilterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWafFilterResponseBody>(model1);
      }
    }
  }


  virtual ~GetWafFilterResponse() = default;
};
class GetWafQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> paths{};

  GetWafQuotaRequest() {}

  explicit GetWafQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      paths = make_shared<string>(boost::any_cast<string>(m["Paths"]));
    }
  }


  virtual ~GetWafQuotaRequest() = default;
};
class GetWafQuotaResponseBodyQuotaList : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<map<string, QuotaListItemsValue>> items{};
  shared_ptr<WafQuotaInteger> numberItemsPerList{};
  shared_ptr<WafQuotaInteger> numberItemsTotal{};
  shared_ptr<WafQuotaInteger> numberTotal{};

  GetWafQuotaResponseBodyQuotaList() {}

  explicit GetWafQuotaResponseBodyQuotaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (items) {
      map<string, boost::any> temp1;
      for(auto item1:*items){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["Items"] = boost::any(temp1);
    }
    if (numberItemsPerList) {
      res["NumberItemsPerList"] = numberItemsPerList ? boost::any(numberItemsPerList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numberItemsTotal) {
      res["NumberItemsTotal"] = numberItemsTotal ? boost::any(numberItemsTotal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numberTotal) {
      res["NumberTotal"] = numberTotal ? boost::any(numberTotal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        map<string, QuotaListItemsValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            QuotaListItemsValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        items = make_shared<map<string, QuotaListItemsValue>>(expect1);
      }
    }
    if (m.find("NumberItemsPerList") != m.end() && !m["NumberItemsPerList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NumberItemsPerList"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NumberItemsPerList"]));
        numberItemsPerList = make_shared<WafQuotaInteger>(model1);
      }
    }
    if (m.find("NumberItemsTotal") != m.end() && !m["NumberItemsTotal"].empty()) {
      if (typeid(map<string, boost::any>) == m["NumberItemsTotal"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NumberItemsTotal"]));
        numberItemsTotal = make_shared<WafQuotaInteger>(model1);
      }
    }
    if (m.find("NumberTotal") != m.end() && !m["NumberTotal"].empty()) {
      if (typeid(map<string, boost::any>) == m["NumberTotal"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NumberTotal"]));
        numberTotal = make_shared<WafQuotaInteger>(model1);
      }
    }
  }


  virtual ~GetWafQuotaResponseBodyQuotaList() = default;
};
class GetWafQuotaResponseBodyQuotaManagedRulesGroup : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<WafQuotaInteger> numberTotal{};

  GetWafQuotaResponseBodyQuotaManagedRulesGroup() {}

  explicit GetWafQuotaResponseBodyQuotaManagedRulesGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (numberTotal) {
      res["NumberTotal"] = numberTotal ? boost::any(numberTotal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("NumberTotal") != m.end() && !m["NumberTotal"].empty()) {
      if (typeid(map<string, boost::any>) == m["NumberTotal"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NumberTotal"]));
        numberTotal = make_shared<WafQuotaInteger>(model1);
      }
    }
  }


  virtual ~GetWafQuotaResponseBodyQuotaManagedRulesGroup() = default;
};
class GetWafQuotaResponseBodyQuotaPage : public Darabonba::Model {
public:
  shared_ptr<map<string, QuotaPageContentTypesValue>> contentTypes{};
  shared_ptr<bool> enable{};
  shared_ptr<WafQuotaInteger> numberTotal{};

  GetWafQuotaResponseBodyQuotaPage() {}

  explicit GetWafQuotaResponseBodyQuotaPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypes) {
      map<string, boost::any> temp1;
      for(auto item1:*contentTypes){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["ContentTypes"] = boost::any(temp1);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (numberTotal) {
      res["NumberTotal"] = numberTotal ? boost::any(numberTotal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypes") != m.end() && !m["ContentTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContentTypes"].type()) {
        map<string, QuotaPageContentTypesValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["ContentTypes"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            QuotaPageContentTypesValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        contentTypes = make_shared<map<string, QuotaPageContentTypesValue>>(expect1);
      }
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("NumberTotal") != m.end() && !m["NumberTotal"].empty()) {
      if (typeid(map<string, boost::any>) == m["NumberTotal"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NumberTotal"]));
        numberTotal = make_shared<WafQuotaInteger>(model1);
      }
    }
  }


  virtual ~GetWafQuotaResponseBodyQuotaPage() = default;
};
class GetWafQuotaResponseBodyQuotaScenePolicy : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<WafQuotaInteger> numberTotal{};

  GetWafQuotaResponseBodyQuotaScenePolicy() {}

  explicit GetWafQuotaResponseBodyQuotaScenePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (numberTotal) {
      res["NumberTotal"] = numberTotal ? boost::any(numberTotal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("NumberTotal") != m.end() && !m["NumberTotal"].empty()) {
      if (typeid(map<string, boost::any>) == m["NumberTotal"].type()) {
        WafQuotaInteger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NumberTotal"]));
        numberTotal = make_shared<WafQuotaInteger>(model1);
      }
    }
  }


  virtual ~GetWafQuotaResponseBodyQuotaScenePolicy() = default;
};
class GetWafQuotaResponseBodyQuota : public Darabonba::Model {
public:
  shared_ptr<GetWafQuotaResponseBodyQuotaList> list{};
  shared_ptr<GetWafQuotaResponseBodyQuotaManagedRulesGroup> managedRulesGroup{};
  shared_ptr<GetWafQuotaResponseBodyQuotaPage> page{};
  shared_ptr<GetWafQuotaResponseBodyQuotaScenePolicy> scenePolicy{};

  GetWafQuotaResponseBodyQuota() {}

  explicit GetWafQuotaResponseBodyQuota(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (managedRulesGroup) {
      res["ManagedRulesGroup"] = managedRulesGroup ? boost::any(managedRulesGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (page) {
      res["Page"] = page ? boost::any(page->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scenePolicy) {
      res["ScenePolicy"] = scenePolicy ? boost::any(scenePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetWafQuotaResponseBodyQuotaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetWafQuotaResponseBodyQuotaList>(model1);
      }
    }
    if (m.find("ManagedRulesGroup") != m.end() && !m["ManagedRulesGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManagedRulesGroup"].type()) {
        GetWafQuotaResponseBodyQuotaManagedRulesGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManagedRulesGroup"]));
        managedRulesGroup = make_shared<GetWafQuotaResponseBodyQuotaManagedRulesGroup>(model1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      if (typeid(map<string, boost::any>) == m["Page"].type()) {
        GetWafQuotaResponseBodyQuotaPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Page"]));
        page = make_shared<GetWafQuotaResponseBodyQuotaPage>(model1);
      }
    }
    if (m.find("ScenePolicy") != m.end() && !m["ScenePolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScenePolicy"].type()) {
        GetWafQuotaResponseBodyQuotaScenePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScenePolicy"]));
        scenePolicy = make_shared<GetWafQuotaResponseBodyQuotaScenePolicy>(model1);
      }
    }
  }


  virtual ~GetWafQuotaResponseBodyQuota() = default;
};
class GetWafQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetWafQuotaResponseBodyQuota> quota{};
  shared_ptr<string> requestId{};

  GetWafQuotaResponseBody() {}

  explicit GetWafQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quota) {
      res["Quota"] = quota ? boost::any(quota->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      if (typeid(map<string, boost::any>) == m["Quota"].type()) {
        GetWafQuotaResponseBodyQuota model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Quota"]));
        quota = make_shared<GetWafQuotaResponseBodyQuota>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetWafQuotaResponseBody() = default;
};
class GetWafQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWafQuotaResponseBody> body{};

  GetWafQuotaResponse() {}

  explicit GetWafQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWafQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWafQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~GetWafQuotaResponse() = default;
};
class GetWafRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> siteId{};

  GetWafRuleRequest() {}

  explicit GetWafRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetWafRuleRequest() = default;
};
class GetWafRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<WafRuleConfig> config{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> phase{};
  shared_ptr<long> position{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  GetWafRuleResponseBody() {}

  explicit GetWafRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        WafRuleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<WafRuleConfig>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetWafRuleResponseBody() = default;
};
class GetWafRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWafRuleResponseBody> body{};

  GetWafRuleResponse() {}

  explicit GetWafRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWafRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWafRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetWafRuleResponse() = default;
};
class GetWafRulesetRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> phase{};
  shared_ptr<long> siteId{};

  GetWafRulesetRequest() {}

  explicit GetWafRulesetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~GetWafRulesetRequest() = default;
};
class GetWafRulesetResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> phase{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<WafRuleConfig>> rules{};
  shared_ptr<WafBatchRuleShared> shared{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  GetWafRulesetResponseBody() {}

  explicit GetWafRulesetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (shared) {
      res["Shared"] = shared ? boost::any(shared->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<WafRuleConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<WafRuleConfig>>(expect1);
      }
    }
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      if (typeid(map<string, boost::any>) == m["Shared"].type()) {
        WafBatchRuleShared model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Shared"]));
        shared = make_shared<WafBatchRuleShared>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetWafRulesetResponseBody() = default;
};
class GetWafRulesetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWafRulesetResponseBody> body{};

  GetWafRulesetResponse() {}

  explicit GetWafRulesetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWafRulesetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWafRulesetResponseBody>(model1);
      }
    }
  }


  virtual ~GetWafRulesetResponse() = default;
};
class ListCacheReserveInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> status{};

  ListCacheReserveInstancesRequest() {}

  explicit ListCacheReserveInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListCacheReserveInstancesRequest() = default;
};
class ListCacheReserveInstancesResponseBodyInstanceInfo : public Darabonba::Model {
public:
  shared_ptr<string> cacheReserveCapacity{};
  shared_ptr<string> cacheReserveRegion{};
  shared_ptr<string> createTime{};
  shared_ptr<long> duration{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};

  ListCacheReserveInstancesResponseBodyInstanceInfo() {}

  explicit ListCacheReserveInstancesResponseBodyInstanceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheReserveCapacity) {
      res["CacheReserveCapacity"] = boost::any(*cacheReserveCapacity);
    }
    if (cacheReserveRegion) {
      res["CacheReserveRegion"] = boost::any(*cacheReserveRegion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheReserveCapacity") != m.end() && !m["CacheReserveCapacity"].empty()) {
      cacheReserveCapacity = make_shared<string>(boost::any_cast<string>(m["CacheReserveCapacity"]));
    }
    if (m.find("CacheReserveRegion") != m.end() && !m["CacheReserveRegion"].empty()) {
      cacheReserveRegion = make_shared<string>(boost::any_cast<string>(m["CacheReserveRegion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListCacheReserveInstancesResponseBodyInstanceInfo() = default;
};
class ListCacheReserveInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCacheReserveInstancesResponseBodyInstanceInfo>> instanceInfo{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPage{};

  ListCacheReserveInstancesResponseBody() {}

  explicit ListCacheReserveInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*instanceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceInfo"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceInfo") != m.end() && !m["InstanceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceInfo"].type()) {
        vector<ListCacheReserveInstancesResponseBodyInstanceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCacheReserveInstancesResponseBodyInstanceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceInfo = make_shared<vector<ListCacheReserveInstancesResponseBodyInstanceInfo>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~ListCacheReserveInstancesResponseBody() = default;
};
class ListCacheReserveInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCacheReserveInstancesResponseBody> body{};

  ListCacheReserveInstancesResponse() {}

  explicit ListCacheReserveInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCacheReserveInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCacheReserveInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCacheReserveInstancesResponse() = default;
};
class ListCiphersRequest : public Darabonba::Model {
public:
  shared_ptr<string> ciphersGroup{};

  ListCiphersRequest() {}

  explicit ListCiphersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphersGroup) {
      res["CiphersGroup"] = boost::any(*ciphersGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CiphersGroup") != m.end() && !m["CiphersGroup"].empty()) {
      ciphersGroup = make_shared<string>(boost::any_cast<string>(m["CiphersGroup"]));
    }
  }


  virtual ~ListCiphersRequest() = default;
};
class ListCiphersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ciphersGroup{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<long> totalCount{};

  ListCiphersResponseBody() {}

  explicit ListCiphersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphersGroup) {
      res["CiphersGroup"] = boost::any(*ciphersGroup);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CiphersGroup") != m.end() && !m["CiphersGroup"].empty()) {
      ciphersGroup = make_shared<string>(boost::any_cast<string>(m["CiphersGroup"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCiphersResponseBody() = default;
};
class ListCiphersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCiphersResponseBody> body{};

  ListCiphersResponse() {}

  explicit ListCiphersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCiphersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCiphersResponseBody>(model1);
      }
    }
  }


  virtual ~ListCiphersResponse() = default;
};
class ListClientCaCertificatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> siteId{};

  ListClientCaCertificatesRequest() {}

  explicit ListClientCaCertificatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListClientCaCertificatesRequest() = default;
};
class ListClientCaCertificatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> commonName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> issuer{};
  shared_ptr<string> name{};
  shared_ptr<string> notAfter{};
  shared_ptr<string> notBefore{};
  shared_ptr<string> pubkeyAlgorithm{};
  shared_ptr<string> SAN{};
  shared_ptr<string> signatureAlgorithm{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};

  ListClientCaCertificatesResponseBodyResult() {}

  explicit ListClientCaCertificatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notAfter) {
      res["NotAfter"] = boost::any(*notAfter);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    if (pubkeyAlgorithm) {
      res["PubkeyAlgorithm"] = boost::any(*pubkeyAlgorithm);
    }
    if (SAN) {
      res["SAN"] = boost::any(*SAN);
    }
    if (signatureAlgorithm) {
      res["SignatureAlgorithm"] = boost::any(*signatureAlgorithm);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotAfter") != m.end() && !m["NotAfter"].empty()) {
      notAfter = make_shared<string>(boost::any_cast<string>(m["NotAfter"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
    if (m.find("PubkeyAlgorithm") != m.end() && !m["PubkeyAlgorithm"].empty()) {
      pubkeyAlgorithm = make_shared<string>(boost::any_cast<string>(m["PubkeyAlgorithm"]));
    }
    if (m.find("SAN") != m.end() && !m["SAN"].empty()) {
      SAN = make_shared<string>(boost::any_cast<string>(m["SAN"]));
    }
    if (m.find("SignatureAlgorithm") != m.end() && !m["SignatureAlgorithm"].empty()) {
      signatureAlgorithm = make_shared<string>(boost::any_cast<string>(m["SignatureAlgorithm"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListClientCaCertificatesResponseBodyResult() = default;
};
class ListClientCaCertificatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListClientCaCertificatesResponseBodyResult>> result{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<long> totalCount{};

  ListClientCaCertificatesResponseBody() {}

  explicit ListClientCaCertificatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListClientCaCertificatesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClientCaCertificatesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListClientCaCertificatesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClientCaCertificatesResponseBody() = default;
};
class ListClientCaCertificatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClientCaCertificatesResponseBody> body{};

  ListClientCaCertificatesResponse() {}

  explicit ListClientCaCertificatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClientCaCertificatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClientCaCertificatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClientCaCertificatesResponse() = default;
};
class ListClientCertificatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> siteId{};

  ListClientCertificatesRequest() {}

  explicit ListClientCertificatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListClientCertificatesRequest() = default;
};
class ListClientCertificatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> CACertificateId{};
  shared_ptr<string> commonName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> issuer{};
  shared_ptr<string> name{};
  shared_ptr<string> notAfter{};
  shared_ptr<string> notBefore{};
  shared_ptr<string> pubkeyAlgorithm{};
  shared_ptr<string> SAN{};
  shared_ptr<string> signatureAlgorithm{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};

  ListClientCertificatesResponseBodyResult() {}

  explicit ListClientCertificatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CACertificateId) {
      res["CACertificateId"] = boost::any(*CACertificateId);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notAfter) {
      res["NotAfter"] = boost::any(*notAfter);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    if (pubkeyAlgorithm) {
      res["PubkeyAlgorithm"] = boost::any(*pubkeyAlgorithm);
    }
    if (SAN) {
      res["SAN"] = boost::any(*SAN);
    }
    if (signatureAlgorithm) {
      res["SignatureAlgorithm"] = boost::any(*signatureAlgorithm);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CACertificateId") != m.end() && !m["CACertificateId"].empty()) {
      CACertificateId = make_shared<string>(boost::any_cast<string>(m["CACertificateId"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotAfter") != m.end() && !m["NotAfter"].empty()) {
      notAfter = make_shared<string>(boost::any_cast<string>(m["NotAfter"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
    if (m.find("PubkeyAlgorithm") != m.end() && !m["PubkeyAlgorithm"].empty()) {
      pubkeyAlgorithm = make_shared<string>(boost::any_cast<string>(m["PubkeyAlgorithm"]));
    }
    if (m.find("SAN") != m.end() && !m["SAN"].empty()) {
      SAN = make_shared<string>(boost::any_cast<string>(m["SAN"]));
    }
    if (m.find("SignatureAlgorithm") != m.end() && !m["SignatureAlgorithm"].empty()) {
      signatureAlgorithm = make_shared<string>(boost::any_cast<string>(m["SignatureAlgorithm"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListClientCertificatesResponseBodyResult() = default;
};
class ListClientCertificatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListClientCertificatesResponseBodyResult>> result{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<long> totalCount{};

  ListClientCertificatesResponseBody() {}

  explicit ListClientCertificatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListClientCertificatesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClientCertificatesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListClientCertificatesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClientCertificatesResponseBody() = default;
};
class ListClientCertificatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClientCertificatesResponseBody> body{};

  ListClientCertificatesResponse() {}

  explicit ListClientCertificatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClientCertificatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClientCertificatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClientCertificatesResponse() = default;
};
class ListEdgeContainerAppRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> orderKey{};
  shared_ptr<string> orderType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};

  ListEdgeContainerAppRecordsRequest() {}

  explicit ListEdgeContainerAppRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (orderKey) {
      res["OrderKey"] = boost::any(*orderKey);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OrderKey") != m.end() && !m["OrderKey"].empty()) {
      orderKey = make_shared<string>(boost::any_cast<string>(m["OrderKey"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
  }


  virtual ~ListEdgeContainerAppRecordsRequest() = default;
};
class ListEdgeContainerAppRecordsResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cname{};
  shared_ptr<long> configId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> recordId{};
  shared_ptr<string> recordName{};
  shared_ptr<long> schemdId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> updateTime{};

  ListEdgeContainerAppRecordsResponseBodyRecords() {}

  explicit ListEdgeContainerAppRecordsResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (schemdId) {
      res["SchemdId"] = boost::any(*schemdId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SchemdId") != m.end() && !m["SchemdId"].empty()) {
      schemdId = make_shared<long>(boost::any_cast<long>(m["SchemdId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListEdgeContainerAppRecordsResponseBodyRecords() = default;
};
class ListEdgeContainerAppRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListEdgeContainerAppRecordsResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEdgeContainerAppRecordsResponseBody() {}

  explicit ListEdgeContainerAppRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<ListEdgeContainerAppRecordsResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeContainerAppRecordsResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ListEdgeContainerAppRecordsResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEdgeContainerAppRecordsResponseBody() = default;
};
class ListEdgeContainerAppRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEdgeContainerAppRecordsResponseBody> body{};

  ListEdgeContainerAppRecordsResponse() {}

  explicit ListEdgeContainerAppRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeContainerAppRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeContainerAppRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeContainerAppRecordsResponse() = default;
};
class ListEdgeContainerAppVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> orderKey{};
  shared_ptr<string> orderType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> searchType{};

  ListEdgeContainerAppVersionsRequest() {}

  explicit ListEdgeContainerAppVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (orderKey) {
      res["OrderKey"] = boost::any(*orderKey);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (searchType) {
      res["SearchType"] = boost::any(*searchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OrderKey") != m.end() && !m["OrderKey"].empty()) {
      orderKey = make_shared<string>(boost::any_cast<string>(m["OrderKey"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SearchType") != m.end() && !m["SearchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["SearchType"]));
    }
  }


  virtual ~ListEdgeContainerAppVersionsRequest() = default;
};
class ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<long> failureThreshold{};
  shared_ptr<string> host{};
  shared_ptr<string> httpHeaders{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<string> path{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<long> port{};
  shared_ptr<string> scheme{};
  shared_ptr<long> successThreshold{};
  shared_ptr<long> timeoutSeconds{};

  ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent() {}

  explicit ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (failureThreshold) {
      res["FailureThreshold"] = boost::any(*failureThreshold);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (httpHeaders) {
      res["HttpHeaders"] = boost::any(*httpHeaders);
    }
    if (initialDelaySeconds) {
      res["InitialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheme) {
      res["Scheme"] = boost::any(*scheme);
    }
    if (successThreshold) {
      res["SuccessThreshold"] = boost::any(*successThreshold);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("FailureThreshold") != m.end() && !m["FailureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["FailureThreshold"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("HttpHeaders") != m.end() && !m["HttpHeaders"].empty()) {
      httpHeaders = make_shared<string>(boost::any_cast<string>(m["HttpHeaders"]));
    }
    if (m.find("InitialDelaySeconds") != m.end() && !m["InitialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["InitialDelaySeconds"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Scheme") != m.end() && !m["Scheme"].empty()) {
      scheme = make_shared<string>(boost::any_cast<string>(m["Scheme"]));
    }
    if (m.find("SuccessThreshold") != m.end() && !m["SuccessThreshold"].empty()) {
      successThreshold = make_shared<long>(boost::any_cast<long>(m["SuccessThreshold"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent() = default;
};
class ListEdgeContainerAppVersionsResponseBodyVersionsContainers : public Darabonba::Model {
public:
  shared_ptr<string> args{};
  shared_ptr<string> command{};
  shared_ptr<string> envVariables{};
  shared_ptr<string> image{};
  shared_ptr<string> name{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent> probeContent{};
  shared_ptr<string> probeType{};
  shared_ptr<string> spec{};

  ListEdgeContainerAppVersionsResponseBodyVersionsContainers() {}

  explicit ListEdgeContainerAppVersionsResponseBodyVersionsContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (envVariables) {
      res["EnvVariables"] = boost::any(*envVariables);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (probeContent) {
      res["ProbeContent"] = probeContent ? boost::any(probeContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (probeType) {
      res["ProbeType"] = boost::any(*probeType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("EnvVariables") != m.end() && !m["EnvVariables"].empty()) {
      envVariables = make_shared<string>(boost::any_cast<string>(m["EnvVariables"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProbeContent") != m.end() && !m["ProbeContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProbeContent"].type()) {
        ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProbeContent"]));
        probeContent = make_shared<ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent>(model1);
      }
    }
    if (m.find("ProbeType") != m.end() && !m["ProbeType"].empty()) {
      probeType = make_shared<string>(boost::any_cast<string>(m["ProbeType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~ListEdgeContainerAppVersionsResponseBodyVersionsContainers() = default;
};
class ListEdgeContainerAppVersionsResponseBodyVersions : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<vector<ListEdgeContainerAppVersionsResponseBodyVersionsContainers>> containers{};
  shared_ptr<string> createTime{};
  shared_ptr<string> lastPublishTime{};
  shared_ptr<string> name{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> remarks{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> versionId{};

  ListEdgeContainerAppVersionsResponseBodyVersions() {}

  explicit ListEdgeContainerAppVersionsResponseBodyVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastPublishTime) {
      res["LastPublishTime"] = boost::any(*lastPublishTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<ListEdgeContainerAppVersionsResponseBodyVersionsContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeContainerAppVersionsResponseBodyVersionsContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<ListEdgeContainerAppVersionsResponseBodyVersionsContainers>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastPublishTime") != m.end() && !m["LastPublishTime"].empty()) {
      lastPublishTime = make_shared<string>(boost::any_cast<string>(m["LastPublishTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~ListEdgeContainerAppVersionsResponseBodyVersions() = default;
};
class ListEdgeContainerAppVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListEdgeContainerAppVersionsResponseBodyVersions>> versions{};

  ListEdgeContainerAppVersionsResponseBody() {}

  explicit ListEdgeContainerAppVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (versions) {
      vector<boost::any> temp1;
      for(auto item1:*versions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Versions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      if (typeid(vector<boost::any>) == m["Versions"].type()) {
        vector<ListEdgeContainerAppVersionsResponseBodyVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Versions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeContainerAppVersionsResponseBodyVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        versions = make_shared<vector<ListEdgeContainerAppVersionsResponseBodyVersions>>(expect1);
      }
    }
  }


  virtual ~ListEdgeContainerAppVersionsResponseBody() = default;
};
class ListEdgeContainerAppVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEdgeContainerAppVersionsResponseBody> body{};

  ListEdgeContainerAppVersionsResponse() {}

  explicit ListEdgeContainerAppVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeContainerAppVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeContainerAppVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeContainerAppVersionsResponse() = default;
};
class ListEdgeContainerAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderKey{};
  shared_ptr<string> orderType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> searchType{};

  ListEdgeContainerAppsRequest() {}

  explicit ListEdgeContainerAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderKey) {
      res["OrderKey"] = boost::any(*orderKey);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (searchType) {
      res["SearchType"] = boost::any(*searchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderKey") != m.end() && !m["OrderKey"].empty()) {
      orderKey = make_shared<string>(boost::any_cast<string>(m["OrderKey"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SearchType") != m.end() && !m["SearchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["SearchType"]));
    }
  }


  virtual ~ListEdgeContainerAppsRequest() = default;
};
class ListEdgeContainerAppsResponseBodyAppsHealthCheck : public Darabonba::Model {
public:
  shared_ptr<long> failTimes{};
  shared_ptr<string> host{};
  shared_ptr<string> httpCode{};
  shared_ptr<long> interval{};
  shared_ptr<string> method{};
  shared_ptr<long> port{};
  shared_ptr<long> succTimes{};
  shared_ptr<long> timeout{};
  shared_ptr<string> type{};
  shared_ptr<string> uri{};

  ListEdgeContainerAppsResponseBodyAppsHealthCheck() {}

  explicit ListEdgeContainerAppsResponseBodyAppsHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failTimes) {
      res["FailTimes"] = boost::any(*failTimes);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (succTimes) {
      res["SuccTimes"] = boost::any(*succTimes);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailTimes") != m.end() && !m["FailTimes"].empty()) {
      failTimes = make_shared<long>(boost::any_cast<long>(m["FailTimes"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SuccTimes") != m.end() && !m["SuccTimes"].empty()) {
      succTimes = make_shared<long>(boost::any_cast<long>(m["SuccTimes"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~ListEdgeContainerAppsResponseBodyAppsHealthCheck() = default;
};
class ListEdgeContainerAppsResponseBodyApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<string> gatewayType{};
  shared_ptr<ListEdgeContainerAppsResponseBodyAppsHealthCheck> healthCheck{};
  shared_ptr<string> name{};
  shared_ptr<long> percentage{};
  shared_ptr<string> quicCid{};
  shared_ptr<string> remarks{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> status{};
  shared_ptr<long> targetPort{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> versionCount{};

  ListEdgeContainerAppsResponseBodyApps() {}

  explicit ListEdgeContainerAppsResponseBodyApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (healthCheck) {
      res["HealthCheck"] = healthCheck ? boost::any(healthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (quicCid) {
      res["QuicCid"] = boost::any(*quicCid);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (versionCount) {
      res["VersionCount"] = boost::any(*versionCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthCheck"].type()) {
        ListEdgeContainerAppsResponseBodyAppsHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthCheck"]));
        healthCheck = make_shared<ListEdgeContainerAppsResponseBodyAppsHealthCheck>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("QuicCid") != m.end() && !m["QuicCid"].empty()) {
      quicCid = make_shared<string>(boost::any_cast<string>(m["QuicCid"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VersionCount") != m.end() && !m["VersionCount"].empty()) {
      versionCount = make_shared<long>(boost::any_cast<long>(m["VersionCount"]));
    }
  }


  virtual ~ListEdgeContainerAppsResponseBodyApps() = default;
};
class ListEdgeContainerAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEdgeContainerAppsResponseBodyApps>> apps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEdgeContainerAppsResponseBody() {}

  explicit ListEdgeContainerAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apps) {
      vector<boost::any> temp1;
      for(auto item1:*apps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apps"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(vector<boost::any>) == m["Apps"].type()) {
        vector<ListEdgeContainerAppsResponseBodyApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeContainerAppsResponseBodyApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apps = make_shared<vector<ListEdgeContainerAppsResponseBodyApps>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEdgeContainerAppsResponseBody() = default;
};
class ListEdgeContainerAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEdgeContainerAppsResponseBody> body{};

  ListEdgeContainerAppsResponse() {}

  explicit ListEdgeContainerAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeContainerAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeContainerAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeContainerAppsResponse() = default;
};
class ListEdgeContainerRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> recordMatchType{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};

  ListEdgeContainerRecordsRequest() {}

  explicit ListEdgeContainerRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordMatchType) {
      res["RecordMatchType"] = boost::any(*recordMatchType);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordMatchType") != m.end() && !m["RecordMatchType"].empty()) {
      recordMatchType = make_shared<string>(boost::any_cast<string>(m["RecordMatchType"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListEdgeContainerRecordsRequest() = default;
};
class ListEdgeContainerRecordsResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> recordCname{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> updateTime{};

  ListEdgeContainerRecordsResponseBodyRecords() {}

  explicit ListEdgeContainerRecordsResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (recordCname) {
      res["RecordCname"] = boost::any(*recordCname);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("RecordCname") != m.end() && !m["RecordCname"].empty()) {
      recordCname = make_shared<string>(boost::any_cast<string>(m["RecordCname"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListEdgeContainerRecordsResponseBodyRecords() = default;
};
class ListEdgeContainerRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListEdgeContainerRecordsResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEdgeContainerRecordsResponseBody() {}

  explicit ListEdgeContainerRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<ListEdgeContainerRecordsResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeContainerRecordsResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ListEdgeContainerRecordsResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEdgeContainerRecordsResponseBody() = default;
};
class ListEdgeContainerRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEdgeContainerRecordsResponseBody> body{};

  ListEdgeContainerRecordsResponse() {}

  explicit ListEdgeContainerRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeContainerRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeContainerRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeContainerRecordsResponse() = default;
};
class ListEdgeRoutinePlansResponseBodyPlanInfo : public Darabonba::Model {
public:
  shared_ptr<string> billingMode{};
  shared_ptr<string> erRoutineCodeVersionQuota{};
  shared_ptr<string> erRoutineQuota{};
  shared_ptr<string> erRoutineRouteSiteCountQuota{};
  shared_ptr<string> paymentMethod{};
  shared_ptr<string> planName{};

  ListEdgeRoutinePlansResponseBodyPlanInfo() {}

  explicit ListEdgeRoutinePlansResponseBodyPlanInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingMode) {
      res["BillingMode"] = boost::any(*billingMode);
    }
    if (erRoutineCodeVersionQuota) {
      res["ErRoutineCodeVersionQuota"] = boost::any(*erRoutineCodeVersionQuota);
    }
    if (erRoutineQuota) {
      res["ErRoutineQuota"] = boost::any(*erRoutineQuota);
    }
    if (erRoutineRouteSiteCountQuota) {
      res["ErRoutineRouteSiteCountQuota"] = boost::any(*erRoutineRouteSiteCountQuota);
    }
    if (paymentMethod) {
      res["PaymentMethod"] = boost::any(*paymentMethod);
    }
    if (planName) {
      res["PlanName"] = boost::any(*planName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingMode") != m.end() && !m["BillingMode"].empty()) {
      billingMode = make_shared<string>(boost::any_cast<string>(m["BillingMode"]));
    }
    if (m.find("ErRoutineCodeVersionQuota") != m.end() && !m["ErRoutineCodeVersionQuota"].empty()) {
      erRoutineCodeVersionQuota = make_shared<string>(boost::any_cast<string>(m["ErRoutineCodeVersionQuota"]));
    }
    if (m.find("ErRoutineQuota") != m.end() && !m["ErRoutineQuota"].empty()) {
      erRoutineQuota = make_shared<string>(boost::any_cast<string>(m["ErRoutineQuota"]));
    }
    if (m.find("ErRoutineRouteSiteCountQuota") != m.end() && !m["ErRoutineRouteSiteCountQuota"].empty()) {
      erRoutineRouteSiteCountQuota = make_shared<string>(boost::any_cast<string>(m["ErRoutineRouteSiteCountQuota"]));
    }
    if (m.find("PaymentMethod") != m.end() && !m["PaymentMethod"].empty()) {
      paymentMethod = make_shared<string>(boost::any_cast<string>(m["PaymentMethod"]));
    }
    if (m.find("PlanName") != m.end() && !m["PlanName"].empty()) {
      planName = make_shared<string>(boost::any_cast<string>(m["PlanName"]));
    }
  }


  virtual ~ListEdgeRoutinePlansResponseBodyPlanInfo() = default;
};
class ListEdgeRoutinePlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListEdgeRoutinePlansResponseBodyPlanInfo>> planInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPage{};

  ListEdgeRoutinePlansResponseBody() {}

  explicit ListEdgeRoutinePlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (planInfo) {
      vector<boost::any> temp1;
      for(auto item1:*planInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlanInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlanInfo") != m.end() && !m["PlanInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PlanInfo"].type()) {
        vector<ListEdgeRoutinePlansResponseBodyPlanInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlanInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeRoutinePlansResponseBodyPlanInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        planInfo = make_shared<vector<ListEdgeRoutinePlansResponseBodyPlanInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~ListEdgeRoutinePlansResponseBody() = default;
};
class ListEdgeRoutinePlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEdgeRoutinePlansResponseBody> body{};

  ListEdgeRoutinePlansResponse() {}

  explicit ListEdgeRoutinePlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeRoutinePlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeRoutinePlansResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeRoutinePlansResponse() = default;
};
class ListEdgeRoutineRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> recordMatchType{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};

  ListEdgeRoutineRecordsRequest() {}

  explicit ListEdgeRoutineRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordMatchType) {
      res["RecordMatchType"] = boost::any(*recordMatchType);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordMatchType") != m.end() && !m["RecordMatchType"].empty()) {
      recordMatchType = make_shared<string>(boost::any_cast<string>(m["RecordMatchType"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListEdgeRoutineRecordsRequest() = default;
};
class ListEdgeRoutineRecordsResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> recordCname{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> updateTime{};

  ListEdgeRoutineRecordsResponseBodyRecords() {}

  explicit ListEdgeRoutineRecordsResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (recordCname) {
      res["RecordCname"] = boost::any(*recordCname);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("RecordCname") != m.end() && !m["RecordCname"].empty()) {
      recordCname = make_shared<string>(boost::any_cast<string>(m["RecordCname"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListEdgeRoutineRecordsResponseBodyRecords() = default;
};
class ListEdgeRoutineRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListEdgeRoutineRecordsResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEdgeRoutineRecordsResponseBody() {}

  explicit ListEdgeRoutineRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<ListEdgeRoutineRecordsResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeRoutineRecordsResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ListEdgeRoutineRecordsResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEdgeRoutineRecordsResponseBody() = default;
};
class ListEdgeRoutineRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEdgeRoutineRecordsResponseBody> body{};

  ListEdgeRoutineRecordsResponse() {}

  explicit ListEdgeRoutineRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeRoutineRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeRoutineRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeRoutineRecordsResponse() = default;
};
class ListInstanceQuotasRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> quotaNames{};
  shared_ptr<long> siteId{};

  ListInstanceQuotasRequest() {}

  explicit ListInstanceQuotasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (quotaNames) {
      res["QuotaNames"] = boost::any(*quotaNames);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("QuotaNames") != m.end() && !m["QuotaNames"].empty()) {
      quotaNames = make_shared<string>(boost::any_cast<string>(m["QuotaNames"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListInstanceQuotasRequest() = default;
};
class ListInstanceQuotasResponseBodyQuotas : public Darabonba::Model {
public:
  shared_ptr<string> quotaName{};
  shared_ptr<string> quotaValue{};
  shared_ptr<string> quotaValueType{};

  ListInstanceQuotasResponseBodyQuotas() {}

  explicit ListInstanceQuotasResponseBodyQuotas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaName) {
      res["QuotaName"] = boost::any(*quotaName);
    }
    if (quotaValue) {
      res["QuotaValue"] = boost::any(*quotaValue);
    }
    if (quotaValueType) {
      res["QuotaValueType"] = boost::any(*quotaValueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaName") != m.end() && !m["QuotaName"].empty()) {
      quotaName = make_shared<string>(boost::any_cast<string>(m["QuotaName"]));
    }
    if (m.find("QuotaValue") != m.end() && !m["QuotaValue"].empty()) {
      quotaValue = make_shared<string>(boost::any_cast<string>(m["QuotaValue"]));
    }
    if (m.find("QuotaValueType") != m.end() && !m["QuotaValueType"].empty()) {
      quotaValueType = make_shared<string>(boost::any_cast<string>(m["QuotaValueType"]));
    }
  }


  virtual ~ListInstanceQuotasResponseBodyQuotas() = default;
};
class ListInstanceQuotasResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<ListInstanceQuotasResponseBodyQuotas>> quotas{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  ListInstanceQuotasResponseBody() {}

  explicit ListInstanceQuotasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (quotas) {
      vector<boost::any> temp1;
      for(auto item1:*quotas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Quotas"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Quotas") != m.end() && !m["Quotas"].empty()) {
      if (typeid(vector<boost::any>) == m["Quotas"].type()) {
        vector<ListInstanceQuotasResponseBodyQuotas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Quotas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceQuotasResponseBodyQuotas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        quotas = make_shared<vector<ListInstanceQuotasResponseBodyQuotas>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstanceQuotasResponseBody() = default;
};
class ListInstanceQuotasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceQuotasResponseBody> body{};

  ListInstanceQuotasResponse() {}

  explicit ListInstanceQuotasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceQuotasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceQuotasResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceQuotasResponse() = default;
};
class ListInstanceQuotasWithUsageRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> quotaNames{};
  shared_ptr<long> siteId{};

  ListInstanceQuotasWithUsageRequest() {}

  explicit ListInstanceQuotasWithUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (quotaNames) {
      res["QuotaNames"] = boost::any(*quotaNames);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("QuotaNames") != m.end() && !m["QuotaNames"].empty()) {
      quotaNames = make_shared<string>(boost::any_cast<string>(m["QuotaNames"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListInstanceQuotasWithUsageRequest() = default;
};
class ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> siteUsage{};

  ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage() {}

  explicit ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (siteUsage) {
      res["SiteUsage"] = boost::any(*siteUsage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("SiteUsage") != m.end() && !m["SiteUsage"].empty()) {
      siteUsage = make_shared<string>(boost::any_cast<string>(m["SiteUsage"]));
    }
  }


  virtual ~ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage() = default;
};
class ListInstanceQuotasWithUsageResponseBodyQuotas : public Darabonba::Model {
public:
  shared_ptr<string> quotaName{};
  shared_ptr<string> quotaValue{};
  shared_ptr<vector<ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage>> siteUsage{};
  shared_ptr<string> usage{};

  ListInstanceQuotasWithUsageResponseBodyQuotas() {}

  explicit ListInstanceQuotasWithUsageResponseBodyQuotas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaName) {
      res["QuotaName"] = boost::any(*quotaName);
    }
    if (quotaValue) {
      res["QuotaValue"] = boost::any(*quotaValue);
    }
    if (siteUsage) {
      vector<boost::any> temp1;
      for(auto item1:*siteUsage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SiteUsage"] = boost::any(temp1);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaName") != m.end() && !m["QuotaName"].empty()) {
      quotaName = make_shared<string>(boost::any_cast<string>(m["QuotaName"]));
    }
    if (m.find("QuotaValue") != m.end() && !m["QuotaValue"].empty()) {
      quotaValue = make_shared<string>(boost::any_cast<string>(m["QuotaValue"]));
    }
    if (m.find("SiteUsage") != m.end() && !m["SiteUsage"].empty()) {
      if (typeid(vector<boost::any>) == m["SiteUsage"].type()) {
        vector<ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SiteUsage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        siteUsage = make_shared<vector<ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage>>(expect1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListInstanceQuotasWithUsageResponseBodyQuotas() = default;
};
class ListInstanceQuotasWithUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<ListInstanceQuotasWithUsageResponseBodyQuotas>> quotas{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  ListInstanceQuotasWithUsageResponseBody() {}

  explicit ListInstanceQuotasWithUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (quotas) {
      vector<boost::any> temp1;
      for(auto item1:*quotas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Quotas"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Quotas") != m.end() && !m["Quotas"].empty()) {
      if (typeid(vector<boost::any>) == m["Quotas"].type()) {
        vector<ListInstanceQuotasWithUsageResponseBodyQuotas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Quotas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceQuotasWithUsageResponseBodyQuotas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        quotas = make_shared<vector<ListInstanceQuotasWithUsageResponseBodyQuotas>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstanceQuotasWithUsageResponseBody() = default;
};
class ListInstanceQuotasWithUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceQuotasWithUsageResponseBody> body{};

  ListInstanceQuotasWithUsageResponse() {}

  explicit ListInstanceQuotasWithUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceQuotasWithUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceQuotasWithUsageResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceQuotasWithUsageResponse() = default;
};
class ListKvsRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prefix{};

  ListKvsRequest() {}

  explicit ListKvsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
  }


  virtual ~ListKvsRequest() = default;
};
class ListKvsResponseBodyKeys : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> updateTime{};

  ListKvsResponseBodyKeys() {}

  explicit ListKvsResponseBodyKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListKvsResponseBodyKeys() = default;
};
class ListKvsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListKvsResponseBodyKeys>> keys{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListKvsResponseBody() {}

  explicit ListKvsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keys) {
      vector<boost::any> temp1;
      for(auto item1:*keys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Keys"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<ListKvsResponseBodyKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Keys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListKvsResponseBodyKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keys = make_shared<vector<ListKvsResponseBodyKeys>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListKvsResponseBody() = default;
};
class ListKvsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListKvsResponseBody> body{};

  ListKvsResponse() {}

  explicit ListKvsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListKvsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListKvsResponseBody>(model1);
      }
    }
  }


  virtual ~ListKvsResponse() = default;
};
class ListListsRequestQueryArgs : public Darabonba::Model {
public:
  shared_ptr<bool> desc{};
  shared_ptr<string> descriptionLike{};
  shared_ptr<string> idLike{};
  shared_ptr<string> itemLike{};
  shared_ptr<string> kind{};
  shared_ptr<string> nameItemLike{};
  shared_ptr<string> nameLike{};
  shared_ptr<string> orderBy{};

  ListListsRequestQueryArgs() {}

  explicit ListListsRequestQueryArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (descriptionLike) {
      res["DescriptionLike"] = boost::any(*descriptionLike);
    }
    if (idLike) {
      res["IdLike"] = boost::any(*idLike);
    }
    if (itemLike) {
      res["ItemLike"] = boost::any(*itemLike);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (nameItemLike) {
      res["NameItemLike"] = boost::any(*nameItemLike);
    }
    if (nameLike) {
      res["NameLike"] = boost::any(*nameLike);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<bool>(boost::any_cast<bool>(m["Desc"]));
    }
    if (m.find("DescriptionLike") != m.end() && !m["DescriptionLike"].empty()) {
      descriptionLike = make_shared<string>(boost::any_cast<string>(m["DescriptionLike"]));
    }
    if (m.find("IdLike") != m.end() && !m["IdLike"].empty()) {
      idLike = make_shared<string>(boost::any_cast<string>(m["IdLike"]));
    }
    if (m.find("ItemLike") != m.end() && !m["ItemLike"].empty()) {
      itemLike = make_shared<string>(boost::any_cast<string>(m["ItemLike"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("NameItemLike") != m.end() && !m["NameItemLike"].empty()) {
      nameItemLike = make_shared<string>(boost::any_cast<string>(m["NameItemLike"]));
    }
    if (m.find("NameLike") != m.end() && !m["NameLike"].empty()) {
      nameLike = make_shared<string>(boost::any_cast<string>(m["NameLike"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
  }


  virtual ~ListListsRequestQueryArgs() = default;
};
class ListListsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListListsRequestQueryArgs> queryArgs{};

  ListListsRequest() {}

  explicit ListListsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryArgs) {
      res["QueryArgs"] = queryArgs ? boost::any(queryArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryArgs"].type()) {
        ListListsRequestQueryArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryArgs"]));
        queryArgs = make_shared<ListListsRequestQueryArgs>(model1);
      }
    }
  }


  virtual ~ListListsRequest() = default;
};
class ListListsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryArgsShrink{};

  ListListsShrinkRequest() {}

  explicit ListListsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryArgsShrink) {
      res["QueryArgs"] = boost::any(*queryArgsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgsShrink = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
  }


  virtual ~ListListsShrinkRequest() = default;
};
class ListListsResponseBodyLists : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> kind{};
  shared_ptr<long> length{};
  shared_ptr<string> name{};
  shared_ptr<string> updateTime{};

  ListListsResponseBodyLists() {}

  explicit ListListsResponseBodyLists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListListsResponseBodyLists() = default;
};
class ListListsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListListsResponseBodyLists>> lists{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> usage{};

  ListListsResponseBody() {}

  explicit ListListsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lists) {
      vector<boost::any> temp1;
      for(auto item1:*lists){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Lists"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lists") != m.end() && !m["Lists"].empty()) {
      if (typeid(vector<boost::any>) == m["Lists"].type()) {
        vector<ListListsResponseBodyLists> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Lists"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListListsResponseBodyLists model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lists = make_shared<vector<ListListsResponseBodyLists>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
  }


  virtual ~ListListsResponseBody() = default;
};
class ListListsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListListsResponseBody> body{};

  ListListsResponse() {}

  explicit ListListsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListListsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListListsResponseBody>(model1);
      }
    }
  }


  virtual ~ListListsResponse() = default;
};
class ListLoadBalancerRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListLoadBalancerRegionsRequest() {}

  explicit ListLoadBalancerRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListLoadBalancerRegionsRequest() = default;
};
class ListLoadBalancerRegionsResponseBodyRegionsSubRegions : public Darabonba::Model {
public:
  shared_ptr<string> subRegionCnName{};
  shared_ptr<string> subRegionCode{};
  shared_ptr<string> subRegionEnName{};

  ListLoadBalancerRegionsResponseBodyRegionsSubRegions() {}

  explicit ListLoadBalancerRegionsResponseBodyRegionsSubRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subRegionCnName) {
      res["SubRegionCnName"] = boost::any(*subRegionCnName);
    }
    if (subRegionCode) {
      res["SubRegionCode"] = boost::any(*subRegionCode);
    }
    if (subRegionEnName) {
      res["SubRegionEnName"] = boost::any(*subRegionEnName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubRegionCnName") != m.end() && !m["SubRegionCnName"].empty()) {
      subRegionCnName = make_shared<string>(boost::any_cast<string>(m["SubRegionCnName"]));
    }
    if (m.find("SubRegionCode") != m.end() && !m["SubRegionCode"].empty()) {
      subRegionCode = make_shared<string>(boost::any_cast<string>(m["SubRegionCode"]));
    }
    if (m.find("SubRegionEnName") != m.end() && !m["SubRegionEnName"].empty()) {
      subRegionEnName = make_shared<string>(boost::any_cast<string>(m["SubRegionEnName"]));
    }
  }


  virtual ~ListLoadBalancerRegionsResponseBodyRegionsSubRegions() = default;
};
class ListLoadBalancerRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> regionCnName{};
  shared_ptr<string> regionCode{};
  shared_ptr<string> regionEnName{};
  shared_ptr<vector<ListLoadBalancerRegionsResponseBodyRegionsSubRegions>> subRegions{};

  ListLoadBalancerRegionsResponseBodyRegions() {}

  explicit ListLoadBalancerRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionCnName) {
      res["RegionCnName"] = boost::any(*regionCnName);
    }
    if (regionCode) {
      res["RegionCode"] = boost::any(*regionCode);
    }
    if (regionEnName) {
      res["RegionEnName"] = boost::any(*regionEnName);
    }
    if (subRegions) {
      vector<boost::any> temp1;
      for(auto item1:*subRegions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubRegions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionCnName") != m.end() && !m["RegionCnName"].empty()) {
      regionCnName = make_shared<string>(boost::any_cast<string>(m["RegionCnName"]));
    }
    if (m.find("RegionCode") != m.end() && !m["RegionCode"].empty()) {
      regionCode = make_shared<string>(boost::any_cast<string>(m["RegionCode"]));
    }
    if (m.find("RegionEnName") != m.end() && !m["RegionEnName"].empty()) {
      regionEnName = make_shared<string>(boost::any_cast<string>(m["RegionEnName"]));
    }
    if (m.find("SubRegions") != m.end() && !m["SubRegions"].empty()) {
      if (typeid(vector<boost::any>) == m["SubRegions"].type()) {
        vector<ListLoadBalancerRegionsResponseBodyRegionsSubRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubRegions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLoadBalancerRegionsResponseBodyRegionsSubRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subRegions = make_shared<vector<ListLoadBalancerRegionsResponseBodyRegionsSubRegions>>(expect1);
      }
    }
  }


  virtual ~ListLoadBalancerRegionsResponseBodyRegions() = default;
};
class ListLoadBalancerRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListLoadBalancerRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPage{};

  ListLoadBalancerRegionsResponseBody() {}

  explicit ListLoadBalancerRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<ListLoadBalancerRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLoadBalancerRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<ListLoadBalancerRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~ListLoadBalancerRegionsResponseBody() = default;
};
class ListLoadBalancerRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLoadBalancerRegionsResponseBody> body{};

  ListLoadBalancerRegionsResponse() {}

  explicit ListLoadBalancerRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLoadBalancerRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLoadBalancerRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLoadBalancerRegionsResponse() = default;
};
class ListManagedRulesGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListManagedRulesGroupsRequest() {}

  explicit ListManagedRulesGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListManagedRulesGroupsRequest() = default;
};
class ListManagedRulesGroupsResponseBodyManagedRulesGroups : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> ruleCount{};

  ListManagedRulesGroupsResponseBodyManagedRulesGroups() {}

  explicit ListManagedRulesGroupsResponseBodyManagedRulesGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
  }


  virtual ~ListManagedRulesGroupsResponseBodyManagedRulesGroups() = default;
};
class ListManagedRulesGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListManagedRulesGroupsResponseBodyManagedRulesGroups>> managedRulesGroups{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListManagedRulesGroupsResponseBody() {}

  explicit ListManagedRulesGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedRulesGroups) {
      vector<boost::any> temp1;
      for(auto item1:*managedRulesGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedRulesGroups"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedRulesGroups") != m.end() && !m["ManagedRulesGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedRulesGroups"].type()) {
        vector<ListManagedRulesGroupsResponseBodyManagedRulesGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedRulesGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListManagedRulesGroupsResponseBodyManagedRulesGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedRulesGroups = make_shared<vector<ListManagedRulesGroupsResponseBodyManagedRulesGroups>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListManagedRulesGroupsResponseBody() = default;
};
class ListManagedRulesGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListManagedRulesGroupsResponseBody> body{};

  ListManagedRulesGroupsResponse() {}

  explicit ListManagedRulesGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListManagedRulesGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListManagedRulesGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListManagedRulesGroupsResponse() = default;
};
class ListPagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListPagesRequest() {}

  explicit ListPagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListPagesRequest() = default;
};
class ListPagesResponseBodyPages : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> kind{};
  shared_ptr<string> name{};
  shared_ptr<string> updateTime{};

  ListPagesResponseBodyPages() {}

  explicit ListPagesResponseBodyPages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListPagesResponseBodyPages() = default;
};
class ListPagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListPagesResponseBodyPages>> pages{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> usage{};

  ListPagesResponseBody() {}

  explicit ListPagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pages) {
      vector<boost::any> temp1;
      for(auto item1:*pages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pages"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pages") != m.end() && !m["Pages"].empty()) {
      if (typeid(vector<boost::any>) == m["Pages"].type()) {
        vector<ListPagesResponseBodyPages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPagesResponseBodyPages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pages = make_shared<vector<ListPagesResponseBodyPages>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
  }


  virtual ~ListPagesResponseBody() = default;
};
class ListPagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPagesResponseBody> body{};

  ListPagesResponse() {}

  explicit ListPagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPagesResponse() = default;
};
class ListRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> proxied{};
  shared_ptr<string> recordMatchType{};
  shared_ptr<string> recordName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  ListRecordsRequest() {}

  explicit ListRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordMatchType) {
      res["RecordMatchType"] = boost::any(*recordMatchType);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordMatchType") != m.end() && !m["RecordMatchType"].empty()) {
      recordMatchType = make_shared<string>(boost::any_cast<string>(m["RecordMatchType"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListRecordsRequest() = default;
};
class ListRecordsResponseBodyRecordsAuthConf : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> authType{};
  shared_ptr<string> region{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> version{};

  ListRecordsResponseBodyRecordsAuthConf() {}

  explicit ListRecordsResponseBodyRecordsAuthConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListRecordsResponseBodyRecordsAuthConf() = default;
};
class ListRecordsResponseBodyRecordsData : public Darabonba::Model {
public:
  shared_ptr<long> algorithm{};
  shared_ptr<string> certificate{};
  shared_ptr<string> fingerprint{};
  shared_ptr<long> flag{};
  shared_ptr<long> keyTag{};
  shared_ptr<long> matchingType{};
  shared_ptr<long> port{};
  shared_ptr<long> priority{};
  shared_ptr<long> selector{};
  shared_ptr<string> tag{};
  shared_ptr<long> type{};
  shared_ptr<long> usage{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  ListRecordsResponseBodyRecordsData() {}

  explicit ListRecordsResponseBodyRecordsData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (keyTag) {
      res["KeyTag"] = boost::any(*keyTag);
    }
    if (matchingType) {
      res["MatchingType"] = boost::any(*matchingType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<long>(boost::any_cast<long>(m["Algorithm"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("KeyTag") != m.end() && !m["KeyTag"].empty()) {
      keyTag = make_shared<long>(boost::any_cast<long>(m["KeyTag"]));
    }
    if (m.find("MatchingType") != m.end() && !m["MatchingType"].empty()) {
      matchingType = make_shared<long>(boost::any_cast<long>(m["MatchingType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<long>(boost::any_cast<long>(m["Selector"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~ListRecordsResponseBodyRecordsData() = default;
};
class ListRecordsResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<ListRecordsResponseBodyRecordsAuthConf> authConf{};
  shared_ptr<string> bizName{};
  shared_ptr<string> comment{};
  shared_ptr<string> createTime{};
  shared_ptr<ListRecordsResponseBodyRecordsData> data{};
  shared_ptr<string> hostPolicy{};
  shared_ptr<bool> proxied{};
  shared_ptr<string> recordCname{};
  shared_ptr<long> recordId{};
  shared_ptr<string> recordName{};
  shared_ptr<string> recordSourceType{};
  shared_ptr<string> recordType{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<long> ttl{};
  shared_ptr<string> updateTime{};

  ListRecordsResponseBodyRecords() {}

  explicit ListRecordsResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConf) {
      res["AuthConf"] = authConf ? boost::any(authConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostPolicy) {
      res["HostPolicy"] = boost::any(*hostPolicy);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordCname) {
      res["RecordCname"] = boost::any(*recordCname);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordName) {
      res["RecordName"] = boost::any(*recordName);
    }
    if (recordSourceType) {
      res["RecordSourceType"] = boost::any(*recordSourceType);
    }
    if (recordType) {
      res["RecordType"] = boost::any(*recordType);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthConf") != m.end() && !m["AuthConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthConf"].type()) {
        ListRecordsResponseBodyRecordsAuthConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthConf"]));
        authConf = make_shared<ListRecordsResponseBodyRecordsAuthConf>(model1);
      }
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRecordsResponseBodyRecordsData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRecordsResponseBodyRecordsData>(model1);
      }
    }
    if (m.find("HostPolicy") != m.end() && !m["HostPolicy"].empty()) {
      hostPolicy = make_shared<string>(boost::any_cast<string>(m["HostPolicy"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordCname") != m.end() && !m["RecordCname"].empty()) {
      recordCname = make_shared<string>(boost::any_cast<string>(m["RecordCname"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("RecordName") != m.end() && !m["RecordName"].empty()) {
      recordName = make_shared<string>(boost::any_cast<string>(m["RecordName"]));
    }
    if (m.find("RecordSourceType") != m.end() && !m["RecordSourceType"].empty()) {
      recordSourceType = make_shared<string>(boost::any_cast<string>(m["RecordSourceType"]));
    }
    if (m.find("RecordType") != m.end() && !m["RecordType"].empty()) {
      recordType = make_shared<string>(boost::any_cast<string>(m["RecordType"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListRecordsResponseBodyRecords() = default;
};
class ListRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListRecordsResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListRecordsResponseBody() {}

  explicit ListRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<ListRecordsResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecordsResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ListRecordsResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRecordsResponseBody() = default;
};
class ListRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRecordsResponseBody> body{};

  ListRecordsResponse() {}

  explicit ListRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecordsResponse() = default;
};
class ListRoutineCanaryAreasResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> canaryAreas{};
  shared_ptr<string> requestId{};

  ListRoutineCanaryAreasResponseBody() {}

  explicit ListRoutineCanaryAreasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canaryAreas) {
      res["CanaryAreas"] = boost::any(*canaryAreas);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanaryAreas") != m.end() && !m["CanaryAreas"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CanaryAreas"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CanaryAreas"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      canaryAreas = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRoutineCanaryAreasResponseBody() = default;
};
class ListRoutineCanaryAreasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRoutineCanaryAreasResponseBody> body{};

  ListRoutineCanaryAreasResponse() {}

  explicit ListRoutineCanaryAreasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRoutineCanaryAreasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRoutineCanaryAreasResponseBody>(model1);
      }
    }
  }


  virtual ~ListRoutineCanaryAreasResponse() = default;
};
class ListRoutineOptionalSpecsResponseBodySpecs : public Darabonba::Model {
public:
  shared_ptr<bool> isAvailable{};
  shared_ptr<string> specName{};

  ListRoutineOptionalSpecsResponseBodySpecs() {}

  explicit ListRoutineOptionalSpecsResponseBodySpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isAvailable) {
      res["IsAvailable"] = boost::any(*isAvailable);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsAvailable") != m.end() && !m["IsAvailable"].empty()) {
      isAvailable = make_shared<bool>(boost::any_cast<bool>(m["IsAvailable"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
  }


  virtual ~ListRoutineOptionalSpecsResponseBodySpecs() = default;
};
class ListRoutineOptionalSpecsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRoutineOptionalSpecsResponseBodySpecs>> specs{};

  ListRoutineOptionalSpecsResponseBody() {}

  explicit ListRoutineOptionalSpecsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specs) {
      vector<boost::any> temp1;
      for(auto item1:*specs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Specs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Specs") != m.end() && !m["Specs"].empty()) {
      if (typeid(vector<boost::any>) == m["Specs"].type()) {
        vector<ListRoutineOptionalSpecsResponseBodySpecs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Specs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRoutineOptionalSpecsResponseBodySpecs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specs = make_shared<vector<ListRoutineOptionalSpecsResponseBodySpecs>>(expect1);
      }
    }
  }


  virtual ~ListRoutineOptionalSpecsResponseBody() = default;
};
class ListRoutineOptionalSpecsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRoutineOptionalSpecsResponseBody> body{};

  ListRoutineOptionalSpecsResponse() {}

  explicit ListRoutineOptionalSpecsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRoutineOptionalSpecsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRoutineOptionalSpecsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRoutineOptionalSpecsResponse() = default;
};
class ListScheduledPreloadExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ListScheduledPreloadExecutionsRequest() {}

  explicit ListScheduledPreloadExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListScheduledPreloadExecutionsRequest() = default;
};
class ListScheduledPreloadExecutionsResponseBodyExecutions : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jobId{};
  shared_ptr<long> sliceLen{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListScheduledPreloadExecutionsResponseBodyExecutions() {}

  explicit ListScheduledPreloadExecutionsResponseBodyExecutions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (sliceLen) {
      res["SliceLen"] = boost::any(*sliceLen);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SliceLen") != m.end() && !m["SliceLen"].empty()) {
      sliceLen = make_shared<long>(boost::any_cast<long>(m["SliceLen"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListScheduledPreloadExecutionsResponseBodyExecutions() = default;
};
class ListScheduledPreloadExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListScheduledPreloadExecutionsResponseBodyExecutions>> executions{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListScheduledPreloadExecutionsResponseBody() {}

  explicit ListScheduledPreloadExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executions) {
      vector<boost::any> temp1;
      for(auto item1:*executions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Executions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      if (typeid(vector<boost::any>) == m["Executions"].type()) {
        vector<ListScheduledPreloadExecutionsResponseBodyExecutions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Executions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScheduledPreloadExecutionsResponseBodyExecutions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        executions = make_shared<vector<ListScheduledPreloadExecutionsResponseBodyExecutions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScheduledPreloadExecutionsResponseBody() = default;
};
class ListScheduledPreloadExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScheduledPreloadExecutionsResponseBody> body{};

  ListScheduledPreloadExecutionsResponse() {}

  explicit ListScheduledPreloadExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScheduledPreloadExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScheduledPreloadExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListScheduledPreloadExecutionsResponse() = default;
};
class ListScheduledPreloadJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> siteId{};
  shared_ptr<long> startTime{};

  ListScheduledPreloadJobsRequest() {}

  explicit ListScheduledPreloadJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListScheduledPreloadJobsRequest() = default;
};
class ListScheduledPreloadJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> domains{};
  shared_ptr<string> errorInfo{};
  shared_ptr<string> failedFileOss{};
  shared_ptr<string> fileId{};
  shared_ptr<string> id{};
  shared_ptr<string> insertWay{};
  shared_ptr<string> name{};
  shared_ptr<long> siteId{};
  shared_ptr<long> taskSubmitted{};
  shared_ptr<string> taskType{};
  shared_ptr<long> urlCount{};
  shared_ptr<long> urlSubmitted{};

  ListScheduledPreloadJobsResponseBodyJobs() {}

  explicit ListScheduledPreloadJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (createdAt) {
      res["CreatedAt"] = boost::any(*createdAt);
    }
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (failedFileOss) {
      res["FailedFileOss"] = boost::any(*failedFileOss);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (insertWay) {
      res["InsertWay"] = boost::any(*insertWay);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskSubmitted) {
      res["TaskSubmitted"] = boost::any(*taskSubmitted);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (urlCount) {
      res["UrlCount"] = boost::any(*urlCount);
    }
    if (urlSubmitted) {
      res["UrlSubmitted"] = boost::any(*urlSubmitted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("CreatedAt") != m.end() && !m["CreatedAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["CreatedAt"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      domains = make_shared<string>(boost::any_cast<string>(m["Domains"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("FailedFileOss") != m.end() && !m["FailedFileOss"].empty()) {
      failedFileOss = make_shared<string>(boost::any_cast<string>(m["FailedFileOss"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InsertWay") != m.end() && !m["InsertWay"].empty()) {
      insertWay = make_shared<string>(boost::any_cast<string>(m["InsertWay"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TaskSubmitted") != m.end() && !m["TaskSubmitted"].empty()) {
      taskSubmitted = make_shared<long>(boost::any_cast<long>(m["TaskSubmitted"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UrlCount") != m.end() && !m["UrlCount"].empty()) {
      urlCount = make_shared<long>(boost::any_cast<long>(m["UrlCount"]));
    }
    if (m.find("UrlSubmitted") != m.end() && !m["UrlSubmitted"].empty()) {
      urlSubmitted = make_shared<long>(boost::any_cast<long>(m["UrlSubmitted"]));
    }
  }


  virtual ~ListScheduledPreloadJobsResponseBodyJobs() = default;
};
class ListScheduledPreloadJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListScheduledPreloadJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListScheduledPreloadJobsResponseBody() {}

  explicit ListScheduledPreloadJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListScheduledPreloadJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScheduledPreloadJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListScheduledPreloadJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListScheduledPreloadJobsResponseBody() = default;
};
class ListScheduledPreloadJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScheduledPreloadJobsResponseBody> body{};

  ListScheduledPreloadJobsResponse() {}

  explicit ListScheduledPreloadJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScheduledPreloadJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScheduledPreloadJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListScheduledPreloadJobsResponse() = default;
};
class ListSiteDeliveryTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> siteId{};

  ListSiteDeliveryTasksRequest() {}

  explicit ListSiteDeliveryTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListSiteDeliveryTasksRequest() = default;
};
class ListSiteDeliveryTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deliveryType{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  ListSiteDeliveryTasksResponseBodyTasks() {}

  explicit ListSiteDeliveryTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<string>(boost::any_cast<string>(m["DeliveryType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ListSiteDeliveryTasksResponseBodyTasks() = default;
};
class ListSiteDeliveryTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSiteDeliveryTasksResponseBodyTasks>> tasks{};
  shared_ptr<long> totalCount{};

  ListSiteDeliveryTasksResponseBody() {}

  explicit ListSiteDeliveryTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListSiteDeliveryTasksResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteDeliveryTasksResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListSiteDeliveryTasksResponseBodyTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSiteDeliveryTasksResponseBody() = default;
};
class ListSiteDeliveryTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSiteDeliveryTasksResponseBody> body{};

  ListSiteDeliveryTasksResponse() {}

  explicit ListSiteDeliveryTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSiteDeliveryTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSiteDeliveryTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListSiteDeliveryTasksResponse() = default;
};
class ListSiteFunctionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> configType{};
  shared_ptr<string> functionName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  ListSiteFunctionsRequest() {}

  explicit ListSiteFunctionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~ListSiteFunctionsRequest() = default;
};
class ListSiteFunctionsResponseBodyConfigsCacheReserve : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> instanceId{};

  ListSiteFunctionsResponseBodyConfigsCacheReserve() {}

  explicit ListSiteFunctionsResponseBodyConfigsCacheReserve(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsCacheReserve() = default;
};
class ListSiteFunctionsResponseBodyConfigsCacheRules : public Darabonba::Model {
public:
  shared_ptr<string> additionalCacheablePorts{};
  shared_ptr<string> browserCacheMode{};
  shared_ptr<string> browserCacheTtl{};
  shared_ptr<string> bypassCache{};
  shared_ptr<string> cacheDeceptionArmor{};
  shared_ptr<string> cacheReserveEligibility{};
  shared_ptr<string> checkPresenceCookie{};
  shared_ptr<string> checkPresenceHeader{};
  shared_ptr<long> configId{};
  shared_ptr<string> edgeCacheMode{};
  shared_ptr<string> edgeCacheTtl{};
  shared_ptr<string> edgeStatusCodeCacheTtl{};
  shared_ptr<string> includeCookie{};
  shared_ptr<string> includeHeader{};
  shared_ptr<string> queryString{};
  shared_ptr<string> queryStringMode{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> serveStale{};
  shared_ptr<string> sortQueryStringForCache{};
  shared_ptr<string> userDeviceType{};
  shared_ptr<string> userGeo{};
  shared_ptr<string> userLanguage{};

  ListSiteFunctionsResponseBodyConfigsCacheRules() {}

  explicit ListSiteFunctionsResponseBodyConfigsCacheRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalCacheablePorts) {
      res["AdditionalCacheablePorts"] = boost::any(*additionalCacheablePorts);
    }
    if (browserCacheMode) {
      res["BrowserCacheMode"] = boost::any(*browserCacheMode);
    }
    if (browserCacheTtl) {
      res["BrowserCacheTtl"] = boost::any(*browserCacheTtl);
    }
    if (bypassCache) {
      res["BypassCache"] = boost::any(*bypassCache);
    }
    if (cacheDeceptionArmor) {
      res["CacheDeceptionArmor"] = boost::any(*cacheDeceptionArmor);
    }
    if (cacheReserveEligibility) {
      res["CacheReserveEligibility"] = boost::any(*cacheReserveEligibility);
    }
    if (checkPresenceCookie) {
      res["CheckPresenceCookie"] = boost::any(*checkPresenceCookie);
    }
    if (checkPresenceHeader) {
      res["CheckPresenceHeader"] = boost::any(*checkPresenceHeader);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (edgeCacheMode) {
      res["EdgeCacheMode"] = boost::any(*edgeCacheMode);
    }
    if (edgeCacheTtl) {
      res["EdgeCacheTtl"] = boost::any(*edgeCacheTtl);
    }
    if (edgeStatusCodeCacheTtl) {
      res["EdgeStatusCodeCacheTtl"] = boost::any(*edgeStatusCodeCacheTtl);
    }
    if (includeCookie) {
      res["IncludeCookie"] = boost::any(*includeCookie);
    }
    if (includeHeader) {
      res["IncludeHeader"] = boost::any(*includeHeader);
    }
    if (queryString) {
      res["QueryString"] = boost::any(*queryString);
    }
    if (queryStringMode) {
      res["QueryStringMode"] = boost::any(*queryStringMode);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (serveStale) {
      res["ServeStale"] = boost::any(*serveStale);
    }
    if (sortQueryStringForCache) {
      res["SortQueryStringForCache"] = boost::any(*sortQueryStringForCache);
    }
    if (userDeviceType) {
      res["UserDeviceType"] = boost::any(*userDeviceType);
    }
    if (userGeo) {
      res["UserGeo"] = boost::any(*userGeo);
    }
    if (userLanguage) {
      res["UserLanguage"] = boost::any(*userLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalCacheablePorts") != m.end() && !m["AdditionalCacheablePorts"].empty()) {
      additionalCacheablePorts = make_shared<string>(boost::any_cast<string>(m["AdditionalCacheablePorts"]));
    }
    if (m.find("BrowserCacheMode") != m.end() && !m["BrowserCacheMode"].empty()) {
      browserCacheMode = make_shared<string>(boost::any_cast<string>(m["BrowserCacheMode"]));
    }
    if (m.find("BrowserCacheTtl") != m.end() && !m["BrowserCacheTtl"].empty()) {
      browserCacheTtl = make_shared<string>(boost::any_cast<string>(m["BrowserCacheTtl"]));
    }
    if (m.find("BypassCache") != m.end() && !m["BypassCache"].empty()) {
      bypassCache = make_shared<string>(boost::any_cast<string>(m["BypassCache"]));
    }
    if (m.find("CacheDeceptionArmor") != m.end() && !m["CacheDeceptionArmor"].empty()) {
      cacheDeceptionArmor = make_shared<string>(boost::any_cast<string>(m["CacheDeceptionArmor"]));
    }
    if (m.find("CacheReserveEligibility") != m.end() && !m["CacheReserveEligibility"].empty()) {
      cacheReserveEligibility = make_shared<string>(boost::any_cast<string>(m["CacheReserveEligibility"]));
    }
    if (m.find("CheckPresenceCookie") != m.end() && !m["CheckPresenceCookie"].empty()) {
      checkPresenceCookie = make_shared<string>(boost::any_cast<string>(m["CheckPresenceCookie"]));
    }
    if (m.find("CheckPresenceHeader") != m.end() && !m["CheckPresenceHeader"].empty()) {
      checkPresenceHeader = make_shared<string>(boost::any_cast<string>(m["CheckPresenceHeader"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("EdgeCacheMode") != m.end() && !m["EdgeCacheMode"].empty()) {
      edgeCacheMode = make_shared<string>(boost::any_cast<string>(m["EdgeCacheMode"]));
    }
    if (m.find("EdgeCacheTtl") != m.end() && !m["EdgeCacheTtl"].empty()) {
      edgeCacheTtl = make_shared<string>(boost::any_cast<string>(m["EdgeCacheTtl"]));
    }
    if (m.find("EdgeStatusCodeCacheTtl") != m.end() && !m["EdgeStatusCodeCacheTtl"].empty()) {
      edgeStatusCodeCacheTtl = make_shared<string>(boost::any_cast<string>(m["EdgeStatusCodeCacheTtl"]));
    }
    if (m.find("IncludeCookie") != m.end() && !m["IncludeCookie"].empty()) {
      includeCookie = make_shared<string>(boost::any_cast<string>(m["IncludeCookie"]));
    }
    if (m.find("IncludeHeader") != m.end() && !m["IncludeHeader"].empty()) {
      includeHeader = make_shared<string>(boost::any_cast<string>(m["IncludeHeader"]));
    }
    if (m.find("QueryString") != m.end() && !m["QueryString"].empty()) {
      queryString = make_shared<string>(boost::any_cast<string>(m["QueryString"]));
    }
    if (m.find("QueryStringMode") != m.end() && !m["QueryStringMode"].empty()) {
      queryStringMode = make_shared<string>(boost::any_cast<string>(m["QueryStringMode"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("ServeStale") != m.end() && !m["ServeStale"].empty()) {
      serveStale = make_shared<string>(boost::any_cast<string>(m["ServeStale"]));
    }
    if (m.find("SortQueryStringForCache") != m.end() && !m["SortQueryStringForCache"].empty()) {
      sortQueryStringForCache = make_shared<string>(boost::any_cast<string>(m["SortQueryStringForCache"]));
    }
    if (m.find("UserDeviceType") != m.end() && !m["UserDeviceType"].empty()) {
      userDeviceType = make_shared<string>(boost::any_cast<string>(m["UserDeviceType"]));
    }
    if (m.find("UserGeo") != m.end() && !m["UserGeo"].empty()) {
      userGeo = make_shared<string>(boost::any_cast<string>(m["UserGeo"]));
    }
    if (m.find("UserLanguage") != m.end() && !m["UserLanguage"].empty()) {
      userLanguage = make_shared<string>(boost::any_cast<string>(m["UserLanguage"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsCacheRules() = default;
};
class ListSiteFunctionsResponseBodyConfigsCacheTags : public Darabonba::Model {
public:
  shared_ptr<string> caseInsensitive{};
  shared_ptr<long> configId{};
  shared_ptr<string> sequence{};
  shared_ptr<string> tagName{};

  ListSiteFunctionsResponseBodyConfigsCacheTags() {}

  explicit ListSiteFunctionsResponseBodyConfigsCacheTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caseInsensitive) {
      res["CaseInsensitive"] = boost::any(*caseInsensitive);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaseInsensitive") != m.end() && !m["CaseInsensitive"].empty()) {
      caseInsensitive = make_shared<string>(boost::any_cast<string>(m["CaseInsensitive"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsCacheTags() = default;
};
class ListSiteFunctionsResponseBodyConfigsCnameFlattening : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> flattenMode{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsCnameFlattening() {}

  explicit ListSiteFunctionsResponseBodyConfigsCnameFlattening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (flattenMode) {
      res["FlattenMode"] = boost::any(*flattenMode);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("FlattenMode") != m.end() && !m["FlattenMode"].empty()) {
      flattenMode = make_shared<string>(boost::any_cast<string>(m["FlattenMode"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsCnameFlattening() = default;
};
class ListSiteFunctionsResponseBodyConfigsCompressionRules : public Darabonba::Model {
public:
  shared_ptr<string> brotli{};
  shared_ptr<long> configId{};
  shared_ptr<string> gzip{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsCompressionRules() {}

  explicit ListSiteFunctionsResponseBodyConfigsCompressionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (brotli) {
      res["Brotli"] = boost::any(*brotli);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (gzip) {
      res["Gzip"] = boost::any(*gzip);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Brotli") != m.end() && !m["Brotli"].empty()) {
      brotli = make_shared<string>(boost::any_cast<string>(m["Brotli"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Gzip") != m.end() && !m["Gzip"].empty()) {
      gzip = make_shared<string>(boost::any_cast<string>(m["Gzip"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsCompressionRules() = default;
};
class ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization() {}

  explicit ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization() = default;
};
class ListSiteFunctionsResponseBodyConfigsDevelopmentMode : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsDevelopmentMode() {}

  explicit ListSiteFunctionsResponseBodyConfigsDevelopmentMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsDevelopmentMode() = default;
};
class ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification() {}

  explicit ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification() = default;
};
class ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification>> requestHeaderModification{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules() {}

  explicit ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (requestHeaderModification) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaderModification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaderModification"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("RequestHeaderModification") != m.end() && !m["RequestHeaderModification"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaderModification"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaderModification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaderModification = make_shared<vector<ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRulesRequestHeaderModification>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules() = default;
};
class ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification() {}

  explicit ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification() = default;
};
class ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification>> responseHeaderModification{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules() {}

  explicit ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (responseHeaderModification) {
      vector<boost::any> temp1;
      for(auto item1:*responseHeaderModification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseHeaderModification"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("ResponseHeaderModification") != m.end() && !m["ResponseHeaderModification"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseHeaderModification"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseHeaderModification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseHeaderModification = make_shared<vector<ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRulesResponseHeaderModification>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules() = default;
};
class ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> altSvc{};
  shared_ptr<string> altSvcClear{};
  shared_ptr<string> altSvcMa{};
  shared_ptr<string> altSvcPersist{};
  shared_ptr<long> configId{};
  shared_ptr<string> hsts{};
  shared_ptr<string> hstsIncludeSubdomains{};
  shared_ptr<string> hstsMaxAge{};
  shared_ptr<string> hstsPreload{};
  shared_ptr<string> httpsForce{};
  shared_ptr<string> httpsForceCode{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration() {}

  explicit ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (altSvc) {
      res["AltSvc"] = boost::any(*altSvc);
    }
    if (altSvcClear) {
      res["AltSvcClear"] = boost::any(*altSvcClear);
    }
    if (altSvcMa) {
      res["AltSvcMa"] = boost::any(*altSvcMa);
    }
    if (altSvcPersist) {
      res["AltSvcPersist"] = boost::any(*altSvcPersist);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (hsts) {
      res["Hsts"] = boost::any(*hsts);
    }
    if (hstsIncludeSubdomains) {
      res["HstsIncludeSubdomains"] = boost::any(*hstsIncludeSubdomains);
    }
    if (hstsMaxAge) {
      res["HstsMaxAge"] = boost::any(*hstsMaxAge);
    }
    if (hstsPreload) {
      res["HstsPreload"] = boost::any(*hstsPreload);
    }
    if (httpsForce) {
      res["HttpsForce"] = boost::any(*httpsForce);
    }
    if (httpsForceCode) {
      res["HttpsForceCode"] = boost::any(*httpsForceCode);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AltSvc") != m.end() && !m["AltSvc"].empty()) {
      altSvc = make_shared<string>(boost::any_cast<string>(m["AltSvc"]));
    }
    if (m.find("AltSvcClear") != m.end() && !m["AltSvcClear"].empty()) {
      altSvcClear = make_shared<string>(boost::any_cast<string>(m["AltSvcClear"]));
    }
    if (m.find("AltSvcMa") != m.end() && !m["AltSvcMa"].empty()) {
      altSvcMa = make_shared<string>(boost::any_cast<string>(m["AltSvcMa"]));
    }
    if (m.find("AltSvcPersist") != m.end() && !m["AltSvcPersist"].empty()) {
      altSvcPersist = make_shared<string>(boost::any_cast<string>(m["AltSvcPersist"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Hsts") != m.end() && !m["Hsts"].empty()) {
      hsts = make_shared<string>(boost::any_cast<string>(m["Hsts"]));
    }
    if (m.find("HstsIncludeSubdomains") != m.end() && !m["HstsIncludeSubdomains"].empty()) {
      hstsIncludeSubdomains = make_shared<string>(boost::any_cast<string>(m["HstsIncludeSubdomains"]));
    }
    if (m.find("HstsMaxAge") != m.end() && !m["HstsMaxAge"].empty()) {
      hstsMaxAge = make_shared<string>(boost::any_cast<string>(m["HstsMaxAge"]));
    }
    if (m.find("HstsPreload") != m.end() && !m["HstsPreload"].empty()) {
      hstsPreload = make_shared<string>(boost::any_cast<string>(m["HstsPreload"]));
    }
    if (m.find("HttpsForce") != m.end() && !m["HttpsForce"].empty()) {
      httpsForce = make_shared<string>(boost::any_cast<string>(m["HttpsForce"]));
    }
    if (m.find("HttpsForceCode") != m.end() && !m["HttpsForceCode"].empty()) {
      httpsForceCode = make_shared<string>(boost::any_cast<string>(m["HttpsForceCode"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration() = default;
};
class ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> ciphersuite{};
  shared_ptr<string> ciphersuiteGroup{};
  shared_ptr<long> configId{};
  shared_ptr<string> http2{};
  shared_ptr<string> http3{};
  shared_ptr<string> https{};
  shared_ptr<string> ocspStapling{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> tls10{};
  shared_ptr<string> tls11{};
  shared_ptr<string> tls12{};
  shared_ptr<string> tls13{};

  ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration() {}

  explicit ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphersuite) {
      res["Ciphersuite"] = boost::any(*ciphersuite);
    }
    if (ciphersuiteGroup) {
      res["CiphersuiteGroup"] = boost::any(*ciphersuiteGroup);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (http2) {
      res["Http2"] = boost::any(*http2);
    }
    if (http3) {
      res["Http3"] = boost::any(*http3);
    }
    if (https) {
      res["Https"] = boost::any(*https);
    }
    if (ocspStapling) {
      res["OcspStapling"] = boost::any(*ocspStapling);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (tls10) {
      res["Tls10"] = boost::any(*tls10);
    }
    if (tls11) {
      res["Tls11"] = boost::any(*tls11);
    }
    if (tls12) {
      res["Tls12"] = boost::any(*tls12);
    }
    if (tls13) {
      res["Tls13"] = boost::any(*tls13);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ciphersuite") != m.end() && !m["Ciphersuite"].empty()) {
      ciphersuite = make_shared<string>(boost::any_cast<string>(m["Ciphersuite"]));
    }
    if (m.find("CiphersuiteGroup") != m.end() && !m["CiphersuiteGroup"].empty()) {
      ciphersuiteGroup = make_shared<string>(boost::any_cast<string>(m["CiphersuiteGroup"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Http2") != m.end() && !m["Http2"].empty()) {
      http2 = make_shared<string>(boost::any_cast<string>(m["Http2"]));
    }
    if (m.find("Http3") != m.end() && !m["Http3"].empty()) {
      http3 = make_shared<string>(boost::any_cast<string>(m["Http3"]));
    }
    if (m.find("Https") != m.end() && !m["Https"].empty()) {
      https = make_shared<string>(boost::any_cast<string>(m["Https"]));
    }
    if (m.find("OcspStapling") != m.end() && !m["OcspStapling"].empty()) {
      ocspStapling = make_shared<string>(boost::any_cast<string>(m["OcspStapling"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("Tls10") != m.end() && !m["Tls10"].empty()) {
      tls10 = make_shared<string>(boost::any_cast<string>(m["Tls10"]));
    }
    if (m.find("Tls11") != m.end() && !m["Tls11"].empty()) {
      tls11 = make_shared<string>(boost::any_cast<string>(m["Tls11"]));
    }
    if (m.find("Tls12") != m.end() && !m["Tls12"].empty()) {
      tls12 = make_shared<string>(boost::any_cast<string>(m["Tls12"]));
    }
    if (m.find("Tls13") != m.end() && !m["Tls13"].empty()) {
      tls13 = make_shared<string>(boost::any_cast<string>(m["Tls13"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration() = default;
};
class ListSiteFunctionsResponseBodyConfigsImageTransform : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsImageTransform() {}

  explicit ListSiteFunctionsResponseBodyConfigsImageTransform(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsImageTransform() = default;
};
class ListSiteFunctionsResponseBodyConfigsIpv6 : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsIpv6() {}

  explicit ListSiteFunctionsResponseBodyConfigsIpv6(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsIpv6() = default;
};
class ListSiteFunctionsResponseBodyConfigsManagedTransforms : public Darabonba::Model {
public:
  shared_ptr<string> addClientGeolocationHeaders{};
  shared_ptr<string> addRealClientIpHeader{};
  shared_ptr<long> configId{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsManagedTransforms() {}

  explicit ListSiteFunctionsResponseBodyConfigsManagedTransforms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addClientGeolocationHeaders) {
      res["AddClientGeolocationHeaders"] = boost::any(*addClientGeolocationHeaders);
    }
    if (addRealClientIpHeader) {
      res["AddRealClientIpHeader"] = boost::any(*addRealClientIpHeader);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddClientGeolocationHeaders") != m.end() && !m["AddClientGeolocationHeaders"].empty()) {
      addClientGeolocationHeaders = make_shared<string>(boost::any_cast<string>(m["AddClientGeolocationHeaders"]));
    }
    if (m.find("AddRealClientIpHeader") != m.end() && !m["AddRealClientIpHeader"].empty()) {
      addRealClientIpHeader = make_shared<string>(boost::any_cast<string>(m["AddRealClientIpHeader"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsManagedTransforms() = default;
};
class ListSiteFunctionsResponseBodyConfigsNetworkOptimization : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> grpc{};
  shared_ptr<string> http2Origin{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> smartRouting{};
  shared_ptr<string> uploadMaxFilesize{};
  shared_ptr<string> websocket{};

  ListSiteFunctionsResponseBodyConfigsNetworkOptimization() {}

  explicit ListSiteFunctionsResponseBodyConfigsNetworkOptimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (grpc) {
      res["Grpc"] = boost::any(*grpc);
    }
    if (http2Origin) {
      res["Http2Origin"] = boost::any(*http2Origin);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (smartRouting) {
      res["SmartRouting"] = boost::any(*smartRouting);
    }
    if (uploadMaxFilesize) {
      res["UploadMaxFilesize"] = boost::any(*uploadMaxFilesize);
    }
    if (websocket) {
      res["Websocket"] = boost::any(*websocket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Grpc") != m.end() && !m["Grpc"].empty()) {
      grpc = make_shared<string>(boost::any_cast<string>(m["Grpc"]));
    }
    if (m.find("Http2Origin") != m.end() && !m["Http2Origin"].empty()) {
      http2Origin = make_shared<string>(boost::any_cast<string>(m["Http2Origin"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("SmartRouting") != m.end() && !m["SmartRouting"].empty()) {
      smartRouting = make_shared<string>(boost::any_cast<string>(m["SmartRouting"]));
    }
    if (m.find("UploadMaxFilesize") != m.end() && !m["UploadMaxFilesize"].empty()) {
      uploadMaxFilesize = make_shared<string>(boost::any_cast<string>(m["UploadMaxFilesize"]));
    }
    if (m.find("Websocket") != m.end() && !m["Websocket"].empty()) {
      websocket = make_shared<string>(boost::any_cast<string>(m["Websocket"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsNetworkOptimization() = default;
};
class ListSiteFunctionsResponseBodyConfigsOriginRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> dnsRecord{};
  shared_ptr<string> originHost{};
  shared_ptr<string> originHttpPort{};
  shared_ptr<string> originHttpsPort{};
  shared_ptr<string> originScheme{};
  shared_ptr<string> originSni{};
  shared_ptr<string> range{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsOriginRules() {}

  explicit ListSiteFunctionsResponseBodyConfigsOriginRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (dnsRecord) {
      res["DnsRecord"] = boost::any(*dnsRecord);
    }
    if (originHost) {
      res["OriginHost"] = boost::any(*originHost);
    }
    if (originHttpPort) {
      res["OriginHttpPort"] = boost::any(*originHttpPort);
    }
    if (originHttpsPort) {
      res["OriginHttpsPort"] = boost::any(*originHttpsPort);
    }
    if (originScheme) {
      res["OriginScheme"] = boost::any(*originScheme);
    }
    if (originSni) {
      res["OriginSni"] = boost::any(*originSni);
    }
    if (range) {
      res["Range"] = boost::any(*range);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("DnsRecord") != m.end() && !m["DnsRecord"].empty()) {
      dnsRecord = make_shared<string>(boost::any_cast<string>(m["DnsRecord"]));
    }
    if (m.find("OriginHost") != m.end() && !m["OriginHost"].empty()) {
      originHost = make_shared<string>(boost::any_cast<string>(m["OriginHost"]));
    }
    if (m.find("OriginHttpPort") != m.end() && !m["OriginHttpPort"].empty()) {
      originHttpPort = make_shared<string>(boost::any_cast<string>(m["OriginHttpPort"]));
    }
    if (m.find("OriginHttpsPort") != m.end() && !m["OriginHttpsPort"].empty()) {
      originHttpsPort = make_shared<string>(boost::any_cast<string>(m["OriginHttpsPort"]));
    }
    if (m.find("OriginScheme") != m.end() && !m["OriginScheme"].empty()) {
      originScheme = make_shared<string>(boost::any_cast<string>(m["OriginScheme"]));
    }
    if (m.find("OriginSni") != m.end() && !m["OriginSni"].empty()) {
      originSni = make_shared<string>(boost::any_cast<string>(m["OriginSni"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      range = make_shared<string>(boost::any_cast<string>(m["Range"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsOriginRules() = default;
};
class ListSiteFunctionsResponseBodyConfigsRedirectRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> reserveQueryString{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> type{};

  ListSiteFunctionsResponseBodyConfigsRedirectRules() {}

  explicit ListSiteFunctionsResponseBodyConfigsRedirectRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (reserveQueryString) {
      res["ReserveQueryString"] = boost::any(*reserveQueryString);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("ReserveQueryString") != m.end() && !m["ReserveQueryString"].empty()) {
      reserveQueryString = make_shared<string>(boost::any_cast<string>(m["ReserveQueryString"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsRedirectRules() = default;
};
class ListSiteFunctionsResponseBodyConfigsRewriteUrlRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> queryString{};
  shared_ptr<string> rewriteQueryStringType{};
  shared_ptr<string> rewriteUriType{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> sequence{};
  shared_ptr<string> uri{};

  ListSiteFunctionsResponseBodyConfigsRewriteUrlRules() {}

  explicit ListSiteFunctionsResponseBodyConfigsRewriteUrlRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (queryString) {
      res["QueryString"] = boost::any(*queryString);
    }
    if (rewriteQueryStringType) {
      res["RewriteQueryStringType"] = boost::any(*rewriteQueryStringType);
    }
    if (rewriteUriType) {
      res["RewriteUriType"] = boost::any(*rewriteUriType);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("QueryString") != m.end() && !m["QueryString"].empty()) {
      queryString = make_shared<string>(boost::any_cast<string>(m["QueryString"]));
    }
    if (m.find("RewriteQueryStringType") != m.end() && !m["RewriteQueryStringType"].empty()) {
      rewriteQueryStringType = make_shared<string>(boost::any_cast<string>(m["RewriteQueryStringType"]));
    }
    if (m.find("RewriteUriType") != m.end() && !m["RewriteUriType"].empty()) {
      rewriteUriType = make_shared<string>(boost::any_cast<string>(m["RewriteUriType"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsRewriteUrlRules() = default;
};
class ListSiteFunctionsResponseBodyConfigsSeoBypass : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsSeoBypass() {}

  explicit ListSiteFunctionsResponseBodyConfigsSeoBypass(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsSeoBypass() = default;
};
class ListSiteFunctionsResponseBodyConfigsSiteNameExclusive : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsSiteNameExclusive() {}

  explicit ListSiteFunctionsResponseBodyConfigsSiteNameExclusive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsSiteNameExclusive() = default;
};
class ListSiteFunctionsResponseBodyConfigsSitePause : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> paused{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsSitePause() {}

  explicit ListSiteFunctionsResponseBodyConfigsSitePause(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (paused) {
      res["Paused"] = boost::any(*paused);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Paused") != m.end() && !m["Paused"].empty()) {
      paused = make_shared<string>(boost::any_cast<string>(m["Paused"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsSitePause() = default;
};
class ListSiteFunctionsResponseBodyConfigsTieredCache : public Darabonba::Model {
public:
  shared_ptr<string> cacheArchitectureMode{};
  shared_ptr<long> configId{};
  shared_ptr<string> sequence{};

  ListSiteFunctionsResponseBodyConfigsTieredCache() {}

  explicit ListSiteFunctionsResponseBodyConfigsTieredCache(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheArchitectureMode) {
      res["CacheArchitectureMode"] = boost::any(*cacheArchitectureMode);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheArchitectureMode") != m.end() && !m["CacheArchitectureMode"].empty()) {
      cacheArchitectureMode = make_shared<string>(boost::any_cast<string>(m["CacheArchitectureMode"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigsTieredCache() = default;
};
class ListSiteFunctionsResponseBodyConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsCacheReserve>> cacheReserve{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsCacheRules>> cacheRules{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsCacheTags>> cacheTags{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsCnameFlattening>> cnameFlattening{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsCompressionRules>> compressionRules{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization>> crossBorderOptimization{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsDevelopmentMode>> developmentMode{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules>> httpRequestHeaderModificationRules{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules>> httpResponseHeaderModificationRules{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration>> httpsApplicationConfiguration{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration>> httpsBasicConfiguration{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsImageTransform>> imageTransform{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsIpv6>> ipv6{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsManagedTransforms>> managedTransforms{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsNetworkOptimization>> networkOptimization{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsOriginRules>> originRules{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsRedirectRules>> redirectRules{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsRewriteUrlRules>> rewriteUrlRules{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsSeoBypass>> seoBypass{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsSiteNameExclusive>> siteNameExclusive{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsSitePause>> sitePause{};
  shared_ptr<vector<ListSiteFunctionsResponseBodyConfigsTieredCache>> tieredCache{};

  ListSiteFunctionsResponseBodyConfigs() {}

  explicit ListSiteFunctionsResponseBodyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheReserve) {
      vector<boost::any> temp1;
      for(auto item1:*cacheReserve){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheReserve"] = boost::any(temp1);
    }
    if (cacheRules) {
      vector<boost::any> temp1;
      for(auto item1:*cacheRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheRules"] = boost::any(temp1);
    }
    if (cacheTags) {
      vector<boost::any> temp1;
      for(auto item1:*cacheTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheTags"] = boost::any(temp1);
    }
    if (cnameFlattening) {
      vector<boost::any> temp1;
      for(auto item1:*cnameFlattening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CnameFlattening"] = boost::any(temp1);
    }
    if (compressionRules) {
      vector<boost::any> temp1;
      for(auto item1:*compressionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CompressionRules"] = boost::any(temp1);
    }
    if (crossBorderOptimization) {
      vector<boost::any> temp1;
      for(auto item1:*crossBorderOptimization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CrossBorderOptimization"] = boost::any(temp1);
    }
    if (developmentMode) {
      vector<boost::any> temp1;
      for(auto item1:*developmentMode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DevelopmentMode"] = boost::any(temp1);
    }
    if (httpRequestHeaderModificationRules) {
      vector<boost::any> temp1;
      for(auto item1:*httpRequestHeaderModificationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpRequestHeaderModificationRules"] = boost::any(temp1);
    }
    if (httpResponseHeaderModificationRules) {
      vector<boost::any> temp1;
      for(auto item1:*httpResponseHeaderModificationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpResponseHeaderModificationRules"] = boost::any(temp1);
    }
    if (httpsApplicationConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*httpsApplicationConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpsApplicationConfiguration"] = boost::any(temp1);
    }
    if (httpsBasicConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*httpsBasicConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpsBasicConfiguration"] = boost::any(temp1);
    }
    if (imageTransform) {
      vector<boost::any> temp1;
      for(auto item1:*imageTransform){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageTransform"] = boost::any(temp1);
    }
    if (ipv6) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6"] = boost::any(temp1);
    }
    if (managedTransforms) {
      vector<boost::any> temp1;
      for(auto item1:*managedTransforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedTransforms"] = boost::any(temp1);
    }
    if (networkOptimization) {
      vector<boost::any> temp1;
      for(auto item1:*networkOptimization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkOptimization"] = boost::any(temp1);
    }
    if (originRules) {
      vector<boost::any> temp1;
      for(auto item1:*originRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OriginRules"] = boost::any(temp1);
    }
    if (redirectRules) {
      vector<boost::any> temp1;
      for(auto item1:*redirectRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RedirectRules"] = boost::any(temp1);
    }
    if (rewriteUrlRules) {
      vector<boost::any> temp1;
      for(auto item1:*rewriteUrlRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RewriteUrlRules"] = boost::any(temp1);
    }
    if (seoBypass) {
      vector<boost::any> temp1;
      for(auto item1:*seoBypass){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SeoBypass"] = boost::any(temp1);
    }
    if (siteNameExclusive) {
      vector<boost::any> temp1;
      for(auto item1:*siteNameExclusive){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SiteNameExclusive"] = boost::any(temp1);
    }
    if (sitePause) {
      vector<boost::any> temp1;
      for(auto item1:*sitePause){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SitePause"] = boost::any(temp1);
    }
    if (tieredCache) {
      vector<boost::any> temp1;
      for(auto item1:*tieredCache){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TieredCache"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheReserve") != m.end() && !m["CacheReserve"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheReserve"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsCacheReserve> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheReserve"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsCacheReserve model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheReserve = make_shared<vector<ListSiteFunctionsResponseBodyConfigsCacheReserve>>(expect1);
      }
    }
    if (m.find("CacheRules") != m.end() && !m["CacheRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheRules"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsCacheRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsCacheRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheRules = make_shared<vector<ListSiteFunctionsResponseBodyConfigsCacheRules>>(expect1);
      }
    }
    if (m.find("CacheTags") != m.end() && !m["CacheTags"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheTags"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsCacheTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsCacheTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheTags = make_shared<vector<ListSiteFunctionsResponseBodyConfigsCacheTags>>(expect1);
      }
    }
    if (m.find("CnameFlattening") != m.end() && !m["CnameFlattening"].empty()) {
      if (typeid(vector<boost::any>) == m["CnameFlattening"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsCnameFlattening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CnameFlattening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsCnameFlattening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cnameFlattening = make_shared<vector<ListSiteFunctionsResponseBodyConfigsCnameFlattening>>(expect1);
      }
    }
    if (m.find("CompressionRules") != m.end() && !m["CompressionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CompressionRules"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsCompressionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CompressionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsCompressionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compressionRules = make_shared<vector<ListSiteFunctionsResponseBodyConfigsCompressionRules>>(expect1);
      }
    }
    if (m.find("CrossBorderOptimization") != m.end() && !m["CrossBorderOptimization"].empty()) {
      if (typeid(vector<boost::any>) == m["CrossBorderOptimization"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CrossBorderOptimization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        crossBorderOptimization = make_shared<vector<ListSiteFunctionsResponseBodyConfigsCrossBorderOptimization>>(expect1);
      }
    }
    if (m.find("DevelopmentMode") != m.end() && !m["DevelopmentMode"].empty()) {
      if (typeid(vector<boost::any>) == m["DevelopmentMode"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsDevelopmentMode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DevelopmentMode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsDevelopmentMode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        developmentMode = make_shared<vector<ListSiteFunctionsResponseBodyConfigsDevelopmentMode>>(expect1);
      }
    }
    if (m.find("HttpRequestHeaderModificationRules") != m.end() && !m["HttpRequestHeaderModificationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpRequestHeaderModificationRules"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpRequestHeaderModificationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpRequestHeaderModificationRules = make_shared<vector<ListSiteFunctionsResponseBodyConfigsHttpRequestHeaderModificationRules>>(expect1);
      }
    }
    if (m.find("HttpResponseHeaderModificationRules") != m.end() && !m["HttpResponseHeaderModificationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpResponseHeaderModificationRules"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpResponseHeaderModificationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpResponseHeaderModificationRules = make_shared<vector<ListSiteFunctionsResponseBodyConfigsHttpResponseHeaderModificationRules>>(expect1);
      }
    }
    if (m.find("HttpsApplicationConfiguration") != m.end() && !m["HttpsApplicationConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpsApplicationConfiguration"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpsApplicationConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpsApplicationConfiguration = make_shared<vector<ListSiteFunctionsResponseBodyConfigsHttpsApplicationConfiguration>>(expect1);
      }
    }
    if (m.find("HttpsBasicConfiguration") != m.end() && !m["HttpsBasicConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpsBasicConfiguration"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpsBasicConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpsBasicConfiguration = make_shared<vector<ListSiteFunctionsResponseBodyConfigsHttpsBasicConfiguration>>(expect1);
      }
    }
    if (m.find("ImageTransform") != m.end() && !m["ImageTransform"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageTransform"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsImageTransform> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageTransform"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsImageTransform model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageTransform = make_shared<vector<ListSiteFunctionsResponseBodyConfigsImageTransform>>(expect1);
      }
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsIpv6> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsIpv6 model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6 = make_shared<vector<ListSiteFunctionsResponseBodyConfigsIpv6>>(expect1);
      }
    }
    if (m.find("ManagedTransforms") != m.end() && !m["ManagedTransforms"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedTransforms"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsManagedTransforms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedTransforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsManagedTransforms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedTransforms = make_shared<vector<ListSiteFunctionsResponseBodyConfigsManagedTransforms>>(expect1);
      }
    }
    if (m.find("NetworkOptimization") != m.end() && !m["NetworkOptimization"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkOptimization"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsNetworkOptimization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkOptimization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsNetworkOptimization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkOptimization = make_shared<vector<ListSiteFunctionsResponseBodyConfigsNetworkOptimization>>(expect1);
      }
    }
    if (m.find("OriginRules") != m.end() && !m["OriginRules"].empty()) {
      if (typeid(vector<boost::any>) == m["OriginRules"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsOriginRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OriginRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsOriginRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        originRules = make_shared<vector<ListSiteFunctionsResponseBodyConfigsOriginRules>>(expect1);
      }
    }
    if (m.find("RedirectRules") != m.end() && !m["RedirectRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RedirectRules"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsRedirectRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RedirectRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsRedirectRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        redirectRules = make_shared<vector<ListSiteFunctionsResponseBodyConfigsRedirectRules>>(expect1);
      }
    }
    if (m.find("RewriteUrlRules") != m.end() && !m["RewriteUrlRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RewriteUrlRules"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsRewriteUrlRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RewriteUrlRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsRewriteUrlRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rewriteUrlRules = make_shared<vector<ListSiteFunctionsResponseBodyConfigsRewriteUrlRules>>(expect1);
      }
    }
    if (m.find("SeoBypass") != m.end() && !m["SeoBypass"].empty()) {
      if (typeid(vector<boost::any>) == m["SeoBypass"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsSeoBypass> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SeoBypass"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsSeoBypass model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        seoBypass = make_shared<vector<ListSiteFunctionsResponseBodyConfigsSeoBypass>>(expect1);
      }
    }
    if (m.find("SiteNameExclusive") != m.end() && !m["SiteNameExclusive"].empty()) {
      if (typeid(vector<boost::any>) == m["SiteNameExclusive"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsSiteNameExclusive> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SiteNameExclusive"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsSiteNameExclusive model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        siteNameExclusive = make_shared<vector<ListSiteFunctionsResponseBodyConfigsSiteNameExclusive>>(expect1);
      }
    }
    if (m.find("SitePause") != m.end() && !m["SitePause"].empty()) {
      if (typeid(vector<boost::any>) == m["SitePause"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsSitePause> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SitePause"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsSitePause model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sitePause = make_shared<vector<ListSiteFunctionsResponseBodyConfigsSitePause>>(expect1);
      }
    }
    if (m.find("TieredCache") != m.end() && !m["TieredCache"].empty()) {
      if (typeid(vector<boost::any>) == m["TieredCache"].type()) {
        vector<ListSiteFunctionsResponseBodyConfigsTieredCache> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TieredCache"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSiteFunctionsResponseBodyConfigsTieredCache model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tieredCache = make_shared<vector<ListSiteFunctionsResponseBodyConfigsTieredCache>>(expect1);
      }
    }
  }


  virtual ~ListSiteFunctionsResponseBodyConfigs() = default;
};
class ListSiteFunctionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSiteFunctionsResponseBodyConfigs> configs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPage{};

  ListSiteFunctionsResponseBody() {}

  explicit ListSiteFunctionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      res["Configs"] = configs ? boost::any(configs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Configs"].type()) {
        ListSiteFunctionsResponseBodyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Configs"]));
        configs = make_shared<ListSiteFunctionsResponseBodyConfigs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~ListSiteFunctionsResponseBody() = default;
};
class ListSiteFunctionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSiteFunctionsResponseBody> body{};

  ListSiteFunctionsResponse() {}

  explicit ListSiteFunctionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSiteFunctionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSiteFunctionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSiteFunctionsResponse() = default;
};
class ListSitesRequestTagFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListSitesRequestTagFilter() {}

  explicit ListSitesRequestTagFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListSitesRequestTagFilter() = default;
};
class ListSitesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> coverage{};
  shared_ptr<bool> onlyEnterprise{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> planSubscribeType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> siteSearchType{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListSitesRequestTagFilter>> tagFilter{};

  ListSitesRequest() {}

  explicit ListSitesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (onlyEnterprise) {
      res["OnlyEnterprise"] = boost::any(*onlyEnterprise);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (planSubscribeType) {
      res["PlanSubscribeType"] = boost::any(*planSubscribeType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (siteSearchType) {
      res["SiteSearchType"] = boost::any(*siteSearchType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tagFilter) {
      vector<boost::any> temp1;
      for(auto item1:*tagFilter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagFilter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("OnlyEnterprise") != m.end() && !m["OnlyEnterprise"].empty()) {
      onlyEnterprise = make_shared<bool>(boost::any_cast<bool>(m["OnlyEnterprise"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlanSubscribeType") != m.end() && !m["PlanSubscribeType"].empty()) {
      planSubscribeType = make_shared<string>(boost::any_cast<string>(m["PlanSubscribeType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("SiteSearchType") != m.end() && !m["SiteSearchType"].empty()) {
      siteSearchType = make_shared<string>(boost::any_cast<string>(m["SiteSearchType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TagFilter") != m.end() && !m["TagFilter"].empty()) {
      if (typeid(vector<boost::any>) == m["TagFilter"].type()) {
        vector<ListSitesRequestTagFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagFilter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSitesRequestTagFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagFilter = make_shared<vector<ListSitesRequestTagFilter>>(expect1);
      }
    }
  }


  virtual ~ListSitesRequest() = default;
};
class ListSitesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> coverage{};
  shared_ptr<bool> onlyEnterprise{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> planSubscribeType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> siteSearchType{};
  shared_ptr<string> status{};
  shared_ptr<string> tagFilterShrink{};

  ListSitesShrinkRequest() {}

  explicit ListSitesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (onlyEnterprise) {
      res["OnlyEnterprise"] = boost::any(*onlyEnterprise);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (planSubscribeType) {
      res["PlanSubscribeType"] = boost::any(*planSubscribeType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (siteSearchType) {
      res["SiteSearchType"] = boost::any(*siteSearchType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tagFilterShrink) {
      res["TagFilter"] = boost::any(*tagFilterShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("OnlyEnterprise") != m.end() && !m["OnlyEnterprise"].empty()) {
      onlyEnterprise = make_shared<bool>(boost::any_cast<bool>(m["OnlyEnterprise"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlanSubscribeType") != m.end() && !m["PlanSubscribeType"].empty()) {
      planSubscribeType = make_shared<string>(boost::any_cast<string>(m["PlanSubscribeType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("SiteSearchType") != m.end() && !m["SiteSearchType"].empty()) {
      siteSearchType = make_shared<string>(boost::any_cast<string>(m["SiteSearchType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TagFilter") != m.end() && !m["TagFilter"].empty()) {
      tagFilterShrink = make_shared<string>(boost::any_cast<string>(m["TagFilter"]));
    }
  }


  virtual ~ListSitesShrinkRequest() = default;
};
class ListSitesResponseBodySites : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> cnameZone{};
  shared_ptr<string> coverage{};
  shared_ptr<string> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nameServerList{};
  shared_ptr<string> planName{};
  shared_ptr<string> planSpecName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> verifyCode{};
  shared_ptr<string> visitTime{};

  ListSitesResponseBodySites() {}

  explicit ListSitesResponseBodySites(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (cnameZone) {
      res["CnameZone"] = boost::any(*cnameZone);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nameServerList) {
      res["NameServerList"] = boost::any(*nameServerList);
    }
    if (planName) {
      res["PlanName"] = boost::any(*planName);
    }
    if (planSpecName) {
      res["PlanSpecName"] = boost::any(*planSpecName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (verifyCode) {
      res["VerifyCode"] = boost::any(*verifyCode);
    }
    if (visitTime) {
      res["VisitTime"] = boost::any(*visitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("CnameZone") != m.end() && !m["CnameZone"].empty()) {
      cnameZone = make_shared<string>(boost::any_cast<string>(m["CnameZone"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NameServerList") != m.end() && !m["NameServerList"].empty()) {
      nameServerList = make_shared<string>(boost::any_cast<string>(m["NameServerList"]));
    }
    if (m.find("PlanName") != m.end() && !m["PlanName"].empty()) {
      planName = make_shared<string>(boost::any_cast<string>(m["PlanName"]));
    }
    if (m.find("PlanSpecName") != m.end() && !m["PlanSpecName"].empty()) {
      planSpecName = make_shared<string>(boost::any_cast<string>(m["PlanSpecName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VerifyCode") != m.end() && !m["VerifyCode"].empty()) {
      verifyCode = make_shared<string>(boost::any_cast<string>(m["VerifyCode"]));
    }
    if (m.find("VisitTime") != m.end() && !m["VisitTime"].empty()) {
      visitTime = make_shared<string>(boost::any_cast<string>(m["VisitTime"]));
    }
  }


  virtual ~ListSitesResponseBodySites() = default;
};
class ListSitesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSitesResponseBodySites>> sites{};
  shared_ptr<long> totalCount{};

  ListSitesResponseBody() {}

  explicit ListSitesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sites) {
      vector<boost::any> temp1;
      for(auto item1:*sites){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sites"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sites") != m.end() && !m["Sites"].empty()) {
      if (typeid(vector<boost::any>) == m["Sites"].type()) {
        vector<ListSitesResponseBodySites> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sites"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSitesResponseBodySites model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sites = make_shared<vector<ListSitesResponseBodySites>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSitesResponseBody() = default;
};
class ListSitesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSitesResponseBody> body{};

  ListSitesResponse() {}

  explicit ListSitesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSitesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSitesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSitesResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxItem{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxItem) {
      res["MaxItem"] = boost::any(*maxItem);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxItem") != m.end() && !m["MaxItem"].empty()) {
      maxItem = make_shared<long>(boost::any_cast<long>(m["MaxItem"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};
  shared_ptr<long> totalCount{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListUploadTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> siteId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  ListUploadTasksRequest() {}

  explicit ListUploadTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListUploadTasksRequest() = default;
};
class ListUploadTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> uploadId{};
  shared_ptr<string> uploadTaskName{};

  ListUploadTasksResponseBodyTasks() {}

  explicit ListUploadTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uploadId) {
      res["UploadId"] = boost::any(*uploadId);
    }
    if (uploadTaskName) {
      res["UploadTaskName"] = boost::any(*uploadTaskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UploadId") != m.end() && !m["UploadId"].empty()) {
      uploadId = make_shared<string>(boost::any_cast<string>(m["UploadId"]));
    }
    if (m.find("UploadTaskName") != m.end() && !m["UploadTaskName"].empty()) {
      uploadTaskName = make_shared<string>(boost::any_cast<string>(m["UploadTaskName"]));
    }
  }


  virtual ~ListUploadTasksResponseBodyTasks() = default;
};
class ListUploadTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListUploadTasksResponseBodyTasks>> tasks{};

  ListUploadTasksResponseBody() {}

  explicit ListUploadTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListUploadTasksResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUploadTasksResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListUploadTasksResponseBodyTasks>>(expect1);
      }
    }
  }


  virtual ~ListUploadTasksResponseBody() = default;
};
class ListUploadTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUploadTasksResponseBody> body{};

  ListUploadTasksResponse() {}

  explicit ListUploadTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUploadTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUploadTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListUploadTasksResponse() = default;
};
class ListUserDeliveryTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListUserDeliveryTasksRequest() {}

  explicit ListUserDeliveryTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListUserDeliveryTasksRequest() = default;
};
class ListUserDeliveryTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deliveryType{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  ListUserDeliveryTasksResponseBodyTasks() {}

  explicit ListUserDeliveryTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deliveryType) {
      res["DeliveryType"] = boost::any(*deliveryType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeliveryType") != m.end() && !m["DeliveryType"].empty()) {
      deliveryType = make_shared<string>(boost::any_cast<string>(m["DeliveryType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ListUserDeliveryTasksResponseBodyTasks() = default;
};
class ListUserDeliveryTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListUserDeliveryTasksResponseBodyTasks>> tasks{};
  shared_ptr<long> totalCount{};

  ListUserDeliveryTasksResponseBody() {}

  explicit ListUserDeliveryTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListUserDeliveryTasksResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserDeliveryTasksResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListUserDeliveryTasksResponseBodyTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUserDeliveryTasksResponseBody() = default;
};
class ListUserDeliveryTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserDeliveryTasksResponseBody> body{};

  ListUserDeliveryTasksResponse() {}

  explicit ListUserDeliveryTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserDeliveryTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserDeliveryTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserDeliveryTasksResponse() = default;
};
class ListUserRatePlanInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkRemainingSiteQuota{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> remainingExpireDays{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> status{};

  ListUserRatePlanInstancesRequest() {}

  explicit ListUserRatePlanInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkRemainingSiteQuota) {
      res["CheckRemainingSiteQuota"] = boost::any(*checkRemainingSiteQuota);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remainingExpireDays) {
      res["RemainingExpireDays"] = boost::any(*remainingExpireDays);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckRemainingSiteQuota") != m.end() && !m["CheckRemainingSiteQuota"].empty()) {
      checkRemainingSiteQuota = make_shared<string>(boost::any_cast<string>(m["CheckRemainingSiteQuota"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RemainingExpireDays") != m.end() && !m["RemainingExpireDays"].empty()) {
      remainingExpireDays = make_shared<long>(boost::any_cast<long>(m["RemainingExpireDays"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListUserRatePlanInstancesRequest() = default;
};
class ListUserRatePlanInstancesResponseBodyInstanceInfoSites : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};
  shared_ptr<string> siteStatus{};

  ListUserRatePlanInstancesResponseBodyInstanceInfoSites() {}

  explicit ListUserRatePlanInstancesResponseBodyInstanceInfoSites(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    if (siteStatus) {
      res["SiteStatus"] = boost::any(*siteStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
    if (m.find("SiteStatus") != m.end() && !m["SiteStatus"].empty()) {
      siteStatus = make_shared<string>(boost::any_cast<string>(m["SiteStatus"]));
    }
  }


  virtual ~ListUserRatePlanInstancesResponseBodyInstanceInfoSites() = default;
};
class ListUserRatePlanInstancesResponseBodyInstanceInfo : public Darabonba::Model {
public:
  shared_ptr<string> billingMode{};
  shared_ptr<string> botInstanceLevel{};
  shared_ptr<string> coverages{};
  shared_ptr<string> createTime{};
  shared_ptr<string> crossborderTraffic{};
  shared_ptr<string> ddosBurstableDomesticProtection{};
  shared_ptr<string> ddosBurstableOverseasProtection{};
  shared_ptr<string> ddosInstanceLevel{};
  shared_ptr<long> duration{};
  shared_ptr<string> edgeRoutineRquest{};
  shared_ptr<string> edgeWafRequest{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> layer4Traffic{};
  shared_ptr<string> layer4TrafficIntl{};
  shared_ptr<string> planName{};
  shared_ptr<string> planTraffic{};
  shared_ptr<string> planType{};
  shared_ptr<string> siteQuota{};
  shared_ptr<vector<ListUserRatePlanInstancesResponseBodyInstanceInfoSites>> sites{};
  shared_ptr<string> smartRoutingRequest{};
  shared_ptr<string> staticRequest{};
  shared_ptr<string> status{};

  ListUserRatePlanInstancesResponseBodyInstanceInfo() {}

  explicit ListUserRatePlanInstancesResponseBodyInstanceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingMode) {
      res["BillingMode"] = boost::any(*billingMode);
    }
    if (botInstanceLevel) {
      res["BotInstanceLevel"] = boost::any(*botInstanceLevel);
    }
    if (coverages) {
      res["Coverages"] = boost::any(*coverages);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (crossborderTraffic) {
      res["CrossborderTraffic"] = boost::any(*crossborderTraffic);
    }
    if (ddosBurstableDomesticProtection) {
      res["DdosBurstableDomesticProtection"] = boost::any(*ddosBurstableDomesticProtection);
    }
    if (ddosBurstableOverseasProtection) {
      res["DdosBurstableOverseasProtection"] = boost::any(*ddosBurstableOverseasProtection);
    }
    if (ddosInstanceLevel) {
      res["DdosInstanceLevel"] = boost::any(*ddosInstanceLevel);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (edgeRoutineRquest) {
      res["EdgeRoutineRquest"] = boost::any(*edgeRoutineRquest);
    }
    if (edgeWafRequest) {
      res["EdgeWafRequest"] = boost::any(*edgeWafRequest);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (layer4Traffic) {
      res["Layer4Traffic"] = boost::any(*layer4Traffic);
    }
    if (layer4TrafficIntl) {
      res["Layer4TrafficIntl"] = boost::any(*layer4TrafficIntl);
    }
    if (planName) {
      res["PlanName"] = boost::any(*planName);
    }
    if (planTraffic) {
      res["PlanTraffic"] = boost::any(*planTraffic);
    }
    if (planType) {
      res["PlanType"] = boost::any(*planType);
    }
    if (siteQuota) {
      res["SiteQuota"] = boost::any(*siteQuota);
    }
    if (sites) {
      vector<boost::any> temp1;
      for(auto item1:*sites){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sites"] = boost::any(temp1);
    }
    if (smartRoutingRequest) {
      res["SmartRoutingRequest"] = boost::any(*smartRoutingRequest);
    }
    if (staticRequest) {
      res["StaticRequest"] = boost::any(*staticRequest);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingMode") != m.end() && !m["BillingMode"].empty()) {
      billingMode = make_shared<string>(boost::any_cast<string>(m["BillingMode"]));
    }
    if (m.find("BotInstanceLevel") != m.end() && !m["BotInstanceLevel"].empty()) {
      botInstanceLevel = make_shared<string>(boost::any_cast<string>(m["BotInstanceLevel"]));
    }
    if (m.find("Coverages") != m.end() && !m["Coverages"].empty()) {
      coverages = make_shared<string>(boost::any_cast<string>(m["Coverages"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CrossborderTraffic") != m.end() && !m["CrossborderTraffic"].empty()) {
      crossborderTraffic = make_shared<string>(boost::any_cast<string>(m["CrossborderTraffic"]));
    }
    if (m.find("DdosBurstableDomesticProtection") != m.end() && !m["DdosBurstableDomesticProtection"].empty()) {
      ddosBurstableDomesticProtection = make_shared<string>(boost::any_cast<string>(m["DdosBurstableDomesticProtection"]));
    }
    if (m.find("DdosBurstableOverseasProtection") != m.end() && !m["DdosBurstableOverseasProtection"].empty()) {
      ddosBurstableOverseasProtection = make_shared<string>(boost::any_cast<string>(m["DdosBurstableOverseasProtection"]));
    }
    if (m.find("DdosInstanceLevel") != m.end() && !m["DdosInstanceLevel"].empty()) {
      ddosInstanceLevel = make_shared<string>(boost::any_cast<string>(m["DdosInstanceLevel"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EdgeRoutineRquest") != m.end() && !m["EdgeRoutineRquest"].empty()) {
      edgeRoutineRquest = make_shared<string>(boost::any_cast<string>(m["EdgeRoutineRquest"]));
    }
    if (m.find("EdgeWafRequest") != m.end() && !m["EdgeWafRequest"].empty()) {
      edgeWafRequest = make_shared<string>(boost::any_cast<string>(m["EdgeWafRequest"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Layer4Traffic") != m.end() && !m["Layer4Traffic"].empty()) {
      layer4Traffic = make_shared<string>(boost::any_cast<string>(m["Layer4Traffic"]));
    }
    if (m.find("Layer4TrafficIntl") != m.end() && !m["Layer4TrafficIntl"].empty()) {
      layer4TrafficIntl = make_shared<string>(boost::any_cast<string>(m["Layer4TrafficIntl"]));
    }
    if (m.find("PlanName") != m.end() && !m["PlanName"].empty()) {
      planName = make_shared<string>(boost::any_cast<string>(m["PlanName"]));
    }
    if (m.find("PlanTraffic") != m.end() && !m["PlanTraffic"].empty()) {
      planTraffic = make_shared<string>(boost::any_cast<string>(m["PlanTraffic"]));
    }
    if (m.find("PlanType") != m.end() && !m["PlanType"].empty()) {
      planType = make_shared<string>(boost::any_cast<string>(m["PlanType"]));
    }
    if (m.find("SiteQuota") != m.end() && !m["SiteQuota"].empty()) {
      siteQuota = make_shared<string>(boost::any_cast<string>(m["SiteQuota"]));
    }
    if (m.find("Sites") != m.end() && !m["Sites"].empty()) {
      if (typeid(vector<boost::any>) == m["Sites"].type()) {
        vector<ListUserRatePlanInstancesResponseBodyInstanceInfoSites> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sites"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserRatePlanInstancesResponseBodyInstanceInfoSites model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sites = make_shared<vector<ListUserRatePlanInstancesResponseBodyInstanceInfoSites>>(expect1);
      }
    }
    if (m.find("SmartRoutingRequest") != m.end() && !m["SmartRoutingRequest"].empty()) {
      smartRoutingRequest = make_shared<string>(boost::any_cast<string>(m["SmartRoutingRequest"]));
    }
    if (m.find("StaticRequest") != m.end() && !m["StaticRequest"].empty()) {
      staticRequest = make_shared<string>(boost::any_cast<string>(m["StaticRequest"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListUserRatePlanInstancesResponseBodyInstanceInfo() = default;
};
class ListUserRatePlanInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserRatePlanInstancesResponseBodyInstanceInfo>> instanceInfo{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPage{};

  ListUserRatePlanInstancesResponseBody() {}

  explicit ListUserRatePlanInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*instanceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceInfo"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceInfo") != m.end() && !m["InstanceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceInfo"].type()) {
        vector<ListUserRatePlanInstancesResponseBodyInstanceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserRatePlanInstancesResponseBodyInstanceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceInfo = make_shared<vector<ListUserRatePlanInstancesResponseBodyInstanceInfo>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~ListUserRatePlanInstancesResponseBody() = default;
};
class ListUserRatePlanInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserRatePlanInstancesResponseBody> body{};

  ListUserRatePlanInstancesResponse() {}

  explicit ListUserRatePlanInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserRatePlanInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserRatePlanInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserRatePlanInstancesResponse() = default;
};
class ListWafManagedRulesRequestQueryArgs : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> idNameLike{};
  shared_ptr<vector<long>> protectionLevels{};
  shared_ptr<string> status{};

  ListWafManagedRulesRequestQueryArgs() {}

  explicit ListWafManagedRulesRequestQueryArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (idNameLike) {
      res["IdNameLike"] = boost::any(*idNameLike);
    }
    if (protectionLevels) {
      res["ProtectionLevels"] = boost::any(*protectionLevels);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("IdNameLike") != m.end() && !m["IdNameLike"].empty()) {
      idNameLike = make_shared<string>(boost::any_cast<string>(m["IdNameLike"]));
    }
    if (m.find("ProtectionLevels") != m.end() && !m["ProtectionLevels"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProtectionLevels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProtectionLevels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      protectionLevels = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListWafManagedRulesRequestQueryArgs() = default;
};
class ListWafManagedRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> attackType{};
  shared_ptr<long> id{};
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> protectionLevel{};
  shared_ptr<ListWafManagedRulesRequestQueryArgs> queryArgs{};
  shared_ptr<long> siteId{};

  ListWafManagedRulesRequest() {}

  explicit ListWafManagedRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackType) {
      res["AttackType"] = boost::any(*attackType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (protectionLevel) {
      res["ProtectionLevel"] = boost::any(*protectionLevel);
    }
    if (queryArgs) {
      res["QueryArgs"] = queryArgs ? boost::any(queryArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackType") != m.end() && !m["AttackType"].empty()) {
      attackType = make_shared<long>(boost::any_cast<long>(m["AttackType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProtectionLevel") != m.end() && !m["ProtectionLevel"].empty()) {
      protectionLevel = make_shared<long>(boost::any_cast<long>(m["ProtectionLevel"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryArgs"].type()) {
        ListWafManagedRulesRequestQueryArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryArgs"]));
        queryArgs = make_shared<ListWafManagedRulesRequestQueryArgs>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListWafManagedRulesRequest() = default;
};
class ListWafManagedRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> attackType{};
  shared_ptr<long> id{};
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> protectionLevel{};
  shared_ptr<string> queryArgsShrink{};
  shared_ptr<long> siteId{};

  ListWafManagedRulesShrinkRequest() {}

  explicit ListWafManagedRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackType) {
      res["AttackType"] = boost::any(*attackType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (protectionLevel) {
      res["ProtectionLevel"] = boost::any(*protectionLevel);
    }
    if (queryArgsShrink) {
      res["QueryArgs"] = boost::any(*queryArgsShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackType") != m.end() && !m["AttackType"].empty()) {
      attackType = make_shared<long>(boost::any_cast<long>(m["AttackType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProtectionLevel") != m.end() && !m["ProtectionLevel"].empty()) {
      protectionLevel = make_shared<long>(boost::any_cast<long>(m["ProtectionLevel"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgsShrink = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListWafManagedRulesShrinkRequest() = default;
};
class ListWafManagedRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> protectionLevel{};
  shared_ptr<string> status{};

  ListWafManagedRulesResponseBodyRules() {}

  explicit ListWafManagedRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protectionLevel) {
      res["ProtectionLevel"] = boost::any(*protectionLevel);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProtectionLevel") != m.end() && !m["ProtectionLevel"].empty()) {
      protectionLevel = make_shared<long>(boost::any_cast<long>(m["ProtectionLevel"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListWafManagedRulesResponseBodyRules() = default;
};
class ListWafManagedRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWafManagedRulesResponseBodyRules>> rules{};
  shared_ptr<long> totalCount{};

  ListWafManagedRulesResponseBody() {}

  explicit ListWafManagedRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListWafManagedRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWafManagedRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListWafManagedRulesResponseBodyRules>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListWafManagedRulesResponseBody() = default;
};
class ListWafManagedRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWafManagedRulesResponseBody> body{};

  ListWafManagedRulesResponse() {}

  explicit ListWafManagedRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWafManagedRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWafManagedRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWafManagedRulesResponse() = default;
};
class ListWafPhasesRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  ListWafPhasesRequest() {}

  explicit ListWafPhasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~ListWafPhasesRequest() = default;
};
class ListWafPhasesResponseBodyPhasesRulesets : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<WafRuleConfig>> rules{};
  shared_ptr<WafBatchRuleShared> shared{};

  ListWafPhasesResponseBodyPhasesRulesets() {}

  explicit ListWafPhasesResponseBodyPhasesRulesets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (shared) {
      res["Shared"] = shared ? boost::any(shared->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<WafRuleConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WafRuleConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<WafRuleConfig>>(expect1);
      }
    }
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      if (typeid(map<string, boost::any>) == m["Shared"].type()) {
        WafBatchRuleShared model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Shared"]));
        shared = make_shared<WafBatchRuleShared>(model1);
      }
    }
  }


  virtual ~ListWafPhasesResponseBodyPhasesRulesets() = default;
};
class ListWafPhasesResponseBodyPhases : public Darabonba::Model {
public:
  shared_ptr<string> phase{};
  shared_ptr<vector<ListWafPhasesResponseBodyPhasesRulesets>> rulesets{};

  ListWafPhasesResponseBodyPhases() {}

  explicit ListWafPhasesResponseBodyPhases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (rulesets) {
      vector<boost::any> temp1;
      for(auto item1:*rulesets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rulesets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("Rulesets") != m.end() && !m["Rulesets"].empty()) {
      if (typeid(vector<boost::any>) == m["Rulesets"].type()) {
        vector<ListWafPhasesResponseBodyPhasesRulesets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rulesets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWafPhasesResponseBodyPhasesRulesets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rulesets = make_shared<vector<ListWafPhasesResponseBodyPhasesRulesets>>(expect1);
      }
    }
  }


  virtual ~ListWafPhasesResponseBodyPhases() = default;
};
class ListWafPhasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListWafPhasesResponseBodyPhases>> phases{};
  shared_ptr<string> requestId{};

  ListWafPhasesResponseBody() {}

  explicit ListWafPhasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phases) {
      vector<boost::any> temp1;
      for(auto item1:*phases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Phases"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Phases") != m.end() && !m["Phases"].empty()) {
      if (typeid(vector<boost::any>) == m["Phases"].type()) {
        vector<ListWafPhasesResponseBodyPhases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Phases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWafPhasesResponseBodyPhases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phases = make_shared<vector<ListWafPhasesResponseBodyPhases>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListWafPhasesResponseBody() = default;
};
class ListWafPhasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWafPhasesResponseBody> body{};

  ListWafPhasesResponse() {}

  explicit ListWafPhasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWafPhasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWafPhasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWafPhasesResponse() = default;
};
class ListWafRulesRequestQueryArgs : public Darabonba::Model {
public:
  shared_ptr<bool> desc{};
  shared_ptr<long> id{};
  shared_ptr<string> idNameLike{};
  shared_ptr<string> nameLike{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> rulesetId{};
  shared_ptr<string> status{};

  ListWafRulesRequestQueryArgs() {}

  explicit ListWafRulesRequestQueryArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idNameLike) {
      res["IdNameLike"] = boost::any(*idNameLike);
    }
    if (nameLike) {
      res["NameLike"] = boost::any(*nameLike);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (rulesetId) {
      res["RulesetId"] = boost::any(*rulesetId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<bool>(boost::any_cast<bool>(m["Desc"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IdNameLike") != m.end() && !m["IdNameLike"].empty()) {
      idNameLike = make_shared<string>(boost::any_cast<string>(m["IdNameLike"]));
    }
    if (m.find("NameLike") != m.end() && !m["NameLike"].empty()) {
      nameLike = make_shared<string>(boost::any_cast<string>(m["NameLike"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("RulesetId") != m.end() && !m["RulesetId"].empty()) {
      rulesetId = make_shared<long>(boost::any_cast<long>(m["RulesetId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListWafRulesRequestQueryArgs() = default;
};
class ListWafRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phase{};
  shared_ptr<ListWafRulesRequestQueryArgs> queryArgs{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  ListWafRulesRequest() {}

  explicit ListWafRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (queryArgs) {
      res["QueryArgs"] = queryArgs ? boost::any(queryArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryArgs"].type()) {
        ListWafRulesRequestQueryArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryArgs"]));
        queryArgs = make_shared<ListWafRulesRequestQueryArgs>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~ListWafRulesRequest() = default;
};
class ListWafRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phase{};
  shared_ptr<string> queryArgsShrink{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  ListWafRulesShrinkRequest() {}

  explicit ListWafRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (queryArgsShrink) {
      res["QueryArgs"] = boost::any(*queryArgsShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgsShrink = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~ListWafRulesShrinkRequest() = default;
};
class ListWafRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<vector<string>> characteristicsFields{};
  shared_ptr<WafRuleConfig> config{};
  shared_ptr<vector<string>> fields{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> phase{};
  shared_ptr<long> position{};
  shared_ptr<long> rulesetId{};
  shared_ptr<string> skip{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<WafTimer> timer{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};

  ListWafRulesResponseBodyRules() {}

  explicit ListWafRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (characteristicsFields) {
      res["CharacteristicsFields"] = boost::any(*characteristicsFields);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (rulesetId) {
      res["RulesetId"] = boost::any(*rulesetId);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timer) {
      res["Timer"] = timer ? boost::any(timer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("CharacteristicsFields") != m.end() && !m["CharacteristicsFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CharacteristicsFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CharacteristicsFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      characteristicsFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        WafRuleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<WafRuleConfig>(model1);
      }
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Fields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("RulesetId") != m.end() && !m["RulesetId"].empty()) {
      rulesetId = make_shared<long>(boost::any_cast<long>(m["RulesetId"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<string>(boost::any_cast<string>(m["Skip"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Timer") != m.end() && !m["Timer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timer"].type()) {
        WafTimer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timer"]));
        timer = make_shared<WafTimer>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListWafRulesResponseBodyRules() = default;
};
class ListWafRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> instanceUsage{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWafRulesResponseBodyRules>> rules{};
  shared_ptr<long> siteUsage{};
  shared_ptr<long> totalCount{};

  ListWafRulesResponseBody() {}

  explicit ListWafRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceUsage) {
      res["InstanceUsage"] = boost::any(*instanceUsage);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (siteUsage) {
      res["SiteUsage"] = boost::any(*siteUsage);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceUsage") != m.end() && !m["InstanceUsage"].empty()) {
      instanceUsage = make_shared<long>(boost::any_cast<long>(m["InstanceUsage"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListWafRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWafRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListWafRulesResponseBodyRules>>(expect1);
      }
    }
    if (m.find("SiteUsage") != m.end() && !m["SiteUsage"].empty()) {
      siteUsage = make_shared<long>(boost::any_cast<long>(m["SiteUsage"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListWafRulesResponseBody() = default;
};
class ListWafRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWafRulesResponseBody> body{};

  ListWafRulesResponse() {}

  explicit ListWafRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWafRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWafRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWafRulesResponse() = default;
};
class ListWafRulesetsRequestQueryArgs : public Darabonba::Model {
public:
  shared_ptr<string> anyLike{};
  shared_ptr<bool> desc{};
  shared_ptr<string> nameLike{};
  shared_ptr<string> orderBy{};

  ListWafRulesetsRequestQueryArgs() {}

  explicit ListWafRulesetsRequestQueryArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anyLike) {
      res["AnyLike"] = boost::any(*anyLike);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (nameLike) {
      res["NameLike"] = boost::any(*nameLike);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnyLike") != m.end() && !m["AnyLike"].empty()) {
      anyLike = make_shared<string>(boost::any_cast<string>(m["AnyLike"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<bool>(boost::any_cast<bool>(m["Desc"]));
    }
    if (m.find("NameLike") != m.end() && !m["NameLike"].empty()) {
      nameLike = make_shared<string>(boost::any_cast<string>(m["NameLike"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
  }


  virtual ~ListWafRulesetsRequestQueryArgs() = default;
};
class ListWafRulesetsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phase{};
  shared_ptr<ListWafRulesetsRequestQueryArgs> queryArgs{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  ListWafRulesetsRequest() {}

  explicit ListWafRulesetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (queryArgs) {
      res["QueryArgs"] = queryArgs ? boost::any(queryArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryArgs"].type()) {
        ListWafRulesetsRequestQueryArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryArgs"]));
        queryArgs = make_shared<ListWafRulesetsRequestQueryArgs>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~ListWafRulesetsRequest() = default;
};
class ListWafRulesetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phase{};
  shared_ptr<string> queryArgsShrink{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};

  ListWafRulesetsShrinkRequest() {}

  explicit ListWafRulesetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (queryArgsShrink) {
      res["QueryArgs"] = boost::any(*queryArgsShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgsShrink = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
  }


  virtual ~ListWafRulesetsShrinkRequest() = default;
};
class ListWafRulesetsResponseBodyRulesets : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fields{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> phase{};
  shared_ptr<string> status{};
  shared_ptr<string> target{};
  shared_ptr<vector<string>> types{};
  shared_ptr<string> updateTime{};

  ListWafRulesetsResponseBodyRulesets() {}

  explicit ListWafRulesetsResponseBodyRulesets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Fields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListWafRulesetsResponseBodyRulesets() = default;
};
class ListWafRulesetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> instanceUsage{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWafRulesetsResponseBodyRulesets>> rulesets{};
  shared_ptr<long> siteUsage{};
  shared_ptr<long> totalCount{};

  ListWafRulesetsResponseBody() {}

  explicit ListWafRulesetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceUsage) {
      res["InstanceUsage"] = boost::any(*instanceUsage);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rulesets) {
      vector<boost::any> temp1;
      for(auto item1:*rulesets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rulesets"] = boost::any(temp1);
    }
    if (siteUsage) {
      res["SiteUsage"] = boost::any(*siteUsage);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceUsage") != m.end() && !m["InstanceUsage"].empty()) {
      instanceUsage = make_shared<long>(boost::any_cast<long>(m["InstanceUsage"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rulesets") != m.end() && !m["Rulesets"].empty()) {
      if (typeid(vector<boost::any>) == m["Rulesets"].type()) {
        vector<ListWafRulesetsResponseBodyRulesets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rulesets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWafRulesetsResponseBodyRulesets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rulesets = make_shared<vector<ListWafRulesetsResponseBodyRulesets>>(expect1);
      }
    }
    if (m.find("SiteUsage") != m.end() && !m["SiteUsage"].empty()) {
      siteUsage = make_shared<long>(boost::any_cast<long>(m["SiteUsage"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListWafRulesetsResponseBody() = default;
};
class ListWafRulesetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWafRulesetsResponseBody> body{};

  ListWafRulesetsResponse() {}

  explicit ListWafRulesetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWafRulesetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWafRulesetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWafRulesetsResponse() = default;
};
class ListWafTemplateRulesRequestQueryArgs : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  ListWafTemplateRulesRequestQueryArgs() {}

  explicit ListWafTemplateRulesRequestQueryArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListWafTemplateRulesRequestQueryArgs() = default;
};
class ListWafTemplateRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> phase{};
  shared_ptr<ListWafTemplateRulesRequestQueryArgs> queryArgs{};
  shared_ptr<long> siteId{};

  ListWafTemplateRulesRequest() {}

  explicit ListWafTemplateRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (queryArgs) {
      res["QueryArgs"] = queryArgs ? boost::any(queryArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryArgs"].type()) {
        ListWafTemplateRulesRequestQueryArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryArgs"]));
        queryArgs = make_shared<ListWafTemplateRulesRequestQueryArgs>(model1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListWafTemplateRulesRequest() = default;
};
class ListWafTemplateRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> phase{};
  shared_ptr<string> queryArgsShrink{};
  shared_ptr<long> siteId{};

  ListWafTemplateRulesShrinkRequest() {}

  explicit ListWafTemplateRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (queryArgsShrink) {
      res["QueryArgs"] = boost::any(*queryArgsShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgsShrink = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListWafTemplateRulesShrinkRequest() = default;
};
class ListWafTemplateRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<WafRuleConfig> config{};
  shared_ptr<string> name{};
  shared_ptr<string> phase{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListWafTemplateRulesResponseBodyRules() {}

  explicit ListWafTemplateRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        WafRuleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<WafRuleConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListWafTemplateRulesResponseBodyRules() = default;
};
class ListWafTemplateRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWafTemplateRulesResponseBodyRules>> rules{};

  ListWafTemplateRulesResponseBody() {}

  explicit ListWafTemplateRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListWafTemplateRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWafTemplateRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListWafTemplateRulesResponseBodyRules>>(expect1);
      }
    }
  }


  virtual ~ListWafTemplateRulesResponseBody() = default;
};
class ListWafTemplateRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWafTemplateRulesResponseBody> body{};

  ListWafTemplateRulesResponse() {}

  explicit ListWafTemplateRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWafTemplateRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWafTemplateRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWafTemplateRulesResponse() = default;
};
class ListWafUsageOfRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> phase{};
  shared_ptr<long> siteId{};

  ListWafUsageOfRulesRequest() {}

  explicit ListWafUsageOfRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~ListWafUsageOfRulesRequest() = default;
};
class ListWafUsageOfRulesResponseBodySites : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> usage{};

  ListWafUsageOfRulesResponseBodySites() {}

  explicit ListWafUsageOfRulesResponseBodySites(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
  }


  virtual ~ListWafUsageOfRulesResponseBodySites() = default;
};
class ListWafUsageOfRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWafUsageOfRulesResponseBodySites>> sites{};

  ListWafUsageOfRulesResponseBody() {}

  explicit ListWafUsageOfRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sites) {
      vector<boost::any> temp1;
      for(auto item1:*sites){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sites"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sites") != m.end() && !m["Sites"].empty()) {
      if (typeid(vector<boost::any>) == m["Sites"].type()) {
        vector<ListWafUsageOfRulesResponseBodySites> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sites"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWafUsageOfRulesResponseBodySites model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sites = make_shared<vector<ListWafUsageOfRulesResponseBodySites>>(expect1);
      }
    }
  }


  virtual ~ListWafUsageOfRulesResponseBody() = default;
};
class ListWafUsageOfRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWafUsageOfRulesResponseBody> body{};

  ListWafUsageOfRulesResponse() {}

  explicit ListWafUsageOfRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWafUsageOfRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWafUsageOfRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWafUsageOfRulesResponse() = default;
};
class ListWaitingRoomEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<long> waitingRoomEventId{};
  shared_ptr<string> waitingRoomId{};

  ListWaitingRoomEventsRequest() {}

  explicit ListWaitingRoomEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (waitingRoomEventId) {
      res["WaitingRoomEventId"] = boost::any(*waitingRoomEventId);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("WaitingRoomEventId") != m.end() && !m["WaitingRoomEventId"].empty()) {
      waitingRoomEventId = make_shared<long>(boost::any_cast<long>(m["WaitingRoomEventId"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
  }


  virtual ~ListWaitingRoomEventsRequest() = default;
};
class ListWaitingRoomEventsResponseBodyWaitingRoomEvents : public Darabonba::Model {
public:
  shared_ptr<string> customPageHtml{};
  shared_ptr<string> description{};
  shared_ptr<string> disableSessionRenewalEnable{};
  shared_ptr<string> enable{};
  shared_ptr<string> endTime{};
  shared_ptr<string> jsonResponseEnable{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<string> newUsersPerMinute{};
  shared_ptr<string> preQueueEnable{};
  shared_ptr<string> preQueueStartTime{};
  shared_ptr<string> queuingMethod{};
  shared_ptr<string> queuingStatusCode{};
  shared_ptr<string> randomPreQueueEnable{};
  shared_ptr<string> sessionDuration{};
  shared_ptr<string> startTime{};
  shared_ptr<string> totalActiveUsers{};
  shared_ptr<long> waitingRoomEventId{};
  shared_ptr<string> waitingRoomId{};
  shared_ptr<string> waitingRoomType{};

  ListWaitingRoomEventsResponseBodyWaitingRoomEvents() {}

  explicit ListWaitingRoomEventsResponseBodyWaitingRoomEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customPageHtml) {
      res["CustomPageHtml"] = boost::any(*customPageHtml);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableSessionRenewalEnable) {
      res["DisableSessionRenewalEnable"] = boost::any(*disableSessionRenewalEnable);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jsonResponseEnable) {
      res["JsonResponseEnable"] = boost::any(*jsonResponseEnable);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newUsersPerMinute) {
      res["NewUsersPerMinute"] = boost::any(*newUsersPerMinute);
    }
    if (preQueueEnable) {
      res["PreQueueEnable"] = boost::any(*preQueueEnable);
    }
    if (preQueueStartTime) {
      res["PreQueueStartTime"] = boost::any(*preQueueStartTime);
    }
    if (queuingMethod) {
      res["QueuingMethod"] = boost::any(*queuingMethod);
    }
    if (queuingStatusCode) {
      res["QueuingStatusCode"] = boost::any(*queuingStatusCode);
    }
    if (randomPreQueueEnable) {
      res["RandomPreQueueEnable"] = boost::any(*randomPreQueueEnable);
    }
    if (sessionDuration) {
      res["SessionDuration"] = boost::any(*sessionDuration);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalActiveUsers) {
      res["TotalActiveUsers"] = boost::any(*totalActiveUsers);
    }
    if (waitingRoomEventId) {
      res["WaitingRoomEventId"] = boost::any(*waitingRoomEventId);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    if (waitingRoomType) {
      res["WaitingRoomType"] = boost::any(*waitingRoomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomPageHtml") != m.end() && !m["CustomPageHtml"].empty()) {
      customPageHtml = make_shared<string>(boost::any_cast<string>(m["CustomPageHtml"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableSessionRenewalEnable") != m.end() && !m["DisableSessionRenewalEnable"].empty()) {
      disableSessionRenewalEnable = make_shared<string>(boost::any_cast<string>(m["DisableSessionRenewalEnable"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JsonResponseEnable") != m.end() && !m["JsonResponseEnable"].empty()) {
      jsonResponseEnable = make_shared<string>(boost::any_cast<string>(m["JsonResponseEnable"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewUsersPerMinute") != m.end() && !m["NewUsersPerMinute"].empty()) {
      newUsersPerMinute = make_shared<string>(boost::any_cast<string>(m["NewUsersPerMinute"]));
    }
    if (m.find("PreQueueEnable") != m.end() && !m["PreQueueEnable"].empty()) {
      preQueueEnable = make_shared<string>(boost::any_cast<string>(m["PreQueueEnable"]));
    }
    if (m.find("PreQueueStartTime") != m.end() && !m["PreQueueStartTime"].empty()) {
      preQueueStartTime = make_shared<string>(boost::any_cast<string>(m["PreQueueStartTime"]));
    }
    if (m.find("QueuingMethod") != m.end() && !m["QueuingMethod"].empty()) {
      queuingMethod = make_shared<string>(boost::any_cast<string>(m["QueuingMethod"]));
    }
    if (m.find("QueuingStatusCode") != m.end() && !m["QueuingStatusCode"].empty()) {
      queuingStatusCode = make_shared<string>(boost::any_cast<string>(m["QueuingStatusCode"]));
    }
    if (m.find("RandomPreQueueEnable") != m.end() && !m["RandomPreQueueEnable"].empty()) {
      randomPreQueueEnable = make_shared<string>(boost::any_cast<string>(m["RandomPreQueueEnable"]));
    }
    if (m.find("SessionDuration") != m.end() && !m["SessionDuration"].empty()) {
      sessionDuration = make_shared<string>(boost::any_cast<string>(m["SessionDuration"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TotalActiveUsers") != m.end() && !m["TotalActiveUsers"].empty()) {
      totalActiveUsers = make_shared<string>(boost::any_cast<string>(m["TotalActiveUsers"]));
    }
    if (m.find("WaitingRoomEventId") != m.end() && !m["WaitingRoomEventId"].empty()) {
      waitingRoomEventId = make_shared<long>(boost::any_cast<long>(m["WaitingRoomEventId"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
    if (m.find("WaitingRoomType") != m.end() && !m["WaitingRoomType"].empty()) {
      waitingRoomType = make_shared<string>(boost::any_cast<string>(m["WaitingRoomType"]));
    }
  }


  virtual ~ListWaitingRoomEventsResponseBodyWaitingRoomEvents() = default;
};
class ListWaitingRoomEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWaitingRoomEventsResponseBodyWaitingRoomEvents>> waitingRoomEvents{};

  ListWaitingRoomEventsResponseBody() {}

  explicit ListWaitingRoomEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waitingRoomEvents) {
      vector<boost::any> temp1;
      for(auto item1:*waitingRoomEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaitingRoomEvents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaitingRoomEvents") != m.end() && !m["WaitingRoomEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["WaitingRoomEvents"].type()) {
        vector<ListWaitingRoomEventsResponseBodyWaitingRoomEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaitingRoomEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWaitingRoomEventsResponseBodyWaitingRoomEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waitingRoomEvents = make_shared<vector<ListWaitingRoomEventsResponseBodyWaitingRoomEvents>>(expect1);
      }
    }
  }


  virtual ~ListWaitingRoomEventsResponseBody() = default;
};
class ListWaitingRoomEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWaitingRoomEventsResponseBody> body{};

  ListWaitingRoomEventsResponse() {}

  explicit ListWaitingRoomEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWaitingRoomEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWaitingRoomEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWaitingRoomEventsResponse() = default;
};
class ListWaitingRoomRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ruleName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> waitingRoomId{};
  shared_ptr<long> waitingRoomRuleId{};

  ListWaitingRoomRulesRequest() {}

  explicit ListWaitingRoomRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    if (waitingRoomRuleId) {
      res["WaitingRoomRuleId"] = boost::any(*waitingRoomRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
    if (m.find("WaitingRoomRuleId") != m.end() && !m["WaitingRoomRuleId"].empty()) {
      waitingRoomRuleId = make_shared<long>(boost::any_cast<long>(m["WaitingRoomRuleId"]));
    }
  }


  virtual ~ListWaitingRoomRulesRequest() = default;
};
class ListWaitingRoomRulesResponseBodyWaitingRoomRules : public Darabonba::Model {
public:
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> waitingRoomRuleId{};

  ListWaitingRoomRulesResponseBodyWaitingRoomRules() {}

  explicit ListWaitingRoomRulesResponseBodyWaitingRoomRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (waitingRoomRuleId) {
      res["WaitingRoomRuleId"] = boost::any(*waitingRoomRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("WaitingRoomRuleId") != m.end() && !m["WaitingRoomRuleId"].empty()) {
      waitingRoomRuleId = make_shared<long>(boost::any_cast<long>(m["WaitingRoomRuleId"]));
    }
  }


  virtual ~ListWaitingRoomRulesResponseBodyWaitingRoomRules() = default;
};
class ListWaitingRoomRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWaitingRoomRulesResponseBodyWaitingRoomRules>> waitingRoomRules{};

  ListWaitingRoomRulesResponseBody() {}

  explicit ListWaitingRoomRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waitingRoomRules) {
      vector<boost::any> temp1;
      for(auto item1:*waitingRoomRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaitingRoomRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaitingRoomRules") != m.end() && !m["WaitingRoomRules"].empty()) {
      if (typeid(vector<boost::any>) == m["WaitingRoomRules"].type()) {
        vector<ListWaitingRoomRulesResponseBodyWaitingRoomRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaitingRoomRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWaitingRoomRulesResponseBodyWaitingRoomRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waitingRoomRules = make_shared<vector<ListWaitingRoomRulesResponseBodyWaitingRoomRules>>(expect1);
      }
    }
  }


  virtual ~ListWaitingRoomRulesResponseBody() = default;
};
class ListWaitingRoomRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWaitingRoomRulesResponseBody> body{};

  ListWaitingRoomRulesResponse() {}

  explicit ListWaitingRoomRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWaitingRoomRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWaitingRoomRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWaitingRoomRulesResponse() = default;
};
class ListWaitingRoomsRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> waitingRoomId{};

  ListWaitingRoomsRequest() {}

  explicit ListWaitingRoomsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
  }


  virtual ~ListWaitingRoomsRequest() = default;
};
class ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> path{};
  shared_ptr<string> subdomain{};

  ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath() {}

  explicit ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (subdomain) {
      res["Subdomain"] = boost::any(*subdomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Subdomain") != m.end() && !m["Subdomain"].empty()) {
      subdomain = make_shared<string>(boost::any_cast<string>(m["Subdomain"]));
    }
  }


  virtual ~ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath() = default;
};
class ListWaitingRoomsResponseBodyWaitingRooms : public Darabonba::Model {
public:
  shared_ptr<string> cookieName{};
  shared_ptr<string> customPageHtml{};
  shared_ptr<string> description{};
  shared_ptr<string> disableSessionRenewalEnable{};
  shared_ptr<string> enable{};
  shared_ptr<vector<ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath>> hostNameAndPath{};
  shared_ptr<string> jsonResponseEnable{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<string> newUsersPerMinute{};
  shared_ptr<string> queueAllEnable{};
  shared_ptr<string> queuingMethod{};
  shared_ptr<string> queuingStatusCode{};
  shared_ptr<string> sessionDuration{};
  shared_ptr<string> totalActiveUsers{};
  shared_ptr<string> waitingRoomId{};
  shared_ptr<string> waitingRoomType{};

  ListWaitingRoomsResponseBodyWaitingRooms() {}

  explicit ListWaitingRoomsResponseBodyWaitingRooms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookieName) {
      res["CookieName"] = boost::any(*cookieName);
    }
    if (customPageHtml) {
      res["CustomPageHtml"] = boost::any(*customPageHtml);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableSessionRenewalEnable) {
      res["DisableSessionRenewalEnable"] = boost::any(*disableSessionRenewalEnable);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (hostNameAndPath) {
      vector<boost::any> temp1;
      for(auto item1:*hostNameAndPath){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostNameAndPath"] = boost::any(temp1);
    }
    if (jsonResponseEnable) {
      res["JsonResponseEnable"] = boost::any(*jsonResponseEnable);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newUsersPerMinute) {
      res["NewUsersPerMinute"] = boost::any(*newUsersPerMinute);
    }
    if (queueAllEnable) {
      res["QueueAllEnable"] = boost::any(*queueAllEnable);
    }
    if (queuingMethod) {
      res["QueuingMethod"] = boost::any(*queuingMethod);
    }
    if (queuingStatusCode) {
      res["QueuingStatusCode"] = boost::any(*queuingStatusCode);
    }
    if (sessionDuration) {
      res["SessionDuration"] = boost::any(*sessionDuration);
    }
    if (totalActiveUsers) {
      res["TotalActiveUsers"] = boost::any(*totalActiveUsers);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    if (waitingRoomType) {
      res["WaitingRoomType"] = boost::any(*waitingRoomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CookieName") != m.end() && !m["CookieName"].empty()) {
      cookieName = make_shared<string>(boost::any_cast<string>(m["CookieName"]));
    }
    if (m.find("CustomPageHtml") != m.end() && !m["CustomPageHtml"].empty()) {
      customPageHtml = make_shared<string>(boost::any_cast<string>(m["CustomPageHtml"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableSessionRenewalEnable") != m.end() && !m["DisableSessionRenewalEnable"].empty()) {
      disableSessionRenewalEnable = make_shared<string>(boost::any_cast<string>(m["DisableSessionRenewalEnable"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("HostNameAndPath") != m.end() && !m["HostNameAndPath"].empty()) {
      if (typeid(vector<boost::any>) == m["HostNameAndPath"].type()) {
        vector<ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostNameAndPath"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostNameAndPath = make_shared<vector<ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath>>(expect1);
      }
    }
    if (m.find("JsonResponseEnable") != m.end() && !m["JsonResponseEnable"].empty()) {
      jsonResponseEnable = make_shared<string>(boost::any_cast<string>(m["JsonResponseEnable"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewUsersPerMinute") != m.end() && !m["NewUsersPerMinute"].empty()) {
      newUsersPerMinute = make_shared<string>(boost::any_cast<string>(m["NewUsersPerMinute"]));
    }
    if (m.find("QueueAllEnable") != m.end() && !m["QueueAllEnable"].empty()) {
      queueAllEnable = make_shared<string>(boost::any_cast<string>(m["QueueAllEnable"]));
    }
    if (m.find("QueuingMethod") != m.end() && !m["QueuingMethod"].empty()) {
      queuingMethod = make_shared<string>(boost::any_cast<string>(m["QueuingMethod"]));
    }
    if (m.find("QueuingStatusCode") != m.end() && !m["QueuingStatusCode"].empty()) {
      queuingStatusCode = make_shared<string>(boost::any_cast<string>(m["QueuingStatusCode"]));
    }
    if (m.find("SessionDuration") != m.end() && !m["SessionDuration"].empty()) {
      sessionDuration = make_shared<string>(boost::any_cast<string>(m["SessionDuration"]));
    }
    if (m.find("TotalActiveUsers") != m.end() && !m["TotalActiveUsers"].empty()) {
      totalActiveUsers = make_shared<string>(boost::any_cast<string>(m["TotalActiveUsers"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
    if (m.find("WaitingRoomType") != m.end() && !m["WaitingRoomType"].empty()) {
      waitingRoomType = make_shared<string>(boost::any_cast<string>(m["WaitingRoomType"]));
    }
  }


  virtual ~ListWaitingRoomsResponseBodyWaitingRooms() = default;
};
class ListWaitingRoomsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWaitingRoomsResponseBodyWaitingRooms>> waitingRooms{};

  ListWaitingRoomsResponseBody() {}

  explicit ListWaitingRoomsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waitingRooms) {
      vector<boost::any> temp1;
      for(auto item1:*waitingRooms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaitingRooms"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaitingRooms") != m.end() && !m["WaitingRooms"].empty()) {
      if (typeid(vector<boost::any>) == m["WaitingRooms"].type()) {
        vector<ListWaitingRoomsResponseBodyWaitingRooms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaitingRooms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWaitingRoomsResponseBodyWaitingRooms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waitingRooms = make_shared<vector<ListWaitingRoomsResponseBodyWaitingRooms>>(expect1);
      }
    }
  }


  virtual ~ListWaitingRoomsResponseBody() = default;
};
class ListWaitingRoomsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWaitingRoomsResponseBody> body{};

  ListWaitingRoomsResponse() {}

  explicit ListWaitingRoomsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWaitingRoomsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWaitingRoomsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWaitingRoomsResponse() = default;
};
class PreloadCachesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> content{};
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> siteId{};

  PreloadCachesRequest() {}

  explicit PreloadCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (headers) {
      res["Headers"] = boost::any(*headers);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Content"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      content = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~PreloadCachesRequest() = default;
};
class PreloadCachesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentShrink{};
  shared_ptr<string> headersShrink{};
  shared_ptr<long> siteId{};

  PreloadCachesShrinkRequest() {}

  explicit PreloadCachesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentShrink) {
      res["Content"] = boost::any(*contentShrink);
    }
    if (headersShrink) {
      res["Headers"] = boost::any(*headersShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      contentShrink = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      headersShrink = make_shared<string>(boost::any_cast<string>(m["Headers"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~PreloadCachesShrinkRequest() = default;
};
class PreloadCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  PreloadCachesResponseBody() {}

  explicit PreloadCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~PreloadCachesResponseBody() = default;
};
class PreloadCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PreloadCachesResponseBody> body{};

  PreloadCachesResponse() {}

  explicit PreloadCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PreloadCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PreloadCachesResponseBody>(model1);
      }
    }
  }


  virtual ~PreloadCachesResponse() = default;
};
class PublishEdgeContainerAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> fullRelease{};
  shared_ptr<long> percentage{};
  shared_ptr<string> publishEnv{};
  shared_ptr<string> publishType{};
  shared_ptr<vector<string>> regions{};
  shared_ptr<string> remarks{};
  shared_ptr<string> startTime{};
  shared_ptr<string> versionId{};

  PublishEdgeContainerAppVersionRequest() {}

  explicit PublishEdgeContainerAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (fullRelease) {
      res["FullRelease"] = boost::any(*fullRelease);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (publishEnv) {
      res["PublishEnv"] = boost::any(*publishEnv);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("FullRelease") != m.end() && !m["FullRelease"].empty()) {
      fullRelease = make_shared<bool>(boost::any_cast<bool>(m["FullRelease"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("PublishEnv") != m.end() && !m["PublishEnv"].empty()) {
      publishEnv = make_shared<string>(boost::any_cast<string>(m["PublishEnv"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Regions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~PublishEdgeContainerAppVersionRequest() = default;
};
class PublishEdgeContainerAppVersionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> fullRelease{};
  shared_ptr<long> percentage{};
  shared_ptr<string> publishEnv{};
  shared_ptr<string> publishType{};
  shared_ptr<string> regionsShrink{};
  shared_ptr<string> remarks{};
  shared_ptr<string> startTime{};
  shared_ptr<string> versionId{};

  PublishEdgeContainerAppVersionShrinkRequest() {}

  explicit PublishEdgeContainerAppVersionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (fullRelease) {
      res["FullRelease"] = boost::any(*fullRelease);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (publishEnv) {
      res["PublishEnv"] = boost::any(*publishEnv);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (regionsShrink) {
      res["Regions"] = boost::any(*regionsShrink);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("FullRelease") != m.end() && !m["FullRelease"].empty()) {
      fullRelease = make_shared<bool>(boost::any_cast<bool>(m["FullRelease"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("PublishEnv") != m.end() && !m["PublishEnv"].empty()) {
      publishEnv = make_shared<string>(boost::any_cast<string>(m["PublishEnv"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      regionsShrink = make_shared<string>(boost::any_cast<string>(m["Regions"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~PublishEdgeContainerAppVersionShrinkRequest() = default;
};
class PublishEdgeContainerAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishEdgeContainerAppVersionResponseBody() {}

  explicit PublishEdgeContainerAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishEdgeContainerAppVersionResponseBody() = default;
};
class PublishEdgeContainerAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishEdgeContainerAppVersionResponseBody> body{};

  PublishEdgeContainerAppVersionResponse() {}

  explicit PublishEdgeContainerAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishEdgeContainerAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishEdgeContainerAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishEdgeContainerAppVersionResponse() = default;
};
class PublishRoutineCodeVersionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> canaryAreaList{};
  shared_ptr<string> canaryCodeVersion{};
  shared_ptr<string> codeVersion{};
  shared_ptr<string> env{};
  shared_ptr<string> name{};

  PublishRoutineCodeVersionRequest() {}

  explicit PublishRoutineCodeVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canaryAreaList) {
      res["CanaryAreaList"] = boost::any(*canaryAreaList);
    }
    if (canaryCodeVersion) {
      res["CanaryCodeVersion"] = boost::any(*canaryCodeVersion);
    }
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanaryAreaList") != m.end() && !m["CanaryAreaList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CanaryAreaList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CanaryAreaList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      canaryAreaList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CanaryCodeVersion") != m.end() && !m["CanaryCodeVersion"].empty()) {
      canaryCodeVersion = make_shared<string>(boost::any_cast<string>(m["CanaryCodeVersion"]));
    }
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~PublishRoutineCodeVersionRequest() = default;
};
class PublishRoutineCodeVersionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> canaryAreaListShrink{};
  shared_ptr<string> canaryCodeVersion{};
  shared_ptr<string> codeVersion{};
  shared_ptr<string> env{};
  shared_ptr<string> name{};

  PublishRoutineCodeVersionShrinkRequest() {}

  explicit PublishRoutineCodeVersionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canaryAreaListShrink) {
      res["CanaryAreaList"] = boost::any(*canaryAreaListShrink);
    }
    if (canaryCodeVersion) {
      res["CanaryCodeVersion"] = boost::any(*canaryCodeVersion);
    }
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanaryAreaList") != m.end() && !m["CanaryAreaList"].empty()) {
      canaryAreaListShrink = make_shared<string>(boost::any_cast<string>(m["CanaryAreaList"]));
    }
    if (m.find("CanaryCodeVersion") != m.end() && !m["CanaryCodeVersion"].empty()) {
      canaryCodeVersion = make_shared<string>(boost::any_cast<string>(m["CanaryCodeVersion"]));
    }
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~PublishRoutineCodeVersionShrinkRequest() = default;
};
class PublishRoutineCodeVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> codeVersion{};
  shared_ptr<string> requestId{};

  PublishRoutineCodeVersionResponseBody() {}

  explicit PublishRoutineCodeVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeVersion) {
      res["CodeVersion"] = boost::any(*codeVersion);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeVersion") != m.end() && !m["CodeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["CodeVersion"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishRoutineCodeVersionResponseBody() = default;
};
class PublishRoutineCodeVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishRoutineCodeVersionResponseBody> body{};

  PublishRoutineCodeVersionResponse() {}

  explicit PublishRoutineCodeVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishRoutineCodeVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishRoutineCodeVersionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishRoutineCodeVersionResponse() = default;
};
class PurgeCachesRequestContent : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cacheTags{};
  shared_ptr<vector<string>> directories{};
  shared_ptr<vector<boost::any>> files{};
  shared_ptr<vector<string>> hostnames{};
  shared_ptr<vector<string>> ignoreParams{};
  shared_ptr<bool> purgeAll{};

  PurgeCachesRequestContent() {}

  explicit PurgeCachesRequestContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheTags) {
      res["CacheTags"] = boost::any(*cacheTags);
    }
    if (directories) {
      res["Directories"] = boost::any(*directories);
    }
    if (files) {
      res["Files"] = boost::any(*files);
    }
    if (hostnames) {
      res["Hostnames"] = boost::any(*hostnames);
    }
    if (ignoreParams) {
      res["IgnoreParams"] = boost::any(*ignoreParams);
    }
    if (purgeAll) {
      res["PurgeAll"] = boost::any(*purgeAll);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheTags") != m.end() && !m["CacheTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CacheTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CacheTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cacheTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Directories") != m.end() && !m["Directories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Directories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Directories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      directories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Files"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      files = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("Hostnames") != m.end() && !m["Hostnames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Hostnames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hostnames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostnames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IgnoreParams") != m.end() && !m["IgnoreParams"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoreParams"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoreParams"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoreParams = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PurgeAll") != m.end() && !m["PurgeAll"].empty()) {
      purgeAll = make_shared<bool>(boost::any_cast<bool>(m["PurgeAll"]));
    }
  }


  virtual ~PurgeCachesRequestContent() = default;
};
class PurgeCachesRequest : public Darabonba::Model {
public:
  shared_ptr<PurgeCachesRequestContent> content{};
  shared_ptr<bool> edgeComputePurge{};
  shared_ptr<bool> force{};
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};

  PurgeCachesRequest() {}

  explicit PurgeCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (edgeComputePurge) {
      res["EdgeComputePurge"] = boost::any(*edgeComputePurge);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        PurgeCachesRequestContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<PurgeCachesRequestContent>(model1);
      }
    }
    if (m.find("EdgeComputePurge") != m.end() && !m["EdgeComputePurge"].empty()) {
      edgeComputePurge = make_shared<bool>(boost::any_cast<bool>(m["EdgeComputePurge"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PurgeCachesRequest() = default;
};
class PurgeCachesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentShrink{};
  shared_ptr<bool> edgeComputePurge{};
  shared_ptr<bool> force{};
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};

  PurgeCachesShrinkRequest() {}

  explicit PurgeCachesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentShrink) {
      res["Content"] = boost::any(*contentShrink);
    }
    if (edgeComputePurge) {
      res["EdgeComputePurge"] = boost::any(*edgeComputePurge);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      contentShrink = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EdgeComputePurge") != m.end() && !m["EdgeComputePurge"].empty()) {
      edgeComputePurge = make_shared<bool>(boost::any_cast<bool>(m["EdgeComputePurge"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PurgeCachesShrinkRequest() = default;
};
class PurgeCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  PurgeCachesResponseBody() {}

  explicit PurgeCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~PurgeCachesResponseBody() = default;
};
class PurgeCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PurgeCachesResponseBody> body{};

  PurgeCachesResponse() {}

  explicit PurgeCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PurgeCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PurgeCachesResponseBody>(model1);
      }
    }
  }


  virtual ~PurgeCachesResponse() = default;
};
class PutKvRequest : public Darabonba::Model {
public:
  shared_ptr<bool> base64{};
  shared_ptr<long> expiration{};
  shared_ptr<long> expirationTtl{};
  shared_ptr<string> key{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> value{};

  PutKvRequest() {}

  explicit PutKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (base64) {
      res["Base64"] = boost::any(*base64);
    }
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (expirationTtl) {
      res["ExpirationTtl"] = boost::any(*expirationTtl);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Base64") != m.end() && !m["Base64"].empty()) {
      base64 = make_shared<bool>(boost::any_cast<bool>(m["Base64"]));
    }
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<long>(boost::any_cast<long>(m["Expiration"]));
    }
    if (m.find("ExpirationTtl") != m.end() && !m["ExpirationTtl"].empty()) {
      expirationTtl = make_shared<long>(boost::any_cast<long>(m["ExpirationTtl"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutKvRequest() = default;
};
class PutKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> length{};
  shared_ptr<string> requestId{};
  shared_ptr<string> value{};

  PutKvResponseBody() {}

  explicit PutKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutKvResponseBody() = default;
};
class PutKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutKvResponseBody> body{};

  PutKvResponse() {}

  explicit PutKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutKvResponseBody>(model1);
      }
    }
  }


  virtual ~PutKvResponse() = default;
};
class PutKvWithHighCapacityRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> url{};

  PutKvWithHighCapacityRequest() {}

  explicit PutKvWithHighCapacityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~PutKvWithHighCapacityRequest() = default;
};
class PutKvWithHighCapacityAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> namespace_{};
  shared_ptr<Darabonba::Stream> urlObject{};

  PutKvWithHighCapacityAdvanceRequest() {}

  explicit PutKvWithHighCapacityAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (urlObject) {
      res["Url"] = boost::any(*urlObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      urlObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["Url"]));
    }
  }


  virtual ~PutKvWithHighCapacityAdvanceRequest() = default;
};
class PutKvWithHighCapacityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> length{};
  shared_ptr<string> requestId{};
  shared_ptr<string> value{};

  PutKvWithHighCapacityResponseBody() {}

  explicit PutKvWithHighCapacityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutKvWithHighCapacityResponseBody() = default;
};
class PutKvWithHighCapacityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutKvWithHighCapacityResponseBody> body{};

  PutKvWithHighCapacityResponse() {}

  explicit PutKvWithHighCapacityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutKvWithHighCapacityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutKvWithHighCapacityResponseBody>(model1);
      }
    }
  }


  virtual ~PutKvWithHighCapacityResponse() = default;
};
class RebuildEdgeContainerAppStagingEnvRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  RebuildEdgeContainerAppStagingEnvRequest() {}

  explicit RebuildEdgeContainerAppStagingEnvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~RebuildEdgeContainerAppStagingEnvRequest() = default;
};
class RebuildEdgeContainerAppStagingEnvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RebuildEdgeContainerAppStagingEnvResponseBody() {}

  explicit RebuildEdgeContainerAppStagingEnvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebuildEdgeContainerAppStagingEnvResponseBody() = default;
};
class RebuildEdgeContainerAppStagingEnvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebuildEdgeContainerAppStagingEnvResponseBody> body{};

  RebuildEdgeContainerAppStagingEnvResponse() {}

  explicit RebuildEdgeContainerAppStagingEnvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebuildEdgeContainerAppStagingEnvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebuildEdgeContainerAppStagingEnvResponseBody>(model1);
      }
    }
  }


  virtual ~RebuildEdgeContainerAppStagingEnvResponse() = default;
};
class ResetScheduledPreloadJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ResetScheduledPreloadJobRequest() {}

  explicit ResetScheduledPreloadJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ResetScheduledPreloadJobRequest() = default;
};
class ResetScheduledPreloadJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> domains{};
  shared_ptr<string> errorInfo{};
  shared_ptr<string> failedFileOss{};
  shared_ptr<string> fileId{};
  shared_ptr<string> id{};
  shared_ptr<string> insertWay{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<long> taskSubmitted{};
  shared_ptr<string> taskType{};
  shared_ptr<long> urlCount{};
  shared_ptr<long> urlSubmitted{};

  ResetScheduledPreloadJobResponseBody() {}

  explicit ResetScheduledPreloadJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (createdAt) {
      res["CreatedAt"] = boost::any(*createdAt);
    }
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    if (failedFileOss) {
      res["FailedFileOss"] = boost::any(*failedFileOss);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (insertWay) {
      res["InsertWay"] = boost::any(*insertWay);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskSubmitted) {
      res["TaskSubmitted"] = boost::any(*taskSubmitted);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (urlCount) {
      res["UrlCount"] = boost::any(*urlCount);
    }
    if (urlSubmitted) {
      res["UrlSubmitted"] = boost::any(*urlSubmitted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("CreatedAt") != m.end() && !m["CreatedAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["CreatedAt"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      domains = make_shared<string>(boost::any_cast<string>(m["Domains"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
    if (m.find("FailedFileOss") != m.end() && !m["FailedFileOss"].empty()) {
      failedFileOss = make_shared<string>(boost::any_cast<string>(m["FailedFileOss"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InsertWay") != m.end() && !m["InsertWay"].empty()) {
      insertWay = make_shared<string>(boost::any_cast<string>(m["InsertWay"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TaskSubmitted") != m.end() && !m["TaskSubmitted"].empty()) {
      taskSubmitted = make_shared<long>(boost::any_cast<long>(m["TaskSubmitted"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UrlCount") != m.end() && !m["UrlCount"].empty()) {
      urlCount = make_shared<long>(boost::any_cast<long>(m["UrlCount"]));
    }
    if (m.find("UrlSubmitted") != m.end() && !m["UrlSubmitted"].empty()) {
      urlSubmitted = make_shared<long>(boost::any_cast<long>(m["UrlSubmitted"]));
    }
  }


  virtual ~ResetScheduledPreloadJobResponseBody() = default;
};
class ResetScheduledPreloadJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetScheduledPreloadJobResponseBody> body{};

  ResetScheduledPreloadJobResponse() {}

  explicit ResetScheduledPreloadJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetScheduledPreloadJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetScheduledPreloadJobResponseBody>(model1);
      }
    }
  }


  virtual ~ResetScheduledPreloadJobResponse() = default;
};
class RevokeClientCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  RevokeClientCertificateRequest() {}

  explicit RevokeClientCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~RevokeClientCertificateRequest() = default;
};
class RevokeClientCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  RevokeClientCertificateResponseBody() {}

  explicit RevokeClientCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~RevokeClientCertificateResponseBody() = default;
};
class RevokeClientCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeClientCertificateResponseBody> body{};

  RevokeClientCertificateResponse() {}

  explicit RevokeClientCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeClientCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeClientCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeClientCertificateResponse() = default;
};
class RollbackEdgeContainerAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> remarks{};
  shared_ptr<string> versionId{};

  RollbackEdgeContainerAppVersionRequest() {}

  explicit RollbackEdgeContainerAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~RollbackEdgeContainerAppVersionRequest() = default;
};
class RollbackEdgeContainerAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackEdgeContainerAppVersionResponseBody() {}

  explicit RollbackEdgeContainerAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackEdgeContainerAppVersionResponseBody() = default;
};
class RollbackEdgeContainerAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackEdgeContainerAppVersionResponseBody> body{};

  RollbackEdgeContainerAppVersionResponse() {}

  explicit RollbackEdgeContainerAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackEdgeContainerAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackEdgeContainerAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackEdgeContainerAppVersionResponse() = default;
};
class SetCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> casId{};
  shared_ptr<string> certificate{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> region{};
  shared_ptr<string> securityToken{};
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};
  shared_ptr<bool> update{};

  SetCertificateRequest() {}

  explicit SetCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casId) {
      res["CasId"] = boost::any(*casId);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (update) {
      res["Update"] = boost::any(*update);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasId") != m.end() && !m["CasId"].empty()) {
      casId = make_shared<long>(boost::any_cast<long>(m["CasId"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Update") != m.end() && !m["Update"].empty()) {
      update = make_shared<bool>(boost::any_cast<bool>(m["Update"]));
    }
  }


  virtual ~SetCertificateRequest() = default;
};
class SetCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCertificateResponseBody() {}

  explicit SetCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCertificateResponseBody() = default;
};
class SetCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCertificateResponseBody> body{};

  SetCertificateResponse() {}

  explicit SetCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetCertificateResponse() = default;
};
class SetClientCertificateHostnamesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostnames{};
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  SetClientCertificateHostnamesRequest() {}

  explicit SetClientCertificateHostnamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostnames) {
      res["Hostnames"] = boost::any(*hostnames);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hostnames") != m.end() && !m["Hostnames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Hostnames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hostnames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostnames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~SetClientCertificateHostnamesRequest() = default;
};
class SetClientCertificateHostnamesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostnamesShrink{};
  shared_ptr<string> id{};
  shared_ptr<long> siteId{};

  SetClientCertificateHostnamesShrinkRequest() {}

  explicit SetClientCertificateHostnamesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostnamesShrink) {
      res["Hostnames"] = boost::any(*hostnamesShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hostnames") != m.end() && !m["Hostnames"].empty()) {
      hostnamesShrink = make_shared<string>(boost::any_cast<string>(m["Hostnames"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~SetClientCertificateHostnamesShrinkRequest() = default;
};
class SetClientCertificateHostnamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteName{};

  SetClientCertificateHostnamesResponseBody() {}

  explicit SetClientCertificateHostnamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteName) {
      res["SiteName"] = boost::any(*siteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteName") != m.end() && !m["SiteName"].empty()) {
      siteName = make_shared<string>(boost::any_cast<string>(m["SiteName"]));
    }
  }


  virtual ~SetClientCertificateHostnamesResponseBody() = default;
};
class SetClientCertificateHostnamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetClientCertificateHostnamesResponseBody> body{};

  SetClientCertificateHostnamesResponse() {}

  explicit SetClientCertificateHostnamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetClientCertificateHostnamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetClientCertificateHostnamesResponseBody>(model1);
      }
    }
  }


  virtual ~SetClientCertificateHostnamesResponse() = default;
};
class SetHttpDDoSAttackIntelligentProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> aiMode{};
  shared_ptr<string> aiTemplate{};
  shared_ptr<long> siteId{};

  SetHttpDDoSAttackIntelligentProtectionRequest() {}

  explicit SetHttpDDoSAttackIntelligentProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiMode) {
      res["AiMode"] = boost::any(*aiMode);
    }
    if (aiTemplate) {
      res["AiTemplate"] = boost::any(*aiTemplate);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiMode") != m.end() && !m["AiMode"].empty()) {
      aiMode = make_shared<string>(boost::any_cast<string>(m["AiMode"]));
    }
    if (m.find("AiTemplate") != m.end() && !m["AiTemplate"].empty()) {
      aiTemplate = make_shared<string>(boost::any_cast<string>(m["AiTemplate"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~SetHttpDDoSAttackIntelligentProtectionRequest() = default;
};
class SetHttpDDoSAttackIntelligentProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aiMode{};
  shared_ptr<string> aiTemplate{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};

  SetHttpDDoSAttackIntelligentProtectionResponseBody() {}

  explicit SetHttpDDoSAttackIntelligentProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiMode) {
      res["AiMode"] = boost::any(*aiMode);
    }
    if (aiTemplate) {
      res["AiTemplate"] = boost::any(*aiTemplate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiMode") != m.end() && !m["AiMode"].empty()) {
      aiMode = make_shared<string>(boost::any_cast<string>(m["AiMode"]));
    }
    if (m.find("AiTemplate") != m.end() && !m["AiTemplate"].empty()) {
      aiTemplate = make_shared<string>(boost::any_cast<string>(m["AiTemplate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~SetHttpDDoSAttackIntelligentProtectionResponseBody() = default;
};
class SetHttpDDoSAttackIntelligentProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetHttpDDoSAttackIntelligentProtectionResponseBody> body{};

  SetHttpDDoSAttackIntelligentProtectionResponse() {}

  explicit SetHttpDDoSAttackIntelligentProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetHttpDDoSAttackIntelligentProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetHttpDDoSAttackIntelligentProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~SetHttpDDoSAttackIntelligentProtectionResponse() = default;
};
class SetHttpDDoSAttackProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalMode{};
  shared_ptr<long> siteId{};

  SetHttpDDoSAttackProtectionRequest() {}

  explicit SetHttpDDoSAttackProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalMode) {
      res["GlobalMode"] = boost::any(*globalMode);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalMode") != m.end() && !m["GlobalMode"].empty()) {
      globalMode = make_shared<string>(boost::any_cast<string>(m["GlobalMode"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~SetHttpDDoSAttackProtectionRequest() = default;
};
class SetHttpDDoSAttackProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> globalMode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> siteId{};

  SetHttpDDoSAttackProtectionResponseBody() {}

  explicit SetHttpDDoSAttackProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalMode) {
      res["GlobalMode"] = boost::any(*globalMode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalMode") != m.end() && !m["GlobalMode"].empty()) {
      globalMode = make_shared<string>(boost::any_cast<string>(m["GlobalMode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~SetHttpDDoSAttackProtectionResponseBody() = default;
};
class SetHttpDDoSAttackProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetHttpDDoSAttackProtectionResponseBody> body{};

  SetHttpDDoSAttackProtectionResponse() {}

  explicit SetHttpDDoSAttackProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetHttpDDoSAttackProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetHttpDDoSAttackProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~SetHttpDDoSAttackProtectionResponse() = default;
};
class StartScheduledPreloadExecutionRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  StartScheduledPreloadExecutionRequest() {}

  explicit StartScheduledPreloadExecutionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~StartScheduledPreloadExecutionRequest() = default;
};
class StartScheduledPreloadExecutionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> sliceLen{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  StartScheduledPreloadExecutionResponseBody() {}

  explicit StartScheduledPreloadExecutionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sliceLen) {
      res["SliceLen"] = boost::any(*sliceLen);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SliceLen") != m.end() && !m["SliceLen"].empty()) {
      sliceLen = make_shared<long>(boost::any_cast<long>(m["SliceLen"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~StartScheduledPreloadExecutionResponseBody() = default;
};
class StartScheduledPreloadExecutionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartScheduledPreloadExecutionResponseBody> body{};

  StartScheduledPreloadExecutionResponse() {}

  explicit StartScheduledPreloadExecutionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartScheduledPreloadExecutionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartScheduledPreloadExecutionResponseBody>(model1);
      }
    }
  }


  virtual ~StartScheduledPreloadExecutionResponse() = default;
};
class StopScheduledPreloadExecutionRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  StopScheduledPreloadExecutionRequest() {}

  explicit StopScheduledPreloadExecutionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~StopScheduledPreloadExecutionRequest() = default;
};
class StopScheduledPreloadExecutionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> sliceLen{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  StopScheduledPreloadExecutionResponseBody() {}

  explicit StopScheduledPreloadExecutionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sliceLen) {
      res["SliceLen"] = boost::any(*sliceLen);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SliceLen") != m.end() && !m["SliceLen"].empty()) {
      sliceLen = make_shared<long>(boost::any_cast<long>(m["SliceLen"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~StopScheduledPreloadExecutionResponseBody() = default;
};
class StopScheduledPreloadExecutionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopScheduledPreloadExecutionResponseBody> body{};

  StopScheduledPreloadExecutionResponse() {}

  explicit StopScheduledPreloadExecutionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopScheduledPreloadExecutionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopScheduledPreloadExecutionResponseBody>(model1);
      }
    }
  }


  virtual ~StopScheduledPreloadExecutionResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateCustomScenePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> name{};
  shared_ptr<string> objects{};
  shared_ptr<long> policyId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> template_{};

  UpdateCustomScenePolicyRequest() {}

  explicit UpdateCustomScenePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objects) {
      res["Objects"] = boost::any(*objects);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Objects") != m.end() && !m["Objects"].empty()) {
      objects = make_shared<string>(boost::any_cast<string>(m["Objects"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~UpdateCustomScenePolicyRequest() = default;
};
class UpdateCustomScenePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> objects{};
  shared_ptr<long> policyId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> template_{};

  UpdateCustomScenePolicyResponseBody() {}

  explicit UpdateCustomScenePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objects) {
      res["Objects"] = boost::any(*objects);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Objects") != m.end() && !m["Objects"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Objects"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Objects"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      objects = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~UpdateCustomScenePolicyResponseBody() = default;
};
class UpdateCustomScenePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomScenePolicyResponseBody> body{};

  UpdateCustomScenePolicyResponse() {}

  explicit UpdateCustomScenePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomScenePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomScenePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomScenePolicyResponse() = default;
};
class UpdateKvNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> title{};

  UpdateKvNamespaceRequest() {}

  explicit UpdateKvNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateKvNamespaceRequest() = default;
};
class UpdateKvNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  UpdateKvNamespaceResponseBody() {}

  explicit UpdateKvNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateKvNamespaceResponseBody() = default;
};
class UpdateKvNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateKvNamespaceResponseBody> body{};

  UpdateKvNamespaceResponse() {}

  explicit UpdateKvNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateKvNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateKvNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateKvNamespaceResponse() = default;
};
class UpdateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> items{};
  shared_ptr<string> name{};

  UpdateListRequest() {}

  explicit UpdateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateListRequest() = default;
};
class UpdateListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> itemsShrink{};
  shared_ptr<string> name{};

  UpdateListShrinkRequest() {}

  explicit UpdateListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (itemsShrink) {
      res["Items"] = boost::any(*itemsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      itemsShrink = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateListShrinkRequest() = default;
};
class UpdateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateListResponseBody() {}

  explicit UpdateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateListResponseBody() = default;
};
class UpdateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateListResponseBody> body{};

  UpdateListResponse() {}

  explicit UpdateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateListResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateListResponse() = default;
};
class UpdateOriginProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> originConverge{};
  shared_ptr<long> siteId{};

  UpdateOriginProtectionRequest() {}

  explicit UpdateOriginProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originConverge) {
      res["OriginConverge"] = boost::any(*originConverge);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginConverge") != m.end() && !m["OriginConverge"].empty()) {
      originConverge = make_shared<string>(boost::any_cast<string>(m["OriginConverge"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~UpdateOriginProtectionRequest() = default;
};
class UpdateOriginProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOriginProtectionResponseBody() {}

  explicit UpdateOriginProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOriginProtectionResponseBody() = default;
};
class UpdateOriginProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateOriginProtectionResponseBody> body{};

  UpdateOriginProtectionResponse() {}

  explicit UpdateOriginProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOriginProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOriginProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOriginProtectionResponse() = default;
};
class UpdateOriginProtectionIpWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  UpdateOriginProtectionIpWhiteListRequest() {}

  explicit UpdateOriginProtectionIpWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~UpdateOriginProtectionIpWhiteListRequest() = default;
};
class UpdateOriginProtectionIpWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOriginProtectionIpWhiteListResponseBody() {}

  explicit UpdateOriginProtectionIpWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOriginProtectionIpWhiteListResponseBody() = default;
};
class UpdateOriginProtectionIpWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateOriginProtectionIpWhiteListResponseBody> body{};

  UpdateOriginProtectionIpWhiteListResponse() {}

  explicit UpdateOriginProtectionIpWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOriginProtectionIpWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOriginProtectionIpWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOriginProtectionIpWhiteListResponse() = default;
};
class UpdatePageRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  UpdatePageRequest() {}

  explicit UpdatePageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdatePageRequest() = default;
};
class UpdatePageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdatePageResponseBody() {}

  explicit UpdatePageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePageResponseBody() = default;
};
class UpdatePageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePageResponseBody> body{};

  UpdatePageResponse() {}

  explicit UpdatePageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePageResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePageResponse() = default;
};
class UpdateRecordRequestAuthConf : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> authType{};
  shared_ptr<string> region{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> version{};

  UpdateRecordRequestAuthConf() {}

  explicit UpdateRecordRequestAuthConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UpdateRecordRequestAuthConf() = default;
};
class UpdateRecordRequestData : public Darabonba::Model {
public:
  shared_ptr<long> algorithm{};
  shared_ptr<string> certificate{};
  shared_ptr<string> fingerprint{};
  shared_ptr<long> flag{};
  shared_ptr<long> keyTag{};
  shared_ptr<long> matchingType{};
  shared_ptr<long> port{};
  shared_ptr<long> priority{};
  shared_ptr<long> selector{};
  shared_ptr<string> tag{};
  shared_ptr<long> type{};
  shared_ptr<long> usage{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  UpdateRecordRequestData() {}

  explicit UpdateRecordRequestData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (keyTag) {
      res["KeyTag"] = boost::any(*keyTag);
    }
    if (matchingType) {
      res["MatchingType"] = boost::any(*matchingType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<long>(boost::any_cast<long>(m["Algorithm"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("KeyTag") != m.end() && !m["KeyTag"].empty()) {
      keyTag = make_shared<long>(boost::any_cast<long>(m["KeyTag"]));
    }
    if (m.find("MatchingType") != m.end() && !m["MatchingType"].empty()) {
      matchingType = make_shared<long>(boost::any_cast<long>(m["MatchingType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<long>(boost::any_cast<long>(m["Selector"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~UpdateRecordRequestData() = default;
};
class UpdateRecordRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateRecordRequestAuthConf> authConf{};
  shared_ptr<string> bizName{};
  shared_ptr<string> comment{};
  shared_ptr<UpdateRecordRequestData> data{};
  shared_ptr<string> hostPolicy{};
  shared_ptr<bool> proxied{};
  shared_ptr<long> recordId{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> ttl{};

  UpdateRecordRequest() {}

  explicit UpdateRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConf) {
      res["AuthConf"] = authConf ? boost::any(authConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostPolicy) {
      res["HostPolicy"] = boost::any(*hostPolicy);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthConf") != m.end() && !m["AuthConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthConf"].type()) {
        UpdateRecordRequestAuthConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthConf"]));
        authConf = make_shared<UpdateRecordRequestAuthConf>(model1);
      }
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateRecordRequestData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateRecordRequestData>(model1);
      }
    }
    if (m.find("HostPolicy") != m.end() && !m["HostPolicy"].empty()) {
      hostPolicy = make_shared<string>(boost::any_cast<string>(m["HostPolicy"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~UpdateRecordRequest() = default;
};
class UpdateRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> authConfShrink{};
  shared_ptr<string> bizName{};
  shared_ptr<string> comment{};
  shared_ptr<string> dataShrink{};
  shared_ptr<string> hostPolicy{};
  shared_ptr<bool> proxied{};
  shared_ptr<long> recordId{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> ttl{};

  UpdateRecordShrinkRequest() {}

  explicit UpdateRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConfShrink) {
      res["AuthConf"] = boost::any(*authConfShrink);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (dataShrink) {
      res["Data"] = boost::any(*dataShrink);
    }
    if (hostPolicy) {
      res["HostPolicy"] = boost::any(*hostPolicy);
    }
    if (proxied) {
      res["Proxied"] = boost::any(*proxied);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthConf") != m.end() && !m["AuthConf"].empty()) {
      authConfShrink = make_shared<string>(boost::any_cast<string>(m["AuthConf"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      dataShrink = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HostPolicy") != m.end() && !m["HostPolicy"].empty()) {
      hostPolicy = make_shared<string>(boost::any_cast<string>(m["HostPolicy"]));
    }
    if (m.find("Proxied") != m.end() && !m["Proxied"].empty()) {
      proxied = make_shared<bool>(boost::any_cast<bool>(m["Proxied"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~UpdateRecordShrinkRequest() = default;
};
class UpdateRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateRecordResponseBody() {}

  explicit UpdateRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRecordResponseBody() = default;
};
class UpdateRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRecordResponseBody> body{};

  UpdateRecordResponse() {}

  explicit UpdateRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRecordResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRecordResponse() = default;
};
class UpdateScheduledPreloadExecutionRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<long> sliceLen{};
  shared_ptr<string> startTime{};

  UpdateScheduledPreloadExecutionRequest() {}

  explicit UpdateScheduledPreloadExecutionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (sliceLen) {
      res["SliceLen"] = boost::any(*sliceLen);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("SliceLen") != m.end() && !m["SliceLen"].empty()) {
      sliceLen = make_shared<long>(boost::any_cast<long>(m["SliceLen"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~UpdateScheduledPreloadExecutionRequest() = default;
};
class UpdateScheduledPreloadExecutionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> sliceLen{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  UpdateScheduledPreloadExecutionResponseBody() {}

  explicit UpdateScheduledPreloadExecutionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sliceLen) {
      res["SliceLen"] = boost::any(*sliceLen);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SliceLen") != m.end() && !m["SliceLen"].empty()) {
      sliceLen = make_shared<long>(boost::any_cast<long>(m["SliceLen"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateScheduledPreloadExecutionResponseBody() = default;
};
class UpdateScheduledPreloadExecutionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateScheduledPreloadExecutionResponseBody> body{};

  UpdateScheduledPreloadExecutionResponse() {}

  explicit UpdateScheduledPreloadExecutionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateScheduledPreloadExecutionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateScheduledPreloadExecutionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateScheduledPreloadExecutionResponse() = default;
};
class UpdateSiteAccessTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<long> siteId{};

  UpdateSiteAccessTypeRequest() {}

  explicit UpdateSiteAccessTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~UpdateSiteAccessTypeRequest() = default;
};
class UpdateSiteAccessTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSiteAccessTypeResponseBody() {}

  explicit UpdateSiteAccessTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSiteAccessTypeResponseBody() = default;
};
class UpdateSiteAccessTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSiteAccessTypeResponseBody> body{};

  UpdateSiteAccessTypeResponse() {}

  explicit UpdateSiteAccessTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSiteAccessTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSiteAccessTypeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSiteAccessTypeResponse() = default;
};
class UpdateSiteCoverageRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverage{};
  shared_ptr<long> siteId{};

  UpdateSiteCoverageRequest() {}

  explicit UpdateSiteCoverageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~UpdateSiteCoverageRequest() = default;
};
class UpdateSiteCoverageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSiteCoverageResponseBody() {}

  explicit UpdateSiteCoverageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSiteCoverageResponseBody() = default;
};
class UpdateSiteCoverageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSiteCoverageResponseBody> body{};

  UpdateSiteCoverageResponse() {}

  explicit UpdateSiteCoverageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSiteCoverageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSiteCoverageResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSiteCoverageResponse() = default;
};
class UpdateSiteCustomLogRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cookies{};
  shared_ptr<vector<string>> requestHeaders{};
  shared_ptr<vector<string>> responseHeaders{};
  shared_ptr<long> siteId{};

  UpdateSiteCustomLogRequest() {}

  explicit UpdateSiteCustomLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookies) {
      res["Cookies"] = boost::any(*cookies);
    }
    if (requestHeaders) {
      res["RequestHeaders"] = boost::any(*requestHeaders);
    }
    if (responseHeaders) {
      res["ResponseHeaders"] = boost::any(*responseHeaders);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookies") != m.end() && !m["Cookies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Cookies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Cookies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cookies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResponseHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResponseHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      responseHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~UpdateSiteCustomLogRequest() = default;
};
class UpdateSiteCustomLogShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cookiesShrink{};
  shared_ptr<string> requestHeadersShrink{};
  shared_ptr<string> responseHeadersShrink{};
  shared_ptr<long> siteId{};

  UpdateSiteCustomLogShrinkRequest() {}

  explicit UpdateSiteCustomLogShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookiesShrink) {
      res["Cookies"] = boost::any(*cookiesShrink);
    }
    if (requestHeadersShrink) {
      res["RequestHeaders"] = boost::any(*requestHeadersShrink);
    }
    if (responseHeadersShrink) {
      res["ResponseHeaders"] = boost::any(*responseHeadersShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookies") != m.end() && !m["Cookies"].empty()) {
      cookiesShrink = make_shared<string>(boost::any_cast<string>(m["Cookies"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      requestHeadersShrink = make_shared<string>(boost::any_cast<string>(m["RequestHeaders"]));
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      responseHeadersShrink = make_shared<string>(boost::any_cast<string>(m["ResponseHeaders"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~UpdateSiteCustomLogShrinkRequest() = default;
};
class UpdateSiteCustomLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSiteCustomLogResponseBody() {}

  explicit UpdateSiteCustomLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSiteCustomLogResponseBody() = default;
};
class UpdateSiteCustomLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSiteCustomLogResponseBody> body{};

  UpdateSiteCustomLogResponse() {}

  explicit UpdateSiteCustomLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSiteCustomLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSiteCustomLogResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSiteCustomLogResponse() = default;
};
class UpdateSiteDeliveryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<double> discardRate{};
  shared_ptr<string> fieldName{};
  shared_ptr<long> siteId{};
  shared_ptr<string> taskName{};

  UpdateSiteDeliveryTaskRequest() {}

  explicit UpdateSiteDeliveryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (discardRate) {
      res["DiscardRate"] = boost::any(*discardRate);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DiscardRate") != m.end() && !m["DiscardRate"].empty()) {
      discardRate = make_shared<double>(boost::any_cast<double>(m["DiscardRate"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~UpdateSiteDeliveryTaskRequest() = default;
};
class UpdateSiteDeliveryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSiteDeliveryTaskResponseBody() {}

  explicit UpdateSiteDeliveryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSiteDeliveryTaskResponseBody() = default;
};
class UpdateSiteDeliveryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSiteDeliveryTaskResponseBody> body{};

  UpdateSiteDeliveryTaskResponse() {}

  explicit UpdateSiteDeliveryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSiteDeliveryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSiteDeliveryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSiteDeliveryTaskResponse() = default;
};
class UpdateSiteDeliveryTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<long> siteId{};
  shared_ptr<string> taskName{};

  UpdateSiteDeliveryTaskStatusRequest() {}

  explicit UpdateSiteDeliveryTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~UpdateSiteDeliveryTaskStatusRequest() = default;
};
class UpdateSiteDeliveryTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  UpdateSiteDeliveryTaskStatusResponseBody() {}

  explicit UpdateSiteDeliveryTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~UpdateSiteDeliveryTaskStatusResponseBody() = default;
};
class UpdateSiteDeliveryTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSiteDeliveryTaskStatusResponseBody> body{};

  UpdateSiteDeliveryTaskStatusResponse() {}

  explicit UpdateSiteDeliveryTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSiteDeliveryTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSiteDeliveryTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSiteDeliveryTaskStatusResponse() = default;
};
class UpdateSiteFunctionRequestCacheReserve : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};
  shared_ptr<string> instanceId{};

  UpdateSiteFunctionRequestCacheReserve() {}

  explicit UpdateSiteFunctionRequestCacheReserve(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestCacheReserve() = default;
};
class UpdateSiteFunctionRequestCacheRules : public Darabonba::Model {
public:
  shared_ptr<string> additionalCacheablePorts{};
  shared_ptr<string> browserCacheMode{};
  shared_ptr<string> browserCacheTtl{};
  shared_ptr<string> bypassCache{};
  shared_ptr<string> cacheDeceptionArmor{};
  shared_ptr<string> cacheReserveEligibility{};
  shared_ptr<string> checkPresenceCookie{};
  shared_ptr<string> checkPresenceHeader{};
  shared_ptr<long> configId{};
  shared_ptr<string> edgeCacheMode{};
  shared_ptr<string> edgeCacheTtl{};
  shared_ptr<string> edgeStatusCodeCacheTtl{};
  shared_ptr<string> includeCookie{};
  shared_ptr<string> includeHeader{};
  shared_ptr<string> queryString{};
  shared_ptr<string> queryStringMode{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> serveStale{};
  shared_ptr<string> sortQueryStringForCache{};
  shared_ptr<string> userDeviceType{};
  shared_ptr<string> userGeo{};
  shared_ptr<string> userLanguage{};

  UpdateSiteFunctionRequestCacheRules() {}

  explicit UpdateSiteFunctionRequestCacheRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalCacheablePorts) {
      res["AdditionalCacheablePorts"] = boost::any(*additionalCacheablePorts);
    }
    if (browserCacheMode) {
      res["BrowserCacheMode"] = boost::any(*browserCacheMode);
    }
    if (browserCacheTtl) {
      res["BrowserCacheTtl"] = boost::any(*browserCacheTtl);
    }
    if (bypassCache) {
      res["BypassCache"] = boost::any(*bypassCache);
    }
    if (cacheDeceptionArmor) {
      res["CacheDeceptionArmor"] = boost::any(*cacheDeceptionArmor);
    }
    if (cacheReserveEligibility) {
      res["CacheReserveEligibility"] = boost::any(*cacheReserveEligibility);
    }
    if (checkPresenceCookie) {
      res["CheckPresenceCookie"] = boost::any(*checkPresenceCookie);
    }
    if (checkPresenceHeader) {
      res["CheckPresenceHeader"] = boost::any(*checkPresenceHeader);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (edgeCacheMode) {
      res["EdgeCacheMode"] = boost::any(*edgeCacheMode);
    }
    if (edgeCacheTtl) {
      res["EdgeCacheTtl"] = boost::any(*edgeCacheTtl);
    }
    if (edgeStatusCodeCacheTtl) {
      res["EdgeStatusCodeCacheTtl"] = boost::any(*edgeStatusCodeCacheTtl);
    }
    if (includeCookie) {
      res["IncludeCookie"] = boost::any(*includeCookie);
    }
    if (includeHeader) {
      res["IncludeHeader"] = boost::any(*includeHeader);
    }
    if (queryString) {
      res["QueryString"] = boost::any(*queryString);
    }
    if (queryStringMode) {
      res["QueryStringMode"] = boost::any(*queryStringMode);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (serveStale) {
      res["ServeStale"] = boost::any(*serveStale);
    }
    if (sortQueryStringForCache) {
      res["SortQueryStringForCache"] = boost::any(*sortQueryStringForCache);
    }
    if (userDeviceType) {
      res["UserDeviceType"] = boost::any(*userDeviceType);
    }
    if (userGeo) {
      res["UserGeo"] = boost::any(*userGeo);
    }
    if (userLanguage) {
      res["UserLanguage"] = boost::any(*userLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalCacheablePorts") != m.end() && !m["AdditionalCacheablePorts"].empty()) {
      additionalCacheablePorts = make_shared<string>(boost::any_cast<string>(m["AdditionalCacheablePorts"]));
    }
    if (m.find("BrowserCacheMode") != m.end() && !m["BrowserCacheMode"].empty()) {
      browserCacheMode = make_shared<string>(boost::any_cast<string>(m["BrowserCacheMode"]));
    }
    if (m.find("BrowserCacheTtl") != m.end() && !m["BrowserCacheTtl"].empty()) {
      browserCacheTtl = make_shared<string>(boost::any_cast<string>(m["BrowserCacheTtl"]));
    }
    if (m.find("BypassCache") != m.end() && !m["BypassCache"].empty()) {
      bypassCache = make_shared<string>(boost::any_cast<string>(m["BypassCache"]));
    }
    if (m.find("CacheDeceptionArmor") != m.end() && !m["CacheDeceptionArmor"].empty()) {
      cacheDeceptionArmor = make_shared<string>(boost::any_cast<string>(m["CacheDeceptionArmor"]));
    }
    if (m.find("CacheReserveEligibility") != m.end() && !m["CacheReserveEligibility"].empty()) {
      cacheReserveEligibility = make_shared<string>(boost::any_cast<string>(m["CacheReserveEligibility"]));
    }
    if (m.find("CheckPresenceCookie") != m.end() && !m["CheckPresenceCookie"].empty()) {
      checkPresenceCookie = make_shared<string>(boost::any_cast<string>(m["CheckPresenceCookie"]));
    }
    if (m.find("CheckPresenceHeader") != m.end() && !m["CheckPresenceHeader"].empty()) {
      checkPresenceHeader = make_shared<string>(boost::any_cast<string>(m["CheckPresenceHeader"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("EdgeCacheMode") != m.end() && !m["EdgeCacheMode"].empty()) {
      edgeCacheMode = make_shared<string>(boost::any_cast<string>(m["EdgeCacheMode"]));
    }
    if (m.find("EdgeCacheTtl") != m.end() && !m["EdgeCacheTtl"].empty()) {
      edgeCacheTtl = make_shared<string>(boost::any_cast<string>(m["EdgeCacheTtl"]));
    }
    if (m.find("EdgeStatusCodeCacheTtl") != m.end() && !m["EdgeStatusCodeCacheTtl"].empty()) {
      edgeStatusCodeCacheTtl = make_shared<string>(boost::any_cast<string>(m["EdgeStatusCodeCacheTtl"]));
    }
    if (m.find("IncludeCookie") != m.end() && !m["IncludeCookie"].empty()) {
      includeCookie = make_shared<string>(boost::any_cast<string>(m["IncludeCookie"]));
    }
    if (m.find("IncludeHeader") != m.end() && !m["IncludeHeader"].empty()) {
      includeHeader = make_shared<string>(boost::any_cast<string>(m["IncludeHeader"]));
    }
    if (m.find("QueryString") != m.end() && !m["QueryString"].empty()) {
      queryString = make_shared<string>(boost::any_cast<string>(m["QueryString"]));
    }
    if (m.find("QueryStringMode") != m.end() && !m["QueryStringMode"].empty()) {
      queryStringMode = make_shared<string>(boost::any_cast<string>(m["QueryStringMode"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("ServeStale") != m.end() && !m["ServeStale"].empty()) {
      serveStale = make_shared<string>(boost::any_cast<string>(m["ServeStale"]));
    }
    if (m.find("SortQueryStringForCache") != m.end() && !m["SortQueryStringForCache"].empty()) {
      sortQueryStringForCache = make_shared<string>(boost::any_cast<string>(m["SortQueryStringForCache"]));
    }
    if (m.find("UserDeviceType") != m.end() && !m["UserDeviceType"].empty()) {
      userDeviceType = make_shared<string>(boost::any_cast<string>(m["UserDeviceType"]));
    }
    if (m.find("UserGeo") != m.end() && !m["UserGeo"].empty()) {
      userGeo = make_shared<string>(boost::any_cast<string>(m["UserGeo"]));
    }
    if (m.find("UserLanguage") != m.end() && !m["UserLanguage"].empty()) {
      userLanguage = make_shared<string>(boost::any_cast<string>(m["UserLanguage"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestCacheRules() = default;
};
class UpdateSiteFunctionRequestCacheTags : public Darabonba::Model {
public:
  shared_ptr<string> caseInsensitive{};
  shared_ptr<long> configId{};
  shared_ptr<string> tagName{};

  UpdateSiteFunctionRequestCacheTags() {}

  explicit UpdateSiteFunctionRequestCacheTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caseInsensitive) {
      res["CaseInsensitive"] = boost::any(*caseInsensitive);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaseInsensitive") != m.end() && !m["CaseInsensitive"].empty()) {
      caseInsensitive = make_shared<string>(boost::any_cast<string>(m["CaseInsensitive"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestCacheTags() = default;
};
class UpdateSiteFunctionRequestCnameFlattening : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> flattenMode{};

  UpdateSiteFunctionRequestCnameFlattening() {}

  explicit UpdateSiteFunctionRequestCnameFlattening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (flattenMode) {
      res["FlattenMode"] = boost::any(*flattenMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("FlattenMode") != m.end() && !m["FlattenMode"].empty()) {
      flattenMode = make_shared<string>(boost::any_cast<string>(m["FlattenMode"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestCnameFlattening() = default;
};
class UpdateSiteFunctionRequestCompressionRules : public Darabonba::Model {
public:
  shared_ptr<string> brotli{};
  shared_ptr<long> configId{};
  shared_ptr<string> gzip{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  UpdateSiteFunctionRequestCompressionRules() {}

  explicit UpdateSiteFunctionRequestCompressionRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (brotli) {
      res["Brotli"] = boost::any(*brotli);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (gzip) {
      res["Gzip"] = boost::any(*gzip);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Brotli") != m.end() && !m["Brotli"].empty()) {
      brotli = make_shared<string>(boost::any_cast<string>(m["Brotli"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Gzip") != m.end() && !m["Gzip"].empty()) {
      gzip = make_shared<string>(boost::any_cast<string>(m["Gzip"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestCompressionRules() = default;
};
class UpdateSiteFunctionRequestCrossBorderOptimization : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};

  UpdateSiteFunctionRequestCrossBorderOptimization() {}

  explicit UpdateSiteFunctionRequestCrossBorderOptimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestCrossBorderOptimization() = default;
};
class UpdateSiteFunctionRequestDevelopmentMode : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};

  UpdateSiteFunctionRequestDevelopmentMode() {}

  explicit UpdateSiteFunctionRequestDevelopmentMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestDevelopmentMode() = default;
};
class UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification() {}

  explicit UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification() = default;
};
class UpdateSiteFunctionRequestHttpRequestHeaderModificationRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<vector<UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification>> requestHeaderModification{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  UpdateSiteFunctionRequestHttpRequestHeaderModificationRules() {}

  explicit UpdateSiteFunctionRequestHttpRequestHeaderModificationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (requestHeaderModification) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaderModification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaderModification"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("RequestHeaderModification") != m.end() && !m["RequestHeaderModification"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaderModification"].type()) {
        vector<UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaderModification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaderModification = make_shared<vector<UpdateSiteFunctionRequestHttpRequestHeaderModificationRulesRequestHeaderModification>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestHttpRequestHeaderModificationRules() = default;
};
class UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification() {}

  explicit UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification() = default;
};
class UpdateSiteFunctionRequestHttpResponseHeaderModificationRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<vector<UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification>> responseHeaderModification{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  UpdateSiteFunctionRequestHttpResponseHeaderModificationRules() {}

  explicit UpdateSiteFunctionRequestHttpResponseHeaderModificationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (responseHeaderModification) {
      vector<boost::any> temp1;
      for(auto item1:*responseHeaderModification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseHeaderModification"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("ResponseHeaderModification") != m.end() && !m["ResponseHeaderModification"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseHeaderModification"].type()) {
        vector<UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseHeaderModification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseHeaderModification = make_shared<vector<UpdateSiteFunctionRequestHttpResponseHeaderModificationRulesResponseHeaderModification>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestHttpResponseHeaderModificationRules() = default;
};
class UpdateSiteFunctionRequestHttpsApplicationConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> altSvc{};
  shared_ptr<string> altSvcClear{};
  shared_ptr<string> altSvcMa{};
  shared_ptr<string> altSvcPersist{};
  shared_ptr<long> configId{};
  shared_ptr<string> hsts{};
  shared_ptr<string> hstsIncludeSubdomains{};
  shared_ptr<string> hstsMaxAge{};
  shared_ptr<string> hstsPreload{};
  shared_ptr<string> httpsForce{};
  shared_ptr<string> httpsForceCode{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  UpdateSiteFunctionRequestHttpsApplicationConfiguration() {}

  explicit UpdateSiteFunctionRequestHttpsApplicationConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (altSvc) {
      res["AltSvc"] = boost::any(*altSvc);
    }
    if (altSvcClear) {
      res["AltSvcClear"] = boost::any(*altSvcClear);
    }
    if (altSvcMa) {
      res["AltSvcMa"] = boost::any(*altSvcMa);
    }
    if (altSvcPersist) {
      res["AltSvcPersist"] = boost::any(*altSvcPersist);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (hsts) {
      res["Hsts"] = boost::any(*hsts);
    }
    if (hstsIncludeSubdomains) {
      res["HstsIncludeSubdomains"] = boost::any(*hstsIncludeSubdomains);
    }
    if (hstsMaxAge) {
      res["HstsMaxAge"] = boost::any(*hstsMaxAge);
    }
    if (hstsPreload) {
      res["HstsPreload"] = boost::any(*hstsPreload);
    }
    if (httpsForce) {
      res["HttpsForce"] = boost::any(*httpsForce);
    }
    if (httpsForceCode) {
      res["HttpsForceCode"] = boost::any(*httpsForceCode);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AltSvc") != m.end() && !m["AltSvc"].empty()) {
      altSvc = make_shared<string>(boost::any_cast<string>(m["AltSvc"]));
    }
    if (m.find("AltSvcClear") != m.end() && !m["AltSvcClear"].empty()) {
      altSvcClear = make_shared<string>(boost::any_cast<string>(m["AltSvcClear"]));
    }
    if (m.find("AltSvcMa") != m.end() && !m["AltSvcMa"].empty()) {
      altSvcMa = make_shared<string>(boost::any_cast<string>(m["AltSvcMa"]));
    }
    if (m.find("AltSvcPersist") != m.end() && !m["AltSvcPersist"].empty()) {
      altSvcPersist = make_shared<string>(boost::any_cast<string>(m["AltSvcPersist"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Hsts") != m.end() && !m["Hsts"].empty()) {
      hsts = make_shared<string>(boost::any_cast<string>(m["Hsts"]));
    }
    if (m.find("HstsIncludeSubdomains") != m.end() && !m["HstsIncludeSubdomains"].empty()) {
      hstsIncludeSubdomains = make_shared<string>(boost::any_cast<string>(m["HstsIncludeSubdomains"]));
    }
    if (m.find("HstsMaxAge") != m.end() && !m["HstsMaxAge"].empty()) {
      hstsMaxAge = make_shared<string>(boost::any_cast<string>(m["HstsMaxAge"]));
    }
    if (m.find("HstsPreload") != m.end() && !m["HstsPreload"].empty()) {
      hstsPreload = make_shared<string>(boost::any_cast<string>(m["HstsPreload"]));
    }
    if (m.find("HttpsForce") != m.end() && !m["HttpsForce"].empty()) {
      httpsForce = make_shared<string>(boost::any_cast<string>(m["HttpsForce"]));
    }
    if (m.find("HttpsForceCode") != m.end() && !m["HttpsForceCode"].empty()) {
      httpsForceCode = make_shared<string>(boost::any_cast<string>(m["HttpsForceCode"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestHttpsApplicationConfiguration() = default;
};
class UpdateSiteFunctionRequestHttpsBasicConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> ciphersuite{};
  shared_ptr<string> ciphersuiteGroup{};
  shared_ptr<long> configId{};
  shared_ptr<string> http2{};
  shared_ptr<string> http3{};
  shared_ptr<string> https{};
  shared_ptr<string> ocspStapling{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> tls10{};
  shared_ptr<string> tls11{};
  shared_ptr<string> tls12{};
  shared_ptr<string> tls13{};

  UpdateSiteFunctionRequestHttpsBasicConfiguration() {}

  explicit UpdateSiteFunctionRequestHttpsBasicConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphersuite) {
      res["Ciphersuite"] = boost::any(*ciphersuite);
    }
    if (ciphersuiteGroup) {
      res["CiphersuiteGroup"] = boost::any(*ciphersuiteGroup);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (http2) {
      res["Http2"] = boost::any(*http2);
    }
    if (http3) {
      res["Http3"] = boost::any(*http3);
    }
    if (https) {
      res["Https"] = boost::any(*https);
    }
    if (ocspStapling) {
      res["OcspStapling"] = boost::any(*ocspStapling);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (tls10) {
      res["Tls10"] = boost::any(*tls10);
    }
    if (tls11) {
      res["Tls11"] = boost::any(*tls11);
    }
    if (tls12) {
      res["Tls12"] = boost::any(*tls12);
    }
    if (tls13) {
      res["Tls13"] = boost::any(*tls13);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ciphersuite") != m.end() && !m["Ciphersuite"].empty()) {
      ciphersuite = make_shared<string>(boost::any_cast<string>(m["Ciphersuite"]));
    }
    if (m.find("CiphersuiteGroup") != m.end() && !m["CiphersuiteGroup"].empty()) {
      ciphersuiteGroup = make_shared<string>(boost::any_cast<string>(m["CiphersuiteGroup"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Http2") != m.end() && !m["Http2"].empty()) {
      http2 = make_shared<string>(boost::any_cast<string>(m["Http2"]));
    }
    if (m.find("Http3") != m.end() && !m["Http3"].empty()) {
      http3 = make_shared<string>(boost::any_cast<string>(m["Http3"]));
    }
    if (m.find("Https") != m.end() && !m["Https"].empty()) {
      https = make_shared<string>(boost::any_cast<string>(m["Https"]));
    }
    if (m.find("OcspStapling") != m.end() && !m["OcspStapling"].empty()) {
      ocspStapling = make_shared<string>(boost::any_cast<string>(m["OcspStapling"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Tls10") != m.end() && !m["Tls10"].empty()) {
      tls10 = make_shared<string>(boost::any_cast<string>(m["Tls10"]));
    }
    if (m.find("Tls11") != m.end() && !m["Tls11"].empty()) {
      tls11 = make_shared<string>(boost::any_cast<string>(m["Tls11"]));
    }
    if (m.find("Tls12") != m.end() && !m["Tls12"].empty()) {
      tls12 = make_shared<string>(boost::any_cast<string>(m["Tls12"]));
    }
    if (m.find("Tls13") != m.end() && !m["Tls13"].empty()) {
      tls13 = make_shared<string>(boost::any_cast<string>(m["Tls13"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestHttpsBasicConfiguration() = default;
};
class UpdateSiteFunctionRequestImageTransform : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};

  UpdateSiteFunctionRequestImageTransform() {}

  explicit UpdateSiteFunctionRequestImageTransform(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestImageTransform() = default;
};
class UpdateSiteFunctionRequestIpv6 : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};

  UpdateSiteFunctionRequestIpv6() {}

  explicit UpdateSiteFunctionRequestIpv6(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestIpv6() = default;
};
class UpdateSiteFunctionRequestManagedTransforms : public Darabonba::Model {
public:
  shared_ptr<string> addClientGeolocationHeaders{};
  shared_ptr<string> addRealClientIpHeader{};
  shared_ptr<long> configId{};

  UpdateSiteFunctionRequestManagedTransforms() {}

  explicit UpdateSiteFunctionRequestManagedTransforms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addClientGeolocationHeaders) {
      res["AddClientGeolocationHeaders"] = boost::any(*addClientGeolocationHeaders);
    }
    if (addRealClientIpHeader) {
      res["AddRealClientIpHeader"] = boost::any(*addRealClientIpHeader);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddClientGeolocationHeaders") != m.end() && !m["AddClientGeolocationHeaders"].empty()) {
      addClientGeolocationHeaders = make_shared<string>(boost::any_cast<string>(m["AddClientGeolocationHeaders"]));
    }
    if (m.find("AddRealClientIpHeader") != m.end() && !m["AddRealClientIpHeader"].empty()) {
      addRealClientIpHeader = make_shared<string>(boost::any_cast<string>(m["AddRealClientIpHeader"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestManagedTransforms() = default;
};
class UpdateSiteFunctionRequestNetworkOptimization : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> grpc{};
  shared_ptr<string> http2Origin{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> smartRouting{};
  shared_ptr<string> uploadMaxFilesize{};
  shared_ptr<string> websocket{};

  UpdateSiteFunctionRequestNetworkOptimization() {}

  explicit UpdateSiteFunctionRequestNetworkOptimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (grpc) {
      res["Grpc"] = boost::any(*grpc);
    }
    if (http2Origin) {
      res["Http2Origin"] = boost::any(*http2Origin);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (smartRouting) {
      res["SmartRouting"] = boost::any(*smartRouting);
    }
    if (uploadMaxFilesize) {
      res["UploadMaxFilesize"] = boost::any(*uploadMaxFilesize);
    }
    if (websocket) {
      res["Websocket"] = boost::any(*websocket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Grpc") != m.end() && !m["Grpc"].empty()) {
      grpc = make_shared<string>(boost::any_cast<string>(m["Grpc"]));
    }
    if (m.find("Http2Origin") != m.end() && !m["Http2Origin"].empty()) {
      http2Origin = make_shared<string>(boost::any_cast<string>(m["Http2Origin"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SmartRouting") != m.end() && !m["SmartRouting"].empty()) {
      smartRouting = make_shared<string>(boost::any_cast<string>(m["SmartRouting"]));
    }
    if (m.find("UploadMaxFilesize") != m.end() && !m["UploadMaxFilesize"].empty()) {
      uploadMaxFilesize = make_shared<string>(boost::any_cast<string>(m["UploadMaxFilesize"]));
    }
    if (m.find("Websocket") != m.end() && !m["Websocket"].empty()) {
      websocket = make_shared<string>(boost::any_cast<string>(m["Websocket"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestNetworkOptimization() = default;
};
class UpdateSiteFunctionRequestOriginRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> dnsRecord{};
  shared_ptr<string> originHost{};
  shared_ptr<string> originHttpPort{};
  shared_ptr<string> originHttpsPort{};
  shared_ptr<string> originScheme{};
  shared_ptr<string> originSni{};
  shared_ptr<string> range{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};

  UpdateSiteFunctionRequestOriginRules() {}

  explicit UpdateSiteFunctionRequestOriginRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (dnsRecord) {
      res["DnsRecord"] = boost::any(*dnsRecord);
    }
    if (originHost) {
      res["OriginHost"] = boost::any(*originHost);
    }
    if (originHttpPort) {
      res["OriginHttpPort"] = boost::any(*originHttpPort);
    }
    if (originHttpsPort) {
      res["OriginHttpsPort"] = boost::any(*originHttpsPort);
    }
    if (originScheme) {
      res["OriginScheme"] = boost::any(*originScheme);
    }
    if (originSni) {
      res["OriginSni"] = boost::any(*originSni);
    }
    if (range) {
      res["Range"] = boost::any(*range);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("DnsRecord") != m.end() && !m["DnsRecord"].empty()) {
      dnsRecord = make_shared<string>(boost::any_cast<string>(m["DnsRecord"]));
    }
    if (m.find("OriginHost") != m.end() && !m["OriginHost"].empty()) {
      originHost = make_shared<string>(boost::any_cast<string>(m["OriginHost"]));
    }
    if (m.find("OriginHttpPort") != m.end() && !m["OriginHttpPort"].empty()) {
      originHttpPort = make_shared<string>(boost::any_cast<string>(m["OriginHttpPort"]));
    }
    if (m.find("OriginHttpsPort") != m.end() && !m["OriginHttpsPort"].empty()) {
      originHttpsPort = make_shared<string>(boost::any_cast<string>(m["OriginHttpsPort"]));
    }
    if (m.find("OriginScheme") != m.end() && !m["OriginScheme"].empty()) {
      originScheme = make_shared<string>(boost::any_cast<string>(m["OriginScheme"]));
    }
    if (m.find("OriginSni") != m.end() && !m["OriginSni"].empty()) {
      originSni = make_shared<string>(boost::any_cast<string>(m["OriginSni"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      range = make_shared<string>(boost::any_cast<string>(m["Range"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestOriginRules() = default;
};
class UpdateSiteFunctionRequestRedirectRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> reserveQueryString{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> type{};

  UpdateSiteFunctionRequestRedirectRules() {}

  explicit UpdateSiteFunctionRequestRedirectRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (reserveQueryString) {
      res["ReserveQueryString"] = boost::any(*reserveQueryString);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("ReserveQueryString") != m.end() && !m["ReserveQueryString"].empty()) {
      reserveQueryString = make_shared<string>(boost::any_cast<string>(m["ReserveQueryString"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestRedirectRules() = default;
};
class UpdateSiteFunctionRequestRewriteUrlRules : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> queryString{};
  shared_ptr<string> rewriteQueryStringType{};
  shared_ptr<string> rewriteUriType{};
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> uri{};

  UpdateSiteFunctionRequestRewriteUrlRules() {}

  explicit UpdateSiteFunctionRequestRewriteUrlRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (queryString) {
      res["QueryString"] = boost::any(*queryString);
    }
    if (rewriteQueryStringType) {
      res["RewriteQueryStringType"] = boost::any(*rewriteQueryStringType);
    }
    if (rewriteUriType) {
      res["RewriteUriType"] = boost::any(*rewriteUriType);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("QueryString") != m.end() && !m["QueryString"].empty()) {
      queryString = make_shared<string>(boost::any_cast<string>(m["QueryString"]));
    }
    if (m.find("RewriteQueryStringType") != m.end() && !m["RewriteQueryStringType"].empty()) {
      rewriteQueryStringType = make_shared<string>(boost::any_cast<string>(m["RewriteQueryStringType"]));
    }
    if (m.find("RewriteUriType") != m.end() && !m["RewriteUriType"].empty()) {
      rewriteUriType = make_shared<string>(boost::any_cast<string>(m["RewriteUriType"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestRewriteUrlRules() = default;
};
class UpdateSiteFunctionRequestSeoBypass : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};

  UpdateSiteFunctionRequestSeoBypass() {}

  explicit UpdateSiteFunctionRequestSeoBypass(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestSeoBypass() = default;
};
class UpdateSiteFunctionRequestSiteNameExclusive : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> enable{};

  UpdateSiteFunctionRequestSiteNameExclusive() {}

  explicit UpdateSiteFunctionRequestSiteNameExclusive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestSiteNameExclusive() = default;
};
class UpdateSiteFunctionRequestSitePause : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> paused{};

  UpdateSiteFunctionRequestSitePause() {}

  explicit UpdateSiteFunctionRequestSitePause(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (paused) {
      res["Paused"] = boost::any(*paused);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("Paused") != m.end() && !m["Paused"].empty()) {
      paused = make_shared<string>(boost::any_cast<string>(m["Paused"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestSitePause() = default;
};
class UpdateSiteFunctionRequestTieredCache : public Darabonba::Model {
public:
  shared_ptr<string> cacheArchitectureMode{};
  shared_ptr<long> configId{};

  UpdateSiteFunctionRequestTieredCache() {}

  explicit UpdateSiteFunctionRequestTieredCache(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheArchitectureMode) {
      res["CacheArchitectureMode"] = boost::any(*cacheArchitectureMode);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheArchitectureMode") != m.end() && !m["CacheArchitectureMode"].empty()) {
      cacheArchitectureMode = make_shared<string>(boost::any_cast<string>(m["CacheArchitectureMode"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
  }


  virtual ~UpdateSiteFunctionRequestTieredCache() = default;
};
class UpdateSiteFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateSiteFunctionRequestCacheReserve>> cacheReserve{};
  shared_ptr<vector<UpdateSiteFunctionRequestCacheRules>> cacheRules{};
  shared_ptr<vector<UpdateSiteFunctionRequestCacheTags>> cacheTags{};
  shared_ptr<vector<UpdateSiteFunctionRequestCnameFlattening>> cnameFlattening{};
  shared_ptr<vector<UpdateSiteFunctionRequestCompressionRules>> compressionRules{};
  shared_ptr<vector<UpdateSiteFunctionRequestCrossBorderOptimization>> crossBorderOptimization{};
  shared_ptr<vector<UpdateSiteFunctionRequestDevelopmentMode>> developmentMode{};
  shared_ptr<vector<UpdateSiteFunctionRequestHttpRequestHeaderModificationRules>> httpRequestHeaderModificationRules{};
  shared_ptr<vector<UpdateSiteFunctionRequestHttpResponseHeaderModificationRules>> httpResponseHeaderModificationRules{};
  shared_ptr<vector<UpdateSiteFunctionRequestHttpsApplicationConfiguration>> httpsApplicationConfiguration{};
  shared_ptr<vector<UpdateSiteFunctionRequestHttpsBasicConfiguration>> httpsBasicConfiguration{};
  shared_ptr<vector<UpdateSiteFunctionRequestImageTransform>> imageTransform{};
  shared_ptr<vector<UpdateSiteFunctionRequestIpv6>> ipv6{};
  shared_ptr<vector<UpdateSiteFunctionRequestManagedTransforms>> managedTransforms{};
  shared_ptr<vector<UpdateSiteFunctionRequestNetworkOptimization>> networkOptimization{};
  shared_ptr<vector<UpdateSiteFunctionRequestOriginRules>> originRules{};
  shared_ptr<vector<UpdateSiteFunctionRequestRedirectRules>> redirectRules{};
  shared_ptr<vector<UpdateSiteFunctionRequestRewriteUrlRules>> rewriteUrlRules{};
  shared_ptr<vector<UpdateSiteFunctionRequestSeoBypass>> seoBypass{};
  shared_ptr<long> siteId{};
  shared_ptr<vector<UpdateSiteFunctionRequestSiteNameExclusive>> siteNameExclusive{};
  shared_ptr<vector<UpdateSiteFunctionRequestSitePause>> sitePause{};
  shared_ptr<vector<UpdateSiteFunctionRequestTieredCache>> tieredCache{};

  UpdateSiteFunctionRequest() {}

  explicit UpdateSiteFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheReserve) {
      vector<boost::any> temp1;
      for(auto item1:*cacheReserve){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheReserve"] = boost::any(temp1);
    }
    if (cacheRules) {
      vector<boost::any> temp1;
      for(auto item1:*cacheRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheRules"] = boost::any(temp1);
    }
    if (cacheTags) {
      vector<boost::any> temp1;
      for(auto item1:*cacheTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CacheTags"] = boost::any(temp1);
    }
    if (cnameFlattening) {
      vector<boost::any> temp1;
      for(auto item1:*cnameFlattening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CnameFlattening"] = boost::any(temp1);
    }
    if (compressionRules) {
      vector<boost::any> temp1;
      for(auto item1:*compressionRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CompressionRules"] = boost::any(temp1);
    }
    if (crossBorderOptimization) {
      vector<boost::any> temp1;
      for(auto item1:*crossBorderOptimization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CrossBorderOptimization"] = boost::any(temp1);
    }
    if (developmentMode) {
      vector<boost::any> temp1;
      for(auto item1:*developmentMode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DevelopmentMode"] = boost::any(temp1);
    }
    if (httpRequestHeaderModificationRules) {
      vector<boost::any> temp1;
      for(auto item1:*httpRequestHeaderModificationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpRequestHeaderModificationRules"] = boost::any(temp1);
    }
    if (httpResponseHeaderModificationRules) {
      vector<boost::any> temp1;
      for(auto item1:*httpResponseHeaderModificationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpResponseHeaderModificationRules"] = boost::any(temp1);
    }
    if (httpsApplicationConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*httpsApplicationConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpsApplicationConfiguration"] = boost::any(temp1);
    }
    if (httpsBasicConfiguration) {
      vector<boost::any> temp1;
      for(auto item1:*httpsBasicConfiguration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpsBasicConfiguration"] = boost::any(temp1);
    }
    if (imageTransform) {
      vector<boost::any> temp1;
      for(auto item1:*imageTransform){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageTransform"] = boost::any(temp1);
    }
    if (ipv6) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6"] = boost::any(temp1);
    }
    if (managedTransforms) {
      vector<boost::any> temp1;
      for(auto item1:*managedTransforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedTransforms"] = boost::any(temp1);
    }
    if (networkOptimization) {
      vector<boost::any> temp1;
      for(auto item1:*networkOptimization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkOptimization"] = boost::any(temp1);
    }
    if (originRules) {
      vector<boost::any> temp1;
      for(auto item1:*originRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OriginRules"] = boost::any(temp1);
    }
    if (redirectRules) {
      vector<boost::any> temp1;
      for(auto item1:*redirectRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RedirectRules"] = boost::any(temp1);
    }
    if (rewriteUrlRules) {
      vector<boost::any> temp1;
      for(auto item1:*rewriteUrlRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RewriteUrlRules"] = boost::any(temp1);
    }
    if (seoBypass) {
      vector<boost::any> temp1;
      for(auto item1:*seoBypass){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SeoBypass"] = boost::any(temp1);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteNameExclusive) {
      vector<boost::any> temp1;
      for(auto item1:*siteNameExclusive){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SiteNameExclusive"] = boost::any(temp1);
    }
    if (sitePause) {
      vector<boost::any> temp1;
      for(auto item1:*sitePause){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SitePause"] = boost::any(temp1);
    }
    if (tieredCache) {
      vector<boost::any> temp1;
      for(auto item1:*tieredCache){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TieredCache"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheReserve") != m.end() && !m["CacheReserve"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheReserve"].type()) {
        vector<UpdateSiteFunctionRequestCacheReserve> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheReserve"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestCacheReserve model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheReserve = make_shared<vector<UpdateSiteFunctionRequestCacheReserve>>(expect1);
      }
    }
    if (m.find("CacheRules") != m.end() && !m["CacheRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheRules"].type()) {
        vector<UpdateSiteFunctionRequestCacheRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestCacheRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheRules = make_shared<vector<UpdateSiteFunctionRequestCacheRules>>(expect1);
      }
    }
    if (m.find("CacheTags") != m.end() && !m["CacheTags"].empty()) {
      if (typeid(vector<boost::any>) == m["CacheTags"].type()) {
        vector<UpdateSiteFunctionRequestCacheTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CacheTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestCacheTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cacheTags = make_shared<vector<UpdateSiteFunctionRequestCacheTags>>(expect1);
      }
    }
    if (m.find("CnameFlattening") != m.end() && !m["CnameFlattening"].empty()) {
      if (typeid(vector<boost::any>) == m["CnameFlattening"].type()) {
        vector<UpdateSiteFunctionRequestCnameFlattening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CnameFlattening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestCnameFlattening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cnameFlattening = make_shared<vector<UpdateSiteFunctionRequestCnameFlattening>>(expect1);
      }
    }
    if (m.find("CompressionRules") != m.end() && !m["CompressionRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CompressionRules"].type()) {
        vector<UpdateSiteFunctionRequestCompressionRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CompressionRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestCompressionRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compressionRules = make_shared<vector<UpdateSiteFunctionRequestCompressionRules>>(expect1);
      }
    }
    if (m.find("CrossBorderOptimization") != m.end() && !m["CrossBorderOptimization"].empty()) {
      if (typeid(vector<boost::any>) == m["CrossBorderOptimization"].type()) {
        vector<UpdateSiteFunctionRequestCrossBorderOptimization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CrossBorderOptimization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestCrossBorderOptimization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        crossBorderOptimization = make_shared<vector<UpdateSiteFunctionRequestCrossBorderOptimization>>(expect1);
      }
    }
    if (m.find("DevelopmentMode") != m.end() && !m["DevelopmentMode"].empty()) {
      if (typeid(vector<boost::any>) == m["DevelopmentMode"].type()) {
        vector<UpdateSiteFunctionRequestDevelopmentMode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DevelopmentMode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestDevelopmentMode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        developmentMode = make_shared<vector<UpdateSiteFunctionRequestDevelopmentMode>>(expect1);
      }
    }
    if (m.find("HttpRequestHeaderModificationRules") != m.end() && !m["HttpRequestHeaderModificationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpRequestHeaderModificationRules"].type()) {
        vector<UpdateSiteFunctionRequestHttpRequestHeaderModificationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpRequestHeaderModificationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestHttpRequestHeaderModificationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpRequestHeaderModificationRules = make_shared<vector<UpdateSiteFunctionRequestHttpRequestHeaderModificationRules>>(expect1);
      }
    }
    if (m.find("HttpResponseHeaderModificationRules") != m.end() && !m["HttpResponseHeaderModificationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpResponseHeaderModificationRules"].type()) {
        vector<UpdateSiteFunctionRequestHttpResponseHeaderModificationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpResponseHeaderModificationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestHttpResponseHeaderModificationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpResponseHeaderModificationRules = make_shared<vector<UpdateSiteFunctionRequestHttpResponseHeaderModificationRules>>(expect1);
      }
    }
    if (m.find("HttpsApplicationConfiguration") != m.end() && !m["HttpsApplicationConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpsApplicationConfiguration"].type()) {
        vector<UpdateSiteFunctionRequestHttpsApplicationConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpsApplicationConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestHttpsApplicationConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpsApplicationConfiguration = make_shared<vector<UpdateSiteFunctionRequestHttpsApplicationConfiguration>>(expect1);
      }
    }
    if (m.find("HttpsBasicConfiguration") != m.end() && !m["HttpsBasicConfiguration"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpsBasicConfiguration"].type()) {
        vector<UpdateSiteFunctionRequestHttpsBasicConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpsBasicConfiguration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestHttpsBasicConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpsBasicConfiguration = make_shared<vector<UpdateSiteFunctionRequestHttpsBasicConfiguration>>(expect1);
      }
    }
    if (m.find("ImageTransform") != m.end() && !m["ImageTransform"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageTransform"].type()) {
        vector<UpdateSiteFunctionRequestImageTransform> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageTransform"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestImageTransform model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageTransform = make_shared<vector<UpdateSiteFunctionRequestImageTransform>>(expect1);
      }
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6"].type()) {
        vector<UpdateSiteFunctionRequestIpv6> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestIpv6 model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6 = make_shared<vector<UpdateSiteFunctionRequestIpv6>>(expect1);
      }
    }
    if (m.find("ManagedTransforms") != m.end() && !m["ManagedTransforms"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedTransforms"].type()) {
        vector<UpdateSiteFunctionRequestManagedTransforms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedTransforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestManagedTransforms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedTransforms = make_shared<vector<UpdateSiteFunctionRequestManagedTransforms>>(expect1);
      }
    }
    if (m.find("NetworkOptimization") != m.end() && !m["NetworkOptimization"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkOptimization"].type()) {
        vector<UpdateSiteFunctionRequestNetworkOptimization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkOptimization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestNetworkOptimization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkOptimization = make_shared<vector<UpdateSiteFunctionRequestNetworkOptimization>>(expect1);
      }
    }
    if (m.find("OriginRules") != m.end() && !m["OriginRules"].empty()) {
      if (typeid(vector<boost::any>) == m["OriginRules"].type()) {
        vector<UpdateSiteFunctionRequestOriginRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OriginRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestOriginRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        originRules = make_shared<vector<UpdateSiteFunctionRequestOriginRules>>(expect1);
      }
    }
    if (m.find("RedirectRules") != m.end() && !m["RedirectRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RedirectRules"].type()) {
        vector<UpdateSiteFunctionRequestRedirectRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RedirectRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestRedirectRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        redirectRules = make_shared<vector<UpdateSiteFunctionRequestRedirectRules>>(expect1);
      }
    }
    if (m.find("RewriteUrlRules") != m.end() && !m["RewriteUrlRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RewriteUrlRules"].type()) {
        vector<UpdateSiteFunctionRequestRewriteUrlRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RewriteUrlRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestRewriteUrlRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rewriteUrlRules = make_shared<vector<UpdateSiteFunctionRequestRewriteUrlRules>>(expect1);
      }
    }
    if (m.find("SeoBypass") != m.end() && !m["SeoBypass"].empty()) {
      if (typeid(vector<boost::any>) == m["SeoBypass"].type()) {
        vector<UpdateSiteFunctionRequestSeoBypass> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SeoBypass"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestSeoBypass model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        seoBypass = make_shared<vector<UpdateSiteFunctionRequestSeoBypass>>(expect1);
      }
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteNameExclusive") != m.end() && !m["SiteNameExclusive"].empty()) {
      if (typeid(vector<boost::any>) == m["SiteNameExclusive"].type()) {
        vector<UpdateSiteFunctionRequestSiteNameExclusive> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SiteNameExclusive"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestSiteNameExclusive model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        siteNameExclusive = make_shared<vector<UpdateSiteFunctionRequestSiteNameExclusive>>(expect1);
      }
    }
    if (m.find("SitePause") != m.end() && !m["SitePause"].empty()) {
      if (typeid(vector<boost::any>) == m["SitePause"].type()) {
        vector<UpdateSiteFunctionRequestSitePause> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SitePause"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestSitePause model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sitePause = make_shared<vector<UpdateSiteFunctionRequestSitePause>>(expect1);
      }
    }
    if (m.find("TieredCache") != m.end() && !m["TieredCache"].empty()) {
      if (typeid(vector<boost::any>) == m["TieredCache"].type()) {
        vector<UpdateSiteFunctionRequestTieredCache> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TieredCache"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSiteFunctionRequestTieredCache model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tieredCache = make_shared<vector<UpdateSiteFunctionRequestTieredCache>>(expect1);
      }
    }
  }


  virtual ~UpdateSiteFunctionRequest() = default;
};
class UpdateSiteFunctionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cacheReserveShrink{};
  shared_ptr<string> cacheRulesShrink{};
  shared_ptr<string> cacheTagsShrink{};
  shared_ptr<string> cnameFlatteningShrink{};
  shared_ptr<string> compressionRulesShrink{};
  shared_ptr<string> crossBorderOptimizationShrink{};
  shared_ptr<string> developmentModeShrink{};
  shared_ptr<string> httpRequestHeaderModificationRulesShrink{};
  shared_ptr<string> httpResponseHeaderModificationRulesShrink{};
  shared_ptr<string> httpsApplicationConfigurationShrink{};
  shared_ptr<string> httpsBasicConfigurationShrink{};
  shared_ptr<string> imageTransformShrink{};
  shared_ptr<string> ipv6Shrink{};
  shared_ptr<string> managedTransformsShrink{};
  shared_ptr<string> networkOptimizationShrink{};
  shared_ptr<string> originRulesShrink{};
  shared_ptr<string> redirectRulesShrink{};
  shared_ptr<string> rewriteUrlRulesShrink{};
  shared_ptr<string> seoBypassShrink{};
  shared_ptr<long> siteId{};
  shared_ptr<string> siteNameExclusiveShrink{};
  shared_ptr<string> sitePauseShrink{};
  shared_ptr<string> tieredCacheShrink{};

  UpdateSiteFunctionShrinkRequest() {}

  explicit UpdateSiteFunctionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheReserveShrink) {
      res["CacheReserve"] = boost::any(*cacheReserveShrink);
    }
    if (cacheRulesShrink) {
      res["CacheRules"] = boost::any(*cacheRulesShrink);
    }
    if (cacheTagsShrink) {
      res["CacheTags"] = boost::any(*cacheTagsShrink);
    }
    if (cnameFlatteningShrink) {
      res["CnameFlattening"] = boost::any(*cnameFlatteningShrink);
    }
    if (compressionRulesShrink) {
      res["CompressionRules"] = boost::any(*compressionRulesShrink);
    }
    if (crossBorderOptimizationShrink) {
      res["CrossBorderOptimization"] = boost::any(*crossBorderOptimizationShrink);
    }
    if (developmentModeShrink) {
      res["DevelopmentMode"] = boost::any(*developmentModeShrink);
    }
    if (httpRequestHeaderModificationRulesShrink) {
      res["HttpRequestHeaderModificationRules"] = boost::any(*httpRequestHeaderModificationRulesShrink);
    }
    if (httpResponseHeaderModificationRulesShrink) {
      res["HttpResponseHeaderModificationRules"] = boost::any(*httpResponseHeaderModificationRulesShrink);
    }
    if (httpsApplicationConfigurationShrink) {
      res["HttpsApplicationConfiguration"] = boost::any(*httpsApplicationConfigurationShrink);
    }
    if (httpsBasicConfigurationShrink) {
      res["HttpsBasicConfiguration"] = boost::any(*httpsBasicConfigurationShrink);
    }
    if (imageTransformShrink) {
      res["ImageTransform"] = boost::any(*imageTransformShrink);
    }
    if (ipv6Shrink) {
      res["Ipv6"] = boost::any(*ipv6Shrink);
    }
    if (managedTransformsShrink) {
      res["ManagedTransforms"] = boost::any(*managedTransformsShrink);
    }
    if (networkOptimizationShrink) {
      res["NetworkOptimization"] = boost::any(*networkOptimizationShrink);
    }
    if (originRulesShrink) {
      res["OriginRules"] = boost::any(*originRulesShrink);
    }
    if (redirectRulesShrink) {
      res["RedirectRules"] = boost::any(*redirectRulesShrink);
    }
    if (rewriteUrlRulesShrink) {
      res["RewriteUrlRules"] = boost::any(*rewriteUrlRulesShrink);
    }
    if (seoBypassShrink) {
      res["SeoBypass"] = boost::any(*seoBypassShrink);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteNameExclusiveShrink) {
      res["SiteNameExclusive"] = boost::any(*siteNameExclusiveShrink);
    }
    if (sitePauseShrink) {
      res["SitePause"] = boost::any(*sitePauseShrink);
    }
    if (tieredCacheShrink) {
      res["TieredCache"] = boost::any(*tieredCacheShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheReserve") != m.end() && !m["CacheReserve"].empty()) {
      cacheReserveShrink = make_shared<string>(boost::any_cast<string>(m["CacheReserve"]));
    }
    if (m.find("CacheRules") != m.end() && !m["CacheRules"].empty()) {
      cacheRulesShrink = make_shared<string>(boost::any_cast<string>(m["CacheRules"]));
    }
    if (m.find("CacheTags") != m.end() && !m["CacheTags"].empty()) {
      cacheTagsShrink = make_shared<string>(boost::any_cast<string>(m["CacheTags"]));
    }
    if (m.find("CnameFlattening") != m.end() && !m["CnameFlattening"].empty()) {
      cnameFlatteningShrink = make_shared<string>(boost::any_cast<string>(m["CnameFlattening"]));
    }
    if (m.find("CompressionRules") != m.end() && !m["CompressionRules"].empty()) {
      compressionRulesShrink = make_shared<string>(boost::any_cast<string>(m["CompressionRules"]));
    }
    if (m.find("CrossBorderOptimization") != m.end() && !m["CrossBorderOptimization"].empty()) {
      crossBorderOptimizationShrink = make_shared<string>(boost::any_cast<string>(m["CrossBorderOptimization"]));
    }
    if (m.find("DevelopmentMode") != m.end() && !m["DevelopmentMode"].empty()) {
      developmentModeShrink = make_shared<string>(boost::any_cast<string>(m["DevelopmentMode"]));
    }
    if (m.find("HttpRequestHeaderModificationRules") != m.end() && !m["HttpRequestHeaderModificationRules"].empty()) {
      httpRequestHeaderModificationRulesShrink = make_shared<string>(boost::any_cast<string>(m["HttpRequestHeaderModificationRules"]));
    }
    if (m.find("HttpResponseHeaderModificationRules") != m.end() && !m["HttpResponseHeaderModificationRules"].empty()) {
      httpResponseHeaderModificationRulesShrink = make_shared<string>(boost::any_cast<string>(m["HttpResponseHeaderModificationRules"]));
    }
    if (m.find("HttpsApplicationConfiguration") != m.end() && !m["HttpsApplicationConfiguration"].empty()) {
      httpsApplicationConfigurationShrink = make_shared<string>(boost::any_cast<string>(m["HttpsApplicationConfiguration"]));
    }
    if (m.find("HttpsBasicConfiguration") != m.end() && !m["HttpsBasicConfiguration"].empty()) {
      httpsBasicConfigurationShrink = make_shared<string>(boost::any_cast<string>(m["HttpsBasicConfiguration"]));
    }
    if (m.find("ImageTransform") != m.end() && !m["ImageTransform"].empty()) {
      imageTransformShrink = make_shared<string>(boost::any_cast<string>(m["ImageTransform"]));
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      ipv6Shrink = make_shared<string>(boost::any_cast<string>(m["Ipv6"]));
    }
    if (m.find("ManagedTransforms") != m.end() && !m["ManagedTransforms"].empty()) {
      managedTransformsShrink = make_shared<string>(boost::any_cast<string>(m["ManagedTransforms"]));
    }
    if (m.find("NetworkOptimization") != m.end() && !m["NetworkOptimization"].empty()) {
      networkOptimizationShrink = make_shared<string>(boost::any_cast<string>(m["NetworkOptimization"]));
    }
    if (m.find("OriginRules") != m.end() && !m["OriginRules"].empty()) {
      originRulesShrink = make_shared<string>(boost::any_cast<string>(m["OriginRules"]));
    }
    if (m.find("RedirectRules") != m.end() && !m["RedirectRules"].empty()) {
      redirectRulesShrink = make_shared<string>(boost::any_cast<string>(m["RedirectRules"]));
    }
    if (m.find("RewriteUrlRules") != m.end() && !m["RewriteUrlRules"].empty()) {
      rewriteUrlRulesShrink = make_shared<string>(boost::any_cast<string>(m["RewriteUrlRules"]));
    }
    if (m.find("SeoBypass") != m.end() && !m["SeoBypass"].empty()) {
      seoBypassShrink = make_shared<string>(boost::any_cast<string>(m["SeoBypass"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteNameExclusive") != m.end() && !m["SiteNameExclusive"].empty()) {
      siteNameExclusiveShrink = make_shared<string>(boost::any_cast<string>(m["SiteNameExclusive"]));
    }
    if (m.find("SitePause") != m.end() && !m["SitePause"].empty()) {
      sitePauseShrink = make_shared<string>(boost::any_cast<string>(m["SitePause"]));
    }
    if (m.find("TieredCache") != m.end() && !m["TieredCache"].empty()) {
      tieredCacheShrink = make_shared<string>(boost::any_cast<string>(m["TieredCache"]));
    }
  }


  virtual ~UpdateSiteFunctionShrinkRequest() = default;
};
class UpdateSiteFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSiteFunctionResponseBody() {}

  explicit UpdateSiteFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSiteFunctionResponseBody() = default;
};
class UpdateSiteFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSiteFunctionResponseBody> body{};

  UpdateSiteFunctionResponse() {}

  explicit UpdateSiteFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSiteFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSiteFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSiteFunctionResponse() = default;
};
class UpdateSiteVanityNSRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> vanityNSList{};

  UpdateSiteVanityNSRequest() {}

  explicit UpdateSiteVanityNSRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (vanityNSList) {
      res["VanityNSList"] = boost::any(*vanityNSList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("VanityNSList") != m.end() && !m["VanityNSList"].empty()) {
      vanityNSList = make_shared<string>(boost::any_cast<string>(m["VanityNSList"]));
    }
  }


  virtual ~UpdateSiteVanityNSRequest() = default;
};
class UpdateSiteVanityNSResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSiteVanityNSResponseBody() {}

  explicit UpdateSiteVanityNSResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSiteVanityNSResponseBody() = default;
};
class UpdateSiteVanityNSResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSiteVanityNSResponseBody> body{};

  UpdateSiteVanityNSResponse() {}

  explicit UpdateSiteVanityNSResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSiteVanityNSResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSiteVanityNSResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSiteVanityNSResponse() = default;
};
class UpdateUserDeliveryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<double> discardRate{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> taskName{};

  UpdateUserDeliveryTaskRequest() {}

  explicit UpdateUserDeliveryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (discardRate) {
      res["DiscardRate"] = boost::any(*discardRate);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DiscardRate") != m.end() && !m["DiscardRate"].empty()) {
      discardRate = make_shared<double>(boost::any_cast<double>(m["DiscardRate"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~UpdateUserDeliveryTaskRequest() = default;
};
class UpdateUserDeliveryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateUserDeliveryTaskResponseBody() {}

  explicit UpdateUserDeliveryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateUserDeliveryTaskResponseBody() = default;
};
class UpdateUserDeliveryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserDeliveryTaskResponseBody> body{};

  UpdateUserDeliveryTaskResponse() {}

  explicit UpdateUserDeliveryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserDeliveryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserDeliveryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserDeliveryTaskResponse() = default;
};
class UpdateUserDeliveryTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> taskName{};

  UpdateUserDeliveryTaskStatusRequest() {}

  explicit UpdateUserDeliveryTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~UpdateUserDeliveryTaskStatusRequest() = default;
};
class UpdateUserDeliveryTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  UpdateUserDeliveryTaskStatusResponseBody() {}

  explicit UpdateUserDeliveryTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~UpdateUserDeliveryTaskStatusResponseBody() = default;
};
class UpdateUserDeliveryTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserDeliveryTaskStatusResponseBody> body{};

  UpdateUserDeliveryTaskStatusResponse() {}

  explicit UpdateUserDeliveryTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserDeliveryTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserDeliveryTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserDeliveryTaskStatusResponse() = default;
};
class UpdateWafRuleRequest : public Darabonba::Model {
public:
  shared_ptr<WafRuleConfig> config{};
  shared_ptr<long> id{};
  shared_ptr<long> position{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};
  shared_ptr<string> status{};

  UpdateWafRuleRequest() {}

  explicit UpdateWafRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        WafRuleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<WafRuleConfig>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateWafRuleRequest() = default;
};
class UpdateWafRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configShrink{};
  shared_ptr<long> id{};
  shared_ptr<long> position{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};
  shared_ptr<string> status{};

  UpdateWafRuleShrinkRequest() {}

  explicit UpdateWafRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configShrink) {
      res["Config"] = boost::any(*configShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      configShrink = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateWafRuleShrinkRequest() = default;
};
class UpdateWafRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  UpdateWafRuleResponseBody() {}

  explicit UpdateWafRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateWafRuleResponseBody() = default;
};
class UpdateWafRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWafRuleResponseBody> body{};

  UpdateWafRuleResponse() {}

  explicit UpdateWafRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWafRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWafRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWafRuleResponse() = default;
};
class UpdateWafRulesetRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> siteId{};
  shared_ptr<long> siteVersion{};
  shared_ptr<string> status{};

  UpdateWafRulesetRequest() {}

  explicit UpdateWafRulesetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (siteVersion) {
      res["SiteVersion"] = boost::any(*siteVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("SiteVersion") != m.end() && !m["SiteVersion"].empty()) {
      siteVersion = make_shared<long>(boost::any_cast<long>(m["SiteVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateWafRulesetRequest() = default;
};
class UpdateWafRulesetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateWafRulesetResponseBody() {}

  explicit UpdateWafRulesetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateWafRulesetResponseBody() = default;
};
class UpdateWafRulesetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWafRulesetResponseBody> body{};

  UpdateWafRulesetResponse() {}

  explicit UpdateWafRulesetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWafRulesetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWafRulesetResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWafRulesetResponse() = default;
};
class UpdateWaitingRoomRequestHostNameAndPath : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> path{};
  shared_ptr<string> subdomain{};

  UpdateWaitingRoomRequestHostNameAndPath() {}

  explicit UpdateWaitingRoomRequestHostNameAndPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (subdomain) {
      res["Subdomain"] = boost::any(*subdomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Subdomain") != m.end() && !m["Subdomain"].empty()) {
      subdomain = make_shared<string>(boost::any_cast<string>(m["Subdomain"]));
    }
  }


  virtual ~UpdateWaitingRoomRequestHostNameAndPath() = default;
};
class UpdateWaitingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<string> cookieName{};
  shared_ptr<string> customPageHtml{};
  shared_ptr<string> description{};
  shared_ptr<string> disableSessionRenewalEnable{};
  shared_ptr<string> enable{};
  shared_ptr<vector<UpdateWaitingRoomRequestHostNameAndPath>> hostNameAndPath{};
  shared_ptr<string> jsonResponseEnable{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<string> newUsersPerMinute{};
  shared_ptr<string> queueAllEnable{};
  shared_ptr<string> queuingMethod{};
  shared_ptr<string> queuingStatusCode{};
  shared_ptr<string> sessionDuration{};
  shared_ptr<long> siteId{};
  shared_ptr<string> totalActiveUsers{};
  shared_ptr<string> waitingRoomId{};
  shared_ptr<string> waitingRoomType{};

  UpdateWaitingRoomRequest() {}

  explicit UpdateWaitingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookieName) {
      res["CookieName"] = boost::any(*cookieName);
    }
    if (customPageHtml) {
      res["CustomPageHtml"] = boost::any(*customPageHtml);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableSessionRenewalEnable) {
      res["DisableSessionRenewalEnable"] = boost::any(*disableSessionRenewalEnable);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (hostNameAndPath) {
      vector<boost::any> temp1;
      for(auto item1:*hostNameAndPath){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostNameAndPath"] = boost::any(temp1);
    }
    if (jsonResponseEnable) {
      res["JsonResponseEnable"] = boost::any(*jsonResponseEnable);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newUsersPerMinute) {
      res["NewUsersPerMinute"] = boost::any(*newUsersPerMinute);
    }
    if (queueAllEnable) {
      res["QueueAllEnable"] = boost::any(*queueAllEnable);
    }
    if (queuingMethod) {
      res["QueuingMethod"] = boost::any(*queuingMethod);
    }
    if (queuingStatusCode) {
      res["QueuingStatusCode"] = boost::any(*queuingStatusCode);
    }
    if (sessionDuration) {
      res["SessionDuration"] = boost::any(*sessionDuration);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (totalActiveUsers) {
      res["TotalActiveUsers"] = boost::any(*totalActiveUsers);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    if (waitingRoomType) {
      res["WaitingRoomType"] = boost::any(*waitingRoomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CookieName") != m.end() && !m["CookieName"].empty()) {
      cookieName = make_shared<string>(boost::any_cast<string>(m["CookieName"]));
    }
    if (m.find("CustomPageHtml") != m.end() && !m["CustomPageHtml"].empty()) {
      customPageHtml = make_shared<string>(boost::any_cast<string>(m["CustomPageHtml"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableSessionRenewalEnable") != m.end() && !m["DisableSessionRenewalEnable"].empty()) {
      disableSessionRenewalEnable = make_shared<string>(boost::any_cast<string>(m["DisableSessionRenewalEnable"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("HostNameAndPath") != m.end() && !m["HostNameAndPath"].empty()) {
      if (typeid(vector<boost::any>) == m["HostNameAndPath"].type()) {
        vector<UpdateWaitingRoomRequestHostNameAndPath> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostNameAndPath"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWaitingRoomRequestHostNameAndPath model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostNameAndPath = make_shared<vector<UpdateWaitingRoomRequestHostNameAndPath>>(expect1);
      }
    }
    if (m.find("JsonResponseEnable") != m.end() && !m["JsonResponseEnable"].empty()) {
      jsonResponseEnable = make_shared<string>(boost::any_cast<string>(m["JsonResponseEnable"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewUsersPerMinute") != m.end() && !m["NewUsersPerMinute"].empty()) {
      newUsersPerMinute = make_shared<string>(boost::any_cast<string>(m["NewUsersPerMinute"]));
    }
    if (m.find("QueueAllEnable") != m.end() && !m["QueueAllEnable"].empty()) {
      queueAllEnable = make_shared<string>(boost::any_cast<string>(m["QueueAllEnable"]));
    }
    if (m.find("QueuingMethod") != m.end() && !m["QueuingMethod"].empty()) {
      queuingMethod = make_shared<string>(boost::any_cast<string>(m["QueuingMethod"]));
    }
    if (m.find("QueuingStatusCode") != m.end() && !m["QueuingStatusCode"].empty()) {
      queuingStatusCode = make_shared<string>(boost::any_cast<string>(m["QueuingStatusCode"]));
    }
    if (m.find("SessionDuration") != m.end() && !m["SessionDuration"].empty()) {
      sessionDuration = make_shared<string>(boost::any_cast<string>(m["SessionDuration"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TotalActiveUsers") != m.end() && !m["TotalActiveUsers"].empty()) {
      totalActiveUsers = make_shared<string>(boost::any_cast<string>(m["TotalActiveUsers"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
    if (m.find("WaitingRoomType") != m.end() && !m["WaitingRoomType"].empty()) {
      waitingRoomType = make_shared<string>(boost::any_cast<string>(m["WaitingRoomType"]));
    }
  }


  virtual ~UpdateWaitingRoomRequest() = default;
};
class UpdateWaitingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cookieName{};
  shared_ptr<string> customPageHtml{};
  shared_ptr<string> description{};
  shared_ptr<string> disableSessionRenewalEnable{};
  shared_ptr<string> enable{};
  shared_ptr<string> hostNameAndPathShrink{};
  shared_ptr<string> jsonResponseEnable{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<string> newUsersPerMinute{};
  shared_ptr<string> queueAllEnable{};
  shared_ptr<string> queuingMethod{};
  shared_ptr<string> queuingStatusCode{};
  shared_ptr<string> sessionDuration{};
  shared_ptr<long> siteId{};
  shared_ptr<string> totalActiveUsers{};
  shared_ptr<string> waitingRoomId{};
  shared_ptr<string> waitingRoomType{};

  UpdateWaitingRoomShrinkRequest() {}

  explicit UpdateWaitingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookieName) {
      res["CookieName"] = boost::any(*cookieName);
    }
    if (customPageHtml) {
      res["CustomPageHtml"] = boost::any(*customPageHtml);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableSessionRenewalEnable) {
      res["DisableSessionRenewalEnable"] = boost::any(*disableSessionRenewalEnable);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (hostNameAndPathShrink) {
      res["HostNameAndPath"] = boost::any(*hostNameAndPathShrink);
    }
    if (jsonResponseEnable) {
      res["JsonResponseEnable"] = boost::any(*jsonResponseEnable);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newUsersPerMinute) {
      res["NewUsersPerMinute"] = boost::any(*newUsersPerMinute);
    }
    if (queueAllEnable) {
      res["QueueAllEnable"] = boost::any(*queueAllEnable);
    }
    if (queuingMethod) {
      res["QueuingMethod"] = boost::any(*queuingMethod);
    }
    if (queuingStatusCode) {
      res["QueuingStatusCode"] = boost::any(*queuingStatusCode);
    }
    if (sessionDuration) {
      res["SessionDuration"] = boost::any(*sessionDuration);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (totalActiveUsers) {
      res["TotalActiveUsers"] = boost::any(*totalActiveUsers);
    }
    if (waitingRoomId) {
      res["WaitingRoomId"] = boost::any(*waitingRoomId);
    }
    if (waitingRoomType) {
      res["WaitingRoomType"] = boost::any(*waitingRoomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CookieName") != m.end() && !m["CookieName"].empty()) {
      cookieName = make_shared<string>(boost::any_cast<string>(m["CookieName"]));
    }
    if (m.find("CustomPageHtml") != m.end() && !m["CustomPageHtml"].empty()) {
      customPageHtml = make_shared<string>(boost::any_cast<string>(m["CustomPageHtml"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableSessionRenewalEnable") != m.end() && !m["DisableSessionRenewalEnable"].empty()) {
      disableSessionRenewalEnable = make_shared<string>(boost::any_cast<string>(m["DisableSessionRenewalEnable"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("HostNameAndPath") != m.end() && !m["HostNameAndPath"].empty()) {
      hostNameAndPathShrink = make_shared<string>(boost::any_cast<string>(m["HostNameAndPath"]));
    }
    if (m.find("JsonResponseEnable") != m.end() && !m["JsonResponseEnable"].empty()) {
      jsonResponseEnable = make_shared<string>(boost::any_cast<string>(m["JsonResponseEnable"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewUsersPerMinute") != m.end() && !m["NewUsersPerMinute"].empty()) {
      newUsersPerMinute = make_shared<string>(boost::any_cast<string>(m["NewUsersPerMinute"]));
    }
    if (m.find("QueueAllEnable") != m.end() && !m["QueueAllEnable"].empty()) {
      queueAllEnable = make_shared<string>(boost::any_cast<string>(m["QueueAllEnable"]));
    }
    if (m.find("QueuingMethod") != m.end() && !m["QueuingMethod"].empty()) {
      queuingMethod = make_shared<string>(boost::any_cast<string>(m["QueuingMethod"]));
    }
    if (m.find("QueuingStatusCode") != m.end() && !m["QueuingStatusCode"].empty()) {
      queuingStatusCode = make_shared<string>(boost::any_cast<string>(m["QueuingStatusCode"]));
    }
    if (m.find("SessionDuration") != m.end() && !m["SessionDuration"].empty()) {
      sessionDuration = make_shared<string>(boost::any_cast<string>(m["SessionDuration"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("TotalActiveUsers") != m.end() && !m["TotalActiveUsers"].empty()) {
      totalActiveUsers = make_shared<string>(boost::any_cast<string>(m["TotalActiveUsers"]));
    }
    if (m.find("WaitingRoomId") != m.end() && !m["WaitingRoomId"].empty()) {
      waitingRoomId = make_shared<string>(boost::any_cast<string>(m["WaitingRoomId"]));
    }
    if (m.find("WaitingRoomType") != m.end() && !m["WaitingRoomType"].empty()) {
      waitingRoomType = make_shared<string>(boost::any_cast<string>(m["WaitingRoomType"]));
    }
  }


  virtual ~UpdateWaitingRoomShrinkRequest() = default;
};
class UpdateWaitingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateWaitingRoomResponseBody() {}

  explicit UpdateWaitingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateWaitingRoomResponseBody() = default;
};
class UpdateWaitingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWaitingRoomResponseBody> body{};

  UpdateWaitingRoomResponse() {}

  explicit UpdateWaitingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWaitingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWaitingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWaitingRoomResponse() = default;
};
class UpdateWaitingRoomEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> customPageHtml{};
  shared_ptr<string> description{};
  shared_ptr<string> disableSessionRenewalEnable{};
  shared_ptr<string> enable{};
  shared_ptr<string> endTime{};
  shared_ptr<string> jsonResponseEnable{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<string> newUsersPerMinute{};
  shared_ptr<string> preQueueEnable{};
  shared_ptr<string> preQueueStartTime{};
  shared_ptr<string> queuingMethod{};
  shared_ptr<string> queuingStatusCode{};
  shared_ptr<string> randomPreQueueEnable{};
  shared_ptr<string> sessionDuration{};
  shared_ptr<long> siteId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> totalActiveUsers{};
  shared_ptr<long> waitingRoomEventId{};
  shared_ptr<string> waitingRoomType{};

  UpdateWaitingRoomEventRequest() {}

  explicit UpdateWaitingRoomEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customPageHtml) {
      res["CustomPageHtml"] = boost::any(*customPageHtml);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableSessionRenewalEnable) {
      res["DisableSessionRenewalEnable"] = boost::any(*disableSessionRenewalEnable);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jsonResponseEnable) {
      res["JsonResponseEnable"] = boost::any(*jsonResponseEnable);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newUsersPerMinute) {
      res["NewUsersPerMinute"] = boost::any(*newUsersPerMinute);
    }
    if (preQueueEnable) {
      res["PreQueueEnable"] = boost::any(*preQueueEnable);
    }
    if (preQueueStartTime) {
      res["PreQueueStartTime"] = boost::any(*preQueueStartTime);
    }
    if (queuingMethod) {
      res["QueuingMethod"] = boost::any(*queuingMethod);
    }
    if (queuingStatusCode) {
      res["QueuingStatusCode"] = boost::any(*queuingStatusCode);
    }
    if (randomPreQueueEnable) {
      res["RandomPreQueueEnable"] = boost::any(*randomPreQueueEnable);
    }
    if (sessionDuration) {
      res["SessionDuration"] = boost::any(*sessionDuration);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalActiveUsers) {
      res["TotalActiveUsers"] = boost::any(*totalActiveUsers);
    }
    if (waitingRoomEventId) {
      res["WaitingRoomEventId"] = boost::any(*waitingRoomEventId);
    }
    if (waitingRoomType) {
      res["WaitingRoomType"] = boost::any(*waitingRoomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomPageHtml") != m.end() && !m["CustomPageHtml"].empty()) {
      customPageHtml = make_shared<string>(boost::any_cast<string>(m["CustomPageHtml"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableSessionRenewalEnable") != m.end() && !m["DisableSessionRenewalEnable"].empty()) {
      disableSessionRenewalEnable = make_shared<string>(boost::any_cast<string>(m["DisableSessionRenewalEnable"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JsonResponseEnable") != m.end() && !m["JsonResponseEnable"].empty()) {
      jsonResponseEnable = make_shared<string>(boost::any_cast<string>(m["JsonResponseEnable"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewUsersPerMinute") != m.end() && !m["NewUsersPerMinute"].empty()) {
      newUsersPerMinute = make_shared<string>(boost::any_cast<string>(m["NewUsersPerMinute"]));
    }
    if (m.find("PreQueueEnable") != m.end() && !m["PreQueueEnable"].empty()) {
      preQueueEnable = make_shared<string>(boost::any_cast<string>(m["PreQueueEnable"]));
    }
    if (m.find("PreQueueStartTime") != m.end() && !m["PreQueueStartTime"].empty()) {
      preQueueStartTime = make_shared<string>(boost::any_cast<string>(m["PreQueueStartTime"]));
    }
    if (m.find("QueuingMethod") != m.end() && !m["QueuingMethod"].empty()) {
      queuingMethod = make_shared<string>(boost::any_cast<string>(m["QueuingMethod"]));
    }
    if (m.find("QueuingStatusCode") != m.end() && !m["QueuingStatusCode"].empty()) {
      queuingStatusCode = make_shared<string>(boost::any_cast<string>(m["QueuingStatusCode"]));
    }
    if (m.find("RandomPreQueueEnable") != m.end() && !m["RandomPreQueueEnable"].empty()) {
      randomPreQueueEnable = make_shared<string>(boost::any_cast<string>(m["RandomPreQueueEnable"]));
    }
    if (m.find("SessionDuration") != m.end() && !m["SessionDuration"].empty()) {
      sessionDuration = make_shared<string>(boost::any_cast<string>(m["SessionDuration"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TotalActiveUsers") != m.end() && !m["TotalActiveUsers"].empty()) {
      totalActiveUsers = make_shared<string>(boost::any_cast<string>(m["TotalActiveUsers"]));
    }
    if (m.find("WaitingRoomEventId") != m.end() && !m["WaitingRoomEventId"].empty()) {
      waitingRoomEventId = make_shared<long>(boost::any_cast<long>(m["WaitingRoomEventId"]));
    }
    if (m.find("WaitingRoomType") != m.end() && !m["WaitingRoomType"].empty()) {
      waitingRoomType = make_shared<string>(boost::any_cast<string>(m["WaitingRoomType"]));
    }
  }


  virtual ~UpdateWaitingRoomEventRequest() = default;
};
class UpdateWaitingRoomEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateWaitingRoomEventResponseBody() {}

  explicit UpdateWaitingRoomEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateWaitingRoomEventResponseBody() = default;
};
class UpdateWaitingRoomEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWaitingRoomEventResponseBody> body{};

  UpdateWaitingRoomEventResponse() {}

  explicit UpdateWaitingRoomEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWaitingRoomEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWaitingRoomEventResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWaitingRoomEventResponse() = default;
};
class UpdateWaitingRoomRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> rule{};
  shared_ptr<string> ruleEnable{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> siteId{};
  shared_ptr<long> waitingRoomRuleId{};

  UpdateWaitingRoomRuleRequest() {}

  explicit UpdateWaitingRoomRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (ruleEnable) {
      res["RuleEnable"] = boost::any(*ruleEnable);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (waitingRoomRuleId) {
      res["WaitingRoomRuleId"] = boost::any(*waitingRoomRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("RuleEnable") != m.end() && !m["RuleEnable"].empty()) {
      ruleEnable = make_shared<string>(boost::any_cast<string>(m["RuleEnable"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("WaitingRoomRuleId") != m.end() && !m["WaitingRoomRuleId"].empty()) {
      waitingRoomRuleId = make_shared<long>(boost::any_cast<long>(m["WaitingRoomRuleId"]));
    }
  }


  virtual ~UpdateWaitingRoomRuleRequest() = default;
};
class UpdateWaitingRoomRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateWaitingRoomRuleResponseBody() {}

  explicit UpdateWaitingRoomRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateWaitingRoomRuleResponseBody() = default;
};
class UpdateWaitingRoomRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWaitingRoomRuleResponseBody> body{};

  UpdateWaitingRoomRuleResponse() {}

  explicit UpdateWaitingRoomRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWaitingRoomRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWaitingRoomRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWaitingRoomRuleResponse() = default;
};
class UploadClientCaCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificate{};
  shared_ptr<string> name{};
  shared_ptr<long> siteId{};

  UploadClientCaCertificateRequest() {}

  explicit UploadClientCaCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~UploadClientCaCertificateRequest() = default;
};
class UploadClientCaCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> commonName{};
  shared_ptr<string> fingerprintSha256{};
  shared_ptr<string> id{};
  shared_ptr<string> issuer{};
  shared_ptr<string> notAfter{};
  shared_ptr<string> notBefore{};
  shared_ptr<string> requestId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> signatureAlgorithm{};
  shared_ptr<string> status{};
  shared_ptr<string> validityDays{};

  UploadClientCaCertificateResponseBody() {}

  explicit UploadClientCaCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (fingerprintSha256) {
      res["FingerprintSha256"] = boost::any(*fingerprintSha256);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (notAfter) {
      res["NotAfter"] = boost::any(*notAfter);
    }
    if (notBefore) {
      res["NotBefore"] = boost::any(*notBefore);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (signatureAlgorithm) {
      res["SignatureAlgorithm"] = boost::any(*signatureAlgorithm);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (validityDays) {
      res["ValidityDays"] = boost::any(*validityDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("FingerprintSha256") != m.end() && !m["FingerprintSha256"].empty()) {
      fingerprintSha256 = make_shared<string>(boost::any_cast<string>(m["FingerprintSha256"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("NotAfter") != m.end() && !m["NotAfter"].empty()) {
      notAfter = make_shared<string>(boost::any_cast<string>(m["NotAfter"]));
    }
    if (m.find("NotBefore") != m.end() && !m["NotBefore"].empty()) {
      notBefore = make_shared<string>(boost::any_cast<string>(m["NotBefore"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("SignatureAlgorithm") != m.end() && !m["SignatureAlgorithm"].empty()) {
      signatureAlgorithm = make_shared<string>(boost::any_cast<string>(m["SignatureAlgorithm"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ValidityDays") != m.end() && !m["ValidityDays"].empty()) {
      validityDays = make_shared<string>(boost::any_cast<string>(m["ValidityDays"]));
    }
  }


  virtual ~UploadClientCaCertificateResponseBody() = default;
};
class UploadClientCaCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadClientCaCertificateResponseBody> body{};

  UploadClientCaCertificateResponse() {}

  explicit UploadClientCaCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadClientCaCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadClientCaCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~UploadClientCaCertificateResponse() = default;
};
class UploadFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};
  shared_ptr<string> uploadTaskName{};
  shared_ptr<string> url{};

  UploadFileRequest() {}

  explicit UploadFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uploadTaskName) {
      res["UploadTaskName"] = boost::any(*uploadTaskName);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UploadTaskName") != m.end() && !m["UploadTaskName"].empty()) {
      uploadTaskName = make_shared<string>(boost::any_cast<string>(m["UploadTaskName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UploadFileRequest() = default;
};
class UploadFileAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};
  shared_ptr<string> type{};
  shared_ptr<string> uploadTaskName{};
  shared_ptr<Darabonba::Stream> urlObject{};

  UploadFileAdvanceRequest() {}

  explicit UploadFileAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uploadTaskName) {
      res["UploadTaskName"] = boost::any(*uploadTaskName);
    }
    if (urlObject) {
      res["Url"] = boost::any(*urlObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UploadTaskName") != m.end() && !m["UploadTaskName"].empty()) {
      uploadTaskName = make_shared<string>(boost::any_cast<string>(m["UploadTaskName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      urlObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["Url"]));
    }
  }


  virtual ~UploadFileAdvanceRequest() = default;
};
class UploadFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> uploadId{};

  UploadFileResponseBody() {}

  explicit UploadFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadId) {
      res["UploadId"] = boost::any(*uploadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadId") != m.end() && !m["UploadId"].empty()) {
      uploadId = make_shared<long>(boost::any_cast<long>(m["UploadId"]));
    }
  }


  virtual ~UploadFileResponseBody() = default;
};
class UploadFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadFileResponseBody> body{};

  UploadFileResponse() {}

  explicit UploadFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadFileResponseBody>(model1);
      }
    }
  }


  virtual ~UploadFileResponse() = default;
};
class VerifySiteRequest : public Darabonba::Model {
public:
  shared_ptr<long> siteId{};

  VerifySiteRequest() {}

  explicit VerifySiteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteId) {
      res["SiteId"] = boost::any(*siteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteId") != m.end() && !m["SiteId"].empty()) {
      siteId = make_shared<long>(boost::any_cast<long>(m["SiteId"]));
    }
  }


  virtual ~VerifySiteRequest() = default;
};
class VerifySiteResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> passed{};
  shared_ptr<string> requestId{};

  VerifySiteResponseBody() {}

  explicit VerifySiteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passed) {
      res["Passed"] = boost::any(*passed);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Passed") != m.end() && !m["Passed"].empty()) {
      passed = make_shared<bool>(boost::any_cast<bool>(m["Passed"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifySiteResponseBody() = default;
};
class VerifySiteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifySiteResponseBody> body{};

  VerifySiteResponse() {}

  explicit VerifySiteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifySiteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifySiteResponseBody>(model1);
      }
    }
  }


  virtual ~VerifySiteResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ActivateClientCertificateResponse activateClientCertificateWithOptions(shared_ptr<ActivateClientCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActivateClientCertificateResponse activateClientCertificate(shared_ptr<ActivateClientCertificateRequest> request);
  BatchCreateRecordsResponse batchCreateRecordsWithOptions(shared_ptr<BatchCreateRecordsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCreateRecordsResponse batchCreateRecords(shared_ptr<BatchCreateRecordsRequest> request);
  BatchCreateWafRulesResponse batchCreateWafRulesWithOptions(shared_ptr<BatchCreateWafRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCreateWafRulesResponse batchCreateWafRules(shared_ptr<BatchCreateWafRulesRequest> request);
  BatchDeleteKvResponse batchDeleteKvWithOptions(shared_ptr<BatchDeleteKvRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteKvResponse batchDeleteKv(shared_ptr<BatchDeleteKvRequest> request);
  BatchDeleteKvWithHighCapacityResponse batchDeleteKvWithHighCapacityWithOptions(shared_ptr<BatchDeleteKvWithHighCapacityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteKvWithHighCapacityResponse batchDeleteKvWithHighCapacity(shared_ptr<BatchDeleteKvWithHighCapacityRequest> request);
  BatchDeleteKvWithHighCapacityResponse batchDeleteKvWithHighCapacityAdvance(shared_ptr<BatchDeleteKvWithHighCapacityAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetExpressionFieldsResponse batchGetExpressionFieldsWithOptions(shared_ptr<BatchGetExpressionFieldsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetExpressionFieldsResponse batchGetExpressionFields(shared_ptr<BatchGetExpressionFieldsRequest> request);
  BatchPutKvResponse batchPutKvWithOptions(shared_ptr<BatchPutKvRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchPutKvResponse batchPutKv(shared_ptr<BatchPutKvRequest> request);
  BatchPutKvWithHighCapacityResponse batchPutKvWithHighCapacityWithOptions(shared_ptr<BatchPutKvWithHighCapacityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchPutKvWithHighCapacityResponse batchPutKvWithHighCapacity(shared_ptr<BatchPutKvWithHighCapacityRequest> request);
  BatchPutKvWithHighCapacityResponse batchPutKvWithHighCapacityAdvance(shared_ptr<BatchPutKvWithHighCapacityAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateWafRulesResponse batchUpdateWafRulesWithOptions(shared_ptr<BatchUpdateWafRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateWafRulesResponse batchUpdateWafRules(shared_ptr<BatchUpdateWafRulesRequest> request);
  BlockObjectResponse blockObjectWithOptions(shared_ptr<BlockObjectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BlockObjectResponse blockObject(shared_ptr<BlockObjectRequest> request);
  ChangeResourceGroupResponse changeResourceGroupWithOptions(shared_ptr<ChangeResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeResourceGroupResponse changeResourceGroup(shared_ptr<ChangeResourceGroupRequest> request);
  CheckSiteNameResponse checkSiteNameWithOptions(shared_ptr<CheckSiteNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckSiteNameResponse checkSiteName(shared_ptr<CheckSiteNameRequest> request);
  CheckSiteProjectNameResponse checkSiteProjectNameWithOptions(shared_ptr<CheckSiteProjectNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckSiteProjectNameResponse checkSiteProjectName(shared_ptr<CheckSiteProjectNameRequest> request);
  CheckUserProjectNameResponse checkUserProjectNameWithOptions(shared_ptr<CheckUserProjectNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckUserProjectNameResponse checkUserProjectName(shared_ptr<CheckUserProjectNameRequest> request);
  CommitRoutineStagingCodeResponse commitRoutineStagingCodeWithOptions(shared_ptr<CommitRoutineStagingCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommitRoutineStagingCodeResponse commitRoutineStagingCode(shared_ptr<CommitRoutineStagingCodeRequest> request);
  CreateClientCertificateResponse createClientCertificateWithOptions(shared_ptr<CreateClientCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClientCertificateResponse createClientCertificate(shared_ptr<CreateClientCertificateRequest> request);
  CreateCustomScenePolicyResponse createCustomScenePolicyWithOptions(shared_ptr<CreateCustomScenePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomScenePolicyResponse createCustomScenePolicy(shared_ptr<CreateCustomScenePolicyRequest> request);
  CreateEdgeContainerAppResponse createEdgeContainerAppWithOptions(shared_ptr<CreateEdgeContainerAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeContainerAppResponse createEdgeContainerApp(shared_ptr<CreateEdgeContainerAppRequest> request);
  CreateEdgeContainerAppRecordResponse createEdgeContainerAppRecordWithOptions(shared_ptr<CreateEdgeContainerAppRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeContainerAppRecordResponse createEdgeContainerAppRecord(shared_ptr<CreateEdgeContainerAppRecordRequest> request);
  CreateEdgeContainerAppVersionResponse createEdgeContainerAppVersionWithOptions(shared_ptr<CreateEdgeContainerAppVersionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeContainerAppVersionResponse createEdgeContainerAppVersion(shared_ptr<CreateEdgeContainerAppVersionRequest> request);
  CreateKvNamespaceResponse createKvNamespaceWithOptions(shared_ptr<CreateKvNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateKvNamespaceResponse createKvNamespace(shared_ptr<CreateKvNamespaceRequest> request);
  CreateListResponse createListWithOptions(shared_ptr<CreateListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateListResponse createList(shared_ptr<CreateListRequest> request);
  CreateOriginProtectionResponse createOriginProtectionWithOptions(shared_ptr<CreateOriginProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOriginProtectionResponse createOriginProtection(shared_ptr<CreateOriginProtectionRequest> request);
  CreatePageResponse createPageWithOptions(shared_ptr<CreatePageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePageResponse createPage(shared_ptr<CreatePageRequest> request);
  CreateRecordResponse createRecordWithOptions(shared_ptr<CreateRecordRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRecordResponse createRecord(shared_ptr<CreateRecordRequest> request);
  CreateRoutineResponse createRoutineWithOptions(shared_ptr<CreateRoutineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRoutineResponse createRoutine(shared_ptr<CreateRoutineRequest> request);
  CreateRoutineRelatedRecordResponse createRoutineRelatedRecordWithOptions(shared_ptr<CreateRoutineRelatedRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRoutineRelatedRecordResponse createRoutineRelatedRecord(shared_ptr<CreateRoutineRelatedRecordRequest> request);
  CreateRoutineRelatedRouteResponse createRoutineRelatedRouteWithOptions(shared_ptr<CreateRoutineRelatedRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRoutineRelatedRouteResponse createRoutineRelatedRoute(shared_ptr<CreateRoutineRelatedRouteRequest> request);
  CreateScheduledPreloadExecutionsResponse createScheduledPreloadExecutionsWithOptions(shared_ptr<CreateScheduledPreloadExecutionsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScheduledPreloadExecutionsResponse createScheduledPreloadExecutions(shared_ptr<CreateScheduledPreloadExecutionsRequest> request);
  CreateScheduledPreloadJobResponse createScheduledPreloadJobWithOptions(shared_ptr<CreateScheduledPreloadJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScheduledPreloadJobResponse createScheduledPreloadJob(shared_ptr<CreateScheduledPreloadJobRequest> request);
  CreateSiteResponse createSiteWithOptions(shared_ptr<CreateSiteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSiteResponse createSite(shared_ptr<CreateSiteRequest> request);
  CreateSiteCustomLogResponse createSiteCustomLogWithOptions(shared_ptr<CreateSiteCustomLogRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSiteCustomLogResponse createSiteCustomLog(shared_ptr<CreateSiteCustomLogRequest> request);
  CreateSiteDeliveryTaskResponse createSiteDeliveryTaskWithOptions(shared_ptr<CreateSiteDeliveryTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSiteDeliveryTaskResponse createSiteDeliveryTask(shared_ptr<CreateSiteDeliveryTaskRequest> request);
  CreateSiteFunctionResponse createSiteFunctionWithOptions(shared_ptr<CreateSiteFunctionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSiteFunctionResponse createSiteFunction(shared_ptr<CreateSiteFunctionRequest> request);
  CreateUserDeliveryTaskResponse createUserDeliveryTaskWithOptions(shared_ptr<CreateUserDeliveryTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserDeliveryTaskResponse createUserDeliveryTask(shared_ptr<CreateUserDeliveryTaskRequest> request);
  CreateWafRuleResponse createWafRuleWithOptions(shared_ptr<CreateWafRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWafRuleResponse createWafRule(shared_ptr<CreateWafRuleRequest> request);
  CreateWaitingRoomResponse createWaitingRoomWithOptions(shared_ptr<CreateWaitingRoomRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWaitingRoomResponse createWaitingRoom(shared_ptr<CreateWaitingRoomRequest> request);
  CreateWaitingRoomEventResponse createWaitingRoomEventWithOptions(shared_ptr<CreateWaitingRoomEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWaitingRoomEventResponse createWaitingRoomEvent(shared_ptr<CreateWaitingRoomEventRequest> request);
  CreateWaitingRoomRuleResponse createWaitingRoomRuleWithOptions(shared_ptr<CreateWaitingRoomRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWaitingRoomRuleResponse createWaitingRoomRule(shared_ptr<CreateWaitingRoomRuleRequest> request);
  DeleteCertificateResponse deleteCertificateWithOptions(shared_ptr<DeleteCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCertificateResponse deleteCertificate(shared_ptr<DeleteCertificateRequest> request);
  DeleteClientCaCertificateResponse deleteClientCaCertificateWithOptions(shared_ptr<DeleteClientCaCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClientCaCertificateResponse deleteClientCaCertificate(shared_ptr<DeleteClientCaCertificateRequest> request);
  DeleteClientCertificateResponse deleteClientCertificateWithOptions(shared_ptr<DeleteClientCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClientCertificateResponse deleteClientCertificate(shared_ptr<DeleteClientCertificateRequest> request);
  DeleteCustomScenePolicyResponse deleteCustomScenePolicyWithOptions(shared_ptr<DeleteCustomScenePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomScenePolicyResponse deleteCustomScenePolicy(shared_ptr<DeleteCustomScenePolicyRequest> request);
  DeleteEdgeContainerAppResponse deleteEdgeContainerAppWithOptions(shared_ptr<DeleteEdgeContainerAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeContainerAppResponse deleteEdgeContainerApp(shared_ptr<DeleteEdgeContainerAppRequest> request);
  DeleteEdgeContainerAppRecordResponse deleteEdgeContainerAppRecordWithOptions(shared_ptr<DeleteEdgeContainerAppRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeContainerAppRecordResponse deleteEdgeContainerAppRecord(shared_ptr<DeleteEdgeContainerAppRecordRequest> request);
  DeleteEdgeContainerAppVersionResponse deleteEdgeContainerAppVersionWithOptions(shared_ptr<DeleteEdgeContainerAppVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeContainerAppVersionResponse deleteEdgeContainerAppVersion(shared_ptr<DeleteEdgeContainerAppVersionRequest> request);
  DeleteKvResponse deleteKvWithOptions(shared_ptr<DeleteKvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteKvResponse deleteKv(shared_ptr<DeleteKvRequest> request);
  DeleteKvNamespaceResponse deleteKvNamespaceWithOptions(shared_ptr<DeleteKvNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteKvNamespaceResponse deleteKvNamespace(shared_ptr<DeleteKvNamespaceRequest> request);
  DeleteListResponse deleteListWithOptions(shared_ptr<DeleteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteListResponse deleteList(shared_ptr<DeleteListRequest> request);
  DeleteOriginProtectionResponse deleteOriginProtectionWithOptions(shared_ptr<DeleteOriginProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOriginProtectionResponse deleteOriginProtection(shared_ptr<DeleteOriginProtectionRequest> request);
  DeletePageResponse deletePageWithOptions(shared_ptr<DeletePageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePageResponse deletePage(shared_ptr<DeletePageRequest> request);
  DeleteRecordResponse deleteRecordWithOptions(shared_ptr<DeleteRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRecordResponse deleteRecord(shared_ptr<DeleteRecordRequest> request);
  DeleteRoutineResponse deleteRoutineWithOptions(shared_ptr<DeleteRoutineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineResponse deleteRoutine(shared_ptr<DeleteRoutineRequest> request);
  DeleteRoutineCodeVersionResponse deleteRoutineCodeVersionWithOptions(shared_ptr<DeleteRoutineCodeVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineCodeVersionResponse deleteRoutineCodeVersion(shared_ptr<DeleteRoutineCodeVersionRequest> request);
  DeleteRoutineRelatedRecordResponse deleteRoutineRelatedRecordWithOptions(shared_ptr<DeleteRoutineRelatedRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineRelatedRecordResponse deleteRoutineRelatedRecord(shared_ptr<DeleteRoutineRelatedRecordRequest> request);
  DeleteRoutineRelatedRouteResponse deleteRoutineRelatedRouteWithOptions(shared_ptr<DeleteRoutineRelatedRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineRelatedRouteResponse deleteRoutineRelatedRoute(shared_ptr<DeleteRoutineRelatedRouteRequest> request);
  DeleteScheduledPreloadExecutionResponse deleteScheduledPreloadExecutionWithOptions(shared_ptr<DeleteScheduledPreloadExecutionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScheduledPreloadExecutionResponse deleteScheduledPreloadExecution(shared_ptr<DeleteScheduledPreloadExecutionRequest> request);
  DeleteScheduledPreloadJobResponse deleteScheduledPreloadJobWithOptions(shared_ptr<DeleteScheduledPreloadJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScheduledPreloadJobResponse deleteScheduledPreloadJob(shared_ptr<DeleteScheduledPreloadJobRequest> request);
  DeleteSiteResponse deleteSiteWithOptions(shared_ptr<DeleteSiteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSiteResponse deleteSite(shared_ptr<DeleteSiteRequest> request);
  DeleteSiteDeliveryTaskResponse deleteSiteDeliveryTaskWithOptions(shared_ptr<DeleteSiteDeliveryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSiteDeliveryTaskResponse deleteSiteDeliveryTask(shared_ptr<DeleteSiteDeliveryTaskRequest> request);
  DeleteSiteFunctionResponse deleteSiteFunctionWithOptions(shared_ptr<DeleteSiteFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSiteFunctionResponse deleteSiteFunction(shared_ptr<DeleteSiteFunctionRequest> request);
  DeleteUserDeliveryTaskResponse deleteUserDeliveryTaskWithOptions(shared_ptr<DeleteUserDeliveryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserDeliveryTaskResponse deleteUserDeliveryTask(shared_ptr<DeleteUserDeliveryTaskRequest> request);
  DeleteWafRuleResponse deleteWafRuleWithOptions(shared_ptr<DeleteWafRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWafRuleResponse deleteWafRule(shared_ptr<DeleteWafRuleRequest> request);
  DeleteWafRulesetResponse deleteWafRulesetWithOptions(shared_ptr<DeleteWafRulesetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWafRulesetResponse deleteWafRuleset(shared_ptr<DeleteWafRulesetRequest> request);
  DeleteWaitingRoomResponse deleteWaitingRoomWithOptions(shared_ptr<DeleteWaitingRoomRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWaitingRoomResponse deleteWaitingRoom(shared_ptr<DeleteWaitingRoomRequest> request);
  DeleteWaitingRoomEventResponse deleteWaitingRoomEventWithOptions(shared_ptr<DeleteWaitingRoomEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWaitingRoomEventResponse deleteWaitingRoomEvent(shared_ptr<DeleteWaitingRoomEventRequest> request);
  DeleteWaitingRoomRuleResponse deleteWaitingRoomRuleWithOptions(shared_ptr<DeleteWaitingRoomRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWaitingRoomRuleResponse deleteWaitingRoomRule(shared_ptr<DeleteWaitingRoomRuleRequest> request);
  DescribeCustomScenePoliciesResponse describeCustomScenePoliciesWithOptions(shared_ptr<DescribeCustomScenePoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomScenePoliciesResponse describeCustomScenePolicies(shared_ptr<DescribeCustomScenePoliciesRequest> request);
  DescribeDDoSAllEventListResponse describeDDoSAllEventListWithOptions(shared_ptr<DescribeDDoSAllEventListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDoSAllEventListResponse describeDDoSAllEventList(shared_ptr<DescribeDDoSAllEventListRequest> request);
  DescribeHttpDDoSAttackIntelligentProtectionResponse describeHttpDDoSAttackIntelligentProtectionWithOptions(shared_ptr<DescribeHttpDDoSAttackIntelligentProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHttpDDoSAttackIntelligentProtectionResponse describeHttpDDoSAttackIntelligentProtection(shared_ptr<DescribeHttpDDoSAttackIntelligentProtectionRequest> request);
  DescribeHttpDDoSAttackProtectionResponse describeHttpDDoSAttackProtectionWithOptions(shared_ptr<DescribeHttpDDoSAttackProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHttpDDoSAttackProtectionResponse describeHttpDDoSAttackProtection(shared_ptr<DescribeHttpDDoSAttackProtectionRequest> request);
  DescribeKvAccountStatusResponse describeKvAccountStatusWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKvAccountStatusResponse describeKvAccountStatus();
  DescribePreloadTasksResponse describePreloadTasksWithOptions(shared_ptr<DescribePreloadTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePreloadTasksResponse describePreloadTasks(shared_ptr<DescribePreloadTasksRequest> request);
  DescribePurgeTasksResponse describePurgeTasksWithOptions(shared_ptr<DescribePurgeTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurgeTasksResponse describePurgeTasks(shared_ptr<DescribePurgeTasksRequest> request);
  DisableCustomScenePolicyResponse disableCustomScenePolicyWithOptions(shared_ptr<DisableCustomScenePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableCustomScenePolicyResponse disableCustomScenePolicy(shared_ptr<DisableCustomScenePolicyRequest> request);
  EditSiteWafSettingsResponse editSiteWafSettingsWithOptions(shared_ptr<EditSiteWafSettingsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EditSiteWafSettingsResponse editSiteWafSettings(shared_ptr<EditSiteWafSettingsRequest> request);
  EnableCustomScenePolicyResponse enableCustomScenePolicyWithOptions(shared_ptr<EnableCustomScenePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableCustomScenePolicyResponse enableCustomScenePolicy(shared_ptr<EnableCustomScenePolicyRequest> request);
  ExportRecordsResponse exportRecordsWithOptions(shared_ptr<ExportRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportRecordsResponse exportRecords(shared_ptr<ExportRecordsRequest> request);
  GetCacheReserveSpecificationResponse getCacheReserveSpecificationWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCacheReserveSpecificationResponse getCacheReserveSpecification();
  GetCertificateQuotaResponse getCertificateQuotaWithOptions(shared_ptr<GetCertificateQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCertificateQuotaResponse getCertificateQuota(shared_ptr<GetCertificateQuotaRequest> request);
  GetClientCaCertificateResponse getClientCaCertificateWithOptions(shared_ptr<GetClientCaCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClientCaCertificateResponse getClientCaCertificate(shared_ptr<GetClientCaCertificateRequest> request);
  GetClientCertificateResponse getClientCertificateWithOptions(shared_ptr<GetClientCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClientCertificateResponse getClientCertificate(shared_ptr<GetClientCertificateRequest> request);
  GetClientCertificateHostnamesResponse getClientCertificateHostnamesWithOptions(shared_ptr<GetClientCertificateHostnamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClientCertificateHostnamesResponse getClientCertificateHostnames(shared_ptr<GetClientCertificateHostnamesRequest> request);
  GetEdgeContainerAppResponse getEdgeContainerAppWithOptions(shared_ptr<GetEdgeContainerAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeContainerAppResponse getEdgeContainerApp(shared_ptr<GetEdgeContainerAppRequest> request);
  GetEdgeContainerAppStatusResponse getEdgeContainerAppStatusWithOptions(shared_ptr<GetEdgeContainerAppStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeContainerAppStatusResponse getEdgeContainerAppStatus(shared_ptr<GetEdgeContainerAppStatusRequest> request);
  GetEdgeContainerAppVersionResponse getEdgeContainerAppVersionWithOptions(shared_ptr<GetEdgeContainerAppVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeContainerAppVersionResponse getEdgeContainerAppVersion(shared_ptr<GetEdgeContainerAppVersionRequest> request);
  GetEdgeContainerDeployRegionsResponse getEdgeContainerDeployRegionsWithOptions(shared_ptr<GetEdgeContainerDeployRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeContainerDeployRegionsResponse getEdgeContainerDeployRegions(shared_ptr<GetEdgeContainerDeployRegionsRequest> request);
  GetEdgeContainerLogsResponse getEdgeContainerLogsWithOptions(shared_ptr<GetEdgeContainerLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeContainerLogsResponse getEdgeContainerLogs(shared_ptr<GetEdgeContainerLogsRequest> request);
  GetEdgeContainerStagingDeployStatusResponse getEdgeContainerStagingDeployStatusWithOptions(shared_ptr<GetEdgeContainerStagingDeployStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeContainerStagingDeployStatusResponse getEdgeContainerStagingDeployStatus(shared_ptr<GetEdgeContainerStagingDeployStatusRequest> request);
  GetEdgeContainerTerminalResponse getEdgeContainerTerminalWithOptions(shared_ptr<GetEdgeContainerTerminalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeContainerTerminalResponse getEdgeContainerTerminal(shared_ptr<GetEdgeContainerTerminalRequest> request);
  GetErServiceResponse getErServiceWithOptions(shared_ptr<GetErServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetErServiceResponse getErService(shared_ptr<GetErServiceRequest> request);
  GetKvResponse getKvWithOptions(shared_ptr<GetKvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetKvResponse getKv(shared_ptr<GetKvRequest> request);
  GetKvAccountResponse getKvAccountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetKvAccountResponse getKvAccount();
  GetKvNamespaceResponse getKvNamespaceWithOptions(shared_ptr<GetKvNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetKvNamespaceResponse getKvNamespace(shared_ptr<GetKvNamespaceRequest> request);
  GetListResponse getListWithOptions(shared_ptr<GetListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetListResponse getList(shared_ptr<GetListRequest> request);
  GetOriginProtectionResponse getOriginProtectionWithOptions(shared_ptr<GetOriginProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOriginProtectionResponse getOriginProtection(shared_ptr<GetOriginProtectionRequest> request);
  GetPageResponse getPageWithOptions(shared_ptr<GetPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPageResponse getPage(shared_ptr<GetPageRequest> request);
  GetPurgeQuotaResponse getPurgeQuotaWithOptions(shared_ptr<GetPurgeQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPurgeQuotaResponse getPurgeQuota(shared_ptr<GetPurgeQuotaRequest> request);
  GetRealtimeDeliveryFieldResponse getRealtimeDeliveryFieldWithOptions(shared_ptr<GetRealtimeDeliveryFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRealtimeDeliveryFieldResponse getRealtimeDeliveryField(shared_ptr<GetRealtimeDeliveryFieldRequest> request);
  GetRecordResponse getRecordWithOptions(shared_ptr<GetRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRecordResponse getRecord(shared_ptr<GetRecordRequest> request);
  GetRoutineResponse getRoutineWithOptions(shared_ptr<GetRoutineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRoutineResponse getRoutine(shared_ptr<GetRoutineRequest> request);
  GetRoutineStagingCodeUploadInfoResponse getRoutineStagingCodeUploadInfoWithOptions(shared_ptr<GetRoutineStagingCodeUploadInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRoutineStagingCodeUploadInfoResponse getRoutineStagingCodeUploadInfo(shared_ptr<GetRoutineStagingCodeUploadInfoRequest> request);
  GetRoutineStagingEnvIpResponse getRoutineStagingEnvIpWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRoutineStagingEnvIpResponse getRoutineStagingEnvIp();
  GetRoutineUserInfoResponse getRoutineUserInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRoutineUserInfoResponse getRoutineUserInfo();
  GetScheduledPreloadJobResponse getScheduledPreloadJobWithOptions(shared_ptr<GetScheduledPreloadJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetScheduledPreloadJobResponse getScheduledPreloadJob(shared_ptr<GetScheduledPreloadJobRequest> request);
  GetSiteResponse getSiteWithOptions(shared_ptr<GetSiteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSiteResponse getSite(shared_ptr<GetSiteRequest> request);
  GetSiteCurrentNSResponse getSiteCurrentNSWithOptions(shared_ptr<GetSiteCurrentNSRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSiteCurrentNSResponse getSiteCurrentNS(shared_ptr<GetSiteCurrentNSRequest> request);
  GetSiteCustomLogResponse getSiteCustomLogWithOptions(shared_ptr<GetSiteCustomLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSiteCustomLogResponse getSiteCustomLog(shared_ptr<GetSiteCustomLogRequest> request);
  GetSiteDeliveryTaskResponse getSiteDeliveryTaskWithOptions(shared_ptr<GetSiteDeliveryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSiteDeliveryTaskResponse getSiteDeliveryTask(shared_ptr<GetSiteDeliveryTaskRequest> request);
  GetSiteLogDeliveryQuotaResponse getSiteLogDeliveryQuotaWithOptions(shared_ptr<GetSiteLogDeliveryQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSiteLogDeliveryQuotaResponse getSiteLogDeliveryQuota(shared_ptr<GetSiteLogDeliveryQuotaRequest> request);
  GetSiteWafSettingsResponse getSiteWafSettingsWithOptions(shared_ptr<GetSiteWafSettingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSiteWafSettingsResponse getSiteWafSettings(shared_ptr<GetSiteWafSettingsRequest> request);
  GetUploadTaskResponse getUploadTaskWithOptions(shared_ptr<GetUploadTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUploadTaskResponse getUploadTask(shared_ptr<GetUploadTaskRequest> request);
  GetUserDeliveryTaskResponse getUserDeliveryTaskWithOptions(shared_ptr<GetUserDeliveryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserDeliveryTaskResponse getUserDeliveryTask(shared_ptr<GetUserDeliveryTaskRequest> request);
  GetUserLogDeliveryQuotaResponse getUserLogDeliveryQuotaWithOptions(shared_ptr<GetUserLogDeliveryQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserLogDeliveryQuotaResponse getUserLogDeliveryQuota(shared_ptr<GetUserLogDeliveryQuotaRequest> request);
  GetWafBotAppKeyResponse getWafBotAppKeyWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWafBotAppKeyResponse getWafBotAppKey();
  GetWafFilterResponse getWafFilterWithOptions(shared_ptr<GetWafFilterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWafFilterResponse getWafFilter(shared_ptr<GetWafFilterRequest> request);
  GetWafQuotaResponse getWafQuotaWithOptions(shared_ptr<GetWafQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWafQuotaResponse getWafQuota(shared_ptr<GetWafQuotaRequest> request);
  GetWafRuleResponse getWafRuleWithOptions(shared_ptr<GetWafRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWafRuleResponse getWafRule(shared_ptr<GetWafRuleRequest> request);
  GetWafRulesetResponse getWafRulesetWithOptions(shared_ptr<GetWafRulesetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWafRulesetResponse getWafRuleset(shared_ptr<GetWafRulesetRequest> request);
  ListCacheReserveInstancesResponse listCacheReserveInstancesWithOptions(shared_ptr<ListCacheReserveInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCacheReserveInstancesResponse listCacheReserveInstances(shared_ptr<ListCacheReserveInstancesRequest> request);
  ListCiphersResponse listCiphersWithOptions(shared_ptr<ListCiphersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCiphersResponse listCiphers(shared_ptr<ListCiphersRequest> request);
  ListClientCaCertificatesResponse listClientCaCertificatesWithOptions(shared_ptr<ListClientCaCertificatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClientCaCertificatesResponse listClientCaCertificates(shared_ptr<ListClientCaCertificatesRequest> request);
  ListClientCertificatesResponse listClientCertificatesWithOptions(shared_ptr<ListClientCertificatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClientCertificatesResponse listClientCertificates(shared_ptr<ListClientCertificatesRequest> request);
  ListEdgeContainerAppRecordsResponse listEdgeContainerAppRecordsWithOptions(shared_ptr<ListEdgeContainerAppRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeContainerAppRecordsResponse listEdgeContainerAppRecords(shared_ptr<ListEdgeContainerAppRecordsRequest> request);
  ListEdgeContainerAppVersionsResponse listEdgeContainerAppVersionsWithOptions(shared_ptr<ListEdgeContainerAppVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeContainerAppVersionsResponse listEdgeContainerAppVersions(shared_ptr<ListEdgeContainerAppVersionsRequest> request);
  ListEdgeContainerAppsResponse listEdgeContainerAppsWithOptions(shared_ptr<ListEdgeContainerAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeContainerAppsResponse listEdgeContainerApps(shared_ptr<ListEdgeContainerAppsRequest> request);
  ListEdgeContainerRecordsResponse listEdgeContainerRecordsWithOptions(shared_ptr<ListEdgeContainerRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeContainerRecordsResponse listEdgeContainerRecords(shared_ptr<ListEdgeContainerRecordsRequest> request);
  ListEdgeRoutinePlansResponse listEdgeRoutinePlansWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeRoutinePlansResponse listEdgeRoutinePlans();
  ListEdgeRoutineRecordsResponse listEdgeRoutineRecordsWithOptions(shared_ptr<ListEdgeRoutineRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeRoutineRecordsResponse listEdgeRoutineRecords(shared_ptr<ListEdgeRoutineRecordsRequest> request);
  ListInstanceQuotasResponse listInstanceQuotasWithOptions(shared_ptr<ListInstanceQuotasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceQuotasResponse listInstanceQuotas(shared_ptr<ListInstanceQuotasRequest> request);
  ListInstanceQuotasWithUsageResponse listInstanceQuotasWithUsageWithOptions(shared_ptr<ListInstanceQuotasWithUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceQuotasWithUsageResponse listInstanceQuotasWithUsage(shared_ptr<ListInstanceQuotasWithUsageRequest> request);
  ListKvsResponse listKvsWithOptions(shared_ptr<ListKvsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListKvsResponse listKvs(shared_ptr<ListKvsRequest> request);
  ListListsResponse listListsWithOptions(shared_ptr<ListListsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListListsResponse listLists(shared_ptr<ListListsRequest> request);
  ListLoadBalancerRegionsResponse listLoadBalancerRegionsWithOptions(shared_ptr<ListLoadBalancerRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLoadBalancerRegionsResponse listLoadBalancerRegions(shared_ptr<ListLoadBalancerRegionsRequest> request);
  ListManagedRulesGroupsResponse listManagedRulesGroupsWithOptions(shared_ptr<ListManagedRulesGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListManagedRulesGroupsResponse listManagedRulesGroups(shared_ptr<ListManagedRulesGroupsRequest> request);
  ListPagesResponse listPagesWithOptions(shared_ptr<ListPagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPagesResponse listPages(shared_ptr<ListPagesRequest> request);
  ListRecordsResponse listRecordsWithOptions(shared_ptr<ListRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecordsResponse listRecords(shared_ptr<ListRecordsRequest> request);
  ListRoutineCanaryAreasResponse listRoutineCanaryAreasWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRoutineCanaryAreasResponse listRoutineCanaryAreas();
  ListRoutineOptionalSpecsResponse listRoutineOptionalSpecsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRoutineOptionalSpecsResponse listRoutineOptionalSpecs();
  ListScheduledPreloadExecutionsResponse listScheduledPreloadExecutionsWithOptions(shared_ptr<ListScheduledPreloadExecutionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScheduledPreloadExecutionsResponse listScheduledPreloadExecutions(shared_ptr<ListScheduledPreloadExecutionsRequest> request);
  ListScheduledPreloadJobsResponse listScheduledPreloadJobsWithOptions(shared_ptr<ListScheduledPreloadJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScheduledPreloadJobsResponse listScheduledPreloadJobs(shared_ptr<ListScheduledPreloadJobsRequest> request);
  ListSiteDeliveryTasksResponse listSiteDeliveryTasksWithOptions(shared_ptr<ListSiteDeliveryTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSiteDeliveryTasksResponse listSiteDeliveryTasks(shared_ptr<ListSiteDeliveryTasksRequest> request);
  ListSiteFunctionsResponse listSiteFunctionsWithOptions(shared_ptr<ListSiteFunctionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSiteFunctionsResponse listSiteFunctions(shared_ptr<ListSiteFunctionsRequest> request);
  ListSitesResponse listSitesWithOptions(shared_ptr<ListSitesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSitesResponse listSites(shared_ptr<ListSitesRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListUploadTasksResponse listUploadTasksWithOptions(shared_ptr<ListUploadTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUploadTasksResponse listUploadTasks(shared_ptr<ListUploadTasksRequest> request);
  ListUserDeliveryTasksResponse listUserDeliveryTasksWithOptions(shared_ptr<ListUserDeliveryTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserDeliveryTasksResponse listUserDeliveryTasks(shared_ptr<ListUserDeliveryTasksRequest> request);
  ListUserRatePlanInstancesResponse listUserRatePlanInstancesWithOptions(shared_ptr<ListUserRatePlanInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserRatePlanInstancesResponse listUserRatePlanInstances(shared_ptr<ListUserRatePlanInstancesRequest> request);
  ListWafManagedRulesResponse listWafManagedRulesWithOptions(shared_ptr<ListWafManagedRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWafManagedRulesResponse listWafManagedRules(shared_ptr<ListWafManagedRulesRequest> request);
  ListWafPhasesResponse listWafPhasesWithOptions(shared_ptr<ListWafPhasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWafPhasesResponse listWafPhases(shared_ptr<ListWafPhasesRequest> request);
  ListWafRulesResponse listWafRulesWithOptions(shared_ptr<ListWafRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWafRulesResponse listWafRules(shared_ptr<ListWafRulesRequest> request);
  ListWafRulesetsResponse listWafRulesetsWithOptions(shared_ptr<ListWafRulesetsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWafRulesetsResponse listWafRulesets(shared_ptr<ListWafRulesetsRequest> request);
  ListWafTemplateRulesResponse listWafTemplateRulesWithOptions(shared_ptr<ListWafTemplateRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWafTemplateRulesResponse listWafTemplateRules(shared_ptr<ListWafTemplateRulesRequest> request);
  ListWafUsageOfRulesResponse listWafUsageOfRulesWithOptions(shared_ptr<ListWafUsageOfRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWafUsageOfRulesResponse listWafUsageOfRules(shared_ptr<ListWafUsageOfRulesRequest> request);
  ListWaitingRoomEventsResponse listWaitingRoomEventsWithOptions(shared_ptr<ListWaitingRoomEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWaitingRoomEventsResponse listWaitingRoomEvents(shared_ptr<ListWaitingRoomEventsRequest> request);
  ListWaitingRoomRulesResponse listWaitingRoomRulesWithOptions(shared_ptr<ListWaitingRoomRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWaitingRoomRulesResponse listWaitingRoomRules(shared_ptr<ListWaitingRoomRulesRequest> request);
  ListWaitingRoomsResponse listWaitingRoomsWithOptions(shared_ptr<ListWaitingRoomsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWaitingRoomsResponse listWaitingRooms(shared_ptr<ListWaitingRoomsRequest> request);
  PreloadCachesResponse preloadCachesWithOptions(shared_ptr<PreloadCachesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PreloadCachesResponse preloadCaches(shared_ptr<PreloadCachesRequest> request);
  PublishEdgeContainerAppVersionResponse publishEdgeContainerAppVersionWithOptions(shared_ptr<PublishEdgeContainerAppVersionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishEdgeContainerAppVersionResponse publishEdgeContainerAppVersion(shared_ptr<PublishEdgeContainerAppVersionRequest> request);
  PublishRoutineCodeVersionResponse publishRoutineCodeVersionWithOptions(shared_ptr<PublishRoutineCodeVersionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishRoutineCodeVersionResponse publishRoutineCodeVersion(shared_ptr<PublishRoutineCodeVersionRequest> request);
  PurgeCachesResponse purgeCachesWithOptions(shared_ptr<PurgeCachesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PurgeCachesResponse purgeCaches(shared_ptr<PurgeCachesRequest> request);
  PutKvResponse putKvWithOptions(shared_ptr<PutKvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutKvResponse putKv(shared_ptr<PutKvRequest> request);
  PutKvWithHighCapacityResponse putKvWithHighCapacityWithOptions(shared_ptr<PutKvWithHighCapacityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutKvWithHighCapacityResponse putKvWithHighCapacity(shared_ptr<PutKvWithHighCapacityRequest> request);
  PutKvWithHighCapacityResponse putKvWithHighCapacityAdvance(shared_ptr<PutKvWithHighCapacityAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebuildEdgeContainerAppStagingEnvResponse rebuildEdgeContainerAppStagingEnvWithOptions(shared_ptr<RebuildEdgeContainerAppStagingEnvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebuildEdgeContainerAppStagingEnvResponse rebuildEdgeContainerAppStagingEnv(shared_ptr<RebuildEdgeContainerAppStagingEnvRequest> request);
  ResetScheduledPreloadJobResponse resetScheduledPreloadJobWithOptions(shared_ptr<ResetScheduledPreloadJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetScheduledPreloadJobResponse resetScheduledPreloadJob(shared_ptr<ResetScheduledPreloadJobRequest> request);
  RevokeClientCertificateResponse revokeClientCertificateWithOptions(shared_ptr<RevokeClientCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeClientCertificateResponse revokeClientCertificate(shared_ptr<RevokeClientCertificateRequest> request);
  RollbackEdgeContainerAppVersionResponse rollbackEdgeContainerAppVersionWithOptions(shared_ptr<RollbackEdgeContainerAppVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackEdgeContainerAppVersionResponse rollbackEdgeContainerAppVersion(shared_ptr<RollbackEdgeContainerAppVersionRequest> request);
  SetCertificateResponse setCertificateWithOptions(shared_ptr<SetCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCertificateResponse setCertificate(shared_ptr<SetCertificateRequest> request);
  SetClientCertificateHostnamesResponse setClientCertificateHostnamesWithOptions(shared_ptr<SetClientCertificateHostnamesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetClientCertificateHostnamesResponse setClientCertificateHostnames(shared_ptr<SetClientCertificateHostnamesRequest> request);
  SetHttpDDoSAttackIntelligentProtectionResponse setHttpDDoSAttackIntelligentProtectionWithOptions(shared_ptr<SetHttpDDoSAttackIntelligentProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetHttpDDoSAttackIntelligentProtectionResponse setHttpDDoSAttackIntelligentProtection(shared_ptr<SetHttpDDoSAttackIntelligentProtectionRequest> request);
  SetHttpDDoSAttackProtectionResponse setHttpDDoSAttackProtectionWithOptions(shared_ptr<SetHttpDDoSAttackProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetHttpDDoSAttackProtectionResponse setHttpDDoSAttackProtection(shared_ptr<SetHttpDDoSAttackProtectionRequest> request);
  StartScheduledPreloadExecutionResponse startScheduledPreloadExecutionWithOptions(shared_ptr<StartScheduledPreloadExecutionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartScheduledPreloadExecutionResponse startScheduledPreloadExecution(shared_ptr<StartScheduledPreloadExecutionRequest> request);
  StopScheduledPreloadExecutionResponse stopScheduledPreloadExecutionWithOptions(shared_ptr<StopScheduledPreloadExecutionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopScheduledPreloadExecutionResponse stopScheduledPreloadExecution(shared_ptr<StopScheduledPreloadExecutionRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateCustomScenePolicyResponse updateCustomScenePolicyWithOptions(shared_ptr<UpdateCustomScenePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomScenePolicyResponse updateCustomScenePolicy(shared_ptr<UpdateCustomScenePolicyRequest> request);
  UpdateKvNamespaceResponse updateKvNamespaceWithOptions(shared_ptr<UpdateKvNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateKvNamespaceResponse updateKvNamespace(shared_ptr<UpdateKvNamespaceRequest> request);
  UpdateListResponse updateListWithOptions(shared_ptr<UpdateListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateListResponse updateList(shared_ptr<UpdateListRequest> request);
  UpdateOriginProtectionResponse updateOriginProtectionWithOptions(shared_ptr<UpdateOriginProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOriginProtectionResponse updateOriginProtection(shared_ptr<UpdateOriginProtectionRequest> request);
  UpdateOriginProtectionIpWhiteListResponse updateOriginProtectionIpWhiteListWithOptions(shared_ptr<UpdateOriginProtectionIpWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOriginProtectionIpWhiteListResponse updateOriginProtectionIpWhiteList(shared_ptr<UpdateOriginProtectionIpWhiteListRequest> request);
  UpdatePageResponse updatePageWithOptions(shared_ptr<UpdatePageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePageResponse updatePage(shared_ptr<UpdatePageRequest> request);
  UpdateRecordResponse updateRecordWithOptions(shared_ptr<UpdateRecordRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRecordResponse updateRecord(shared_ptr<UpdateRecordRequest> request);
  UpdateScheduledPreloadExecutionResponse updateScheduledPreloadExecutionWithOptions(shared_ptr<UpdateScheduledPreloadExecutionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateScheduledPreloadExecutionResponse updateScheduledPreloadExecution(shared_ptr<UpdateScheduledPreloadExecutionRequest> request);
  UpdateSiteAccessTypeResponse updateSiteAccessTypeWithOptions(shared_ptr<UpdateSiteAccessTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSiteAccessTypeResponse updateSiteAccessType(shared_ptr<UpdateSiteAccessTypeRequest> request);
  UpdateSiteCoverageResponse updateSiteCoverageWithOptions(shared_ptr<UpdateSiteCoverageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSiteCoverageResponse updateSiteCoverage(shared_ptr<UpdateSiteCoverageRequest> request);
  UpdateSiteCustomLogResponse updateSiteCustomLogWithOptions(shared_ptr<UpdateSiteCustomLogRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSiteCustomLogResponse updateSiteCustomLog(shared_ptr<UpdateSiteCustomLogRequest> request);
  UpdateSiteDeliveryTaskResponse updateSiteDeliveryTaskWithOptions(shared_ptr<UpdateSiteDeliveryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSiteDeliveryTaskResponse updateSiteDeliveryTask(shared_ptr<UpdateSiteDeliveryTaskRequest> request);
  UpdateSiteDeliveryTaskStatusResponse updateSiteDeliveryTaskStatusWithOptions(shared_ptr<UpdateSiteDeliveryTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSiteDeliveryTaskStatusResponse updateSiteDeliveryTaskStatus(shared_ptr<UpdateSiteDeliveryTaskStatusRequest> request);
  UpdateSiteFunctionResponse updateSiteFunctionWithOptions(shared_ptr<UpdateSiteFunctionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSiteFunctionResponse updateSiteFunction(shared_ptr<UpdateSiteFunctionRequest> request);
  UpdateSiteVanityNSResponse updateSiteVanityNSWithOptions(shared_ptr<UpdateSiteVanityNSRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSiteVanityNSResponse updateSiteVanityNS(shared_ptr<UpdateSiteVanityNSRequest> request);
  UpdateUserDeliveryTaskResponse updateUserDeliveryTaskWithOptions(shared_ptr<UpdateUserDeliveryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserDeliveryTaskResponse updateUserDeliveryTask(shared_ptr<UpdateUserDeliveryTaskRequest> request);
  UpdateUserDeliveryTaskStatusResponse updateUserDeliveryTaskStatusWithOptions(shared_ptr<UpdateUserDeliveryTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserDeliveryTaskStatusResponse updateUserDeliveryTaskStatus(shared_ptr<UpdateUserDeliveryTaskStatusRequest> request);
  UpdateWafRuleResponse updateWafRuleWithOptions(shared_ptr<UpdateWafRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWafRuleResponse updateWafRule(shared_ptr<UpdateWafRuleRequest> request);
  UpdateWafRulesetResponse updateWafRulesetWithOptions(shared_ptr<UpdateWafRulesetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWafRulesetResponse updateWafRuleset(shared_ptr<UpdateWafRulesetRequest> request);
  UpdateWaitingRoomResponse updateWaitingRoomWithOptions(shared_ptr<UpdateWaitingRoomRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWaitingRoomResponse updateWaitingRoom(shared_ptr<UpdateWaitingRoomRequest> request);
  UpdateWaitingRoomEventResponse updateWaitingRoomEventWithOptions(shared_ptr<UpdateWaitingRoomEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWaitingRoomEventResponse updateWaitingRoomEvent(shared_ptr<UpdateWaitingRoomEventRequest> request);
  UpdateWaitingRoomRuleResponse updateWaitingRoomRuleWithOptions(shared_ptr<UpdateWaitingRoomRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWaitingRoomRuleResponse updateWaitingRoomRule(shared_ptr<UpdateWaitingRoomRuleRequest> request);
  UploadClientCaCertificateResponse uploadClientCaCertificateWithOptions(shared_ptr<UploadClientCaCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadClientCaCertificateResponse uploadClientCaCertificate(shared_ptr<UploadClientCaCertificateRequest> request);
  UploadFileResponse uploadFileWithOptions(shared_ptr<UploadFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadFileResponse uploadFile(shared_ptr<UploadFileRequest> request);
  UploadFileResponse uploadFileAdvance(shared_ptr<UploadFileAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifySiteResponse verifySiteWithOptions(shared_ptr<VerifySiteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifySiteResponse verifySite(shared_ptr<VerifySiteRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_ESA20240910

#endif
