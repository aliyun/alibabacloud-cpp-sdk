// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_MTS20140618_H_
#define ALIBABACLOUD_MTS20140618_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Mts20140618 {
class QueryAuthConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};

  QueryAuthConfigRequest() {}

  explicit QueryAuthConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryAuthConfigRequest() = default;
};
class QueryAuthConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> key2{};
  shared_ptr<string> key1{};
  shared_ptr<string> requestId{};

  QueryAuthConfigResponseBody() {}

  explicit QueryAuthConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key2) {
      res["Key2"] = boost::any(*key2);
    }
    if (key1) {
      res["Key1"] = boost::any(*key1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key2") != m.end() && !m["Key2"].empty()) {
      key2 = make_shared<string>(boost::any_cast<string>(m["Key2"]));
    }
    if (m.find("Key1") != m.end() && !m["Key1"].empty()) {
      key1 = make_shared<string>(boost::any_cast<string>(m["Key1"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryAuthConfigResponseBody() = default;
};
class QueryAuthConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryAuthConfigResponseBody> body{};

  QueryAuthConfigResponse() {}

  explicit QueryAuthConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAuthConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAuthConfigResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAuthConfigResponse() = default;
};
class QueryAsrPipelineListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineIds{};
  shared_ptr<string> ownerAccount{};

  QueryAsrPipelineListRequest() {}

  explicit QueryAsrPipelineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineIds) {
      res["PipelineIds"] = boost::any(*pipelineIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineIds") != m.end() && !m["PipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["PipelineIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryAsrPipelineListRequest() = default;
};
class QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class QueryAsrPipelineListResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  QueryAsrPipelineListResponseBodyPipelineListPipeline() {}

  explicit QueryAsrPipelineListResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryAsrPipelineListResponseBodyPipelineListPipeline() = default;
};
class QueryAsrPipelineListResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAsrPipelineListResponseBodyPipelineListPipeline>> pipeline{};

  QueryAsrPipelineListResponseBodyPipelineList() {}

  explicit QueryAsrPipelineListResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<QueryAsrPipelineListResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAsrPipelineListResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<QueryAsrPipelineListResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~QueryAsrPipelineListResponseBodyPipelineList() = default;
};
class QueryAsrPipelineListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryAsrPipelineListResponseBodyNonExistIds() {}

  explicit QueryAsrPipelineListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryAsrPipelineListResponseBodyNonExistIds() = default;
};
class QueryAsrPipelineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryAsrPipelineListResponseBodyPipelineList> pipelineList{};
  shared_ptr<QueryAsrPipelineListResponseBodyNonExistIds> nonExistIds{};

  QueryAsrPipelineListResponseBody() {}

  explicit QueryAsrPipelineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        QueryAsrPipelineListResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<QueryAsrPipelineListResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryAsrPipelineListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryAsrPipelineListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryAsrPipelineListResponseBody() = default;
};
class QueryAsrPipelineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryAsrPipelineListResponseBody> body{};

  QueryAsrPipelineListResponse() {}

  explicit QueryAsrPipelineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAsrPipelineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAsrPipelineListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAsrPipelineListResponse() = default;
};
class SubmitMediaCensorJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> coverImages{};
  shared_ptr<string> title{};
  shared_ptr<string> description{};
  shared_ptr<string> barrages{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> videoCensorConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitMediaCensorJobRequest() {}

  explicit SubmitMediaCensorJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (coverImages) {
      res["CoverImages"] = boost::any(*coverImages);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (barrages) {
      res["Barrages"] = boost::any(*barrages);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = boost::any(*videoCensorConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("CoverImages") != m.end() && !m["CoverImages"].empty()) {
      coverImages = make_shared<string>(boost::any_cast<string>(m["CoverImages"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Barrages") != m.end() && !m["Barrages"].empty()) {
      barrages = make_shared<string>(boost::any_cast<string>(m["Barrages"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      videoCensorConfig = make_shared<string>(boost::any_cast<string>(m["VideoCensorConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitMediaCensorJobRequest() = default;
};
class SubmitMediaCensorJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitMediaCensorJobResponseBody() {}

  explicit SubmitMediaCensorJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitMediaCensorJobResponseBody() = default;
};
class SubmitMediaCensorJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitMediaCensorJobResponseBody> body{};

  SubmitMediaCensorJobResponse() {}

  explicit SubmitMediaCensorJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaCensorJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaCensorJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaCensorJobResponse() = default;
};
class CreateSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> endUserId{};
  shared_ptr<long> sessionTime{};
  shared_ptr<string> mediaId{};

  CreateSessionRequest() {}

  explicit CreateSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (endUserId) {
      res["EndUserId"] = boost::any(*endUserId);
    }
    if (sessionTime) {
      res["SessionTime"] = boost::any(*sessionTime);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("EndUserId") != m.end() && !m["EndUserId"].empty()) {
      endUserId = make_shared<string>(boost::any_cast<string>(m["EndUserId"]));
    }
    if (m.find("SessionTime") != m.end() && !m["SessionTime"].empty()) {
      sessionTime = make_shared<long>(boost::any_cast<long>(m["SessionTime"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~CreateSessionRequest() = default;
};
class CreateSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ticket{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sessionId{};

  CreateSessionResponseBody() {}

  explicit CreateSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ticket) {
      res["Ticket"] = boost::any(*ticket);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ticket") != m.end() && !m["Ticket"].empty()) {
      ticket = make_shared<string>(boost::any_cast<string>(m["Ticket"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
  }


  virtual ~CreateSessionResponseBody() = default;
};
class CreateSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSessionResponseBody> body{};

  CreateSessionResponse() {}

  explicit CreateSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSessionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSessionResponse() = default;
};
class ListAsrPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> state{};
  shared_ptr<string> ownerAccount{};

  ListAsrPipelineRequest() {}

  explicit ListAsrPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListAsrPipelineRequest() = default;
};
class ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class ListAsrPipelineResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListAsrPipelineResponseBodyPipelineListPipeline() {}

  explicit ListAsrPipelineResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListAsrPipelineResponseBodyPipelineListPipeline() = default;
};
class ListAsrPipelineResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAsrPipelineResponseBodyPipelineListPipeline>> pipeline{};

  ListAsrPipelineResponseBodyPipelineList() {}

  explicit ListAsrPipelineResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<ListAsrPipelineResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAsrPipelineResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<ListAsrPipelineResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~ListAsrPipelineResponseBodyPipelineList() = default;
};
class ListAsrPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<ListAsrPipelineResponseBodyPipelineList> pipelineList{};

  ListAsrPipelineResponseBody() {}

  explicit ListAsrPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        ListAsrPipelineResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<ListAsrPipelineResponseBodyPipelineList>(model1);
      }
    }
  }


  virtual ~ListAsrPipelineResponseBody() = default;
};
class ListAsrPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAsrPipelineResponseBody> body{};

  ListAsrPipelineResponse() {}

  explicit ListAsrPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAsrPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAsrPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~ListAsrPipelineResponse() = default;
};
class ListJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> state{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  ListJobRequest() {}

  explicit ListJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListJobRequest() = default;
};
class ListJobResponseBodyJobListJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  ListJobResponseBodyJobListJobOutputVideoBitrateBnd() {}

  explicit ListJobResponseBodyJobListJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputVideoBitrateBnd() = default;
};
class ListJobResponseBodyJobListJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<ListJobResponseBodyJobListJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> resoPriority{};

  ListJobResponseBodyJobListJobOutputVideo() {}

  explicit ListJobResponseBodyJobListJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        ListJobResponseBodyJobListJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<ListJobResponseBodyJobListJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputVideo() = default;
};
class ListJobResponseBodyJobListJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  ListJobResponseBodyJobListJobOutputTransConfig() {}

  explicit ListJobResponseBodyJobListJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTransConfig() = default;
};
class ListJobResponseBodyJobListJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> id{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};

  ListJobResponseBodyJobListJobOutputEncryption() {}

  explicit ListJobResponseBodyJobListJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputEncryption() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> referPos{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> dy{};

  ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark>> waterMark{};

  ListJobResponseBodyJobListJobOutputWaterMarkList() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkList() = default;
};
class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> sizeSupport{};
  shared_ptr<bool> md5Support{};

  ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS() {}

  explicit ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS() = default;
};
class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS> TS{};

  ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport() {}

  explicit ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport() = default;
};
class ListJobResponseBodyJobListJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> level{};

  ListJobResponseBodyJobListJobOutputAudioVolume() {}

  explicit ListJobResponseBodyJobListJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputAudioVolume() = default;
};
class ListJobResponseBodyJobListJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<ListJobResponseBodyJobListJobOutputAudioVolume> volume{};
  shared_ptr<string> bitrate{};

  ListJobResponseBodyJobListJobOutputAudio() {}

  explicit ListJobResponseBodyJobListJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        ListJobResponseBodyJobListJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<ListJobResponseBodyJobListJobOutputAudioVolume>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputAudio() = default;
};
class ListJobResponseBodyJobListJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> duration{};

  ListJobResponseBodyJobListJobOutputMergeListMerge() {}

  explicit ListJobResponseBodyJobListJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMergeListMerge() = default;
};
class ListJobResponseBodyJobListJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputMergeListMerge>> merge{};

  ListJobResponseBodyJobListJobOutputMergeList() {}

  explicit ListJobResponseBodyJobListJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<ListJobResponseBodyJobListJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<ListJobResponseBodyJobListJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMergeList() = default;
};
class ListJobResponseBodyJobListJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  ListJobResponseBodyJobListJobOutputSuperReso() {}

  explicit ListJobResponseBodyJobListJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSuperReso() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};

  ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  ListJobResponseBodyJobListJobOutputOutSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  ListJobResponseBodyJobListJobOutputOutputFile() {}

  explicit ListJobResponseBodyJobListJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutputFile() = default;
};
class ListJobResponseBodyJobListJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  ListJobResponseBodyJobListJobOutputContainer() {}

  explicit ListJobResponseBodyJobListJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputContainer() = default;
};
class ListJobResponseBodyJobListJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> seek{};
  shared_ptr<string> duration{};

  ListJobResponseBodyJobListJobOutputClipTimeSpan() {}

  explicit ListJobResponseBodyJobListJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputClipTimeSpan() = default;
};
class ListJobResponseBodyJobListJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputClipTimeSpan> timeSpan{};

  ListJobResponseBodyJobListJobOutputClip() {}

  explicit ListJobResponseBodyJobListJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        ListJobResponseBodyJobListJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<ListJobResponseBodyJobListJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputClip() = default;
};
class ListJobResponseBodyJobListJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> openUrl{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};

  ListJobResponseBodyJobListJobOutputOpeningListOpening() {}

  explicit ListJobResponseBodyJobListJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOpeningListOpening() = default;
};
class ListJobResponseBodyJobListJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputOpeningListOpening>> opening{};

  ListJobResponseBodyJobListJobOutputOpeningList() {}

  explicit ListJobResponseBodyJobListJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<ListJobResponseBodyJobListJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<ListJobResponseBodyJobListJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOpeningList() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  ListJobResponseBodyJobListJobOutputMuxConfigWebp() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigWebp() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  ListJobResponseBodyJobListJobOutputMuxConfigGif() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigGif() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  ListJobResponseBodyJobListJobOutputMuxConfigSegment() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigSegment() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigWebp> webp{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigGif> gif{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigSegment> segment{};

  ListJobResponseBodyJobListJobOutputMuxConfig() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigWebp>(model1);
      }
    }
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfig() = default;
};
class ListJobResponseBodyJobListJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> bgColor{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> tailUrl{};

  ListJobResponseBodyJobListJobOutputTailSlateListTailSlate() {}

  explicit ListJobResponseBodyJobListJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTailSlateListTailSlate() = default;
};
class ListJobResponseBodyJobListJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate>> tailSlate{};

  ListJobResponseBodyJobListJobOutputTailSlateList() {}

  explicit ListJobResponseBodyJobListJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTailSlateList() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList> subtitleList{};

  ListJobResponseBodyJobListJobOutputSubtitleConfig() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfig() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> sar{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> height{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> width{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  ListJobResponseBodyJobListJobOutputPropertiesStreams() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreams() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  ListJobResponseBodyJobListJobOutputPropertiesFormat() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesFormat() = default;
};
class ListJobResponseBodyJobListJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreams> streams{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  ListJobResponseBodyJobListJobOutputProperties() {}

  explicit ListJobResponseBodyJobListJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<ListJobResponseBodyJobListJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputProperties() = default;
};
class ListJobResponseBodyJobListJobOutput : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputVideo> video{};
  shared_ptr<ListJobResponseBodyJobListJobOutputTransConfig> transConfig{};
  shared_ptr<ListJobResponseBodyJobListJobOutputEncryption> encryption{};
  shared_ptr<ListJobResponseBodyJobListJobOutputWaterMarkList> waterMarkList{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<string> deWatermark{};
  shared_ptr<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> priority{};
  shared_ptr<ListJobResponseBodyJobListJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMergeList> mergeList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSuperReso> superReso{};
  shared_ptr<string> userData{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutputFile> outputFile{};
  shared_ptr<string> rotate{};
  shared_ptr<ListJobResponseBodyJobListJobOutputContainer> container{};
  shared_ptr<ListJobResponseBodyJobListJobOutputClip> clip{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOpeningList> openingList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfig> muxConfig{};
  shared_ptr<ListJobResponseBodyJobListJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<ListJobResponseBodyJobListJobOutputProperties> properties{};

  ListJobResponseBodyJobListJobOutput() {}

  explicit ListJobResponseBodyJobListJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        ListJobResponseBodyJobListJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<ListJobResponseBodyJobListJobOutputVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        ListJobResponseBodyJobListJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<ListJobResponseBodyJobListJobOutputTransConfig>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        ListJobResponseBodyJobListJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<ListJobResponseBodyJobListJobOutputEncryption>(model1);
      }
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        ListJobResponseBodyJobListJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<ListJobResponseBodyJobListJobOutputWaterMarkList>(model1);
      }
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        ListJobResponseBodyJobListJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<ListJobResponseBodyJobListJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        ListJobResponseBodyJobListJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<ListJobResponseBodyJobListJobOutputMergeList>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        ListJobResponseBodyJobListJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<ListJobResponseBodyJobListJobOutputSuperReso>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<ListJobResponseBodyJobListJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        ListJobResponseBodyJobListJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<ListJobResponseBodyJobListJobOutputOutputFile>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        ListJobResponseBodyJobListJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<ListJobResponseBodyJobListJobOutputContainer>(model1);
      }
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        ListJobResponseBodyJobListJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<ListJobResponseBodyJobListJobOutputClip>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        ListJobResponseBodyJobListJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<ListJobResponseBodyJobListJobOutputOpeningList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<ListJobResponseBodyJobListJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        ListJobResponseBodyJobListJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<ListJobResponseBodyJobListJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        ListJobResponseBodyJobListJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<ListJobResponseBodyJobListJobOutputProperties>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutput() = default;
};
class ListJobResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  ListJobResponseBodyJobListJobInput() {}

  explicit ListJobResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobInput() = default;
};
class ListJobResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  ListJobResponseBodyJobListJobMNSMessageResult() {}

  explicit ListJobResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobMNSMessageResult() = default;
};
class ListJobResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ListJobResponseBodyJobListJobOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<ListJobResponseBodyJobListJobInput> input{};
  shared_ptr<ListJobResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};

  ListJobResponseBodyJobListJob() {}

  explicit ListJobResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListJobResponseBodyJobListJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListJobResponseBodyJobListJobOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListJobResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListJobResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        ListJobResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<ListJobResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJob() = default;
};
class ListJobResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJob>> job{};

  ListJobResponseBodyJobList() {}

  explicit ListJobResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<ListJobResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<ListJobResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobList() = default;
};
class ListJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<ListJobResponseBodyJobList> jobList{};

  ListJobResponseBody() {}

  explicit ListJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        ListJobResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<ListJobResponseBodyJobList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBody() = default;
};
class ListJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListJobResponseBody> body{};

  ListJobResponse() {}

  explicit ListJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobResponse() = default;
};
class QueryIProductionJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> IProductionJobIds{};
  shared_ptr<string> ownerAccount{};

  QueryIProductionJobListRequest() {}

  explicit QueryIProductionJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (IProductionJobIds) {
      res["IProductionJobIds"] = boost::any(*IProductionJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("IProductionJobIds") != m.end() && !m["IProductionJobIds"].empty()) {
      IProductionJobIds = make_shared<string>(boost::any_cast<string>(m["IProductionJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryIProductionJobListRequest() = default;
};
class QueryIProductionJobListResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryIProductionJobListResponseBodyJobs() {}

  explicit QueryIProductionJobListResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryIProductionJobListResponseBodyJobs() = default;
};
class QueryIProductionJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryIProductionJobListResponseBodyNonExistIds() {}

  explicit QueryIProductionJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryIProductionJobListResponseBodyNonExistIds() = default;
};
class QueryIProductionJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryIProductionJobListResponseBodyJobs> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryIProductionJobListResponseBodyNonExistIds> nonExistIds{};

  QueryIProductionJobListResponseBody() {}

  explicit QueryIProductionJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobs) {
      res["Jobs"] = jobs ? boost::any(jobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Jobs"].type()) {
        QueryIProductionJobListResponseBodyJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Jobs"]));
        jobs = make_shared<QueryIProductionJobListResponseBodyJobs>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryIProductionJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryIProductionJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryIProductionJobListResponseBody() = default;
};
class QueryIProductionJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryIProductionJobListResponseBody> body{};

  QueryIProductionJobListResponse() {}

  explicit QueryIProductionJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIProductionJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIProductionJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIProductionJobListResponse() = default;
};
class UpdateMediaPublishStateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaId{};
  shared_ptr<bool> publish{};
  shared_ptr<string> ownerAccount{};

  UpdateMediaPublishStateRequest() {}

  explicit UpdateMediaPublishStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (publish) {
      res["Publish"] = boost::any(*publish);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Publish") != m.end() && !m["Publish"].empty()) {
      publish = make_shared<bool>(boost::any_cast<bool>(m["Publish"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateMediaPublishStateRequest() = default;
};
class UpdateMediaPublishStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaPublishStateResponseBody() {}

  explicit UpdateMediaPublishStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaPublishStateResponseBody() = default;
};
class UpdateMediaPublishStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMediaPublishStateResponseBody> body{};

  UpdateMediaPublishStateResponse() {}

  explicit UpdateMediaPublishStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaPublishStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaPublishStateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaPublishStateResponse() = default;
};
class SubmitFpFileDeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> userData{};
  shared_ptr<string> fileIds{};
  shared_ptr<string> ownerAccount{};

  SubmitFpFileDeleteJobRequest() {}

  explicit SubmitFpFileDeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitFpFileDeleteJobRequest() = default;
};
class SubmitFpFileDeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitFpFileDeleteJobResponseBody() {}

  explicit SubmitFpFileDeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitFpFileDeleteJobResponseBody() = default;
};
class SubmitFpFileDeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitFpFileDeleteJobResponseBody> body{};

  SubmitFpFileDeleteJobResponse() {}

  explicit SubmitFpFileDeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFpFileDeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFpFileDeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFpFileDeleteJobResponse() = default;
};
class QueryAnalysisJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> analysisJobIds{};
  shared_ptr<string> ownerAccount{};

  QueryAnalysisJobListRequest() {}

  explicit QueryAnalysisJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (analysisJobIds) {
      res["AnalysisJobIds"] = boost::any(*analysisJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("AnalysisJobIds") != m.end() && !m["AnalysisJobIds"].empty()) {
      analysisJobIds = make_shared<string>(boost::any_cast<string>(m["AnalysisJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryAnalysisJobListRequest() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl : public Darabonba::Model {
public:
  shared_ptr<string> methodStreaming{};
  shared_ptr<string> rateQuality{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodStreaming) {
      res["MethodStreaming"] = boost::any(*methodStreaming);
    }
    if (rateQuality) {
      res["RateQuality"] = boost::any(*rateQuality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodStreaming") != m.end() && !m["MethodStreaming"].empty()) {
      methodStreaming = make_shared<string>(boost::any_cast<string>(m["MethodStreaming"]));
    }
    if (m.find("RateQuality") != m.end() && !m["RateQuality"].empty()) {
      rateQuality = make_shared<string>(boost::any_cast<string>(m["RateQuality"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop : public Darabonba::Model {
public:
  shared_ptr<string> top{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> left{};
  shared_ptr<string> mode{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (top) {
      res["Top"] = boost::any(*top);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl : public Darabonba::Model {
public:
  shared_ptr<string> deinterlace{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop> crop{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deinterlace) {
      res["Deinterlace"] = boost::any(*deinterlace);
    }
    if (crop) {
      res["Crop"] = crop ? boost::any(crop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deinterlace") != m.end() && !m["Deinterlace"].empty()) {
      deinterlace = make_shared<string>(boost::any_cast<string>(m["Deinterlace"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Crop"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Crop"]));
        crop = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl> qualityControl{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl> propertiesControl{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qualityControl) {
      res["QualityControl"] = qualityControl ? boost::any(qualityControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertiesControl) {
      res["PropertiesControl"] = propertiesControl ? boost::any(propertiesControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QualityControl") != m.end() && !m["QualityControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["QualityControl"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QualityControl"]));
        qualityControl = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl>(model1);
      }
    }
    if (m.find("PropertiesControl") != m.end() && !m["PropertiesControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertiesControl"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertiesControl"]));
        propertiesControl = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> transMode{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> loop{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment> segment{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<string> bitrate{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo> video{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<string> state{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio> audio{};
  shared_ptr<string> id{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer> container{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate>> template_{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> state{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig> analysisConfig{};
  shared_ptr<string> message{};
  shared_ptr<string> priority{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList> templateList{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile> inputFile{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> id{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (analysisConfig) {
      res["AnalysisConfig"] = analysisConfig ? boost::any(analysisConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisConfig"]));
        analysisConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult>(model1);
      }
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob>> analysisJob{};

  QueryAnalysisJobListResponseBodyAnalysisJobList() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJob) {
      vector<boost::any> temp1;
      for(auto item1:*analysisJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnalysisJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJob") != m.end() && !m["AnalysisJob"].empty()) {
      if (typeid(vector<boost::any>) == m["AnalysisJob"].type()) {
        vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnalysisJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        analysisJob = make_shared<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob>>(expect1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobList() = default;
};
class QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds() {}

  explicit QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds() = default;
};
class QueryAnalysisJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobList> analysisJobList{};
  shared_ptr<QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds> nonExistAnalysisJobIds{};

  QueryAnalysisJobListResponseBody() {}

  explicit QueryAnalysisJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (analysisJobList) {
      res["AnalysisJobList"] = analysisJobList ? boost::any(analysisJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistAnalysisJobIds) {
      res["NonExistAnalysisJobIds"] = nonExistAnalysisJobIds ? boost::any(nonExistAnalysisJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AnalysisJobList") != m.end() && !m["AnalysisJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisJobList"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisJobList"]));
        analysisJobList = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobList>(model1);
      }
    }
    if (m.find("NonExistAnalysisJobIds") != m.end() && !m["NonExistAnalysisJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistAnalysisJobIds"].type()) {
        QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistAnalysisJobIds"]));
        nonExistAnalysisJobIds = make_shared<QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBody() = default;
};
class QueryAnalysisJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryAnalysisJobListResponseBody> body{};

  QueryAnalysisJobListResponse() {}

  explicit QueryAnalysisJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAnalysisJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAnalysisJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponse() = default;
};
class SubmitInferenceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> serverName{};
  shared_ptr<string> modelType{};
  shared_ptr<string> input{};

  SubmitInferenceJobRequest() {}

  explicit SubmitInferenceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverName) {
      res["ServerName"] = boost::any(*serverName);
    }
    if (modelType) {
      res["ModelType"] = boost::any(*modelType);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerName") != m.end() && !m["ServerName"].empty()) {
      serverName = make_shared<string>(boost::any_cast<string>(m["ServerName"]));
    }
    if (m.find("ModelType") != m.end() && !m["ModelType"].empty()) {
      modelType = make_shared<string>(boost::any_cast<string>(m["ModelType"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
  }


  virtual ~SubmitInferenceJobRequest() = default;
};
class SubmitInferenceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> testId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> jobId{};

  SubmitInferenceJobResponseBody() {}

  explicit SubmitInferenceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testId) {
      res["TestId"] = boost::any(*testId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestId") != m.end() && !m["TestId"].empty()) {
      testId = make_shared<string>(boost::any_cast<string>(m["TestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitInferenceJobResponseBody() = default;
};
class SubmitInferenceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitInferenceJobResponseBody> body{};

  SubmitInferenceJobResponse() {}

  explicit SubmitInferenceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitInferenceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitInferenceJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitInferenceJobResponse() = default;
};
class ReportCensorJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> label{};
  shared_ptr<string> detail{};
  shared_ptr<string> ownerAccount{};

  ReportCensorJobResultRequest() {}

  explicit ReportCensorJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportCensorJobResultRequest() = default;
};
class ReportCensorJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportCensorJobResultResponseBody() {}

  explicit ReportCensorJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportCensorJobResultResponseBody() = default;
};
class ReportCensorJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportCensorJobResultResponseBody> body{};

  ReportCensorJobResultResponse() {}

  explicit ReportCensorJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportCensorJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportCensorJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportCensorJobResultResponse() = default;
};
class DeleteMcuJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> jobIds{};

  DeleteMcuJobRequest() {}

  explicit DeleteMcuJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
  }


  virtual ~DeleteMcuJobRequest() = default;
};
class DeleteMcuJobResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  DeleteMcuJobResponseBodyNonExistJobIds() {}

  explicit DeleteMcuJobResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteMcuJobResponseBodyNonExistJobIds() = default;
};
class DeleteMcuJobResponseBodyDeletedJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  DeleteMcuJobResponseBodyDeletedJobIds() {}

  explicit DeleteMcuJobResponseBodyDeletedJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteMcuJobResponseBodyDeletedJobIds() = default;
};
class DeleteMcuJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteMcuJobResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteMcuJobResponseBodyDeletedJobIds> deletedJobIds{};

  DeleteMcuJobResponseBody() {}

  explicit DeleteMcuJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deletedJobIds) {
      res["DeletedJobIds"] = deletedJobIds ? boost::any(deletedJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        DeleteMcuJobResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<DeleteMcuJobResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeletedJobIds") != m.end() && !m["DeletedJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeletedJobIds"].type()) {
        DeleteMcuJobResponseBodyDeletedJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeletedJobIds"]));
        deletedJobIds = make_shared<DeleteMcuJobResponseBodyDeletedJobIds>(model1);
      }
    }
  }


  virtual ~DeleteMcuJobResponseBody() = default;
};
class DeleteMcuJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMcuJobResponseBody> body{};

  DeleteMcuJobResponse() {}

  explicit DeleteMcuJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcuJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcuJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcuJobResponse() = default;
};
class QueryInferenceServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> modelType{};
  shared_ptr<long> createTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> maxPageSize{};

  QueryInferenceServerRequest() {}

  explicit QueryInferenceServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelType) {
      res["ModelType"] = boost::any(*modelType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (maxPageSize) {
      res["MaxPageSize"] = boost::any(*maxPageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelType") != m.end() && !m["ModelType"].empty()) {
      modelType = make_shared<string>(boost::any_cast<string>(m["ModelType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("MaxPageSize") != m.end() && !m["MaxPageSize"].empty()) {
      maxPageSize = make_shared<long>(boost::any_cast<long>(m["MaxPageSize"]));
    }
  }


  virtual ~QueryInferenceServerRequest() = default;
};
class QueryInferenceServerResponseBodyFunctions : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<long> createTime{};
  shared_ptr<long> userId{};
  shared_ptr<string> modelType{};
  shared_ptr<string> modelPath{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> testId{};

  QueryInferenceServerResponseBodyFunctions() {}

  explicit QueryInferenceServerResponseBodyFunctions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (modelType) {
      res["ModelType"] = boost::any(*modelType);
    }
    if (modelPath) {
      res["ModelPath"] = boost::any(*modelPath);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (testId) {
      res["TestId"] = boost::any(*testId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("ModelType") != m.end() && !m["ModelType"].empty()) {
      modelType = make_shared<string>(boost::any_cast<string>(m["ModelType"]));
    }
    if (m.find("ModelPath") != m.end() && !m["ModelPath"].empty()) {
      modelPath = make_shared<string>(boost::any_cast<string>(m["ModelPath"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("TestId") != m.end() && !m["TestId"].empty()) {
      testId = make_shared<string>(boost::any_cast<string>(m["TestId"]));
    }
  }


  virtual ~QueryInferenceServerResponseBodyFunctions() = default;
};
class QueryInferenceServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryInferenceServerResponseBodyFunctions>> functions{};
  shared_ptr<string> code{};
  shared_ptr<long> totalSize{};

  QueryInferenceServerResponseBody() {}

  explicit QueryInferenceServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (functions) {
      vector<boost::any> temp1;
      for(auto item1:*functions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Functions"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      if (typeid(vector<boost::any>) == m["Functions"].type()) {
        vector<QueryInferenceServerResponseBodyFunctions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Functions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryInferenceServerResponseBodyFunctions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functions = make_shared<vector<QueryInferenceServerResponseBodyFunctions>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~QueryInferenceServerResponseBody() = default;
};
class QueryInferenceServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryInferenceServerResponseBody> body{};

  QueryInferenceServerResponse() {}

  explicit QueryInferenceServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryInferenceServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryInferenceServerResponseBody>(model1);
      }
    }
  }


  virtual ~QueryInferenceServerResponse() = default;
};
class CheckResourceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> interrupt{};
  shared_ptr<string> invoker{};
  shared_ptr<string> pk{};
  shared_ptr<string> bid{};
  shared_ptr<long> hid{};
  shared_ptr<string> country{};
  shared_ptr<string> taskIdentifier{};
  shared_ptr<string> taskExtraData{};
  shared_ptr<string> gmtWakeup{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};
  shared_ptr<long> level{};
  shared_ptr<string> url{};
  shared_ptr<string> prompt{};

  CheckResourceRequest() {}

  explicit CheckResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interrupt) {
      res["Interrupt"] = boost::any(*interrupt);
    }
    if (invoker) {
      res["Invoker"] = boost::any(*invoker);
    }
    if (pk) {
      res["Pk"] = boost::any(*pk);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (hid) {
      res["Hid"] = boost::any(*hid);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (taskIdentifier) {
      res["TaskIdentifier"] = boost::any(*taskIdentifier);
    }
    if (taskExtraData) {
      res["TaskExtraData"] = boost::any(*taskExtraData);
    }
    if (gmtWakeup) {
      res["GmtWakeup"] = boost::any(*gmtWakeup);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interrupt") != m.end() && !m["Interrupt"].empty()) {
      interrupt = make_shared<bool>(boost::any_cast<bool>(m["Interrupt"]));
    }
    if (m.find("Invoker") != m.end() && !m["Invoker"].empty()) {
      invoker = make_shared<string>(boost::any_cast<string>(m["Invoker"]));
    }
    if (m.find("Pk") != m.end() && !m["Pk"].empty()) {
      pk = make_shared<string>(boost::any_cast<string>(m["Pk"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Hid") != m.end() && !m["Hid"].empty()) {
      hid = make_shared<long>(boost::any_cast<long>(m["Hid"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("TaskIdentifier") != m.end() && !m["TaskIdentifier"].empty()) {
      taskIdentifier = make_shared<string>(boost::any_cast<string>(m["TaskIdentifier"]));
    }
    if (m.find("TaskExtraData") != m.end() && !m["TaskExtraData"].empty()) {
      taskExtraData = make_shared<string>(boost::any_cast<string>(m["TaskExtraData"]));
    }
    if (m.find("GmtWakeup") != m.end() && !m["GmtWakeup"].empty()) {
      gmtWakeup = make_shared<string>(boost::any_cast<string>(m["GmtWakeup"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
  }


  virtual ~CheckResourceRequest() = default;
};
class CheckResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> gmtWakeup{};
  shared_ptr<long> hid{};
  shared_ptr<string> message{};
  shared_ptr<string> taskIdentifier{};
  shared_ptr<bool> success{};
  shared_ptr<string> url{};
  shared_ptr<bool> interrupt{};
  shared_ptr<string> invoker{};
  shared_ptr<string> taskExtraData{};
  shared_ptr<string> country{};
  shared_ptr<string> prompt{};
  shared_ptr<long> level{};
  shared_ptr<string> pk{};
  shared_ptr<string> bid{};

  CheckResourceResponseBody() {}

  explicit CheckResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtWakeup) {
      res["GmtWakeup"] = boost::any(*gmtWakeup);
    }
    if (hid) {
      res["Hid"] = boost::any(*hid);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (taskIdentifier) {
      res["TaskIdentifier"] = boost::any(*taskIdentifier);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (interrupt) {
      res["Interrupt"] = boost::any(*interrupt);
    }
    if (invoker) {
      res["Invoker"] = boost::any(*invoker);
    }
    if (taskExtraData) {
      res["TaskExtraData"] = boost::any(*taskExtraData);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (pk) {
      res["Pk"] = boost::any(*pk);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtWakeup") != m.end() && !m["GmtWakeup"].empty()) {
      gmtWakeup = make_shared<string>(boost::any_cast<string>(m["GmtWakeup"]));
    }
    if (m.find("Hid") != m.end() && !m["Hid"].empty()) {
      hid = make_shared<long>(boost::any_cast<long>(m["Hid"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("TaskIdentifier") != m.end() && !m["TaskIdentifier"].empty()) {
      taskIdentifier = make_shared<string>(boost::any_cast<string>(m["TaskIdentifier"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Interrupt") != m.end() && !m["Interrupt"].empty()) {
      interrupt = make_shared<bool>(boost::any_cast<bool>(m["Interrupt"]));
    }
    if (m.find("Invoker") != m.end() && !m["Invoker"].empty()) {
      invoker = make_shared<string>(boost::any_cast<string>(m["Invoker"]));
    }
    if (m.find("TaskExtraData") != m.end() && !m["TaskExtraData"].empty()) {
      taskExtraData = make_shared<string>(boost::any_cast<string>(m["TaskExtraData"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Pk") != m.end() && !m["Pk"].empty()) {
      pk = make_shared<string>(boost::any_cast<string>(m["Pk"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
  }


  virtual ~CheckResourceResponseBody() = default;
};
class CheckResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckResourceResponseBody> body{};

  CheckResourceResponse() {}

  explicit CheckResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckResourceResponseBody>(model1);
      }
    }
  }


  virtual ~CheckResourceResponse() = default;
};
class ListTerrorismPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> state{};
  shared_ptr<string> ownerAccount{};

  ListTerrorismPipelineRequest() {}

  explicit ListTerrorismPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListTerrorismPipelineRequest() = default;
};
class ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class ListTerrorismPipelineResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListTerrorismPipelineResponseBodyPipelineListPipeline() {}

  explicit ListTerrorismPipelineResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListTerrorismPipelineResponseBodyPipelineListPipeline() = default;
};
class ListTerrorismPipelineResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<ListTerrorismPipelineResponseBodyPipelineListPipeline>> pipeline{};

  ListTerrorismPipelineResponseBodyPipelineList() {}

  explicit ListTerrorismPipelineResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<ListTerrorismPipelineResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTerrorismPipelineResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<ListTerrorismPipelineResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~ListTerrorismPipelineResponseBodyPipelineList() = default;
};
class ListTerrorismPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<ListTerrorismPipelineResponseBodyPipelineList> pipelineList{};

  ListTerrorismPipelineResponseBody() {}

  explicit ListTerrorismPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        ListTerrorismPipelineResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<ListTerrorismPipelineResponseBodyPipelineList>(model1);
      }
    }
  }


  virtual ~ListTerrorismPipelineResponseBody() = default;
};
class ListTerrorismPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTerrorismPipelineResponseBody> body{};

  ListTerrorismPipelineResponse() {}

  explicit ListTerrorismPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTerrorismPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTerrorismPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~ListTerrorismPipelineResponse() = default;
};
class ReportTerrorismJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> label{};
  shared_ptr<string> detail{};
  shared_ptr<string> ownerAccount{};

  ReportTerrorismJobResultRequest() {}

  explicit ReportTerrorismJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportTerrorismJobResultRequest() = default;
};
class ReportTerrorismJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportTerrorismJobResultResponseBody() {}

  explicit ReportTerrorismJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportTerrorismJobResultResponseBody() = default;
};
class ReportTerrorismJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportTerrorismJobResultResponseBody> body{};

  ReportTerrorismJobResultResponse() {}

  explicit ReportTerrorismJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportTerrorismJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportTerrorismJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportTerrorismJobResultResponse() = default;
};
class ListAllMediaBucketRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};

  ListAllMediaBucketRequest() {}

  explicit ListAllMediaBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
  }


  virtual ~ListAllMediaBucketRequest() = default;
};
class ListAllMediaBucketResponseBodyMediaBucketListMediaBucket : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> bucket{};

  ListAllMediaBucketResponseBodyMediaBucketListMediaBucket() {}

  explicit ListAllMediaBucketResponseBodyMediaBucketListMediaBucket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~ListAllMediaBucketResponseBodyMediaBucketListMediaBucket() = default;
};
class ListAllMediaBucketResponseBodyMediaBucketList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket>> mediaBucket{};

  ListAllMediaBucketResponseBodyMediaBucketList() {}

  explicit ListAllMediaBucketResponseBodyMediaBucketList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaBucket) {
      vector<boost::any> temp1;
      for(auto item1:*mediaBucket){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaBucket"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaBucket") != m.end() && !m["MediaBucket"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaBucket"].type()) {
        vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaBucket"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllMediaBucketResponseBodyMediaBucketListMediaBucket model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaBucket = make_shared<vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket>>(expect1);
      }
    }
  }


  virtual ~ListAllMediaBucketResponseBodyMediaBucketList() = default;
};
class ListAllMediaBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<ListAllMediaBucketResponseBodyMediaBucketList> mediaBucketList{};

  ListAllMediaBucketResponseBody() {}

  explicit ListAllMediaBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (mediaBucketList) {
      res["MediaBucketList"] = mediaBucketList ? boost::any(mediaBucketList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MediaBucketList") != m.end() && !m["MediaBucketList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBucketList"].type()) {
        ListAllMediaBucketResponseBodyMediaBucketList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBucketList"]));
        mediaBucketList = make_shared<ListAllMediaBucketResponseBodyMediaBucketList>(model1);
      }
    }
  }


  virtual ~ListAllMediaBucketResponseBody() = default;
};
class ListAllMediaBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAllMediaBucketResponseBody> body{};

  ListAllMediaBucketResponse() {}

  explicit ListAllMediaBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllMediaBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllMediaBucketResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllMediaBucketResponse() = default;
};
class SearchPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> state{};
  shared_ptr<string> ownerAccount{};

  SearchPipelineRequest() {}

  explicit SearchPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SearchPipelineRequest() = default;
};
class SearchPipelineResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> mqTopic{};
  shared_ptr<string> queueName{};
  shared_ptr<string> mqTag{};
  shared_ptr<string> topic{};

  SearchPipelineResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit SearchPipelineResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mqTopic) {
      res["MqTopic"] = boost::any(*mqTopic);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (mqTag) {
      res["MqTag"] = boost::any(*mqTag);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MqTopic") != m.end() && !m["MqTopic"].empty()) {
      mqTopic = make_shared<string>(boost::any_cast<string>(m["MqTopic"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("MqTag") != m.end() && !m["MqTag"].empty()) {
      mqTag = make_shared<string>(boost::any_cast<string>(m["MqTag"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class SearchPipelineResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> speed{};
  shared_ptr<string> state{};
  shared_ptr<long> speedLevel{};
  shared_ptr<SearchPipelineResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<long> quotaAllocate{};

  SearchPipelineResponseBodyPipelineListPipeline() {}

  explicit SearchPipelineResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (quotaAllocate) {
      res["QuotaAllocate"] = boost::any(*quotaAllocate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        SearchPipelineResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<SearchPipelineResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("QuotaAllocate") != m.end() && !m["QuotaAllocate"].empty()) {
      quotaAllocate = make_shared<long>(boost::any_cast<long>(m["QuotaAllocate"]));
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineListPipeline() = default;
};
class SearchPipelineResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchPipelineResponseBodyPipelineListPipeline>> pipeline{};

  SearchPipelineResponseBodyPipelineList() {}

  explicit SearchPipelineResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<SearchPipelineResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchPipelineResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<SearchPipelineResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineList() = default;
};
class SearchPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<SearchPipelineResponseBodyPipelineList> pipelineList{};

  SearchPipelineResponseBody() {}

  explicit SearchPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        SearchPipelineResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<SearchPipelineResponseBodyPipelineList>(model1);
      }
    }
  }


  virtual ~SearchPipelineResponseBody() = default;
};
class SearchPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SearchPipelineResponseBody> body{};

  SearchPipelineResponse() {}

  explicit SearchPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~SearchPipelineResponse() = default;
};
class UnbindOutputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};

  UnbindOutputBucketRequest() {}

  explicit UnbindOutputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UnbindOutputBucketRequest() = default;
};
class UnbindOutputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindOutputBucketResponseBody() {}

  explicit UnbindOutputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindOutputBucketResponseBody() = default;
};
class UnbindOutputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindOutputBucketResponseBody> body{};

  UnbindOutputBucketResponse() {}

  explicit UnbindOutputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindOutputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindOutputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindOutputBucketResponse() = default;
};
class UpdateMediaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> ownerAccount{};

  UpdateMediaCategoryRequest() {}

  explicit UpdateMediaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateMediaCategoryRequest() = default;
};
class UpdateMediaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaCategoryResponseBody() {}

  explicit UpdateMediaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaCategoryResponseBody() = default;
};
class UpdateMediaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMediaCategoryResponseBody> body{};

  UpdateMediaCategoryResponse() {}

  explicit UpdateMediaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaCategoryResponse() = default;
};
class QueryComplexJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryComplexJobListRequest() {}

  explicit QueryComplexJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryComplexJobListRequest() = default;
};
class QueryComplexJobListResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryComplexJobListResponseBodyNonExistJobIds() {}

  explicit QueryComplexJobListResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryComplexJobListResponseBodyNonExistJobIds() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> duration{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> id{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> referPos{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> dy{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark>> waterMark{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> sizeSupport{};
  shared_ptr<bool> md5Support{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS> TS{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> level{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume> volume{};
  shared_ptr<string> bitrate{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> duration{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge>> merge{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> alpha{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile> inputFile{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> seek{};
  shared_ptr<string> duration{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan> timeSpan{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif> gif{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment> segment{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList> subtitleList{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> sar{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> height{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> width{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams> streams{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties() = default;
};
class QueryComplexJobListResponseBodyJobListJobTranscodeOutput : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo> video{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig> transConfig{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption> encryption{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList> waterMarkList{};
  shared_ptr<string> deWatermark{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> priority{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList> mergeList{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso> superReso{};
  shared_ptr<string> userData{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark> digiWaterMark{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile> outputFile{};
  shared_ptr<string> rotate{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer> container{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip> clip{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig> muxConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties> properties{};

  QueryComplexJobListResponseBodyJobListJobTranscodeOutput() {}

  explicit QueryComplexJobListResponseBodyJobListJobTranscodeOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption>(model1);
      }
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer>(model1);
      }
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobTranscodeOutput() = default;
};
class QueryComplexJobListResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QueryComplexJobListResponseBodyJobListJobMNSMessageResult() {}

  explicit QueryComplexJobListResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobMNSMessageResult() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> t{};
  shared_ptr<string> l{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (t) {
      res["T"] = boost::any(*t);
    }
    if (l) {
      res["L"] = boost::any(*l);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
    if (m.find("L") != m.end() && !m["L"].empty()) {
      l = make_shared<string>(boost::any_cast<string>(m["L"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo> clipsConfigVideo{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfigVideo) {
      res["ClipsConfigVideo"] = clipsConfigVideo ? boost::any(clipsConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfigVideo") != m.end() && !m["ClipsConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfigVideo"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfigVideo"]));
        clipsConfigVideo = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig> clipsConfig{};
  shared_ptr<string> out{};
  shared_ptr<string> in{};
  shared_ptr<string> clipID{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfig) {
      res["ClipsConfig"] = clipsConfig ? boost::any(clipsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (clipID) {
      res["clipID"] = boost::any(*clipID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfig") != m.end() && !m["ClipsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfig"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfig"]));
        clipsConfig = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig>(model1);
      }
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("clipID") != m.end() && !m["clipID"].empty()) {
      clipID = make_shared<string>(boost::any_cast<string>(m["clipID"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip>> clip{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> order{};
  shared_ptr<string> id{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips> clips{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clips) {
      res["Clips"] = clips ? boost::any(clips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clips"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clips"]));
        clips = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack>> track{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (track) {
      vector<boost::any> temp1;
      for(auto item1:*track){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Track"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Track") != m.end() && !m["Track"].empty()) {
      if (typeid(vector<boost::any>) == m["Track"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Track"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        track = make_shared<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> channelLayout{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> channels{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> width{};
  shared_ptr<string> renderRatio{};
  shared_ptr<string> isGpuData{};
  shared_ptr<string> height{};
  shared_ptr<string> isOneTrackData{};
  shared_ptr<string> fps{};
  shared_ptr<string> reclosePrec{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (renderRatio) {
      res["RenderRatio"] = boost::any(*renderRatio);
    }
    if (isGpuData) {
      res["IsGpuData"] = boost::any(*isGpuData);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isOneTrackData) {
      res["IsOneTrackData"] = boost::any(*isOneTrackData);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (reclosePrec) {
      res["ReclosePrec"] = boost::any(*reclosePrec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("RenderRatio") != m.end() && !m["RenderRatio"].empty()) {
      renderRatio = make_shared<string>(boost::any_cast<string>(m["RenderRatio"]));
    }
    if (m.find("IsGpuData") != m.end() && !m["IsGpuData"].empty()) {
      isGpuData = make_shared<string>(boost::any_cast<string>(m["IsGpuData"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsOneTrackData") != m.end() && !m["IsOneTrackData"].empty()) {
      isOneTrackData = make_shared<string>(boost::any_cast<string>(m["IsOneTrackData"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("ReclosePrec") != m.end() && !m["ReclosePrec"].empty()) {
      reclosePrec = make_shared<string>(boost::any_cast<string>(m["ReclosePrec"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio> timelineConfigAudio{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo> timelineConfigVideo{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timelineConfigAudio) {
      res["TimelineConfigAudio"] = timelineConfigAudio ? boost::any(timelineConfigAudio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfigVideo) {
      res["TimelineConfigVideo"] = timelineConfigVideo ? boost::any(timelineConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimelineConfigAudio") != m.end() && !m["TimelineConfigAudio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigAudio"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigAudio"]));
        timelineConfigAudio = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio>(model1);
      }
    }
    if (m.find("TimelineConfigVideo") != m.end() && !m["TimelineConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigVideo"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigVideo"]));
        timelineConfigVideo = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList> trackList{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig> timelineConfig{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trackList) {
      res["TrackList"] = trackList ? boost::any(trackList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfig) {
      res["TimelineConfig"] = timelineConfig ? boost::any(timelineConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrackList") != m.end() && !m["TrackList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrackList"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrackList"]));
        trackList = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList>(model1);
      }
    }
    if (m.find("TimelineConfig") != m.end() && !m["TimelineConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfig"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfig"]));
        timelineConfig = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> effectConfig{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (effectConfig) {
      res["EffectConfig"] = boost::any(*effectConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("EffectConfig") != m.end() && !m["EffectConfig"].empty()) {
      effectConfig = make_shared<string>(boost::any_cast<string>(m["EffectConfig"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect>> effect{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      vector<boost::any> temp1;
      for(auto item1:*effect){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Effect"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      if (typeid(vector<boost::any>) == m["Effect"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Effect"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effect = make_shared<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> sourceID{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects> effects{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceStrmMap{};
  shared_ptr<string> out{};
  shared_ptr<string> in{};
  shared_ptr<string> id{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (sourceID) {
      res["SourceID"] = boost::any(*sourceID);
    }
    if (effects) {
      res["Effects"] = effects ? boost::any(effects->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceStrmMap) {
      res["SourceStrmMap"] = boost::any(*sourceStrmMap);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SourceID") != m.end() && !m["SourceID"].empty()) {
      sourceID = make_shared<string>(boost::any_cast<string>(m["SourceID"]));
    }
    if (m.find("Effects") != m.end() && !m["Effects"].empty()) {
      if (typeid(map<string, boost::any>) == m["Effects"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Effects"]));
        effects = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects>(model1);
      }
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceStrmMap") != m.end() && !m["SourceStrmMap"].empty()) {
      sourceStrmMap = make_shared<string>(boost::any_cast<string>(m["SourceStrmMap"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip>> clip{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline> timeline{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList> clipList{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clipList) {
      res["ClipList"] = clipList ? boost::any(clipList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline>(model1);
      }
    }
    if (m.find("ClipList") != m.end() && !m["ClipList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipList"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipList"]));
        clipList = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing> editing{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editing) {
      res["Editing"] = editing ? boost::any(editing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Editing") != m.end() && !m["Editing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Editing"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Editing"]));
        editing = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs() = default;
};
class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs>> complexEditingConfigs{};

  QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs() {}

  explicit QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complexEditingConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*complexEditingConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComplexEditingConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplexEditingConfigs") != m.end() && !m["ComplexEditingConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ComplexEditingConfigs"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComplexEditingConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        complexEditingConfigs = make_shared<vector<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs() = default;
};
class QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile() {}

  explicit QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile() = default;
};
class QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> isNormalSar{};
  shared_ptr<string> deinterlaceMethod{};

  QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig() {}

  explicit QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isNormalSar) {
      res["IsNormalSar"] = boost::any(*isNormalSar);
    }
    if (deinterlaceMethod) {
      res["DeinterlaceMethod"] = boost::any(*deinterlaceMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsNormalSar") != m.end() && !m["IsNormalSar"].empty()) {
      isNormalSar = make_shared<string>(boost::any_cast<string>(m["IsNormalSar"]));
    }
    if (m.find("DeinterlaceMethod") != m.end() && !m["DeinterlaceMethod"].empty()) {
      deinterlaceMethod = make_shared<string>(boost::any_cast<string>(m["DeinterlaceMethod"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig() = default;
};
class QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile> inputFile{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig> inputConfig{};
  shared_ptr<string> id{};

  QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput() {}

  explicit QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile>(model1);
      }
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput() = default;
};
class QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput>> editingInput{};

  QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs() {}

  explicit QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInput) {
      vector<boost::any> temp1;
      for(auto item1:*editingInput){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EditingInput"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInput") != m.end() && !m["EditingInput"].empty()) {
      if (typeid(vector<boost::any>) == m["EditingInput"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EditingInput"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        editingInput = make_shared<vector<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs() = default;
};
class QueryComplexJobListResponseBodyJobListJobInputsInputs : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs> editingInputs{};

  QueryComplexJobListResponseBodyJobListJobInputsInputs() {}

  explicit QueryComplexJobListResponseBodyJobListJobInputsInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInputs) {
      res["EditingInputs"] = editingInputs ? boost::any(editingInputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInputs") != m.end() && !m["EditingInputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingInputs"].type()) {
        QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingInputs"]));
        editingInputs = make_shared<QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobInputsInputs() = default;
};
class QueryComplexJobListResponseBodyJobListJobInputs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJobInputsInputs>> inputs{};

  QueryComplexJobListResponseBodyJobListJobInputs() {}

  explicit QueryComplexJobListResponseBodyJobListJobInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJobInputsInputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJobInputsInputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<QueryComplexJobListResponseBodyJobListJobInputsInputs>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJobInputs() = default;
};
class QueryComplexJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobTranscodeOutput> transcodeOutput{};
  shared_ptr<string> message{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs> complexEditingConfigs{};
  shared_ptr<QueryComplexJobListResponseBodyJobListJobInputs> inputs{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> pipelineId{};

  QueryComplexJobListResponseBodyJobListJob() {}

  explicit QueryComplexJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transcodeOutput) {
      res["transcodeOutput"] = transcodeOutput ? boost::any(transcodeOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (complexEditingConfigs) {
      res["ComplexEditingConfigs"] = complexEditingConfigs ? boost::any(complexEditingConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("transcodeOutput") != m.end() && !m["transcodeOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["transcodeOutput"].type()) {
        QueryComplexJobListResponseBodyJobListJobTranscodeOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transcodeOutput"]));
        transcodeOutput = make_shared<QueryComplexJobListResponseBodyJobListJobTranscodeOutput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryComplexJobListResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryComplexJobListResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
    if (m.find("ComplexEditingConfigs") != m.end() && !m["ComplexEditingConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplexEditingConfigs"].type()) {
        QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplexEditingConfigs"]));
        complexEditingConfigs = make_shared<QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs>(model1);
      }
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        QueryComplexJobListResponseBodyJobListJobInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<QueryComplexJobListResponseBodyJobListJobInputs>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobListJob() = default;
};
class QueryComplexJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryComplexJobListResponseBodyJobListJob>> job{};

  QueryComplexJobListResponseBodyJobList() {}

  explicit QueryComplexJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryComplexJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryComplexJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryComplexJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBodyJobList() = default;
};
class QueryComplexJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryComplexJobListResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryComplexJobListResponseBodyJobList> jobList{};

  QueryComplexJobListResponseBody() {}

  explicit QueryComplexJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QueryComplexJobListResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QueryComplexJobListResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryComplexJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryComplexJobListResponseBodyJobList>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponseBody() = default;
};
class QueryComplexJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryComplexJobListResponseBody> body{};

  QueryComplexJobListResponse() {}

  explicit QueryComplexJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryComplexJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryComplexJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryComplexJobListResponse() = default;
};
class ListInferenceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> serverName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> maxPageSize{};

  ListInferenceJobRequest() {}

  explicit ListInferenceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverName) {
      res["ServerName"] = boost::any(*serverName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (maxPageSize) {
      res["MaxPageSize"] = boost::any(*maxPageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerName") != m.end() && !m["ServerName"].empty()) {
      serverName = make_shared<string>(boost::any_cast<string>(m["ServerName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("MaxPageSize") != m.end() && !m["MaxPageSize"].empty()) {
      maxPageSize = make_shared<long>(boost::any_cast<long>(m["MaxPageSize"]));
    }
  }


  virtual ~ListInferenceJobRequest() = default;
};
class ListInferenceJobResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> result{};
  shared_ptr<string> jobId{};
  shared_ptr<long> userId{};
  shared_ptr<string> message{};
  shared_ptr<long> jobTime{};
  shared_ptr<string> jobParams{};

  ListInferenceJobResponseBodyJobs() {}

  explicit ListInferenceJobResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (jobTime) {
      res["JobTime"] = boost::any(*jobTime);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("JobTime") != m.end() && !m["JobTime"].empty()) {
      jobTime = make_shared<long>(boost::any_cast<long>(m["JobTime"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
  }


  virtual ~ListInferenceJobResponseBodyJobs() = default;
};
class ListInferenceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListInferenceJobResponseBodyJobs>> jobs{};
  shared_ptr<string> code{};
  shared_ptr<long> totalSize{};

  ListInferenceJobResponseBody() {}

  explicit ListInferenceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListInferenceJobResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInferenceJobResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListInferenceJobResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListInferenceJobResponseBody() = default;
};
class ListInferenceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListInferenceJobResponseBody> body{};

  ListInferenceJobResponse() {}

  explicit ListInferenceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInferenceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInferenceJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListInferenceJobResponse() = default;
};
class QueryJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryJobListRequest() {}

  explicit QueryJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryJobListRequest() = default;
};
class QueryJobListResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryJobListResponseBodyNonExistJobIds() {}

  explicit QueryJobListResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryJobListResponseBodyNonExistJobIds() = default;
};
class QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd() {}

  explicit QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd() = default;
};
class QueryJobListResponseBodyJobListJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> resoPriority{};

  QueryJobListResponseBodyJobListJobOutputVideo() {}

  explicit QueryJobListResponseBodyJobListJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputVideo() = default;
};
class QueryJobListResponseBodyJobListJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  QueryJobListResponseBodyJobListJobOutputTransConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTransConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> id{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};

  QueryJobListResponseBodyJobListJobOutputEncryption() {}

  explicit QueryJobListResponseBodyJobListJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputEncryption() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> referPos{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> dy{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark>> waterMark{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkList() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkList() = default;
};
class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> sizeSupport{};
  shared_ptr<bool> md5Support{};

  QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS() {}

  explicit QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS() = default;
};
class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS> TS{};

  QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport() {}

  explicit QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport() = default;
};
class QueryJobListResponseBodyJobListJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> level{};

  QueryJobListResponseBodyJobListJobOutputAudioVolume() {}

  explicit QueryJobListResponseBodyJobListJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputAudioVolume() = default;
};
class QueryJobListResponseBodyJobListJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputAudioVolume> volume{};
  shared_ptr<string> bitrate{};

  QueryJobListResponseBodyJobListJobOutputAudio() {}

  explicit QueryJobListResponseBodyJobListJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        QueryJobListResponseBodyJobListJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<QueryJobListResponseBodyJobListJobOutputAudioVolume>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputAudio() = default;
};
class QueryJobListResponseBodyJobListJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> duration{};

  QueryJobListResponseBodyJobListJobOutputMergeListMerge() {}

  explicit QueryJobListResponseBodyJobListJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMergeListMerge() = default;
};
class QueryJobListResponseBodyJobListJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge>> merge{};

  QueryJobListResponseBodyJobListJobOutputMergeList() {}

  explicit QueryJobListResponseBodyJobListJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMergeList() = default;
};
class QueryJobListResponseBodyJobListJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  QueryJobListResponseBodyJobListJobOutputSuperReso() {}

  explicit QueryJobListResponseBodyJobListJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSuperReso() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryJobListResponseBodyJobListJobOutputOutputFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutputFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryJobListResponseBodyJobListJobOutputContainer() {}

  explicit QueryJobListResponseBodyJobListJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputContainer() = default;
};
class QueryJobListResponseBodyJobListJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> seek{};
  shared_ptr<string> duration{};

  QueryJobListResponseBodyJobListJobOutputClipTimeSpan() {}

  explicit QueryJobListResponseBodyJobListJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputClipTimeSpan() = default;
};
class QueryJobListResponseBodyJobListJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputClipTimeSpan> timeSpan{};

  QueryJobListResponseBodyJobListJobOutputClip() {}

  explicit QueryJobListResponseBodyJobListJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        QueryJobListResponseBodyJobListJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<QueryJobListResponseBodyJobListJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputClip() = default;
};
class QueryJobListResponseBodyJobListJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> openUrl{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};

  QueryJobListResponseBodyJobListJobOutputOpeningListOpening() {}

  explicit QueryJobListResponseBodyJobListJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOpeningListOpening() = default;
};
class QueryJobListResponseBodyJobListJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening>> opening{};

  QueryJobListResponseBodyJobListJobOutputOpeningList() {}

  explicit QueryJobListResponseBodyJobListJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOpeningList() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigWebp() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigWebp() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigGif() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigGif() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigSegment() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigSegment() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigWebp> webp{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigGif> gif{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigSegment> segment{};

  QueryJobListResponseBodyJobListJobOutputMuxConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigWebp>(model1);
      }
    }
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> bgColor{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> tailUrl{};

  QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate() {}

  explicit QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate() = default;
};
class QueryJobListResponseBodyJobListJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate>> tailSlate{};

  QueryJobListResponseBodyJobListJobOutputTailSlateList() {}

  explicit QueryJobListResponseBodyJobListJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTailSlateList() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList> subtitleList{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo : public Darabonba::Model {
public:
  shared_ptr<string> source{};

  QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo>> sourceLogo{};

  QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceLogo) {
      vector<boost::any> temp1;
      for(auto item1:*sourceLogo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceLogo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceLogo") != m.end() && !m["SourceLogo"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceLogo"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceLogo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceLogo = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> sar{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> height{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> width{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreams() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreams() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  QueryJobListResponseBodyJobListJobOutputPropertiesFormat() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesFormat() = default;
};
class QueryJobListResponseBodyJobListJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos> sourceLogos{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreams> streams{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  QueryJobListResponseBodyJobListJobOutputProperties() {}

  explicit QueryJobListResponseBodyJobListJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (sourceLogos) {
      res["SourceLogos"] = sourceLogos ? boost::any(sourceLogos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("SourceLogos") != m.end() && !m["SourceLogos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceLogos"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceLogos"]));
        sourceLogos = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputProperties() = default;
};
class QueryJobListResponseBodyJobListJobOutput : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputVideo> video{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputTransConfig> transConfig{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputEncryption> encryption{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputWaterMarkList> waterMarkList{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<string> deWatermark{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> priority{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMergeList> mergeList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSuperReso> superReso{};
  shared_ptr<string> userData{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutputFile> outputFile{};
  shared_ptr<string> rotate{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputContainer> container{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputClip> clip{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOpeningList> openingList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfig> muxConfig{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputProperties> properties{};

  QueryJobListResponseBodyJobListJobOutput() {}

  explicit QueryJobListResponseBodyJobListJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryJobListResponseBodyJobListJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryJobListResponseBodyJobListJobOutputVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryJobListResponseBodyJobListJobOutputTransConfig>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        QueryJobListResponseBodyJobListJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<QueryJobListResponseBodyJobListJobOutputEncryption>(model1);
      }
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        QueryJobListResponseBodyJobListJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<QueryJobListResponseBodyJobListJobOutputWaterMarkList>(model1);
      }
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryJobListResponseBodyJobListJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryJobListResponseBodyJobListJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        QueryJobListResponseBodyJobListJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<QueryJobListResponseBodyJobListJobOutputMergeList>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        QueryJobListResponseBodyJobListJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<QueryJobListResponseBodyJobListJobOutputSuperReso>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryJobListResponseBodyJobListJobOutputOutputFile>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryJobListResponseBodyJobListJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryJobListResponseBodyJobListJobOutputContainer>(model1);
      }
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        QueryJobListResponseBodyJobListJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<QueryJobListResponseBodyJobListJobOutputClip>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        QueryJobListResponseBodyJobListJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<QueryJobListResponseBodyJobListJobOutputOpeningList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        QueryJobListResponseBodyJobListJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<QueryJobListResponseBodyJobListJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryJobListResponseBodyJobListJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryJobListResponseBodyJobListJobOutputProperties>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutput() = default;
};
class QueryJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryJobListResponseBodyJobListJobInput() {}

  explicit QueryJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobInput() = default;
};
class QueryJobListResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QueryJobListResponseBodyJobListJobMNSMessageResult() {}

  explicit QueryJobListResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobMNSMessageResult() = default;
};
class QueryJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryJobListResponseBodyJobListJobInput> input{};
  shared_ptr<QueryJobListResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};

  QueryJobListResponseBodyJobListJob() {}

  explicit QueryJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        QueryJobListResponseBodyJobListJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<QueryJobListResponseBodyJobListJobOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryJobListResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryJobListResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJob() = default;
};
class QueryJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJob>> job{};

  QueryJobListResponseBodyJobList() {}

  explicit QueryJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobList() = default;
};
class QueryJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryJobListResponseBodyJobList> jobList{};

  QueryJobListResponseBody() {}

  explicit QueryJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QueryJobListResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QueryJobListResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryJobListResponseBodyJobList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBody() = default;
};
class QueryJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryJobListResponseBody> body{};

  QueryJobListResponse() {}

  explicit QueryJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobListResponse() = default;
};
class SearchMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> stateList{};
  shared_ptr<string> ownerAccount{};

  SearchMediaWorkflowRequest() {}

  explicit SearchMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (stateList) {
      res["StateList"] = boost::any(*stateList);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("StateList") != m.end() && !m["StateList"].empty()) {
      stateList = make_shared<string>(boost::any_cast<string>(m["StateList"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SearchMediaWorkflowRequest() = default;
};
class SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<string> triggerMode{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};

  SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow() {}

  explicit SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow() = default;
};
class SearchMediaWorkflowResponseBodyMediaWorkflowList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow>> mediaWorkflow{};

  SearchMediaWorkflowResponseBodyMediaWorkflowList() {}

  explicit SearchMediaWorkflowResponseBodyMediaWorkflowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflow"].type()) {
        vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflow = make_shared<vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow>>(expect1);
      }
    }
  }


  virtual ~SearchMediaWorkflowResponseBodyMediaWorkflowList() = default;
};
class SearchMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<SearchMediaWorkflowResponseBodyMediaWorkflowList> mediaWorkflowList{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};

  SearchMediaWorkflowResponseBody() {}

  explicit SearchMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (mediaWorkflowList) {
      res["MediaWorkflowList"] = mediaWorkflowList ? boost::any(mediaWorkflowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MediaWorkflowList") != m.end() && !m["MediaWorkflowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowList"].type()) {
        SearchMediaWorkflowResponseBodyMediaWorkflowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowList"]));
        mediaWorkflowList = make_shared<SearchMediaWorkflowResponseBodyMediaWorkflowList>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~SearchMediaWorkflowResponseBody() = default;
};
class SearchMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SearchMediaWorkflowResponseBody> body{};

  SearchMediaWorkflowResponse() {}

  explicit SearchMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaWorkflowResponse() = default;
};
class QueryCoverPipelineListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineIds{};
  shared_ptr<string> ownerAccount{};

  QueryCoverPipelineListRequest() {}

  explicit QueryCoverPipelineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineIds) {
      res["PipelineIds"] = boost::any(*pipelineIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineIds") != m.end() && !m["PipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["PipelineIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryCoverPipelineListRequest() = default;
};
class QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class QueryCoverPipelineListResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  QueryCoverPipelineListResponseBodyPipelineListPipeline() {}

  explicit QueryCoverPipelineListResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryCoverPipelineListResponseBodyPipelineListPipeline() = default;
};
class QueryCoverPipelineListResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCoverPipelineListResponseBodyPipelineListPipeline>> pipeline{};

  QueryCoverPipelineListResponseBodyPipelineList() {}

  explicit QueryCoverPipelineListResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<QueryCoverPipelineListResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCoverPipelineListResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<QueryCoverPipelineListResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~QueryCoverPipelineListResponseBodyPipelineList() = default;
};
class QueryCoverPipelineListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryCoverPipelineListResponseBodyNonExistIds() {}

  explicit QueryCoverPipelineListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryCoverPipelineListResponseBodyNonExistIds() = default;
};
class QueryCoverPipelineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryCoverPipelineListResponseBodyPipelineList> pipelineList{};
  shared_ptr<QueryCoverPipelineListResponseBodyNonExistIds> nonExistIds{};

  QueryCoverPipelineListResponseBody() {}

  explicit QueryCoverPipelineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        QueryCoverPipelineListResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<QueryCoverPipelineListResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryCoverPipelineListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryCoverPipelineListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryCoverPipelineListResponseBody() = default;
};
class QueryCoverPipelineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryCoverPipelineListResponseBody> body{};

  QueryCoverPipelineListResponse() {}

  explicit QueryCoverPipelineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCoverPipelineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCoverPipelineListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCoverPipelineListResponse() = default;
};
class QueryFpShotJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> state{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> primaryKeyList{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  QueryFpShotJobListRequest() {}

  explicit QueryFpShotJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (primaryKeyList) {
      res["PrimaryKeyList"] = boost::any(*primaryKeyList);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("PrimaryKeyList") != m.end() && !m["PrimaryKeyList"].empty()) {
      primaryKeyList = make_shared<string>(boost::any_cast<string>(m["PrimaryKeyList"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryFpShotJobListRequest() = default;
};
class QueryFpShotJobListResponseBodyNonExistPrimaryKeys : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFpShotJobListResponseBodyNonExistPrimaryKeys() {}

  explicit QueryFpShotJobListResponseBodyNonExistPrimaryKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFpShotJobListResponseBodyNonExistPrimaryKeys() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> duration{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> duration{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication> duplication{};
  shared_ptr<string> similarity{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput> input{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duplication) {
      res["Duplication"] = duplication ? boost::any(duplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duplication") != m.end() && !m["Duplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["Duplication"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Duplication"]));
        duplication = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication>(model1);
      }
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput>(model1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice>> fpShotSlice{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotSlice) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotSlice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotSlice"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotSlice") != m.end() && !m["FpShotSlice"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotSlice"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotSlice"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotSlice = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot : public Darabonba::Model {
public:
  shared_ptr<string> primaryKey{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices> fpShotSlices{};
  shared_ptr<string> similarity{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (fpShotSlices) {
      res["FpShotSlices"] = fpShotSlices ? boost::any(fpShotSlices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("FpShotSlices") != m.end() && !m["FpShotSlices"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotSlices"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotSlices"]));
        fpShotSlices = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices>(model1);
      }
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot>> fpShot{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShot) {
      vector<boost::any> temp1;
      for(auto item1:*fpShot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShot") != m.end() && !m["FpShot"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShot"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShot = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> duration{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> duration{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication> duplication{};
  shared_ptr<string> similarity{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput> input{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duplication) {
      res["Duplication"] = duplication ? boost::any(duplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duplication") != m.end() && !m["Duplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["Duplication"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Duplication"]));
        duplication = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication>(model1);
      }
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput>(model1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice>> fpShotSlice{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotSlice) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotSlice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotSlice"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotSlice") != m.end() && !m["FpShotSlice"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotSlice"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotSlice"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotSlice = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot : public Darabonba::Model {
public:
  shared_ptr<string> primaryKey{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices> fpShotSlices{};
  shared_ptr<string> similarity{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (fpShotSlices) {
      res["FpShotSlices"] = fpShotSlices ? boost::any(fpShotSlices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("FpShotSlices") != m.end() && !m["FpShotSlices"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotSlices"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotSlices"]));
        fpShotSlices = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices>(model1);
      }
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot>> fpShot{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShot) {
      vector<boost::any> temp1;
      for(auto item1:*fpShot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShot") != m.end() && !m["FpShot"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShot"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShot = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots> audioFpShots{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots> fpShots{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFpShots) {
      res["AudioFpShots"] = audioFpShots ? boost::any(audioFpShots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fpShots) {
      res["FpShots"] = fpShots ? boost::any(fpShots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFpShots") != m.end() && !m["AudioFpShots"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioFpShots"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioFpShots"]));
        audioFpShots = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots>(model1);
      }
    }
    if (m.find("FpShots") != m.end() && !m["FpShots"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShots"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShots"]));
        fpShots = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots>(model1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig : public Darabonba::Model {
public:
  shared_ptr<string> primaryKey{};
  shared_ptr<string> saveType{};
  shared_ptr<string> notary{};
  shared_ptr<string> fpDBId{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    if (notary) {
      res["Notary"] = boost::any(*notary);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
    if (m.find("Notary") != m.end() && !m["Notary"].empty()) {
      notary = make_shared<string>(boost::any_cast<string>(m["Notary"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJob : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult> fpShotResult{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<string> message{};
  shared_ptr<string> txHash{};
  shared_ptr<string> transactionId{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig> fpShotConfig{};
  shared_ptr<string> fileId{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile> inputFile{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> id{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJob() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotResult) {
      res["FpShotResult"] = fpShotResult ? boost::any(fpShotResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (txHash) {
      res["TxHash"] = boost::any(*txHash);
    }
    if (transactionId) {
      res["TransactionId"] = boost::any(*transactionId);
    }
    if (fpShotConfig) {
      res["FpShotConfig"] = fpShotConfig ? boost::any(fpShotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotResult") != m.end() && !m["FpShotResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotResult"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotResult"]));
        fpShotResult = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("TxHash") != m.end() && !m["TxHash"].empty()) {
      txHash = make_shared<string>(boost::any_cast<string>(m["TxHash"]));
    }
    if (m.find("TransactionId") != m.end() && !m["TransactionId"].empty()) {
      transactionId = make_shared<string>(boost::any_cast<string>(m["TransactionId"]));
    }
    if (m.find("FpShotConfig") != m.end() && !m["FpShotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotConfig"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotConfig"]));
        fpShotConfig = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig>(model1);
      }
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJob() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJob>> fpShotJob{};

  QueryFpShotJobListResponseBodyFpShotJobList() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotJob) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotJob") != m.end() && !m["FpShotJob"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotJob"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotJob = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJob>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobList() = default;
};
class QueryFpShotJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFpShotJobListResponseBodyNonExistIds() {}

  explicit QueryFpShotJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFpShotJobListResponseBodyNonExistIds() = default;
};
class QueryFpShotJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryFpShotJobListResponseBodyNonExistPrimaryKeys> nonExistPrimaryKeys{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobList> fpShotJobList{};
  shared_ptr<QueryFpShotJobListResponseBodyNonExistIds> nonExistIds{};

  QueryFpShotJobListResponseBody() {}

  explicit QueryFpShotJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistPrimaryKeys) {
      res["NonExistPrimaryKeys"] = nonExistPrimaryKeys ? boost::any(nonExistPrimaryKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fpShotJobList) {
      res["FpShotJobList"] = fpShotJobList ? boost::any(fpShotJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistPrimaryKeys") != m.end() && !m["NonExistPrimaryKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistPrimaryKeys"].type()) {
        QueryFpShotJobListResponseBodyNonExistPrimaryKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistPrimaryKeys"]));
        nonExistPrimaryKeys = make_shared<QueryFpShotJobListResponseBodyNonExistPrimaryKeys>(model1);
      }
    }
    if (m.find("FpShotJobList") != m.end() && !m["FpShotJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotJobList"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotJobList"]));
        fpShotJobList = make_shared<QueryFpShotJobListResponseBodyFpShotJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryFpShotJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryFpShotJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBody() = default;
};
class QueryFpShotJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryFpShotJobListResponseBody> body{};

  QueryFpShotJobListResponse() {}

  explicit QueryFpShotJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFpShotJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFpShotJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponse() = default;
};
class DeleteMediaTagRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> tag{};
  shared_ptr<string> ownerAccount{};

  DeleteMediaTagRequest() {}

  explicit DeleteMediaTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteMediaTagRequest() = default;
};
class DeleteMediaTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaTagResponseBody() {}

  explicit DeleteMediaTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaTagResponseBody() = default;
};
class DeleteMediaTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMediaTagResponseBody> body{};

  DeleteMediaTagResponse() {}

  explicit DeleteMediaTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaTagResponse() = default;
};
class DeletePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  DeletePipelineRequest() {}

  explicit DeletePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeletePipelineRequest() = default;
};
class DeletePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> pipelineId{};

  DeletePipelineResponseBody() {}

  explicit DeletePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~DeletePipelineResponseBody() = default;
};
class DeletePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeletePipelineResponseBody> body{};

  DeletePipelineResponse() {}

  explicit DeletePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelineResponse() = default;
};
class UpdateSmarttagTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> industry{};
  shared_ptr<string> scene{};
  shared_ptr<string> analyseTypes{};
  shared_ptr<string> faceCategoryIds{};
  shared_ptr<bool> isDefault{};

  UpdateSmarttagTemplateRequest() {}

  explicit UpdateSmarttagTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (analyseTypes) {
      res["AnalyseTypes"] = boost::any(*analyseTypes);
    }
    if (faceCategoryIds) {
      res["FaceCategoryIds"] = boost::any(*faceCategoryIds);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("AnalyseTypes") != m.end() && !m["AnalyseTypes"].empty()) {
      analyseTypes = make_shared<string>(boost::any_cast<string>(m["AnalyseTypes"]));
    }
    if (m.find("FaceCategoryIds") != m.end() && !m["FaceCategoryIds"].empty()) {
      faceCategoryIds = make_shared<string>(boost::any_cast<string>(m["FaceCategoryIds"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
  }


  virtual ~UpdateSmarttagTemplateRequest() = default;
};
class UpdateSmarttagTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSmarttagTemplateResponseBody() {}

  explicit UpdateSmarttagTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSmarttagTemplateResponseBody() = default;
};
class UpdateSmarttagTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSmarttagTemplateResponseBody> body{};

  UpdateSmarttagTemplateResponse() {}

  explicit UpdateSmarttagTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSmarttagTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSmarttagTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSmarttagTemplateResponse() = default;
};
class UpdateAsrPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};

  UpdateAsrPipelineRequest() {}

  explicit UpdateAsrPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateAsrPipelineRequest() = default;
};
class UpdateAsrPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  UpdateAsrPipelineResponseBodyPipelineNotifyConfig() {}

  explicit UpdateAsrPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~UpdateAsrPipelineResponseBodyPipelineNotifyConfig() = default;
};
class UpdateAsrPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<UpdateAsrPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  UpdateAsrPipelineResponseBodyPipeline() {}

  explicit UpdateAsrPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        UpdateAsrPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<UpdateAsrPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateAsrPipelineResponseBodyPipeline() = default;
};
class UpdateAsrPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateAsrPipelineResponseBodyPipeline> pipeline{};

  UpdateAsrPipelineResponseBody() {}

  explicit UpdateAsrPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        UpdateAsrPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<UpdateAsrPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~UpdateAsrPipelineResponseBody() = default;
};
class UpdateAsrPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateAsrPipelineResponseBody> body{};

  UpdateAsrPipelineResponse() {}

  explicit UpdateAsrPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAsrPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAsrPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAsrPipelineResponse() = default;
};
class QueryVideoQualityJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> userId{};
  shared_ptr<string> jobId{};

  QueryVideoQualityJobRequest() {}

  explicit QueryVideoQualityJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryVideoQualityJobRequest() = default;
};
class QueryVideoQualityJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> jobId{};
  shared_ptr<long> userId{};
  shared_ptr<string> videoQualityResults{};
  shared_ptr<string> message{};
  shared_ptr<string> output{};

  QueryVideoQualityJobResponseBodyJob() {}

  explicit QueryVideoQualityJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (videoQualityResults) {
      res["VideoQualityResults"] = boost::any(*videoQualityResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("VideoQualityResults") != m.end() && !m["VideoQualityResults"].empty()) {
      videoQualityResults = make_shared<string>(boost::any_cast<string>(m["VideoQualityResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~QueryVideoQualityJobResponseBodyJob() = default;
};
class QueryVideoQualityJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryVideoQualityJobResponseBodyJob> job{};
  shared_ptr<string> code{};

  QueryVideoQualityJobResponseBody() {}

  explicit QueryVideoQualityJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        QueryVideoQualityJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<QueryVideoQualityJobResponseBodyJob>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~QueryVideoQualityJobResponseBody() = default;
};
class QueryVideoQualityJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryVideoQualityJobResponseBody> body{};

  QueryVideoQualityJobResponse() {}

  explicit QueryVideoQualityJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryVideoQualityJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryVideoQualityJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryVideoQualityJobResponse() = default;
};
class DecryptKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ciphertextBlob{};
  shared_ptr<string> rand{};

  DecryptKeyRequest() {}

  explicit DecryptKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ciphertextBlob) {
      res["CiphertextBlob"] = boost::any(*ciphertextBlob);
    }
    if (rand) {
      res["Rand"] = boost::any(*rand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("CiphertextBlob") != m.end() && !m["CiphertextBlob"].empty()) {
      ciphertextBlob = make_shared<string>(boost::any_cast<string>(m["CiphertextBlob"]));
    }
    if (m.find("Rand") != m.end() && !m["Rand"].empty()) {
      rand = make_shared<string>(boost::any_cast<string>(m["Rand"]));
    }
  }


  virtual ~DecryptKeyRequest() = default;
};
class DecryptKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> rand{};
  shared_ptr<string> requestId{};
  shared_ptr<string> plaintext{};

  DecryptKeyResponseBody() {}

  explicit DecryptKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rand) {
      res["Rand"] = boost::any(*rand);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (plaintext) {
      res["Plaintext"] = boost::any(*plaintext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rand") != m.end() && !m["Rand"].empty()) {
      rand = make_shared<string>(boost::any_cast<string>(m["Rand"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Plaintext") != m.end() && !m["Plaintext"].empty()) {
      plaintext = make_shared<string>(boost::any_cast<string>(m["Plaintext"]));
    }
  }


  virtual ~DecryptKeyResponseBody() = default;
};
class DecryptKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DecryptKeyResponseBody> body{};

  DecryptKeyResponse() {}

  explicit DecryptKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DecryptKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DecryptKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DecryptKeyResponse() = default;
};
class DeleteTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> ownerAccount{};

  DeleteTemplateRequest() {}

  explicit DeleteTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteTemplateRequest() = default;
};
class DeleteTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  DeleteTemplateResponseBody() {}

  explicit DeleteTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteTemplateResponseBody() = default;
};
class DeleteTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTemplateResponseBody> body{};

  DeleteTemplateResponse() {}

  explicit DeleteTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTemplateResponse() = default;
};
class QueryTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateIds{};
  shared_ptr<string> ownerAccount{};

  QueryTemplateListRequest() {}

  explicit QueryTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryTemplateListRequest() = default;
};
class QueryTemplateListResponseBodyNonExistTids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryTemplateListResponseBodyNonExistTids() {}

  explicit QueryTemplateListResponseBodyNonExistTids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTemplateListResponseBodyNonExistTids() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> degrain{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> remove{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> resoPriority{};

  QueryTemplateListResponseBodyTemplateListTemplateVideo() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateVideo() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  QueryTemplateListResponseBodyTemplateListTemplateTransConfig() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateTransConfig() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp> webp{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment> segment{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfig() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp>(model1);
      }
    }
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfig() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<string> bitrate{};

  QueryTemplateListResponseBodyTemplateListTemplateAudio() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateAudio() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryTemplateListResponseBodyTemplateListTemplateContainer() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateContainer() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateVideo> video{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<string> state{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateAudio> audio{};
  shared_ptr<string> id{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateContainer> container{};

  QueryTemplateListResponseBodyTemplateListTemplate() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryTemplateListResponseBodyTemplateListTemplateVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryTemplateListResponseBodyTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryTemplateListResponseBodyTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryTemplateListResponseBodyTemplateListTemplateContainer>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplate() = default;
};
class QueryTemplateListResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTemplateListResponseBodyTemplateListTemplate>> template_{};

  QueryTemplateListResponseBodyTemplateList() {}

  explicit QueryTemplateListResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QueryTemplateListResponseBodyTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTemplateListResponseBodyTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QueryTemplateListResponseBodyTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateList() = default;
};
class QueryTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyNonExistTids> nonExistTids{};
  shared_ptr<QueryTemplateListResponseBodyTemplateList> templateList{};
  shared_ptr<string> requestId{};

  QueryTemplateListResponseBody() {}

  explicit QueryTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistTids) {
      res["NonExistTids"] = nonExistTids ? boost::any(nonExistTids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistTids") != m.end() && !m["NonExistTids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistTids"].type()) {
        QueryTemplateListResponseBodyNonExistTids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistTids"]));
        nonExistTids = make_shared<QueryTemplateListResponseBodyNonExistTids>(model1);
      }
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        QueryTemplateListResponseBodyTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<QueryTemplateListResponseBodyTemplateList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryTemplateListResponseBody() = default;
};
class QueryTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryTemplateListResponseBody> body{};

  QueryTemplateListResponse() {}

  explicit QueryTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponse() = default;
};
class ReportFacerecogJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> facerecog{};
  shared_ptr<string> details{};
  shared_ptr<string> ownerAccount{};

  ReportFacerecogJobResultRequest() {}

  explicit ReportFacerecogJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (facerecog) {
      res["Facerecog"] = boost::any(*facerecog);
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Facerecog") != m.end() && !m["Facerecog"].empty()) {
      facerecog = make_shared<string>(boost::any_cast<string>(m["Facerecog"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportFacerecogJobResultRequest() = default;
};
class ReportFacerecogJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportFacerecogJobResultResponseBody() {}

  explicit ReportFacerecogJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportFacerecogJobResultResponseBody() = default;
};
class ReportFacerecogJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportFacerecogJobResultResponseBody> body{};

  ReportFacerecogJobResultResponse() {}

  explicit ReportFacerecogJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportFacerecogJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportFacerecogJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportFacerecogJobResultResponse() = default;
};
class QueryMCTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateIds{};
  shared_ptr<string> ownerAccount{};

  QueryMCTemplateListRequest() {}

  explicit QueryMCTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMCTemplateListRequest() = default;
};
class QueryMCTemplateListResponseBodyNonExistTids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMCTemplateListResponseBodyNonExistTids() {}

  explicit QueryMCTemplateListResponseBodyNonExistTids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMCTemplateListResponseBodyNonExistTids() = default;
};
class QueryMCTemplateListResponseBodyTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> abuse{};
  shared_ptr<string> state{};
  shared_ptr<string> terrorism{};
  shared_ptr<string> politics{};
  shared_ptr<string> qrcode{};
  shared_ptr<string> live{};
  shared_ptr<string> spam{};
  shared_ptr<string> contraband{};
  shared_ptr<string> ad{};
  shared_ptr<string> porn{};
  shared_ptr<string> name{};
  shared_ptr<string> templateId{};

  QueryMCTemplateListResponseBodyTemplateListTemplate() {}

  explicit QueryMCTemplateListResponseBodyTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["Logo"] = boost::any(*logo);
    }
    if (abuse) {
      res["Abuse"] = boost::any(*abuse);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (terrorism) {
      res["Terrorism"] = boost::any(*terrorism);
    }
    if (politics) {
      res["Politics"] = boost::any(*politics);
    }
    if (qrcode) {
      res["Qrcode"] = boost::any(*qrcode);
    }
    if (live) {
      res["Live"] = boost::any(*live);
    }
    if (spam) {
      res["Spam"] = boost::any(*spam);
    }
    if (contraband) {
      res["Contraband"] = boost::any(*contraband);
    }
    if (ad) {
      res["Ad"] = boost::any(*ad);
    }
    if (porn) {
      res["Porn"] = boost::any(*porn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logo") != m.end() && !m["Logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["Logo"]));
    }
    if (m.find("Abuse") != m.end() && !m["Abuse"].empty()) {
      abuse = make_shared<string>(boost::any_cast<string>(m["Abuse"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Terrorism") != m.end() && !m["Terrorism"].empty()) {
      terrorism = make_shared<string>(boost::any_cast<string>(m["Terrorism"]));
    }
    if (m.find("Politics") != m.end() && !m["Politics"].empty()) {
      politics = make_shared<string>(boost::any_cast<string>(m["Politics"]));
    }
    if (m.find("Qrcode") != m.end() && !m["Qrcode"].empty()) {
      qrcode = make_shared<string>(boost::any_cast<string>(m["Qrcode"]));
    }
    if (m.find("Live") != m.end() && !m["Live"].empty()) {
      live = make_shared<string>(boost::any_cast<string>(m["Live"]));
    }
    if (m.find("Spam") != m.end() && !m["Spam"].empty()) {
      spam = make_shared<string>(boost::any_cast<string>(m["Spam"]));
    }
    if (m.find("Contraband") != m.end() && !m["Contraband"].empty()) {
      contraband = make_shared<string>(boost::any_cast<string>(m["Contraband"]));
    }
    if (m.find("Ad") != m.end() && !m["Ad"].empty()) {
      ad = make_shared<string>(boost::any_cast<string>(m["Ad"]));
    }
    if (m.find("Porn") != m.end() && !m["Porn"].empty()) {
      porn = make_shared<string>(boost::any_cast<string>(m["Porn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~QueryMCTemplateListResponseBodyTemplateListTemplate() = default;
};
class QueryMCTemplateListResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCTemplateListResponseBodyTemplateListTemplate>> template_{};

  QueryMCTemplateListResponseBodyTemplateList() {}

  explicit QueryMCTemplateListResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QueryMCTemplateListResponseBodyTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCTemplateListResponseBodyTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QueryMCTemplateListResponseBodyTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryMCTemplateListResponseBodyTemplateList() = default;
};
class QueryMCTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMCTemplateListResponseBodyNonExistTids> nonExistTids{};
  shared_ptr<QueryMCTemplateListResponseBodyTemplateList> templateList{};
  shared_ptr<string> requestId{};

  QueryMCTemplateListResponseBody() {}

  explicit QueryMCTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistTids) {
      res["NonExistTids"] = nonExistTids ? boost::any(nonExistTids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistTids") != m.end() && !m["NonExistTids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistTids"].type()) {
        QueryMCTemplateListResponseBodyNonExistTids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistTids"]));
        nonExistTids = make_shared<QueryMCTemplateListResponseBodyNonExistTids>(model1);
      }
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        QueryMCTemplateListResponseBodyTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<QueryMCTemplateListResponseBodyTemplateList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMCTemplateListResponseBody() = default;
};
class QueryMCTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMCTemplateListResponseBody> body{};

  QueryMCTemplateListResponse() {}

  explicit QueryMCTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMCTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMCTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMCTemplateListResponse() = default;
};
class UpdateMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> title{};
  shared_ptr<string> description{};
  shared_ptr<string> coverURL{};
  shared_ptr<long> cateId{};
  shared_ptr<string> tags{};
  shared_ptr<string> ownerAccount{};

  UpdateMediaRequest() {}

  explicit UpdateMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateMediaRequest() = default;
};
class UpdateMediaResponseBodyMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  UpdateMediaResponseBodyMediaTags() {}

  explicit UpdateMediaResponseBodyMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaResponseBodyMediaTags() = default;
};
class UpdateMediaResponseBodyMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  UpdateMediaResponseBodyMediaFile() {}

  explicit UpdateMediaResponseBodyMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~UpdateMediaResponseBodyMediaFile() = default;
};
class UpdateMediaResponseBodyMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  UpdateMediaResponseBodyMediaRunIdList() {}

  explicit UpdateMediaResponseBodyMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaResponseBodyMediaRunIdList() = default;
};
class UpdateMediaResponseBodyMedia : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> cateId{};
  shared_ptr<string> height{};
  shared_ptr<string> censorState{};
  shared_ptr<UpdateMediaResponseBodyMediaTags> tags{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> mediaId{};
  shared_ptr<UpdateMediaResponseBodyMediaFile> file{};
  shared_ptr<string> publishState{};
  shared_ptr<string> description{};
  shared_ptr<string> width{};
  shared_ptr<string> size{};
  shared_ptr<string> coverURL{};
  shared_ptr<UpdateMediaResponseBodyMediaRunIdList> runIdList{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> title{};
  shared_ptr<string> format{};

  UpdateMediaResponseBodyMedia() {}

  explicit UpdateMediaResponseBodyMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        UpdateMediaResponseBodyMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<UpdateMediaResponseBodyMediaTags>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        UpdateMediaResponseBodyMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<UpdateMediaResponseBodyMediaFile>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        UpdateMediaResponseBodyMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<UpdateMediaResponseBodyMediaRunIdList>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~UpdateMediaResponseBodyMedia() = default;
};
class UpdateMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMediaResponseBodyMedia> media{};

  UpdateMediaResponseBody() {}

  explicit UpdateMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (media) {
      res["Media"] = media ? boost::any(media->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(map<string, boost::any>) == m["Media"].type()) {
        UpdateMediaResponseBodyMedia model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Media"]));
        media = make_shared<UpdateMediaResponseBodyMedia>(model1);
      }
    }
  }


  virtual ~UpdateMediaResponseBody() = default;
};
class UpdateMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMediaResponseBody> body{};

  UpdateMediaResponse() {}

  explicit UpdateMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaResponse() = default;
};
class ListCensorPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> state{};
  shared_ptr<string> ownerAccount{};

  ListCensorPipelineRequest() {}

  explicit ListCensorPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListCensorPipelineRequest() = default;
};
class ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class ListCensorPipelineResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListCensorPipelineResponseBodyPipelineListPipeline() {}

  explicit ListCensorPipelineResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListCensorPipelineResponseBodyPipelineListPipeline() = default;
};
class ListCensorPipelineResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<ListCensorPipelineResponseBodyPipelineListPipeline>> pipeline{};

  ListCensorPipelineResponseBodyPipelineList() {}

  explicit ListCensorPipelineResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<ListCensorPipelineResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCensorPipelineResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<ListCensorPipelineResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~ListCensorPipelineResponseBodyPipelineList() = default;
};
class ListCensorPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<ListCensorPipelineResponseBodyPipelineList> pipelineList{};

  ListCensorPipelineResponseBody() {}

  explicit ListCensorPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        ListCensorPipelineResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<ListCensorPipelineResponseBodyPipelineList>(model1);
      }
    }
  }


  virtual ~ListCensorPipelineResponseBody() = default;
};
class ListCensorPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCensorPipelineResponseBody> body{};

  ListCensorPipelineResponse() {}

  explicit ListCensorPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCensorPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCensorPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~ListCensorPipelineResponse() = default;
};
class QuerySubtitleJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QuerySubtitleJobListRequest() {}

  explicit QuerySubtitleJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QuerySubtitleJobListRequest() = default;
};
class QuerySubtitleJobListResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QuerySubtitleJobListResponseBodyNonExistJobIds() {}

  explicit QuerySubtitleJobListResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySubtitleJobListResponseBodyNonExistJobIds() = default;
};
class QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult() {}

  explicit QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult() = default;
};
class QuerySubtitleJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> outputConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> inputConfig{};
  shared_ptr<QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};

  QuerySubtitleJobListResponseBodyJobListJob() {}

  explicit QuerySubtitleJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
  }


  virtual ~QuerySubtitleJobListResponseBodyJobListJob() = default;
};
class QuerySubtitleJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySubtitleJobListResponseBodyJobListJob>> job{};

  QuerySubtitleJobListResponseBodyJobList() {}

  explicit QuerySubtitleJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QuerySubtitleJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySubtitleJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QuerySubtitleJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QuerySubtitleJobListResponseBodyJobList() = default;
};
class QuerySubtitleJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySubtitleJobListResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySubtitleJobListResponseBodyJobList> jobList{};

  QuerySubtitleJobListResponseBody() {}

  explicit QuerySubtitleJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QuerySubtitleJobListResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QuerySubtitleJobListResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QuerySubtitleJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QuerySubtitleJobListResponseBodyJobList>(model1);
      }
    }
  }


  virtual ~QuerySubtitleJobListResponseBody() = default;
};
class QuerySubtitleJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySubtitleJobListResponseBody> body{};

  QuerySubtitleJobListResponse() {}

  explicit QuerySubtitleJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySubtitleJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySubtitleJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySubtitleJobListResponse() = default;
};
class QueryVideoGifJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryVideoGifJobListRequest() {}

  explicit QueryVideoGifJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryVideoGifJobListRequest() = default;
};
class QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile() {}

  explicit QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile() = default;
};
class QueryVideoGifJobListResponseBodyJobListJobVideoGifResult : public Darabonba::Model {
public:
  shared_ptr<QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile> outputFile{};

  QueryVideoGifJobListResponseBodyJobListJobVideoGifResult() {}

  explicit QueryVideoGifJobListResponseBodyJobListJobVideoGifResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile>(model1);
      }
    }
  }


  virtual ~QueryVideoGifJobListResponseBodyJobListJobVideoGifResult() = default;
};
class QueryVideoGifJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryVideoGifJobListResponseBodyJobListJobInput() {}

  explicit QueryVideoGifJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryVideoGifJobListResponseBodyJobListJobInput() = default;
};
class QueryVideoGifJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<QueryVideoGifJobListResponseBodyJobListJobVideoGifResult> videoGifResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryVideoGifJobListResponseBodyJobListJobInput> input{};
  shared_ptr<string> id{};

  QueryVideoGifJobListResponseBodyJobListJob() {}

  explicit QueryVideoGifJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (videoGifResult) {
      res["VideoGifResult"] = videoGifResult ? boost::any(videoGifResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("VideoGifResult") != m.end() && !m["VideoGifResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoGifResult"].type()) {
        QueryVideoGifJobListResponseBodyJobListJobVideoGifResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoGifResult"]));
        videoGifResult = make_shared<QueryVideoGifJobListResponseBodyJobListJobVideoGifResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryVideoGifJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryVideoGifJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryVideoGifJobListResponseBodyJobListJob() = default;
};
class QueryVideoGifJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoGifJobListResponseBodyJobListJob>> job{};

  QueryVideoGifJobListResponseBodyJobList() {}

  explicit QueryVideoGifJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryVideoGifJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoGifJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryVideoGifJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryVideoGifJobListResponseBodyJobList() = default;
};
class QueryVideoGifJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryVideoGifJobListResponseBodyNonExistIds() {}

  explicit QueryVideoGifJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryVideoGifJobListResponseBodyNonExistIds() = default;
};
class QueryVideoGifJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryVideoGifJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryVideoGifJobListResponseBodyNonExistIds> nonExistIds{};

  QueryVideoGifJobListResponseBody() {}

  explicit QueryVideoGifJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryVideoGifJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryVideoGifJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryVideoGifJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryVideoGifJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryVideoGifJobListResponseBody() = default;
};
class QueryVideoGifJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryVideoGifJobListResponseBody> body{};

  QueryVideoGifJobListResponse() {}

  explicit QueryVideoGifJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryVideoGifJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryVideoGifJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryVideoGifJobListResponse() = default;
};
class QueryEditingJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryEditingJobListRequest() {}

  explicit QueryEditingJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryEditingJobListRequest() = default;
};
class QueryEditingJobListResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryEditingJobListResponseBodyNonExistJobIds() {}

  explicit QueryEditingJobListResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryEditingJobListResponseBodyNonExistJobIds() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> isNormalSar{};
  shared_ptr<string> deinterlaceMethod{};

  QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isNormalSar) {
      res["IsNormalSar"] = boost::any(*isNormalSar);
    }
    if (deinterlaceMethod) {
      res["DeinterlaceMethod"] = boost::any(*deinterlaceMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsNormalSar") != m.end() && !m["IsNormalSar"].empty()) {
      isNormalSar = make_shared<string>(boost::any_cast<string>(m["IsNormalSar"]));
    }
    if (m.find("DeinterlaceMethod") != m.end() && !m["DeinterlaceMethod"].empty()) {
      deinterlaceMethod = make_shared<string>(boost::any_cast<string>(m["DeinterlaceMethod"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile> inputFile{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig> inputConfig{};
  shared_ptr<string> id{};

  QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile>(model1);
      }
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingInputs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput>> editingInput{};

  QueryEditingJobListResponseBodyJobListJobEditingInputs() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInput) {
      vector<boost::any> temp1;
      for(auto item1:*editingInput){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EditingInput"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInput") != m.end() && !m["EditingInput"].empty()) {
      if (typeid(vector<boost::any>) == m["EditingInput"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EditingInput"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        editingInput = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingInputs() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigVideo() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigVideo() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> duration{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> id{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> referPos{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> dy{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark>> waterMark{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> sizeSupport{};
  shared_ptr<bool> md5Support{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS> TS{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> level{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume> volume{};
  shared_ptr<string> bitrate{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigAudio() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigAudio() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> duration{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge>> merge{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> alpha{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile> inputFile{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> t{};
  shared_ptr<string> l{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (t) {
      res["T"] = boost::any(*t);
    }
    if (l) {
      res["L"] = boost::any(*l);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
    if (m.find("L") != m.end() && !m["L"].empty()) {
      l = make_shared<string>(boost::any_cast<string>(m["L"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo> clipsConfigVideo{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfigVideo) {
      res["ClipsConfigVideo"] = clipsConfigVideo ? boost::any(clipsConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfigVideo") != m.end() && !m["ClipsConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfigVideo"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfigVideo"]));
        clipsConfigVideo = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig> clipsConfig{};
  shared_ptr<string> out{};
  shared_ptr<string> in{};
  shared_ptr<string> clipID{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfig) {
      res["ClipsConfig"] = clipsConfig ? boost::any(clipsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (clipID) {
      res["clipID"] = boost::any(*clipID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfig") != m.end() && !m["ClipsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfig"]));
        clipsConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig>(model1);
      }
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("clipID") != m.end() && !m["clipID"].empty()) {
      clipID = make_shared<string>(boost::any_cast<string>(m["clipID"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip>> clip{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> order{};
  shared_ptr<string> id{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips> clips{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clips) {
      res["Clips"] = clips ? boost::any(clips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clips"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clips"]));
        clips = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack>> track{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (track) {
      vector<boost::any> temp1;
      for(auto item1:*track){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Track"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Track") != m.end() && !m["Track"].empty()) {
      if (typeid(vector<boost::any>) == m["Track"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Track"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        track = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> channelLayout{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> channels{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> width{};
  shared_ptr<string> renderRatio{};
  shared_ptr<string> isGpuData{};
  shared_ptr<string> height{};
  shared_ptr<string> isOneTrackData{};
  shared_ptr<string> fps{};
  shared_ptr<string> reclosePrec{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (renderRatio) {
      res["RenderRatio"] = boost::any(*renderRatio);
    }
    if (isGpuData) {
      res["IsGpuData"] = boost::any(*isGpuData);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isOneTrackData) {
      res["IsOneTrackData"] = boost::any(*isOneTrackData);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (reclosePrec) {
      res["ReclosePrec"] = boost::any(*reclosePrec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("RenderRatio") != m.end() && !m["RenderRatio"].empty()) {
      renderRatio = make_shared<string>(boost::any_cast<string>(m["RenderRatio"]));
    }
    if (m.find("IsGpuData") != m.end() && !m["IsGpuData"].empty()) {
      isGpuData = make_shared<string>(boost::any_cast<string>(m["IsGpuData"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsOneTrackData") != m.end() && !m["IsOneTrackData"].empty()) {
      isOneTrackData = make_shared<string>(boost::any_cast<string>(m["IsOneTrackData"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("ReclosePrec") != m.end() && !m["ReclosePrec"].empty()) {
      reclosePrec = make_shared<string>(boost::any_cast<string>(m["ReclosePrec"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio> timelineConfigAudio{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo> timelineConfigVideo{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timelineConfigAudio) {
      res["TimelineConfigAudio"] = timelineConfigAudio ? boost::any(timelineConfigAudio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfigVideo) {
      res["TimelineConfigVideo"] = timelineConfigVideo ? boost::any(timelineConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimelineConfigAudio") != m.end() && !m["TimelineConfigAudio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigAudio"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigAudio"]));
        timelineConfigAudio = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio>(model1);
      }
    }
    if (m.find("TimelineConfigVideo") != m.end() && !m["TimelineConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigVideo"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigVideo"]));
        timelineConfigVideo = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList> trackList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig> timelineConfig{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trackList) {
      res["TrackList"] = trackList ? boost::any(trackList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfig) {
      res["TimelineConfig"] = timelineConfig ? boost::any(timelineConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrackList") != m.end() && !m["TrackList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrackList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrackList"]));
        trackList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList>(model1);
      }
    }
    if (m.find("TimelineConfig") != m.end() && !m["TimelineConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfig"]));
        timelineConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> effectConfig{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (effectConfig) {
      res["EffectConfig"] = boost::any(*effectConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("EffectConfig") != m.end() && !m["EffectConfig"].empty()) {
      effectConfig = make_shared<string>(boost::any_cast<string>(m["EffectConfig"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect>> effect{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      vector<boost::any> temp1;
      for(auto item1:*effect){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Effect"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      if (typeid(vector<boost::any>) == m["Effect"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Effect"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effect = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> sourceID{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects> effects{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceStrmMap{};
  shared_ptr<string> out{};
  shared_ptr<string> in{};
  shared_ptr<string> id{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (sourceID) {
      res["SourceID"] = boost::any(*sourceID);
    }
    if (effects) {
      res["Effects"] = effects ? boost::any(effects->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceStrmMap) {
      res["SourceStrmMap"] = boost::any(*sourceStrmMap);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SourceID") != m.end() && !m["SourceID"].empty()) {
      sourceID = make_shared<string>(boost::any_cast<string>(m["SourceID"]));
    }
    if (m.find("Effects") != m.end() && !m["Effects"].empty()) {
      if (typeid(map<string, boost::any>) == m["Effects"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Effects"]));
        effects = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects>(model1);
      }
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceStrmMap") != m.end() && !m["SourceStrmMap"].empty()) {
      sourceStrmMap = make_shared<string>(boost::any_cast<string>(m["SourceStrmMap"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip>> clip{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditing : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline> timeline{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList> clipList{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditing() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditing(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clipList) {
      res["ClipList"] = clipList ? boost::any(clipList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline>(model1);
      }
    }
    if (m.find("ClipList") != m.end() && !m["ClipList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipList"]));
        clipList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditing() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigContainer() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigContainer() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> seek{};
  shared_ptr<string> duration{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigClip : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan> timeSpan{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigClip() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigClip() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif> gif{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment> segment{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle>> subtitle{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList> subtitleList{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> sar{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> height{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> width{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams> streams{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigProperties() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigProperties() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigVideo> video{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig> transConfig{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption> encryption{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList> waterMarkList{};
  shared_ptr<string> deWatermark{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> priority{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList> mergeList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso> superReso{};
  shared_ptr<string> userData{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark> digiWaterMark{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile> outputFile{};
  shared_ptr<string> rotate{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditing> editing{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigContainer> container{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigClip> clip{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig> muxConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig> subtitleConfig{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigProperties> properties{};

  QueryEditingJobListResponseBodyJobListJobEditingConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (editing) {
      res["Editing"] = editing ? boost::any(editing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption>(model1);
      }
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Editing") != m.end() && !m["Editing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Editing"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditing model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Editing"]));
        editing = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditing>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigContainer>(model1);
      }
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigClip>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigProperties>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QueryEditingJobListResponseBodyJobListJobMNSMessageResult() {}

  explicit QueryEditingJobListResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobMNSMessageResult() = default;
};
class QueryEditingJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingInputs> editingInputs{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfig> editingConfig{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};

  QueryEditingJobListResponseBodyJobListJob() {}

  explicit QueryEditingJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (editingInputs) {
      res["EditingInputs"] = editingInputs ? boost::any(editingInputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (editingConfig) {
      res["EditingConfig"] = editingConfig ? boost::any(editingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("EditingInputs") != m.end() && !m["EditingInputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingInputs"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingInputs"]));
        editingInputs = make_shared<QueryEditingJobListResponseBodyJobListJobEditingInputs>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingConfig"]));
        editingConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfig>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryEditingJobListResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryEditingJobListResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJob() = default;
};
class QueryEditingJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJob>> job{};

  QueryEditingJobListResponseBodyJobList() {}

  explicit QueryEditingJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryEditingJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobList() = default;
};
class QueryEditingJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryEditingJobListResponseBodyJobList> jobList{};

  QueryEditingJobListResponseBody() {}

  explicit QueryEditingJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QueryEditingJobListResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QueryEditingJobListResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryEditingJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryEditingJobListResponseBodyJobList>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBody() = default;
};
class QueryEditingJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEditingJobListResponseBody> body{};

  QueryEditingJobListResponse() {}

  explicit QueryEditingJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEditingJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEditingJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponse() = default;
};
class UpdateMCTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> name{};
  shared_ptr<string> porn{};
  shared_ptr<string> terrorism{};
  shared_ptr<string> politics{};
  shared_ptr<string> ad{};
  shared_ptr<string> qrcode{};
  shared_ptr<string> live{};
  shared_ptr<string> logo{};
  shared_ptr<string> abuse{};
  shared_ptr<string> contraband{};
  shared_ptr<string> spam{};
  shared_ptr<string> ownerAccount{};

  UpdateMCTemplateRequest() {}

  explicit UpdateMCTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (porn) {
      res["Porn"] = boost::any(*porn);
    }
    if (terrorism) {
      res["Terrorism"] = boost::any(*terrorism);
    }
    if (politics) {
      res["Politics"] = boost::any(*politics);
    }
    if (ad) {
      res["Ad"] = boost::any(*ad);
    }
    if (qrcode) {
      res["Qrcode"] = boost::any(*qrcode);
    }
    if (live) {
      res["Live"] = boost::any(*live);
    }
    if (logo) {
      res["Logo"] = boost::any(*logo);
    }
    if (abuse) {
      res["Abuse"] = boost::any(*abuse);
    }
    if (contraband) {
      res["Contraband"] = boost::any(*contraband);
    }
    if (spam) {
      res["spam"] = boost::any(*spam);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Porn") != m.end() && !m["Porn"].empty()) {
      porn = make_shared<string>(boost::any_cast<string>(m["Porn"]));
    }
    if (m.find("Terrorism") != m.end() && !m["Terrorism"].empty()) {
      terrorism = make_shared<string>(boost::any_cast<string>(m["Terrorism"]));
    }
    if (m.find("Politics") != m.end() && !m["Politics"].empty()) {
      politics = make_shared<string>(boost::any_cast<string>(m["Politics"]));
    }
    if (m.find("Ad") != m.end() && !m["Ad"].empty()) {
      ad = make_shared<string>(boost::any_cast<string>(m["Ad"]));
    }
    if (m.find("Qrcode") != m.end() && !m["Qrcode"].empty()) {
      qrcode = make_shared<string>(boost::any_cast<string>(m["Qrcode"]));
    }
    if (m.find("Live") != m.end() && !m["Live"].empty()) {
      live = make_shared<string>(boost::any_cast<string>(m["Live"]));
    }
    if (m.find("Logo") != m.end() && !m["Logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["Logo"]));
    }
    if (m.find("Abuse") != m.end() && !m["Abuse"].empty()) {
      abuse = make_shared<string>(boost::any_cast<string>(m["Abuse"]));
    }
    if (m.find("Contraband") != m.end() && !m["Contraband"].empty()) {
      contraband = make_shared<string>(boost::any_cast<string>(m["Contraband"]));
    }
    if (m.find("spam") != m.end() && !m["spam"].empty()) {
      spam = make_shared<string>(boost::any_cast<string>(m["spam"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateMCTemplateRequest() = default;
};
class UpdateMCTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> abuse{};
  shared_ptr<string> state{};
  shared_ptr<string> terrorism{};
  shared_ptr<string> politics{};
  shared_ptr<string> qrcode{};
  shared_ptr<string> live{};
  shared_ptr<string> spam{};
  shared_ptr<string> contraband{};
  shared_ptr<string> ad{};
  shared_ptr<string> porn{};
  shared_ptr<string> name{};
  shared_ptr<string> templateId{};

  UpdateMCTemplateResponseBodyTemplate() {}

  explicit UpdateMCTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["Logo"] = boost::any(*logo);
    }
    if (abuse) {
      res["Abuse"] = boost::any(*abuse);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (terrorism) {
      res["Terrorism"] = boost::any(*terrorism);
    }
    if (politics) {
      res["Politics"] = boost::any(*politics);
    }
    if (qrcode) {
      res["Qrcode"] = boost::any(*qrcode);
    }
    if (live) {
      res["Live"] = boost::any(*live);
    }
    if (spam) {
      res["Spam"] = boost::any(*spam);
    }
    if (contraband) {
      res["Contraband"] = boost::any(*contraband);
    }
    if (ad) {
      res["Ad"] = boost::any(*ad);
    }
    if (porn) {
      res["Porn"] = boost::any(*porn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logo") != m.end() && !m["Logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["Logo"]));
    }
    if (m.find("Abuse") != m.end() && !m["Abuse"].empty()) {
      abuse = make_shared<string>(boost::any_cast<string>(m["Abuse"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Terrorism") != m.end() && !m["Terrorism"].empty()) {
      terrorism = make_shared<string>(boost::any_cast<string>(m["Terrorism"]));
    }
    if (m.find("Politics") != m.end() && !m["Politics"].empty()) {
      politics = make_shared<string>(boost::any_cast<string>(m["Politics"]));
    }
    if (m.find("Qrcode") != m.end() && !m["Qrcode"].empty()) {
      qrcode = make_shared<string>(boost::any_cast<string>(m["Qrcode"]));
    }
    if (m.find("Live") != m.end() && !m["Live"].empty()) {
      live = make_shared<string>(boost::any_cast<string>(m["Live"]));
    }
    if (m.find("Spam") != m.end() && !m["Spam"].empty()) {
      spam = make_shared<string>(boost::any_cast<string>(m["Spam"]));
    }
    if (m.find("Contraband") != m.end() && !m["Contraband"].empty()) {
      contraband = make_shared<string>(boost::any_cast<string>(m["Contraband"]));
    }
    if (m.find("Ad") != m.end() && !m["Ad"].empty()) {
      ad = make_shared<string>(boost::any_cast<string>(m["Ad"]));
    }
    if (m.find("Porn") != m.end() && !m["Porn"].empty()) {
      porn = make_shared<string>(boost::any_cast<string>(m["Porn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateMCTemplateResponseBodyTemplate() = default;
};
class UpdateMCTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMCTemplateResponseBodyTemplate> template_{};

  UpdateMCTemplateResponseBody() {}

  explicit UpdateMCTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        UpdateMCTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<UpdateMCTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~UpdateMCTemplateResponseBody() = default;
};
class UpdateMCTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMCTemplateResponseBody> body{};

  UpdateMCTemplateResponse() {}

  explicit UpdateMCTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMCTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMCTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMCTemplateResponse() = default;
};
class ReportCoverJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> result{};
  shared_ptr<string> ownerAccount{};

  ReportCoverJobResultRequest() {}

  explicit ReportCoverJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportCoverJobResultRequest() = default;
};
class ReportCoverJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportCoverJobResultResponseBody() {}

  explicit ReportCoverJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportCoverJobResultResponseBody() = default;
};
class ReportCoverJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportCoverJobResultResponseBody> body{};

  ReportCoverJobResultResponse() {}

  explicit ReportCoverJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportCoverJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportCoverJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportCoverJobResultResponse() = default;
};
class SubmitImageQualityJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitImageQualityJobRequest() {}

  explicit SubmitImageQualityJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitImageQualityJobRequest() = default;
};
class SubmitImageQualityJobResponseBodyImageQualityJobResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> score{};

  SubmitImageQualityJobResponseBodyImageQualityJobResult() {}

  explicit SubmitImageQualityJobResponseBodyImageQualityJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
  }


  virtual ~SubmitImageQualityJobResponseBodyImageQualityJobResult() = default;
};
class SubmitImageQualityJobResponseBodyImageQualityJobInput : public Darabonba::Model {
public:
  shared_ptr<string> url{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitImageQualityJobResponseBodyImageQualityJobInput() {}

  explicit SubmitImageQualityJobResponseBodyImageQualityJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitImageQualityJobResponseBodyImageQualityJobInput() = default;
};
class SubmitImageQualityJobResponseBodyImageQualityJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<SubmitImageQualityJobResponseBodyImageQualityJobResult> result{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitImageQualityJobResponseBodyImageQualityJobInput> input{};

  SubmitImageQualityJobResponseBodyImageQualityJob() {}

  explicit SubmitImageQualityJobResponseBodyImageQualityJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SubmitImageQualityJobResponseBodyImageQualityJobResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SubmitImageQualityJobResponseBodyImageQualityJobResult>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitImageQualityJobResponseBodyImageQualityJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitImageQualityJobResponseBodyImageQualityJobInput>(model1);
      }
    }
  }


  virtual ~SubmitImageQualityJobResponseBodyImageQualityJob() = default;
};
class SubmitImageQualityJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitImageQualityJobResponseBodyImageQualityJob> imageQualityJob{};

  SubmitImageQualityJobResponseBody() {}

  explicit SubmitImageQualityJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (imageQualityJob) {
      res["ImageQualityJob"] = imageQualityJob ? boost::any(imageQualityJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ImageQualityJob") != m.end() && !m["ImageQualityJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageQualityJob"].type()) {
        SubmitImageQualityJobResponseBodyImageQualityJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageQualityJob"]));
        imageQualityJob = make_shared<SubmitImageQualityJobResponseBodyImageQualityJob>(model1);
      }
    }
  }


  virtual ~SubmitImageQualityJobResponseBody() = default;
};
class SubmitImageQualityJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitImageQualityJobResponseBody> body{};

  SubmitImageQualityJobResponse() {}

  explicit SubmitImageQualityJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitImageQualityJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitImageQualityJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitImageQualityJobResponse() = default;
};
class AddMCTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> porn{};
  shared_ptr<string> terrorism{};
  shared_ptr<string> politics{};
  shared_ptr<string> ad{};
  shared_ptr<string> qrcode{};
  shared_ptr<string> live{};
  shared_ptr<string> logo{};
  shared_ptr<string> abuse{};
  shared_ptr<string> contraband{};
  shared_ptr<string> spam{};
  shared_ptr<string> ownerAccount{};

  AddMCTemplateRequest() {}

  explicit AddMCTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (porn) {
      res["Porn"] = boost::any(*porn);
    }
    if (terrorism) {
      res["Terrorism"] = boost::any(*terrorism);
    }
    if (politics) {
      res["Politics"] = boost::any(*politics);
    }
    if (ad) {
      res["Ad"] = boost::any(*ad);
    }
    if (qrcode) {
      res["Qrcode"] = boost::any(*qrcode);
    }
    if (live) {
      res["Live"] = boost::any(*live);
    }
    if (logo) {
      res["Logo"] = boost::any(*logo);
    }
    if (abuse) {
      res["Abuse"] = boost::any(*abuse);
    }
    if (contraband) {
      res["Contraband"] = boost::any(*contraband);
    }
    if (spam) {
      res["spam"] = boost::any(*spam);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Porn") != m.end() && !m["Porn"].empty()) {
      porn = make_shared<string>(boost::any_cast<string>(m["Porn"]));
    }
    if (m.find("Terrorism") != m.end() && !m["Terrorism"].empty()) {
      terrorism = make_shared<string>(boost::any_cast<string>(m["Terrorism"]));
    }
    if (m.find("Politics") != m.end() && !m["Politics"].empty()) {
      politics = make_shared<string>(boost::any_cast<string>(m["Politics"]));
    }
    if (m.find("Ad") != m.end() && !m["Ad"].empty()) {
      ad = make_shared<string>(boost::any_cast<string>(m["Ad"]));
    }
    if (m.find("Qrcode") != m.end() && !m["Qrcode"].empty()) {
      qrcode = make_shared<string>(boost::any_cast<string>(m["Qrcode"]));
    }
    if (m.find("Live") != m.end() && !m["Live"].empty()) {
      live = make_shared<string>(boost::any_cast<string>(m["Live"]));
    }
    if (m.find("Logo") != m.end() && !m["Logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["Logo"]));
    }
    if (m.find("Abuse") != m.end() && !m["Abuse"].empty()) {
      abuse = make_shared<string>(boost::any_cast<string>(m["Abuse"]));
    }
    if (m.find("Contraband") != m.end() && !m["Contraband"].empty()) {
      contraband = make_shared<string>(boost::any_cast<string>(m["Contraband"]));
    }
    if (m.find("spam") != m.end() && !m["spam"].empty()) {
      spam = make_shared<string>(boost::any_cast<string>(m["spam"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddMCTemplateRequest() = default;
};
class AddMCTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> abuse{};
  shared_ptr<string> terrorism{};
  shared_ptr<string> politics{};
  shared_ptr<string> qrcode{};
  shared_ptr<string> spam{};
  shared_ptr<string> live{};
  shared_ptr<string> contraband{};
  shared_ptr<string> ad{};
  shared_ptr<string> porn{};
  shared_ptr<string> name{};
  shared_ptr<string> templateId{};

  AddMCTemplateResponseBodyTemplate() {}

  explicit AddMCTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["Logo"] = boost::any(*logo);
    }
    if (abuse) {
      res["Abuse"] = boost::any(*abuse);
    }
    if (terrorism) {
      res["Terrorism"] = boost::any(*terrorism);
    }
    if (politics) {
      res["Politics"] = boost::any(*politics);
    }
    if (qrcode) {
      res["Qrcode"] = boost::any(*qrcode);
    }
    if (spam) {
      res["Spam"] = boost::any(*spam);
    }
    if (live) {
      res["Live"] = boost::any(*live);
    }
    if (contraband) {
      res["Contraband"] = boost::any(*contraband);
    }
    if (ad) {
      res["Ad"] = boost::any(*ad);
    }
    if (porn) {
      res["Porn"] = boost::any(*porn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logo") != m.end() && !m["Logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["Logo"]));
    }
    if (m.find("Abuse") != m.end() && !m["Abuse"].empty()) {
      abuse = make_shared<string>(boost::any_cast<string>(m["Abuse"]));
    }
    if (m.find("Terrorism") != m.end() && !m["Terrorism"].empty()) {
      terrorism = make_shared<string>(boost::any_cast<string>(m["Terrorism"]));
    }
    if (m.find("Politics") != m.end() && !m["Politics"].empty()) {
      politics = make_shared<string>(boost::any_cast<string>(m["Politics"]));
    }
    if (m.find("Qrcode") != m.end() && !m["Qrcode"].empty()) {
      qrcode = make_shared<string>(boost::any_cast<string>(m["Qrcode"]));
    }
    if (m.find("Spam") != m.end() && !m["Spam"].empty()) {
      spam = make_shared<string>(boost::any_cast<string>(m["Spam"]));
    }
    if (m.find("Live") != m.end() && !m["Live"].empty()) {
      live = make_shared<string>(boost::any_cast<string>(m["Live"]));
    }
    if (m.find("Contraband") != m.end() && !m["Contraband"].empty()) {
      contraband = make_shared<string>(boost::any_cast<string>(m["Contraband"]));
    }
    if (m.find("Ad") != m.end() && !m["Ad"].empty()) {
      ad = make_shared<string>(boost::any_cast<string>(m["Ad"]));
    }
    if (m.find("Porn") != m.end() && !m["Porn"].empty()) {
      porn = make_shared<string>(boost::any_cast<string>(m["Porn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~AddMCTemplateResponseBodyTemplate() = default;
};
class AddMCTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddMCTemplateResponseBodyTemplate> template_{};

  AddMCTemplateResponseBody() {}

  explicit AddMCTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        AddMCTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<AddMCTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~AddMCTemplateResponseBody() = default;
};
class AddMCTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddMCTemplateResponseBody> body{};

  AddMCTemplateResponse() {}

  explicit AddMCTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMCTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMCTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddMCTemplateResponse() = default;
};
class SearchTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> state{};
  shared_ptr<string> ownerAccount{};

  SearchTemplateRequest() {}

  explicit SearchTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SearchTemplateRequest() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> degrain{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> remove{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};

  SearchTemplateResponseBodyTemplateListTemplateVideo() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateVideo() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  SearchTemplateResponseBodyTemplateListTemplateTransConfig() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateTransConfig() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment> segment{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfig() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfig() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<string> bitrate{};

  SearchTemplateResponseBodyTemplateListTemplateAudio() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateAudio() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SearchTemplateResponseBodyTemplateListTemplateContainer() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateContainer() = default;
};
class SearchTemplateResponseBodyTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateVideo> video{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<string> state{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateAudio> audio{};
  shared_ptr<string> id{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateContainer> container{};

  SearchTemplateResponseBodyTemplateListTemplate() {}

  explicit SearchTemplateResponseBodyTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SearchTemplateResponseBodyTemplateListTemplateVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SearchTemplateResponseBodyTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SearchTemplateResponseBodyTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SearchTemplateResponseBodyTemplateListTemplateContainer>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplate() = default;
};
class SearchTemplateResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchTemplateResponseBodyTemplateListTemplate>> template_{};

  SearchTemplateResponseBodyTemplateList() {}

  explicit SearchTemplateResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<SearchTemplateResponseBodyTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTemplateResponseBodyTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<SearchTemplateResponseBodyTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateList() = default;
};
class SearchTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<SearchTemplateResponseBodyTemplateList> templateList{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};

  SearchTemplateResponseBody() {}

  explicit SearchTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        SearchTemplateResponseBodyTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<SearchTemplateResponseBodyTemplateList>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~SearchTemplateResponseBody() = default;
};
class SearchTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SearchTemplateResponseBody> body{};

  SearchTemplateResponse() {}

  explicit SearchTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponse() = default;
};
class UpdateMcuTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> templateId{};
  shared_ptr<string> template_{};

  UpdateMcuTemplateRequest() {}

  explicit UpdateMcuTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~UpdateMcuTemplateRequest() = default;
};
class UpdateMcuTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  UpdateMcuTemplateResponseBody() {}

  explicit UpdateMcuTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateMcuTemplateResponseBody() = default;
};
class UpdateMcuTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMcuTemplateResponseBody> body{};

  UpdateMcuTemplateResponse() {}

  explicit UpdateMcuTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMcuTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMcuTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMcuTemplateResponse() = default;
};
class SubmitFacerecogJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> facerecogConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  SubmitFacerecogJobRequest() {}

  explicit SubmitFacerecogJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (facerecogConfig) {
      res["FacerecogConfig"] = boost::any(*facerecogConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("FacerecogConfig") != m.end() && !m["FacerecogConfig"].empty()) {
      facerecogConfig = make_shared<string>(boost::any_cast<string>(m["FacerecogConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitFacerecogJobRequest() = default;
};
class SubmitFacerecogJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitFacerecogJobResponseBody() {}

  explicit SubmitFacerecogJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitFacerecogJobResponseBody() = default;
};
class SubmitFacerecogJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitFacerecogJobResponseBody> body{};

  SubmitFacerecogJobResponse() {}

  explicit SubmitFacerecogJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFacerecogJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFacerecogJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFacerecogJobResponse() = default;
};
class SubmitEditingJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> editingInputs{};
  shared_ptr<string> editingJobOutputs{};
  shared_ptr<string> outputBucket{};
  shared_ptr<string> outputLocation{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> editingJobURL{};
  shared_ptr<string> editingJobOssFileRoleArn{};
  shared_ptr<long> editingJobOssFileUid{};
  shared_ptr<string> ownerAccount{};

  SubmitEditingJobsRequest() {}

  explicit SubmitEditingJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (editingInputs) {
      res["EditingInputs"] = boost::any(*editingInputs);
    }
    if (editingJobOutputs) {
      res["EditingJobOutputs"] = boost::any(*editingJobOutputs);
    }
    if (outputBucket) {
      res["OutputBucket"] = boost::any(*outputBucket);
    }
    if (outputLocation) {
      res["OutputLocation"] = boost::any(*outputLocation);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (editingJobURL) {
      res["EditingJobURL"] = boost::any(*editingJobURL);
    }
    if (editingJobOssFileRoleArn) {
      res["EditingJobOssFileRoleArn"] = boost::any(*editingJobOssFileRoleArn);
    }
    if (editingJobOssFileUid) {
      res["EditingJobOssFileUid"] = boost::any(*editingJobOssFileUid);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("EditingInputs") != m.end() && !m["EditingInputs"].empty()) {
      editingInputs = make_shared<string>(boost::any_cast<string>(m["EditingInputs"]));
    }
    if (m.find("EditingJobOutputs") != m.end() && !m["EditingJobOutputs"].empty()) {
      editingJobOutputs = make_shared<string>(boost::any_cast<string>(m["EditingJobOutputs"]));
    }
    if (m.find("OutputBucket") != m.end() && !m["OutputBucket"].empty()) {
      outputBucket = make_shared<string>(boost::any_cast<string>(m["OutputBucket"]));
    }
    if (m.find("OutputLocation") != m.end() && !m["OutputLocation"].empty()) {
      outputLocation = make_shared<string>(boost::any_cast<string>(m["OutputLocation"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("EditingJobURL") != m.end() && !m["EditingJobURL"].empty()) {
      editingJobURL = make_shared<string>(boost::any_cast<string>(m["EditingJobURL"]));
    }
    if (m.find("EditingJobOssFileRoleArn") != m.end() && !m["EditingJobOssFileRoleArn"].empty()) {
      editingJobOssFileRoleArn = make_shared<string>(boost::any_cast<string>(m["EditingJobOssFileRoleArn"]));
    }
    if (m.find("EditingJobOssFileUid") != m.end() && !m["EditingJobOssFileUid"].empty()) {
      editingJobOssFileUid = make_shared<long>(boost::any_cast<long>(m["EditingJobOssFileUid"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitEditingJobsRequest() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> isNormalSar{};
  shared_ptr<string> deinterlaceMethod{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isNormalSar) {
      res["IsNormalSar"] = boost::any(*isNormalSar);
    }
    if (deinterlaceMethod) {
      res["DeinterlaceMethod"] = boost::any(*deinterlaceMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsNormalSar") != m.end() && !m["IsNormalSar"].empty()) {
      isNormalSar = make_shared<string>(boost::any_cast<string>(m["IsNormalSar"]));
    }
    if (m.find("DeinterlaceMethod") != m.end() && !m["DeinterlaceMethod"].empty()) {
      deinterlaceMethod = make_shared<string>(boost::any_cast<string>(m["DeinterlaceMethod"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile> inputFile{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig> inputConfig{};
  shared_ptr<string> id{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile>(model1);
      }
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput>> editingInput{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInput) {
      vector<boost::any> temp1;
      for(auto item1:*editingInput){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EditingInput"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInput") != m.end() && !m["EditingInput"].empty()) {
      if (typeid(vector<boost::any>) == m["EditingInput"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EditingInput"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        editingInput = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> duration{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> id{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> referPos{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> dy{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark>> waterMark{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> sizeSupport{};
  shared_ptr<bool> md5Support{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS> TS{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> level{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume> volume{};
  shared_ptr<string> bitrate{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> duration{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge>> merge{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> alpha{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile> inputFile{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> t{};
  shared_ptr<string> l{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (t) {
      res["T"] = boost::any(*t);
    }
    if (l) {
      res["L"] = boost::any(*l);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
    if (m.find("L") != m.end() && !m["L"].empty()) {
      l = make_shared<string>(boost::any_cast<string>(m["L"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo> clipsConfigVideo{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfigVideo) {
      res["ClipsConfigVideo"] = clipsConfigVideo ? boost::any(clipsConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfigVideo") != m.end() && !m["ClipsConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfigVideo"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfigVideo"]));
        clipsConfigVideo = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig> clipsConfig{};
  shared_ptr<string> out{};
  shared_ptr<string> in{};
  shared_ptr<string> clipID{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfig) {
      res["ClipsConfig"] = clipsConfig ? boost::any(clipsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (clipID) {
      res["clipID"] = boost::any(*clipID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfig") != m.end() && !m["ClipsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfig"]));
        clipsConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig>(model1);
      }
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("clipID") != m.end() && !m["clipID"].empty()) {
      clipID = make_shared<string>(boost::any_cast<string>(m["clipID"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip>> clip{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> order{};
  shared_ptr<string> id{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips> clips{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clips) {
      res["Clips"] = clips ? boost::any(clips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clips"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clips"]));
        clips = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack>> track{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (track) {
      vector<boost::any> temp1;
      for(auto item1:*track){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Track"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Track") != m.end() && !m["Track"].empty()) {
      if (typeid(vector<boost::any>) == m["Track"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Track"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        track = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> channelLayout{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> channels{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> width{};
  shared_ptr<string> renderRatio{};
  shared_ptr<string> isGpuData{};
  shared_ptr<string> height{};
  shared_ptr<string> isOneTrackData{};
  shared_ptr<string> fps{};
  shared_ptr<string> reclosePrec{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (renderRatio) {
      res["RenderRatio"] = boost::any(*renderRatio);
    }
    if (isGpuData) {
      res["IsGpuData"] = boost::any(*isGpuData);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isOneTrackData) {
      res["IsOneTrackData"] = boost::any(*isOneTrackData);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (reclosePrec) {
      res["ReclosePrec"] = boost::any(*reclosePrec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("RenderRatio") != m.end() && !m["RenderRatio"].empty()) {
      renderRatio = make_shared<string>(boost::any_cast<string>(m["RenderRatio"]));
    }
    if (m.find("IsGpuData") != m.end() && !m["IsGpuData"].empty()) {
      isGpuData = make_shared<string>(boost::any_cast<string>(m["IsGpuData"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsOneTrackData") != m.end() && !m["IsOneTrackData"].empty()) {
      isOneTrackData = make_shared<string>(boost::any_cast<string>(m["IsOneTrackData"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("ReclosePrec") != m.end() && !m["ReclosePrec"].empty()) {
      reclosePrec = make_shared<string>(boost::any_cast<string>(m["ReclosePrec"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio> timelineConfigAudio{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo> timelineConfigVideo{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timelineConfigAudio) {
      res["TimelineConfigAudio"] = timelineConfigAudio ? boost::any(timelineConfigAudio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfigVideo) {
      res["TimelineConfigVideo"] = timelineConfigVideo ? boost::any(timelineConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimelineConfigAudio") != m.end() && !m["TimelineConfigAudio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigAudio"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigAudio"]));
        timelineConfigAudio = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio>(model1);
      }
    }
    if (m.find("TimelineConfigVideo") != m.end() && !m["TimelineConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigVideo"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigVideo"]));
        timelineConfigVideo = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList> trackList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig> timelineConfig{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trackList) {
      res["TrackList"] = trackList ? boost::any(trackList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfig) {
      res["TimelineConfig"] = timelineConfig ? boost::any(timelineConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrackList") != m.end() && !m["TrackList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrackList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrackList"]));
        trackList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList>(model1);
      }
    }
    if (m.find("TimelineConfig") != m.end() && !m["TimelineConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfig"]));
        timelineConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> effectConfig{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (effectConfig) {
      res["EffectConfig"] = boost::any(*effectConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("EffectConfig") != m.end() && !m["EffectConfig"].empty()) {
      effectConfig = make_shared<string>(boost::any_cast<string>(m["EffectConfig"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect>> effect{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      vector<boost::any> temp1;
      for(auto item1:*effect){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Effect"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      if (typeid(vector<boost::any>) == m["Effect"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Effect"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effect = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> sourceID{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects> effects{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceStrmMap{};
  shared_ptr<string> out{};
  shared_ptr<string> in{};
  shared_ptr<string> id{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (sourceID) {
      res["SourceID"] = boost::any(*sourceID);
    }
    if (effects) {
      res["Effects"] = effects ? boost::any(effects->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceStrmMap) {
      res["SourceStrmMap"] = boost::any(*sourceStrmMap);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SourceID") != m.end() && !m["SourceID"].empty()) {
      sourceID = make_shared<string>(boost::any_cast<string>(m["SourceID"]));
    }
    if (m.find("Effects") != m.end() && !m["Effects"].empty()) {
      if (typeid(map<string, boost::any>) == m["Effects"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Effects"]));
        effects = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects>(model1);
      }
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceStrmMap") != m.end() && !m["SourceStrmMap"].empty()) {
      sourceStrmMap = make_shared<string>(boost::any_cast<string>(m["SourceStrmMap"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip>> clip{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline> timeline{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList> clipList{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clipList) {
      res["ClipList"] = clipList ? boost::any(clipList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline>(model1);
      }
    }
    if (m.find("ClipList") != m.end() && !m["ClipList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipList"]));
        clipList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> seek{};
  shared_ptr<string> duration{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan> timeSpan{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif> gif{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment> segment{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle>> subtitle{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList> subtitleList{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> sar{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> height{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> width{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams> streams{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo> video{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig> transConfig{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption> encryption{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList> waterMarkList{};
  shared_ptr<string> deWatermark{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> priority{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList> mergeList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso> superReso{};
  shared_ptr<string> userData{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark> digiWaterMark{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile> outputFile{};
  shared_ptr<string> rotate{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing> editing{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer> container{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip> clip{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig> muxConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig> subtitleConfig{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties> properties{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (editing) {
      res["Editing"] = editing ? boost::any(editing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption>(model1);
      }
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Editing") != m.end() && !m["Editing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Editing"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Editing"]));
        editing = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer>(model1);
      }
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs> editingInputs{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig> editingConfig{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult> MNSMessageResult{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJob() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (editingInputs) {
      res["EditingInputs"] = editingInputs ? boost::any(editingInputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (editingConfig) {
      res["EditingConfig"] = editingConfig ? boost::any(editingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("EditingInputs") != m.end() && !m["EditingInputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingInputs"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingInputs"]));
        editingInputs = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingConfig"]));
        editingConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJob() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResult : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJob> job{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  SubmitEditingJobsResponseBodyJobResultListJobResult() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJob>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResult() = default;
};
class SubmitEditingJobsResponseBodyJobResultList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResult>> jobResult{};

  SubmitEditingJobsResponseBodyJobResultList() {}

  explicit SubmitEditingJobsResponseBodyJobResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResult) {
      vector<boost::any> temp1;
      for(auto item1:*jobResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResult") != m.end() && !m["JobResult"].empty()) {
      if (typeid(vector<boost::any>) == m["JobResult"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobResult = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResult>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultList() = default;
};
class SubmitEditingJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultList> jobResultList{};
  shared_ptr<string> requestId{};

  SubmitEditingJobsResponseBody() {}

  explicit SubmitEditingJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResultList) {
      res["JobResultList"] = jobResultList ? boost::any(jobResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResultList") != m.end() && !m["JobResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobResultList"].type()) {
        SubmitEditingJobsResponseBodyJobResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobResultList"]));
        jobResultList = make_shared<SubmitEditingJobsResponseBodyJobResultList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBody() = default;
};
class SubmitEditingJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitEditingJobsResponseBody> body{};

  SubmitEditingJobsResponse() {}

  explicit SubmitEditingJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitEditingJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitEditingJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponse() = default;
};
class ReportVideoSplitJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> result{};
  shared_ptr<string> details{};
  shared_ptr<string> ownerAccount{};

  ReportVideoSplitJobResultRequest() {}

  explicit ReportVideoSplitJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportVideoSplitJobResultRequest() = default;
};
class ReportVideoSplitJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportVideoSplitJobResultResponseBody() {}

  explicit ReportVideoSplitJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportVideoSplitJobResultResponseBody() = default;
};
class ReportVideoSplitJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportVideoSplitJobResultResponseBody> body{};

  ReportVideoSplitJobResultResponse() {}

  explicit ReportVideoSplitJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportVideoSplitJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportVideoSplitJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportVideoSplitJobResultResponse() = default;
};
class QueryMediaCensorJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};

  QueryMediaCensorJobDetailRequest() {}

  explicit QueryMediaCensorJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailRequest() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult>> result{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults> results{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult>> coverImageCensorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverImageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*coverImageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverImageCensorResult") != m.end() && !m["CoverImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverImageCensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverImageCensorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile> outputFile{};
  shared_ptr<string> videoCensor{};
  shared_ptr<string> bizType{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensor) {
      res["VideoCensor"] = boost::any(*videoCensor);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("VideoCensor") != m.end() && !m["VideoCensor"].empty()) {
      videoCensor = make_shared<string>(boost::any_cast<string>(m["VideoCensor"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline : public Darabonba::Model {
public:
  shared_ptr<string> timestamp{};
  shared_ptr<string> object{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults> censorResults{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline>> videoTimeline{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimeline) {
      vector<boost::any> temp1;
      for(auto item1:*videoTimeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoTimeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimeline") != m.end() && !m["VideoTimeline"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoTimeline"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoTimeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoTimeline = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines> videoTimelines{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults> censorResults{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimelines) {
      res["VideoTimelines"] = videoTimelines ? boost::any(videoTimelines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimelines") != m.end() && !m["VideoTimelines"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTimelines"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTimelines"]));
        videoTimelines = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults> coverImageCensorResults{};
  shared_ptr<string> state{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult> titleCensorResult{};
  shared_ptr<string> message{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput> input{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult> barrageCensorResult{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult> descCensorResult{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig> videoCensorConfig{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult> vensorCensorResult{};
  shared_ptr<string> pipelineId{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (coverImageCensorResults) {
      res["CoverImageCensorResults"] = coverImageCensorResults ? boost::any(coverImageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = titleCensorResult ? boost::any(titleCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = barrageCensorResult ? boost::any(barrageCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (descCensorResult) {
      res["DescCensorResult"] = descCensorResult ? boost::any(descCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = videoCensorConfig ? boost::any(videoCensorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (vensorCensorResult) {
      res["VensorCensorResult"] = vensorCensorResult ? boost::any(vensorCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("CoverImageCensorResults") != m.end() && !m["CoverImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverImageCensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverImageCensorResults"]));
        coverImageCensorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TitleCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TitleCensorResult"]));
        titleCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput>(model1);
      }
    }
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["BarrageCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BarrageCensorResult"]));
        barrageCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult>(model1);
      }
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescCensorResult"]));
        descCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult>(model1);
      }
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCensorConfig"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCensorConfig"]));
        videoCensorConfig = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("VensorCensorResult") != m.end() && !m["VensorCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VensorCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VensorCensorResult"]));
        vensorCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail() = default;
};
class QueryMediaCensorJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail> mediaCensorJobDetail{};

  QueryMediaCensorJobDetailResponseBody() {}

  explicit QueryMediaCensorJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mediaCensorJobDetail) {
      res["MediaCensorJobDetail"] = mediaCensorJobDetail ? boost::any(mediaCensorJobDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MediaCensorJobDetail") != m.end() && !m["MediaCensorJobDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaCensorJobDetail"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaCensorJobDetail"]));
        mediaCensorJobDetail = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBody() = default;
};
class QueryMediaCensorJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaCensorJobDetailResponseBody> body{};

  QueryMediaCensorJobDetailResponse() {}

  explicit QueryMediaCensorJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaCensorJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaCensorJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponse() = default;
};
class TagCustomPersonRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> categoryDescription{};
  shared_ptr<string> personId{};
  shared_ptr<string> personName{};
  shared_ptr<string> personDescription{};

  TagCustomPersonRequest() {}

  explicit TagCustomPersonRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (categoryDescription) {
      res["CategoryDescription"] = boost::any(*categoryDescription);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    if (personName) {
      res["PersonName"] = boost::any(*personName);
    }
    if (personDescription) {
      res["PersonDescription"] = boost::any(*personDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("CategoryDescription") != m.end() && !m["CategoryDescription"].empty()) {
      categoryDescription = make_shared<string>(boost::any_cast<string>(m["CategoryDescription"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
    if (m.find("PersonName") != m.end() && !m["PersonName"].empty()) {
      personName = make_shared<string>(boost::any_cast<string>(m["PersonName"]));
    }
    if (m.find("PersonDescription") != m.end() && !m["PersonDescription"].empty()) {
      personDescription = make_shared<string>(boost::any_cast<string>(m["PersonDescription"]));
    }
  }


  virtual ~TagCustomPersonRequest() = default;
};
class TagCustomPersonResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagCustomPersonResponseBody() {}

  explicit TagCustomPersonResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagCustomPersonResponseBody() = default;
};
class TagCustomPersonResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TagCustomPersonResponseBody> body{};

  TagCustomPersonResponse() {}

  explicit TagCustomPersonResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagCustomPersonResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagCustomPersonResponseBody>(model1);
      }
    }
  }


  virtual ~TagCustomPersonResponse() = default;
};
class CreateMcuTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> template_{};

  CreateMcuTemplateRequest() {}

  explicit CreateMcuTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~CreateMcuTemplateRequest() = default;
};
class CreateMcuTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  CreateMcuTemplateResponseBody() {}

  explicit CreateMcuTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateMcuTemplateResponseBody() = default;
};
class CreateMcuTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateMcuTemplateResponseBody> body{};

  CreateMcuTemplateResponse() {}

  explicit CreateMcuTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMcuTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMcuTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMcuTemplateResponse() = default;
};
class ListFpShotNotaryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> startOfCreatedTimeRange{};
  shared_ptr<string> endOfCreatedTimeRange{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> ownerAccount{};

  ListFpShotNotaryRequest() {}

  explicit ListFpShotNotaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (startOfCreatedTimeRange) {
      res["StartOfCreatedTimeRange"] = boost::any(*startOfCreatedTimeRange);
    }
    if (endOfCreatedTimeRange) {
      res["EndOfCreatedTimeRange"] = boost::any(*endOfCreatedTimeRange);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("StartOfCreatedTimeRange") != m.end() && !m["StartOfCreatedTimeRange"].empty()) {
      startOfCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfCreatedTimeRange"]));
    }
    if (m.find("EndOfCreatedTimeRange") != m.end() && !m["EndOfCreatedTimeRange"].empty()) {
      endOfCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfCreatedTimeRange"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListFpShotNotaryRequest() = default;
};
class ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> txHash{};
  shared_ptr<string> transactionId{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> detail{};

  ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary() {}

  explicit ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (txHash) {
      res["TxHash"] = boost::any(*txHash);
    }
    if (transactionId) {
      res["TransactionId"] = boost::any(*transactionId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TxHash") != m.end() && !m["TxHash"].empty()) {
      txHash = make_shared<string>(boost::any_cast<string>(m["TxHash"]));
    }
    if (m.find("TransactionId") != m.end() && !m["TransactionId"].empty()) {
      transactionId = make_shared<string>(boost::any_cast<string>(m["TransactionId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
  }


  virtual ~ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary() = default;
};
class ListFpShotNotaryResponseBodyFpShotNotaryList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary>> fpShotNotary{};

  ListFpShotNotaryResponseBodyFpShotNotaryList() {}

  explicit ListFpShotNotaryResponseBodyFpShotNotaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotNotary) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotNotary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotNotary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotNotary") != m.end() && !m["FpShotNotary"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotNotary"].type()) {
        vector<ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotNotary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotNotary = make_shared<vector<ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary>>(expect1);
      }
    }
  }


  virtual ~ListFpShotNotaryResponseBodyFpShotNotaryList() = default;
};
class ListFpShotNotaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListFpShotNotaryResponseBodyFpShotNotaryList> fpShotNotaryList{};
  shared_ptr<string> nextPageToken{};

  ListFpShotNotaryResponseBody() {}

  explicit ListFpShotNotaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (fpShotNotaryList) {
      res["FpShotNotaryList"] = fpShotNotaryList ? boost::any(fpShotNotaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FpShotNotaryList") != m.end() && !m["FpShotNotaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotNotaryList"].type()) {
        ListFpShotNotaryResponseBodyFpShotNotaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotNotaryList"]));
        fpShotNotaryList = make_shared<ListFpShotNotaryResponseBodyFpShotNotaryList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
  }


  virtual ~ListFpShotNotaryResponseBody() = default;
};
class ListFpShotNotaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFpShotNotaryResponseBody> body{};

  ListFpShotNotaryResponse() {}

  explicit ListFpShotNotaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFpShotNotaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFpShotNotaryResponseBody>(model1);
      }
    }
  }


  virtual ~ListFpShotNotaryResponse() = default;
};
class ReportFpShotJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> result{};
  shared_ptr<string> details{};
  shared_ptr<string> ownerAccount{};

  ReportFpShotJobResultRequest() {}

  explicit ReportFpShotJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportFpShotJobResultRequest() = default;
};
class ReportFpShotJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportFpShotJobResultResponseBody() {}

  explicit ReportFpShotJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportFpShotJobResultResponseBody() = default;
};
class ReportFpShotJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportFpShotJobResultResponseBody> body{};

  ReportFpShotJobResultResponse() {}

  explicit ReportFpShotJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportFpShotJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportFpShotJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportFpShotJobResultResponse() = default;
};
class SubmitVideoGifJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> videoGifConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitVideoGifJobRequest() {}

  explicit SubmitVideoGifJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (videoGifConfig) {
      res["VideoGifConfig"] = boost::any(*videoGifConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("VideoGifConfig") != m.end() && !m["VideoGifConfig"].empty()) {
      videoGifConfig = make_shared<string>(boost::any_cast<string>(m["VideoGifConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitVideoGifJobRequest() = default;
};
class SubmitVideoGifJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitVideoGifJobResponseBody() {}

  explicit SubmitVideoGifJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitVideoGifJobResponseBody() = default;
};
class SubmitVideoGifJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitVideoGifJobResponseBody> body{};

  SubmitVideoGifJobResponse() {}

  explicit SubmitVideoGifJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitVideoGifJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitVideoGifJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitVideoGifJobResponse() = default;
};
class QueryAnnotationJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> annotationJobIds{};
  shared_ptr<string> ownerAccount{};

  QueryAnnotationJobListRequest() {}

  explicit QueryAnnotationJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (annotationJobIds) {
      res["AnnotationJobIds"] = boost::any(*annotationJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("AnnotationJobIds") != m.end() && !m["AnnotationJobIds"].empty()) {
      annotationJobIds = make_shared<string>(boost::any_cast<string>(m["AnnotationJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryAnnotationJobListRequest() = default;
};
class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput() {}

  explicit QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput() = default;
};
class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> label{};

  QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation() {}

  explicit QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation() = default;
};
class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation>> annotation{};

  QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations() {}

  explicit QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotation) {
      vector<boost::any> temp1;
      for(auto item1:*annotation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotation"].type()) {
        vector<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotation = make_shared<vector<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation>>(expect1);
      }
    }
  }


  virtual ~QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations() = default;
};
class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult : public Darabonba::Model {
public:
  shared_ptr<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations> annotations{};
  shared_ptr<string> details{};

  QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult() {}

  explicit QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = annotations ? boost::any(annotations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Annotations"].type()) {
        QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Annotations"]));
        annotations = make_shared<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations>(model1);
      }
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
  }


  virtual ~QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult() = default;
};
class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput> input{};
  shared_ptr<string> id{};
  shared_ptr<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult> videoAnnotationResult{};

  QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob() {}

  explicit QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (videoAnnotationResult) {
      res["VideoAnnotationResult"] = videoAnnotationResult ? boost::any(videoAnnotationResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("VideoAnnotationResult") != m.end() && !m["VideoAnnotationResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoAnnotationResult"].type()) {
        QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoAnnotationResult"]));
        videoAnnotationResult = make_shared<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult>(model1);
      }
    }
  }


  virtual ~QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob() = default;
};
class QueryAnnotationJobListResponseBodyAnnotationJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob>> annotationJob{};

  QueryAnnotationJobListResponseBodyAnnotationJobList() {}

  explicit QueryAnnotationJobListResponseBodyAnnotationJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationJob) {
      vector<boost::any> temp1;
      for(auto item1:*annotationJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationJob") != m.end() && !m["AnnotationJob"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationJob"].type()) {
        vector<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationJob = make_shared<vector<QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob>>(expect1);
      }
    }
  }


  virtual ~QueryAnnotationJobListResponseBodyAnnotationJobList() = default;
};
class QueryAnnotationJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryAnnotationJobListResponseBodyNonExistIds() {}

  explicit QueryAnnotationJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryAnnotationJobListResponseBodyNonExistIds() = default;
};
class QueryAnnotationJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryAnnotationJobListResponseBodyAnnotationJobList> annotationJobList{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryAnnotationJobListResponseBodyNonExistIds> nonExistIds{};

  QueryAnnotationJobListResponseBody() {}

  explicit QueryAnnotationJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationJobList) {
      res["AnnotationJobList"] = annotationJobList ? boost::any(annotationJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationJobList") != m.end() && !m["AnnotationJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnnotationJobList"].type()) {
        QueryAnnotationJobListResponseBodyAnnotationJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnnotationJobList"]));
        annotationJobList = make_shared<QueryAnnotationJobListResponseBodyAnnotationJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryAnnotationJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryAnnotationJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryAnnotationJobListResponseBody() = default;
};
class QueryAnnotationJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryAnnotationJobListResponseBody> body{};

  QueryAnnotationJobListResponse() {}

  explicit QueryAnnotationJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAnnotationJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAnnotationJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAnnotationJobListResponse() = default;
};
class SubmitPornJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> pornConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitPornJobRequest() {}

  explicit SubmitPornJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (pornConfig) {
      res["PornConfig"] = boost::any(*pornConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PornConfig") != m.end() && !m["PornConfig"].empty()) {
      pornConfig = make_shared<string>(boost::any_cast<string>(m["PornConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitPornJobRequest() = default;
};
class SubmitPornJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitPornJobResponseBody() {}

  explicit SubmitPornJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitPornJobResponseBody() = default;
};
class SubmitPornJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitPornJobResponseBody> body{};

  SubmitPornJobResponse() {}

  explicit SubmitPornJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitPornJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitPornJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitPornJobResponse() = default;
};
class DescribeMtsUserResourcePackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};

  DescribeMtsUserResourcePackageRequest() {}

  explicit DescribeMtsUserResourcePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeMtsUserResourcePackageRequest() = default;
};
class DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> status{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> currCapacity{};
  shared_ptr<string> initCapacity{};
  shared_ptr<string> instanceId{};

  DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() {}

  explicit DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (currCapacity) {
      res["CurrCapacity"] = boost::any(*currCapacity);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CurrCapacity") != m.end() && !m["CurrCapacity"].empty()) {
      currCapacity = make_shared<string>(boost::any_cast<string>(m["CurrCapacity"]));
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<string>(boost::any_cast<string>(m["InitCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() = default;
};
class DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>> resourcePackageInfo{};

  DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos() {}

  explicit DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePackageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePackageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePackageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePackageInfo") != m.end() && !m["ResourcePackageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePackageInfo"].type()) {
        vector<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePackageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePackageInfo = make_shared<vector<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos() = default;
};
class DescribeMtsUserResourcePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos> resourcePackageInfos{};

  DescribeMtsUserResourcePackageResponseBody() {}

  explicit DescribeMtsUserResourcePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePackageInfos) {
      res["ResourcePackageInfos"] = resourcePackageInfos ? boost::any(resourcePackageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePackageInfos") != m.end() && !m["ResourcePackageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourcePackageInfos"].type()) {
        DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourcePackageInfos"]));
        resourcePackageInfos = make_shared<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos>(model1);
      }
    }
  }


  virtual ~DescribeMtsUserResourcePackageResponseBody() = default;
};
class DescribeMtsUserResourcePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMtsUserResourcePackageResponseBody> body{};

  DescribeMtsUserResourcePackageResponse() {}

  explicit DescribeMtsUserResourcePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMtsUserResourcePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMtsUserResourcePackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMtsUserResourcePackageResponse() = default;
};
class AddTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> container{};
  shared_ptr<string> video{};
  shared_ptr<string> audio{};
  shared_ptr<string> transConfig{};
  shared_ptr<string> muxConfig{};
  shared_ptr<string> ownerAccount{};

  AddTemplateRequest() {}

  explicit AddTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    if (audio) {
      res["Audio"] = boost::any(*audio);
    }
    if (transConfig) {
      res["TransConfig"] = boost::any(*transConfig);
    }
    if (muxConfig) {
      res["MuxConfig"] = boost::any(*muxConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      audio = make_shared<string>(boost::any_cast<string>(m["Audio"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      transConfig = make_shared<string>(boost::any_cast<string>(m["TransConfig"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      muxConfig = make_shared<string>(boost::any_cast<string>(m["MuxConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddTemplateRequest() = default;
};
class AddTemplateResponseBodyTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  AddTemplateResponseBodyTemplateVideoBitrateBnd() {}

  explicit AddTemplateResponseBodyTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateVideoBitrateBnd() = default;
};
class AddTemplateResponseBodyTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> degrain{};
  shared_ptr<AddTemplateResponseBodyTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> remove{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> resoPriority{};

  AddTemplateResponseBodyTemplateVideo() {}

  explicit AddTemplateResponseBodyTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        AddTemplateResponseBodyTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<AddTemplateResponseBodyTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateVideo() = default;
};
class AddTemplateResponseBodyTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  AddTemplateResponseBodyTemplateTransConfig() {}

  explicit AddTemplateResponseBodyTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateTransConfig() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  AddTemplateResponseBodyTemplateMuxConfigWebp() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigWebp() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  AddTemplateResponseBodyTemplateMuxConfigGif() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigGif() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  AddTemplateResponseBodyTemplateMuxConfigSegment() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigSegment() = default;
};
class AddTemplateResponseBodyTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigWebp> webp{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigGif> gif{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigSegment> segment{};

  AddTemplateResponseBodyTemplateMuxConfig() {}

  explicit AddTemplateResponseBodyTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<AddTemplateResponseBodyTemplateMuxConfigWebp>(model1);
      }
    }
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<AddTemplateResponseBodyTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<AddTemplateResponseBodyTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfig() = default;
};
class AddTemplateResponseBodyTemplateAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> level{};

  AddTemplateResponseBodyTemplateAudioVolume() {}

  explicit AddTemplateResponseBodyTemplateAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateAudioVolume() = default;
};
class AddTemplateResponseBodyTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<AddTemplateResponseBodyTemplateAudioVolume> volume{};
  shared_ptr<string> bitrate{};

  AddTemplateResponseBodyTemplateAudio() {}

  explicit AddTemplateResponseBodyTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        AddTemplateResponseBodyTemplateAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<AddTemplateResponseBodyTemplateAudioVolume>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateAudio() = default;
};
class AddTemplateResponseBodyTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  AddTemplateResponseBodyTemplateContainer() {}

  explicit AddTemplateResponseBodyTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateContainer() = default;
};
class AddTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<AddTemplateResponseBodyTemplateVideo> video{};
  shared_ptr<AddTemplateResponseBodyTemplateTransConfig> transConfig{};
  shared_ptr<string> state{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<AddTemplateResponseBodyTemplateAudio> audio{};
  shared_ptr<string> id{};
  shared_ptr<AddTemplateResponseBodyTemplateContainer> container{};

  AddTemplateResponseBodyTemplate() {}

  explicit AddTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        AddTemplateResponseBodyTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<AddTemplateResponseBodyTemplateVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        AddTemplateResponseBodyTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<AddTemplateResponseBodyTemplateTransConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        AddTemplateResponseBodyTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<AddTemplateResponseBodyTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        AddTemplateResponseBodyTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<AddTemplateResponseBodyTemplateAudio>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        AddTemplateResponseBodyTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<AddTemplateResponseBodyTemplateContainer>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBodyTemplate() = default;
};
class AddTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddTemplateResponseBodyTemplate> template_{};

  AddTemplateResponseBody() {}

  explicit AddTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        AddTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<AddTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBody() = default;
};
class AddTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddTemplateResponseBody> body{};

  AddTemplateResponse() {}

  explicit AddTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddTemplateResponse() = default;
};
class SubmitMCJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> video{};
  shared_ptr<string> images{};
  shared_ptr<string> texts{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> censorConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitMCJobRequest() {}

  explicit SubmitMCJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    if (images) {
      res["Images"] = boost::any(*images);
    }
    if (texts) {
      res["Texts"] = boost::any(*texts);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (censorConfig) {
      res["CensorConfig"] = boost::any(*censorConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      images = make_shared<string>(boost::any_cast<string>(m["Images"]));
    }
    if (m.find("Texts") != m.end() && !m["Texts"].empty()) {
      texts = make_shared<string>(boost::any_cast<string>(m["Texts"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("CensorConfig") != m.end() && !m["CensorConfig"].empty()) {
      censorConfig = make_shared<string>(boost::any_cast<string>(m["CensorConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitMCJobRequest() = default;
};
class SubmitMCJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitMCJobResponseBody() {}

  explicit SubmitMCJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitMCJobResponseBody() = default;
};
class SubmitMCJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitMCJobResponseBody> body{};

  SubmitMCJobResponse() {}

  explicit SubmitMCJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMCJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMCJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMCJobResponse() = default;
};
class ReportPornJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> label{};
  shared_ptr<string> detail{};
  shared_ptr<string> ownerAccount{};

  ReportPornJobResultRequest() {}

  explicit ReportPornJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportPornJobResultRequest() = default;
};
class ReportPornJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportPornJobResultResponseBody() {}

  explicit ReportPornJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportPornJobResultResponseBody() = default;
};
class ReportPornJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportPornJobResultResponseBody> body{};

  ReportPornJobResultResponse() {}

  explicit ReportPornJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportPornJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportPornJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportPornJobResultResponse() = default;
};
class UpdateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> topology{};
  shared_ptr<string> ownerAccount{};

  UpdateMediaWorkflowRequest() {}

  explicit UpdateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateMediaWorkflowRequest() = default;
};
class UpdateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<string> triggerMode{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};

  UpdateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit UpdateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~UpdateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class UpdateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};

  UpdateMediaWorkflowResponseBody() {}

  explicit UpdateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        UpdateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<UpdateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
  }


  virtual ~UpdateMediaWorkflowResponseBody() = default;
};
class UpdateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMediaWorkflowResponseBody> body{};

  UpdateMediaWorkflowResponse() {}

  explicit UpdateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaWorkflowResponse() = default;
};
class DeleteSmarttagTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> templateId{};

  DeleteSmarttagTemplateRequest() {}

  explicit DeleteSmarttagTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteSmarttagTemplateRequest() = default;
};
class DeleteSmarttagTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSmarttagTemplateResponseBody() {}

  explicit DeleteSmarttagTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSmarttagTemplateResponseBody() = default;
};
class DeleteSmarttagTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSmarttagTemplateResponseBody> body{};

  DeleteSmarttagTemplateResponse() {}

  explicit DeleteSmarttagTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSmarttagTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSmarttagTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSmarttagTemplateResponse() = default;
};
class QueryMediaWorkflowListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaWorkflowIds{};
  shared_ptr<string> ownerAccount{};

  QueryMediaWorkflowListRequest() {}

  explicit QueryMediaWorkflowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaWorkflowIds) {
      res["MediaWorkflowIds"] = boost::any(*mediaWorkflowIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaWorkflowIds") != m.end() && !m["MediaWorkflowIds"].empty()) {
      mediaWorkflowIds = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMediaWorkflowListRequest() = default;
};
class QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaWorkflowId{};

  QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds() {}

  explicit QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaWorkflowId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaWorkflowId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaWorkflowId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds() = default;
};
class QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<string> triggerMode{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};

  QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow() {}

  explicit QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow() = default;
};
class QueryMediaWorkflowListResponseBodyMediaWorkflowList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow>> mediaWorkflow{};

  QueryMediaWorkflowListResponseBodyMediaWorkflowList() {}

  explicit QueryMediaWorkflowListResponseBodyMediaWorkflowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflow"].type()) {
        vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflow = make_shared<vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyMediaWorkflowList() = default;
};
class QueryMediaWorkflowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds> nonExistMediaWorkflowIds{};
  shared_ptr<QueryMediaWorkflowListResponseBodyMediaWorkflowList> mediaWorkflowList{};
  shared_ptr<string> requestId{};

  QueryMediaWorkflowListResponseBody() {}

  explicit QueryMediaWorkflowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistMediaWorkflowIds) {
      res["NonExistMediaWorkflowIds"] = nonExistMediaWorkflowIds ? boost::any(nonExistMediaWorkflowIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowList) {
      res["MediaWorkflowList"] = mediaWorkflowList ? boost::any(mediaWorkflowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistMediaWorkflowIds") != m.end() && !m["NonExistMediaWorkflowIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaWorkflowIds"].type()) {
        QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaWorkflowIds"]));
        nonExistMediaWorkflowIds = make_shared<QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds>(model1);
      }
    }
    if (m.find("MediaWorkflowList") != m.end() && !m["MediaWorkflowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowList"].type()) {
        QueryMediaWorkflowListResponseBodyMediaWorkflowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowList"]));
        mediaWorkflowList = make_shared<QueryMediaWorkflowListResponseBodyMediaWorkflowList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaWorkflowListResponseBody() = default;
};
class QueryMediaWorkflowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaWorkflowListResponseBody> body{};

  QueryMediaWorkflowListResponse() {}

  explicit QueryMediaWorkflowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaWorkflowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaWorkflowListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaWorkflowListResponse() = default;
};
class SubmitIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> functionName{};
  shared_ptr<string> modelId{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> scheduleParams{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> input{};
  shared_ptr<string> output{};

  SubmitIProductionJobRequest() {}

  explicit SubmitIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (scheduleParams) {
      res["ScheduleParams"] = boost::any(*scheduleParams);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("ScheduleParams") != m.end() && !m["ScheduleParams"].empty()) {
      scheduleParams = make_shared<string>(boost::any_cast<string>(m["ScheduleParams"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~SubmitIProductionJobRequest() = default;
};
class SubmitIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> result{};

  SubmitIProductionJobResponseBody() {}

  explicit SubmitIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~SubmitIProductionJobResponseBody() = default;
};
class SubmitIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitIProductionJobResponseBody> body{};

  SubmitIProductionJobResponse() {}

  explicit SubmitIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitIProductionJobResponse() = default;
};
class GetLicenseRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> licenseUrl{};
  shared_ptr<string> data{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> header{};
  shared_ptr<string> type{};

  GetLicenseRequest() {}

  explicit GetLicenseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (licenseUrl) {
      res["LicenseUrl"] = boost::any(*licenseUrl);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (header) {
      res["Header"] = boost::any(*header);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("LicenseUrl") != m.end() && !m["LicenseUrl"].empty()) {
      licenseUrl = make_shared<string>(boost::any_cast<string>(m["LicenseUrl"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      header = make_shared<string>(boost::any_cast<string>(m["Header"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLicenseRequest() = default;
};
class GetLicenseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> license{};

  GetLicenseResponseBody() {}

  explicit GetLicenseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (license) {
      res["License"] = boost::any(*license);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("License") != m.end() && !m["License"].empty()) {
      license = make_shared<string>(boost::any_cast<string>(m["License"]));
    }
  }


  virtual ~GetLicenseResponseBody() = default;
};
class GetLicenseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetLicenseResponseBody> body{};

  GetLicenseResponse() {}

  explicit GetLicenseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLicenseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLicenseResponseBody>(model1);
      }
    }
  }


  virtual ~GetLicenseResponse() = default;
};
class QueryVideoSummaryJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryVideoSummaryJobListRequest() {}

  explicit QueryVideoSummaryJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryVideoSummaryJobListRequest() = default;
};
class QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary() {}

  explicit QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary() = default;
};
class QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary>> videoSummary{};

  QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList() {}

  explicit QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoSummary) {
      vector<boost::any> temp1;
      for(auto item1:*videoSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoSummary") != m.end() && !m["VideoSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoSummary"].type()) {
        vector<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoSummary = make_shared<vector<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary>>(expect1);
      }
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList() = default;
};
class QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile() {}

  explicit QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile() = default;
};
class QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult : public Darabonba::Model {
public:
  shared_ptr<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList> videoSummaryList{};
  shared_ptr<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile> outputFile{};

  QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult() {}

  explicit QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoSummaryList) {
      res["VideoSummaryList"] = videoSummaryList ? boost::any(videoSummaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoSummaryList") != m.end() && !m["VideoSummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoSummaryList"].type()) {
        QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoSummaryList"]));
        videoSummaryList = make_shared<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile>(model1);
      }
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult() = default;
};
class QueryVideoSummaryJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryVideoSummaryJobListResponseBodyJobListJobInput() {}

  explicit QueryVideoSummaryJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBodyJobListJobInput() = default;
};
class QueryVideoSummaryJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult> videoSummaryResult{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryVideoSummaryJobListResponseBodyJobListJobInput> input{};
  shared_ptr<string> id{};

  QueryVideoSummaryJobListResponseBodyJobListJob() {}

  explicit QueryVideoSummaryJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (videoSummaryResult) {
      res["VideoSummaryResult"] = videoSummaryResult ? boost::any(videoSummaryResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("VideoSummaryResult") != m.end() && !m["VideoSummaryResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoSummaryResult"].type()) {
        QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoSummaryResult"]));
        videoSummaryResult = make_shared<QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryVideoSummaryJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryVideoSummaryJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBodyJobListJob() = default;
};
class QueryVideoSummaryJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoSummaryJobListResponseBodyJobListJob>> job{};

  QueryVideoSummaryJobListResponseBodyJobList() {}

  explicit QueryVideoSummaryJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryVideoSummaryJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoSummaryJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryVideoSummaryJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBodyJobList() = default;
};
class QueryVideoSummaryJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryVideoSummaryJobListResponseBodyNonExistIds() {}

  explicit QueryVideoSummaryJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBodyNonExistIds() = default;
};
class QueryVideoSummaryJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryVideoSummaryJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryVideoSummaryJobListResponseBodyNonExistIds> nonExistIds{};

  QueryVideoSummaryJobListResponseBody() {}

  explicit QueryVideoSummaryJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryVideoSummaryJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryVideoSummaryJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryVideoSummaryJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryVideoSummaryJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryVideoSummaryJobListResponseBody() = default;
};
class QueryVideoSummaryJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryVideoSummaryJobListResponseBody> body{};

  QueryVideoSummaryJobListResponse() {}

  explicit QueryVideoSummaryJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryVideoSummaryJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryVideoSummaryJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryVideoSummaryJobListResponse() = default;
};
class SubmitSmarttagJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> title{};
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> contentAddr{};
  shared_ptr<string> params{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> userData{};
  shared_ptr<string> input{};
  shared_ptr<string> templateId{};

  SubmitSmarttagJobRequest() {}

  explicit SubmitSmarttagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (contentAddr) {
      res["ContentAddr"] = boost::any(*contentAddr);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("ContentAddr") != m.end() && !m["ContentAddr"].empty()) {
      contentAddr = make_shared<string>(boost::any_cast<string>(m["ContentAddr"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitSmarttagJobRequest() = default;
};
class SubmitSmarttagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitSmarttagJobResponseBody() {}

  explicit SubmitSmarttagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitSmarttagJobResponseBody() = default;
};
class SubmitSmarttagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitSmarttagJobResponseBody> body{};

  SubmitSmarttagJobResponse() {}

  explicit SubmitSmarttagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSmarttagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSmarttagJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSmarttagJobResponse() = default;
};
class QuerySmarttagJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> jobId{};

  QuerySmarttagJobRequest() {}

  explicit QuerySmarttagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QuerySmarttagJobRequest() = default;
};
class QuerySmarttagJobResponseBodyResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> data{};

  QuerySmarttagJobResponseBodyResultsResult() {}

  explicit QuerySmarttagJobResponseBodyResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~QuerySmarttagJobResponseBodyResultsResult() = default;
};
class QuerySmarttagJobResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmarttagJobResponseBodyResultsResult>> result{};

  QuerySmarttagJobResponseBodyResults() {}

  explicit QuerySmarttagJobResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QuerySmarttagJobResponseBodyResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmarttagJobResponseBodyResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QuerySmarttagJobResponseBodyResultsResult>>(expect1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponseBodyResults() = default;
};
class QuerySmarttagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> userData{};
  shared_ptr<QuerySmarttagJobResponseBodyResults> results{};

  QuerySmarttagJobResponseBody() {}

  explicit QuerySmarttagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QuerySmarttagJobResponseBodyResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QuerySmarttagJobResponseBodyResults>(model1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponseBody() = default;
};
class QuerySmarttagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySmarttagJobResponseBody> body{};

  QuerySmarttagJobResponse() {}

  explicit QuerySmarttagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmarttagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmarttagJobResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponse() = default;
};
class UpdateMediaCoverRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> ownerAccount{};

  UpdateMediaCoverRequest() {}

  explicit UpdateMediaCoverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateMediaCoverRequest() = default;
};
class UpdateMediaCoverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaCoverResponseBody() {}

  explicit UpdateMediaCoverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaCoverResponseBody() = default;
};
class UpdateMediaCoverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMediaCoverResponseBody> body{};

  UpdateMediaCoverResponse() {}

  explicit UpdateMediaCoverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaCoverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaCoverResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaCoverResponse() = default;
};
class QueryIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};

  QueryIProductionJobRequest() {}

  explicit QueryIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryIProductionJobRequest() = default;
};
class QueryIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<string> input{};
  shared_ptr<string> requestId{};
  shared_ptr<string> userData{};
  shared_ptr<string> state{};
  shared_ptr<string> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> jobId{};
  shared_ptr<string> result{};

  QueryIProductionJobResponseBody() {}

  explicit QueryIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~QueryIProductionJobResponseBody() = default;
};
class QueryIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryIProductionJobResponseBody> body{};

  QueryIProductionJobResponse() {}

  explicit QueryIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIProductionJobResponse() = default;
};
class ListMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> from{};
  shared_ptr<string> to{};
  shared_ptr<string> ownerAccount{};

  ListMediaRequest() {}

  explicit ListMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListMediaRequest() = default;
};
class ListMediaResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  ListMediaResponseBodyMediaListMediaTags() {}

  explicit ListMediaResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMediaResponseBodyMediaListMediaTags() = default;
};
class ListMediaResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  ListMediaResponseBodyMediaListMediaFile() {}

  explicit ListMediaResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~ListMediaResponseBodyMediaListMediaFile() = default;
};
class ListMediaResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  ListMediaResponseBodyMediaListMediaRunIdList() {}

  explicit ListMediaResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMediaResponseBodyMediaListMediaRunIdList() = default;
};
class ListMediaResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> cateId{};
  shared_ptr<string> height{};
  shared_ptr<string> censorState{};
  shared_ptr<ListMediaResponseBodyMediaListMediaTags> tags{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> mediaId{};
  shared_ptr<ListMediaResponseBodyMediaListMediaFile> file{};
  shared_ptr<string> publishState{};
  shared_ptr<string> description{};
  shared_ptr<string> width{};
  shared_ptr<string> size{};
  shared_ptr<string> coverURL{};
  shared_ptr<ListMediaResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> title{};
  shared_ptr<string> format{};

  ListMediaResponseBodyMediaListMedia() {}

  explicit ListMediaResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListMediaResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListMediaResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        ListMediaResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<ListMediaResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        ListMediaResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<ListMediaResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~ListMediaResponseBodyMediaListMedia() = default;
};
class ListMediaResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaResponseBodyMediaListMedia>> media{};

  ListMediaResponseBodyMediaList() {}

  explicit ListMediaResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<ListMediaResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<ListMediaResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~ListMediaResponseBodyMediaList() = default;
};
class ListMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMediaResponseBodyMediaList> mediaList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};

  ListMediaResponseBody() {}

  explicit ListMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        ListMediaResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<ListMediaResponseBodyMediaList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
  }


  virtual ~ListMediaResponseBody() = default;
};
class ListMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMediaResponseBody> body{};

  ListMediaResponse() {}

  explicit ListMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaResponse() = default;
};
class GetPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> data{};

  GetPackageRequest() {}

  explicit GetPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~GetPackageRequest() = default;
};
class GetPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certPackage{};
  shared_ptr<string> requestId{};

  GetPackageResponseBody() {}

  explicit GetPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certPackage) {
      res["CertPackage"] = boost::any(*certPackage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertPackage") != m.end() && !m["CertPackage"].empty()) {
      certPackage = make_shared<string>(boost::any_cast<string>(m["CertPackage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPackageResponseBody() = default;
};
class GetPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetPackageResponseBody> body{};

  GetPackageResponse() {}

  explicit GetPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPackageResponseBody>(model1);
      }
    }
  }


  virtual ~GetPackageResponse() = default;
};
class UpdateWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> name{};
  shared_ptr<string> config{};
  shared_ptr<string> ownerAccount{};

  UpdateWaterMarkTemplateRequest() {}

  explicit UpdateWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateRequest() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> dy{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> duration{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> name{};
  shared_ptr<string> dy{};
  shared_ptr<string> id{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate() = default;
};
class UpdateWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate> waterMarkTemplate{};
  shared_ptr<string> requestId{};

  UpdateWaterMarkTemplateResponseBody() {}

  explicit UpdateWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMarkTemplate) {
      res["WaterMarkTemplate"] = waterMarkTemplate ? boost::any(waterMarkTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplate"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplate"]));
        waterMarkTemplate = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBody() = default;
};
class UpdateWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateWaterMarkTemplateResponseBody> body{};

  UpdateWaterMarkTemplateResponse() {}

  explicit UpdateWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWaterMarkTemplateResponse() = default;
};
class QueryMcuTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> templateId{};

  QueryMcuTemplateRequest() {}

  explicit QueryMcuTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~QueryMcuTemplateRequest() = default;
};
class QueryMcuTemplateResponseBodyTemplatesJob : public Darabonba::Model {
public:
  shared_ptr<string> template_{};
  shared_ptr<string> templateId{};

  QueryMcuTemplateResponseBodyTemplatesJob() {}

  explicit QueryMcuTemplateResponseBodyTemplatesJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~QueryMcuTemplateResponseBodyTemplatesJob() = default;
};
class QueryMcuTemplateResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuTemplateResponseBodyTemplatesJob>> job{};

  QueryMcuTemplateResponseBodyTemplates() {}

  explicit QueryMcuTemplateResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryMcuTemplateResponseBodyTemplatesJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuTemplateResponseBodyTemplatesJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryMcuTemplateResponseBodyTemplatesJob>>(expect1);
      }
    }
  }


  virtual ~QueryMcuTemplateResponseBodyTemplates() = default;
};
class QueryMcuTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryMcuTemplateResponseBodyTemplates> templates{};

  QueryMcuTemplateResponseBody() {}

  explicit QueryMcuTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      res["Templates"] = templates ? boost::any(templates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Templates"].type()) {
        QueryMcuTemplateResponseBodyTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Templates"]));
        templates = make_shared<QueryMcuTemplateResponseBodyTemplates>(model1);
      }
    }
  }


  virtual ~QueryMcuTemplateResponseBody() = default;
};
class QueryMcuTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMcuTemplateResponseBody> body{};

  QueryMcuTemplateResponse() {}

  explicit QueryMcuTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMcuTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMcuTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMcuTemplateResponse() = default;
};
class ActivateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};

  ActivateMediaWorkflowRequest() {}

  explicit ActivateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ActivateMediaWorkflowRequest() = default;
};
class ActivateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};

  ActivateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit ActivateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~ActivateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class ActivateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ActivateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};

  ActivateMediaWorkflowResponseBody() {}

  explicit ActivateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        ActivateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<ActivateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
  }


  virtual ~ActivateMediaWorkflowResponseBody() = default;
};
class ActivateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ActivateMediaWorkflowResponseBody> body{};

  ActivateMediaWorkflowResponse() {}

  explicit ActivateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateMediaWorkflowResponse() = default;
};
class SearchMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> from{};
  shared_ptr<string> to{};
  shared_ptr<string> keyWord{};
  shared_ptr<string> title{};
  shared_ptr<string> description{};
  shared_ptr<string> tag{};
  shared_ptr<string> cateId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  SearchMediaRequest() {}

  explicit SearchMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<string>(boost::any_cast<string>(m["CateId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SearchMediaRequest() = default;
};
class SearchMediaResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  SearchMediaResponseBodyMediaListMediaTags() {}

  explicit SearchMediaResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchMediaResponseBodyMediaListMediaTags() = default;
};
class SearchMediaResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  SearchMediaResponseBodyMediaListMediaFile() {}

  explicit SearchMediaResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListMediaFile() = default;
};
class SearchMediaResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  SearchMediaResponseBodyMediaListMediaRunIdList() {}

  explicit SearchMediaResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchMediaResponseBodyMediaListMediaRunIdList() = default;
};
class SearchMediaResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> cateId{};
  shared_ptr<string> height{};
  shared_ptr<SearchMediaResponseBodyMediaListMediaTags> tags{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> mediaId{};
  shared_ptr<SearchMediaResponseBodyMediaListMediaFile> file{};
  shared_ptr<string> publishState{};
  shared_ptr<string> description{};
  shared_ptr<string> width{};
  shared_ptr<string> size{};
  shared_ptr<string> coverURL{};
  shared_ptr<SearchMediaResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> title{};
  shared_ptr<string> format{};

  SearchMediaResponseBodyMediaListMedia() {}

  explicit SearchMediaResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        SearchMediaResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<SearchMediaResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SearchMediaResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SearchMediaResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        SearchMediaResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<SearchMediaResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListMedia() = default;
};
class SearchMediaResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaResponseBodyMediaListMedia>> media{};

  SearchMediaResponseBodyMediaList() {}

  explicit SearchMediaResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<SearchMediaResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<SearchMediaResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~SearchMediaResponseBodyMediaList() = default;
};
class SearchMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchMediaResponseBodyMediaList> mediaList{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};

  SearchMediaResponseBody() {}

  explicit SearchMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        SearchMediaResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<SearchMediaResponseBodyMediaList>(model1);
      }
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~SearchMediaResponseBody() = default;
};
class SearchMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SearchMediaResponseBody> body{};

  SearchMediaResponse() {}

  explicit SearchMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaResponse() = default;
};
class SubmitTerrorismJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> terrorismConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitTerrorismJobRequest() {}

  explicit SubmitTerrorismJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (terrorismConfig) {
      res["TerrorismConfig"] = boost::any(*terrorismConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("TerrorismConfig") != m.end() && !m["TerrorismConfig"].empty()) {
      terrorismConfig = make_shared<string>(boost::any_cast<string>(m["TerrorismConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitTerrorismJobRequest() = default;
};
class SubmitTerrorismJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitTerrorismJobResponseBody() {}

  explicit SubmitTerrorismJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitTerrorismJobResponseBody() = default;
};
class SubmitTerrorismJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitTerrorismJobResponseBody> body{};

  SubmitTerrorismJobResponse() {}

  explicit SubmitTerrorismJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTerrorismJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTerrorismJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTerrorismJobResponse() = default;
};
class AddCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> parentId{};
  shared_ptr<string> ownerAccount{};

  AddCategoryRequest() {}

  explicit AddCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddCategoryRequest() = default;
};
class AddCategoryResponseBodyCategory : public Darabonba::Model {
public:
  shared_ptr<string> cateName{};
  shared_ptr<string> parentId{};
  shared_ptr<string> cateId{};
  shared_ptr<string> level{};

  AddCategoryResponseBodyCategory() {}

  explicit AddCategoryResponseBodyCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<string>(boost::any_cast<string>(m["CateId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~AddCategoryResponseBodyCategory() = default;
};
class AddCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCategoryResponseBodyCategory> category{};
  shared_ptr<string> requestId{};

  AddCategoryResponseBody() {}

  explicit AddCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = category ? boost::any(category->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(map<string, boost::any>) == m["Category"].type()) {
        AddCategoryResponseBodyCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Category"]));
        category = make_shared<AddCategoryResponseBodyCategory>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCategoryResponseBody() = default;
};
class AddCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddCategoryResponseBody> body{};

  AddCategoryResponse() {}

  explicit AddCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~AddCategoryResponse() = default;
};
class QueryInnerJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};

  QueryInnerJobRequest() {}

  explicit QueryInnerJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryInnerJobRequest() = default;
};
class QueryInnerJobResponseBodyVideo : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<long> result{};
  shared_ptr<string> code{};

  QueryInnerJobResponseBodyVideo() {}

  explicit QueryInnerJobResponseBodyVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~QueryInnerJobResponseBodyVideo() = default;
};
class QueryInnerJobResponseBodyImageResult : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<long> result{};
  shared_ptr<string> code{};

  QueryInnerJobResponseBodyImageResult() {}

  explicit QueryInnerJobResponseBodyImageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~QueryInnerJobResponseBodyImageResult() = default;
};
class QueryInnerJobResponseBodyImage : public Darabonba::Model {
public:
  shared_ptr<vector<QueryInnerJobResponseBodyImageResult>> result{};

  QueryInnerJobResponseBodyImage() {}

  explicit QueryInnerJobResponseBodyImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryInnerJobResponseBodyImageResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryInnerJobResponseBodyImageResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryInnerJobResponseBodyImageResult>>(expect1);
      }
    }
  }


  virtual ~QueryInnerJobResponseBodyImage() = default;
};
class QueryInnerJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryInnerJobResponseBodyVideo> video{};
  shared_ptr<QueryInnerJobResponseBodyImage> image{};

  QueryInnerJobResponseBody() {}

  explicit QueryInnerJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (image) {
      res["Image"] = image ? boost::any(image->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryInnerJobResponseBodyVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryInnerJobResponseBodyVideo>(model1);
      }
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(map<string, boost::any>) == m["Image"].type()) {
        QueryInnerJobResponseBodyImage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Image"]));
        image = make_shared<QueryInnerJobResponseBodyImage>(model1);
      }
    }
  }


  virtual ~QueryInnerJobResponseBody() = default;
};
class QueryInnerJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryInnerJobResponseBody> body{};

  QueryInnerJobResponse() {}

  explicit QueryInnerJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryInnerJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryInnerJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryInnerJobResponse() = default;
};
class ListFpShotFilesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> ownerAccount{};

  ListFpShotFilesRequest() {}

  explicit ListFpShotFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListFpShotFilesRequest() = default;
};
class ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile() {}

  explicit ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile() = default;
};
class ListFpShotFilesResponseBodyFpShotFileListFpShotFile : public Darabonba::Model {
public:
  shared_ptr<string> primaryKey{};
  shared_ptr<ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile> inputFile{};
  shared_ptr<string> fileId{};

  ListFpShotFilesResponseBodyFpShotFileListFpShotFile() {}

  explicit ListFpShotFilesResponseBodyFpShotFileListFpShotFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile>(model1);
      }
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~ListFpShotFilesResponseBodyFpShotFileListFpShotFile() = default;
};
class ListFpShotFilesResponseBodyFpShotFileList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFpShotFilesResponseBodyFpShotFileListFpShotFile>> fpShotFile{};

  ListFpShotFilesResponseBodyFpShotFileList() {}

  explicit ListFpShotFilesResponseBodyFpShotFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotFile) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotFile){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotFile"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotFile") != m.end() && !m["FpShotFile"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotFile"].type()) {
        vector<ListFpShotFilesResponseBodyFpShotFileListFpShotFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotFile"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFpShotFilesResponseBodyFpShotFileListFpShotFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotFile = make_shared<vector<ListFpShotFilesResponseBodyFpShotFileListFpShotFile>>(expect1);
      }
    }
  }


  virtual ~ListFpShotFilesResponseBodyFpShotFileList() = default;
};
class ListFpShotFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<ListFpShotFilesResponseBodyFpShotFileList> fpShotFileList{};

  ListFpShotFilesResponseBody() {}

  explicit ListFpShotFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (fpShotFileList) {
      res["FpShotFileList"] = fpShotFileList ? boost::any(fpShotFileList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("FpShotFileList") != m.end() && !m["FpShotFileList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotFileList"].type()) {
        ListFpShotFilesResponseBodyFpShotFileList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotFileList"]));
        fpShotFileList = make_shared<ListFpShotFilesResponseBodyFpShotFileList>(model1);
      }
    }
  }


  virtual ~ListFpShotFilesResponseBody() = default;
};
class ListFpShotFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFpShotFilesResponseBody> body{};

  ListFpShotFilesResponse() {}

  explicit ListFpShotFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFpShotFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFpShotFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFpShotFilesResponse() = default;
};
class QueryTerrorismPipelineListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineIds{};
  shared_ptr<string> ownerAccount{};

  QueryTerrorismPipelineListRequest() {}

  explicit QueryTerrorismPipelineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineIds) {
      res["PipelineIds"] = boost::any(*pipelineIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineIds") != m.end() && !m["PipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["PipelineIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryTerrorismPipelineListRequest() = default;
};
class QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class QueryTerrorismPipelineListResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  QueryTerrorismPipelineListResponseBodyPipelineListPipeline() {}

  explicit QueryTerrorismPipelineListResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryTerrorismPipelineListResponseBodyPipelineListPipeline() = default;
};
class QueryTerrorismPipelineListResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTerrorismPipelineListResponseBodyPipelineListPipeline>> pipeline{};

  QueryTerrorismPipelineListResponseBodyPipelineList() {}

  explicit QueryTerrorismPipelineListResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<QueryTerrorismPipelineListResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTerrorismPipelineListResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<QueryTerrorismPipelineListResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~QueryTerrorismPipelineListResponseBodyPipelineList() = default;
};
class QueryTerrorismPipelineListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryTerrorismPipelineListResponseBodyNonExistIds() {}

  explicit QueryTerrorismPipelineListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTerrorismPipelineListResponseBodyNonExistIds() = default;
};
class QueryTerrorismPipelineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryTerrorismPipelineListResponseBodyPipelineList> pipelineList{};
  shared_ptr<QueryTerrorismPipelineListResponseBodyNonExistIds> nonExistIds{};

  QueryTerrorismPipelineListResponseBody() {}

  explicit QueryTerrorismPipelineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        QueryTerrorismPipelineListResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<QueryTerrorismPipelineListResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryTerrorismPipelineListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryTerrorismPipelineListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryTerrorismPipelineListResponseBody() = default;
};
class QueryTerrorismPipelineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryTerrorismPipelineListResponseBody> body{};

  QueryTerrorismPipelineListResponse() {}

  explicit QueryTerrorismPipelineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTerrorismPipelineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTerrorismPipelineListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTerrorismPipelineListResponse() = default;
};
class AddMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> fileURL{};
  shared_ptr<string> title{};
  shared_ptr<string> description{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> tags{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowUserData{};
  shared_ptr<bool> inputUnbind{};
  shared_ptr<long> cateId{};
  shared_ptr<string> overrideParams{};
  shared_ptr<string> ownerAccount{};

  AddMediaRequest() {}

  explicit AddMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowUserData) {
      res["MediaWorkflowUserData"] = boost::any(*mediaWorkflowUserData);
    }
    if (inputUnbind) {
      res["InputUnbind"] = boost::any(*inputUnbind);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (overrideParams) {
      res["OverrideParams"] = boost::any(*overrideParams);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowUserData") != m.end() && !m["MediaWorkflowUserData"].empty()) {
      mediaWorkflowUserData = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowUserData"]));
    }
    if (m.find("InputUnbind") != m.end() && !m["InputUnbind"].empty()) {
      inputUnbind = make_shared<bool>(boost::any_cast<bool>(m["InputUnbind"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("OverrideParams") != m.end() && !m["OverrideParams"].empty()) {
      overrideParams = make_shared<string>(boost::any_cast<string>(m["OverrideParams"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddMediaRequest() = default;
};
class AddMediaResponseBodyMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  AddMediaResponseBodyMediaTags() {}

  explicit AddMediaResponseBodyMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddMediaResponseBodyMediaTags() = default;
};
class AddMediaResponseBodyMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  AddMediaResponseBodyMediaFile() {}

  explicit AddMediaResponseBodyMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~AddMediaResponseBodyMediaFile() = default;
};
class AddMediaResponseBodyMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  AddMediaResponseBodyMediaRunIdList() {}

  explicit AddMediaResponseBodyMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddMediaResponseBodyMediaRunIdList() = default;
};
class AddMediaResponseBodyMedia : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> cateId{};
  shared_ptr<string> height{};
  shared_ptr<string> censorState{};
  shared_ptr<AddMediaResponseBodyMediaTags> tags{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> mediaId{};
  shared_ptr<AddMediaResponseBodyMediaFile> file{};
  shared_ptr<string> publishState{};
  shared_ptr<string> description{};
  shared_ptr<string> width{};
  shared_ptr<string> size{};
  shared_ptr<string> coverURL{};
  shared_ptr<AddMediaResponseBodyMediaRunIdList> runIdList{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> title{};
  shared_ptr<string> format{};

  AddMediaResponseBodyMedia() {}

  explicit AddMediaResponseBodyMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        AddMediaResponseBodyMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<AddMediaResponseBodyMediaTags>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        AddMediaResponseBodyMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<AddMediaResponseBodyMediaFile>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        AddMediaResponseBodyMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<AddMediaResponseBodyMediaRunIdList>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~AddMediaResponseBodyMedia() = default;
};
class AddMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddMediaResponseBodyMedia> media{};

  AddMediaResponseBody() {}

  explicit AddMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (media) {
      res["Media"] = media ? boost::any(media->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(map<string, boost::any>) == m["Media"].type()) {
        AddMediaResponseBodyMedia model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Media"]));
        media = make_shared<AddMediaResponseBodyMedia>(model1);
      }
    }
  }


  virtual ~AddMediaResponseBody() = default;
};
class AddMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddMediaResponseBody> body{};

  AddMediaResponse() {}

  explicit AddMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaResponse() = default;
};
class StopIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};

  StopIProductionJobRequest() {}

  explicit StopIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~StopIProductionJobRequest() = default;
};
class StopIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  StopIProductionJobResponseBody() {}

  explicit StopIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~StopIProductionJobResponseBody() = default;
};
class StopIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopIProductionJobResponseBody> body{};

  StopIProductionJobResponse() {}

  explicit StopIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~StopIProductionJobResponse() = default;
};
class DeleteMcuTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> templateId{};

  DeleteMcuTemplateRequest() {}

  explicit DeleteMcuTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteMcuTemplateRequest() = default;
};
class DeleteMcuTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  DeleteMcuTemplateResponseBody() {}

  explicit DeleteMcuTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteMcuTemplateResponseBody() = default;
};
class DeleteMcuTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMcuTemplateResponseBody> body{};

  DeleteMcuTemplateResponse() {}

  explicit DeleteMcuTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMcuTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMcuTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMcuTemplateResponse() = default;
};
class QueryMediaCensorJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> state{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> pipelineId{};

  QueryMediaCensorJobListRequest() {}

  explicit QueryMediaCensorJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~QueryMediaCensorJobListRequest() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult>> result{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults> results{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult>> coverImageCensorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverImageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*coverImageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverImageCensorResult") != m.end() && !m["CoverImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverImageCensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverImageCensorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile> outputFile{};
  shared_ptr<string> videoCensor{};
  shared_ptr<string> bizType{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensor) {
      res["VideoCensor"] = boost::any(*videoCensor);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("VideoCensor") != m.end() && !m["VideoCensor"].empty()) {
      videoCensor = make_shared<string>(boost::any_cast<string>(m["VideoCensor"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline : public Darabonba::Model {
public:
  shared_ptr<string> timestamp{};
  shared_ptr<string> object{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults> censorResults{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline>> videoTimeline{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimeline) {
      vector<boost::any> temp1;
      for(auto item1:*videoTimeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoTimeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimeline") != m.end() && !m["VideoTimeline"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoTimeline"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoTimeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoTimeline = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> rate{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines> videoTimelines{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults> censorResults{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimelines) {
      res["VideoTimelines"] = videoTimelines ? boost::any(videoTimelines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimelines") != m.end() && !m["VideoTimelines"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTimelines"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTimelines"]));
        videoTimelines = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults> coverImageCensorResults{};
  shared_ptr<string> state{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult> titleCensorResult{};
  shared_ptr<string> message{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput> input{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult> barrageCensorResult{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult> descCensorResult{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig> videoCensorConfig{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult> vensorCensorResult{};
  shared_ptr<string> pipelineId{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (coverImageCensorResults) {
      res["CoverImageCensorResults"] = coverImageCensorResults ? boost::any(coverImageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = titleCensorResult ? boost::any(titleCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = barrageCensorResult ? boost::any(barrageCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (descCensorResult) {
      res["DescCensorResult"] = descCensorResult ? boost::any(descCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = videoCensorConfig ? boost::any(videoCensorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (vensorCensorResult) {
      res["VensorCensorResult"] = vensorCensorResult ? boost::any(vensorCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("CoverImageCensorResults") != m.end() && !m["CoverImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverImageCensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverImageCensorResults"]));
        coverImageCensorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TitleCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TitleCensorResult"]));
        titleCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput>(model1);
      }
    }
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["BarrageCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BarrageCensorResult"]));
        barrageCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult>(model1);
      }
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescCensorResult"]));
        descCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult>(model1);
      }
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCensorConfig"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCensorConfig"]));
        videoCensorConfig = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("VensorCensorResult") != m.end() && !m["VensorCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VensorCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VensorCensorResult"]));
        vensorCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob>> mediaCensorJob{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobList() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJob) {
      vector<boost::any> temp1;
      for(auto item1:*mediaCensorJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaCensorJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJob") != m.end() && !m["MediaCensorJob"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaCensorJob"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaCensorJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaCensorJob = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobList() = default;
};
class QueryMediaCensorJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaCensorJobListResponseBodyNonExistIds() {}

  explicit QueryMediaCensorJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyNonExistIds() = default;
};
class QueryMediaCensorJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobList> mediaCensorJobList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobListResponseBodyNonExistIds> nonExistIds{};

  QueryMediaCensorJobListResponseBody() {}

  explicit QueryMediaCensorJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJobList) {
      res["MediaCensorJobList"] = mediaCensorJobList ? boost::any(mediaCensorJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJobList") != m.end() && !m["MediaCensorJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaCensorJobList"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaCensorJobList"]));
        mediaCensorJobList = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryMediaCensorJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryMediaCensorJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBody() = default;
};
class QueryMediaCensorJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaCensorJobListResponseBody> body{};

  QueryMediaCensorJobListResponse() {}

  explicit QueryMediaCensorJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaCensorJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaCensorJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponse() = default;
};
class ListPornPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> state{};
  shared_ptr<string> ownerAccount{};

  ListPornPipelineRequest() {}

  explicit ListPornPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListPornPipelineRequest() = default;
};
class ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class ListPornPipelineResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListPornPipelineResponseBodyPipelineListPipeline() {}

  explicit ListPornPipelineResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListPornPipelineResponseBodyPipelineListPipeline() = default;
};
class ListPornPipelineResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<ListPornPipelineResponseBodyPipelineListPipeline>> pipeline{};

  ListPornPipelineResponseBodyPipelineList() {}

  explicit ListPornPipelineResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<ListPornPipelineResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPornPipelineResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<ListPornPipelineResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~ListPornPipelineResponseBodyPipelineList() = default;
};
class ListPornPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<ListPornPipelineResponseBodyPipelineList> pipelineList{};

  ListPornPipelineResponseBody() {}

  explicit ListPornPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        ListPornPipelineResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<ListPornPipelineResponseBodyPipelineList>(model1);
      }
    }
  }


  virtual ~ListPornPipelineResponseBody() = default;
};
class ListPornPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListPornPipelineResponseBody> body{};

  ListPornPipelineResponse() {}

  explicit ListPornPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPornPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPornPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~ListPornPipelineResponse() = default;
};
class AddTerrorismPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};

  AddTerrorismPipelineRequest() {}

  explicit AddTerrorismPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddTerrorismPipelineRequest() = default;
};
class AddTerrorismPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  AddTerrorismPipelineResponseBodyPipelineNotifyConfig() {}

  explicit AddTerrorismPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~AddTerrorismPipelineResponseBodyPipelineNotifyConfig() = default;
};
class AddTerrorismPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<AddTerrorismPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  AddTerrorismPipelineResponseBodyPipeline() {}

  explicit AddTerrorismPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        AddTerrorismPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<AddTerrorismPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~AddTerrorismPipelineResponseBodyPipeline() = default;
};
class AddTerrorismPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddTerrorismPipelineResponseBodyPipeline> pipeline{};

  AddTerrorismPipelineResponseBody() {}

  explicit AddTerrorismPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        AddTerrorismPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<AddTerrorismPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~AddTerrorismPipelineResponseBody() = default;
};
class AddTerrorismPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddTerrorismPipelineResponseBody> body{};

  AddTerrorismPipelineResponse() {}

  explicit AddTerrorismPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTerrorismPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTerrorismPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~AddTerrorismPipelineResponse() = default;
};
class CreateFpShotDBRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<long> modelId{};
  shared_ptr<string> config{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};

  CreateFpShotDBRequest() {}

  explicit CreateFpShotDBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<long>(boost::any_cast<long>(m["ModelId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CreateFpShotDBRequest() = default;
};
class CreateFpShotDBResponseBodyFpShotDB : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> state{};
  shared_ptr<string> name{};
  shared_ptr<string> fpDBId{};
  shared_ptr<long> modelId{};
  shared_ptr<string> config{};

  CreateFpShotDBResponseBodyFpShotDB() {}

  explicit CreateFpShotDBResponseBodyFpShotDB(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<long>(boost::any_cast<long>(m["ModelId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
  }


  virtual ~CreateFpShotDBResponseBodyFpShotDB() = default;
};
class CreateFpShotDBResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateFpShotDBResponseBodyFpShotDB> fpShotDB{};

  CreateFpShotDBResponseBody() {}

  explicit CreateFpShotDBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (fpShotDB) {
      res["FpShotDB"] = fpShotDB ? boost::any(fpShotDB->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FpShotDB") != m.end() && !m["FpShotDB"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotDB"].type()) {
        CreateFpShotDBResponseBodyFpShotDB model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotDB"]));
        fpShotDB = make_shared<CreateFpShotDBResponseBodyFpShotDB>(model1);
      }
    }
  }


  virtual ~CreateFpShotDBResponseBody() = default;
};
class CreateFpShotDBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFpShotDBResponseBody> body{};

  CreateFpShotDBResponse() {}

  explicit CreateFpShotDBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFpShotDBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFpShotDBResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFpShotDBResponse() = default;
};
class UnregisterCustomFaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> personId{};
  shared_ptr<string> faceId{};

  UnregisterCustomFaceRequest() {}

  explicit UnregisterCustomFaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
  }


  virtual ~UnregisterCustomFaceRequest() = default;
};
class UnregisterCustomFaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnregisterCustomFaceResponseBody() {}

  explicit UnregisterCustomFaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnregisterCustomFaceResponseBody() = default;
};
class UnregisterCustomFaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnregisterCustomFaceResponseBody> body{};

  UnregisterCustomFaceResponse() {}

  explicit UnregisterCustomFaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnregisterCustomFaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnregisterCustomFaceResponseBody>(model1);
      }
    }
  }


  virtual ~UnregisterCustomFaceResponse() = default;
};
class QuerySmarttagTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> templateId{};

  QuerySmarttagTemplateListRequest() {}

  explicit QuerySmarttagTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~QuerySmarttagTemplateListRequest() = default;
};
class QuerySmarttagTemplateListResponseBodyTemplatesTemplate : public Darabonba::Model {
public:
  shared_ptr<string> analyseTypes{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateId{};
  shared_ptr<string> faceCategoryIds{};
  shared_ptr<string> scene{};

  QuerySmarttagTemplateListResponseBodyTemplatesTemplate() {}

  explicit QuerySmarttagTemplateListResponseBodyTemplatesTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analyseTypes) {
      res["AnalyseTypes"] = boost::any(*analyseTypes);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (faceCategoryIds) {
      res["FaceCategoryIds"] = boost::any(*faceCategoryIds);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalyseTypes") != m.end() && !m["AnalyseTypes"].empty()) {
      analyseTypes = make_shared<string>(boost::any_cast<string>(m["AnalyseTypes"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("FaceCategoryIds") != m.end() && !m["FaceCategoryIds"].empty()) {
      faceCategoryIds = make_shared<string>(boost::any_cast<string>(m["FaceCategoryIds"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
  }


  virtual ~QuerySmarttagTemplateListResponseBodyTemplatesTemplate() = default;
};
class QuerySmarttagTemplateListResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmarttagTemplateListResponseBodyTemplatesTemplate>> template_{};

  QuerySmarttagTemplateListResponseBodyTemplates() {}

  explicit QuerySmarttagTemplateListResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QuerySmarttagTemplateListResponseBodyTemplatesTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmarttagTemplateListResponseBodyTemplatesTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QuerySmarttagTemplateListResponseBodyTemplatesTemplate>>(expect1);
      }
    }
  }


  virtual ~QuerySmarttagTemplateListResponseBodyTemplates() = default;
};
class QuerySmarttagTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QuerySmarttagTemplateListResponseBodyTemplates> templates{};

  QuerySmarttagTemplateListResponseBody() {}

  explicit QuerySmarttagTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      res["Templates"] = templates ? boost::any(templates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Templates"].type()) {
        QuerySmarttagTemplateListResponseBodyTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Templates"]));
        templates = make_shared<QuerySmarttagTemplateListResponseBodyTemplates>(model1);
      }
    }
  }


  virtual ~QuerySmarttagTemplateListResponseBody() = default;
};
class QuerySmarttagTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySmarttagTemplateListResponseBody> body{};

  QuerySmarttagTemplateListResponse() {}

  explicit QuerySmarttagTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmarttagTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmarttagTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmarttagTemplateListResponse() = default;
};
class SubmitFpShotJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> fpShotConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitFpShotJobRequest() {}

  explicit SubmitFpShotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (fpShotConfig) {
      res["FpShotConfig"] = boost::any(*fpShotConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("FpShotConfig") != m.end() && !m["FpShotConfig"].empty()) {
      fpShotConfig = make_shared<string>(boost::any_cast<string>(m["FpShotConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitFpShotJobRequest() = default;
};
class SubmitFpShotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitFpShotJobResponseBody() {}

  explicit SubmitFpShotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitFpShotJobResponseBody() = default;
};
class SubmitFpShotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitFpShotJobResponseBody> body{};

  SubmitFpShotJobResponse() {}

  explicit SubmitFpShotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFpShotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFpShotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFpShotJobResponse() = default;
};
class QueryCensorPipelineListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineIds{};
  shared_ptr<string> ownerAccount{};

  QueryCensorPipelineListRequest() {}

  explicit QueryCensorPipelineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineIds) {
      res["PipelineIds"] = boost::any(*pipelineIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineIds") != m.end() && !m["PipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["PipelineIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryCensorPipelineListRequest() = default;
};
class QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class QueryCensorPipelineListResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  QueryCensorPipelineListResponseBodyPipelineListPipeline() {}

  explicit QueryCensorPipelineListResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryCensorPipelineListResponseBodyPipelineListPipeline() = default;
};
class QueryCensorPipelineListResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorPipelineListResponseBodyPipelineListPipeline>> pipeline{};

  QueryCensorPipelineListResponseBodyPipelineList() {}

  explicit QueryCensorPipelineListResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<QueryCensorPipelineListResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorPipelineListResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<QueryCensorPipelineListResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~QueryCensorPipelineListResponseBodyPipelineList() = default;
};
class QueryCensorPipelineListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryCensorPipelineListResponseBodyNonExistIds() {}

  explicit QueryCensorPipelineListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryCensorPipelineListResponseBodyNonExistIds() = default;
};
class QueryCensorPipelineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryCensorPipelineListResponseBodyPipelineList> pipelineList{};
  shared_ptr<QueryCensorPipelineListResponseBodyNonExistIds> nonExistIds{};

  QueryCensorPipelineListResponseBody() {}

  explicit QueryCensorPipelineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        QueryCensorPipelineListResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<QueryCensorPipelineListResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryCensorPipelineListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryCensorPipelineListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryCensorPipelineListResponseBody() = default;
};
class QueryCensorPipelineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryCensorPipelineListResponseBody> body{};

  QueryCensorPipelineListResponse() {}

  explicit QueryCensorPipelineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCensorPipelineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCensorPipelineListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCensorPipelineListResponse() = default;
};
class SubmitMcuJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> template_{};
  shared_ptr<string> userData{};

  SubmitMcuJobRequest() {}

  explicit SubmitMcuJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMcuJobRequest() = default;
};
class SubmitMcuJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitMcuJobResponseBody() {}

  explicit SubmitMcuJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitMcuJobResponseBody() = default;
};
class SubmitMcuJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitMcuJobResponseBody> body{};

  SubmitMcuJobResponse() {}

  explicit SubmitMcuJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMcuJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMcuJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMcuJobResponse() = default;
};
class CategoryTreeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};

  CategoryTreeRequest() {}

  explicit CategoryTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CategoryTreeRequest() = default;
};
class CategoryTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> categoryTree{};

  CategoryTreeResponseBody() {}

  explicit CategoryTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (categoryTree) {
      res["CategoryTree"] = boost::any(*categoryTree);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CategoryTree") != m.end() && !m["CategoryTree"].empty()) {
      categoryTree = make_shared<string>(boost::any_cast<string>(m["CategoryTree"]));
    }
  }


  virtual ~CategoryTreeResponseBody() = default;
};
class CategoryTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CategoryTreeResponseBody> body{};

  CategoryTreeResponse() {}

  explicit CategoryTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CategoryTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CategoryTreeResponseBody>(model1);
      }
    }
  }


  virtual ~CategoryTreeResponse() = default;
};
class SubmitTagJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> tagConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  SubmitTagJobRequest() {}

  explicit SubmitTagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (tagConfig) {
      res["TagConfig"] = boost::any(*tagConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("TagConfig") != m.end() && !m["TagConfig"].empty()) {
      tagConfig = make_shared<string>(boost::any_cast<string>(m["TagConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitTagJobRequest() = default;
};
class SubmitTagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitTagJobResponseBody() {}

  explicit SubmitTagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitTagJobResponseBody() = default;
};
class SubmitTagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitTagJobResponseBody> body{};

  SubmitTagJobResponse() {}

  explicit SubmitTagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTagJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTagJobResponse() = default;
};
class SubmitCoverJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> coverConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  SubmitCoverJobRequest() {}

  explicit SubmitCoverJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (coverConfig) {
      res["CoverConfig"] = boost::any(*coverConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("CoverConfig") != m.end() && !m["CoverConfig"].empty()) {
      coverConfig = make_shared<string>(boost::any_cast<string>(m["CoverConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitCoverJobRequest() = default;
};
class SubmitCoverJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitCoverJobResponseBody() {}

  explicit SubmitCoverJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitCoverJobResponseBody() = default;
};
class SubmitCoverJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitCoverJobResponseBody> body{};

  SubmitCoverJobResponse() {}

  explicit SubmitCoverJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCoverJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCoverJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCoverJobResponse() = default;
};
class AddCensorPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};

  AddCensorPipelineRequest() {}

  explicit AddCensorPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddCensorPipelineRequest() = default;
};
class AddCensorPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  AddCensorPipelineResponseBodyPipelineNotifyConfig() {}

  explicit AddCensorPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~AddCensorPipelineResponseBodyPipelineNotifyConfig() = default;
};
class AddCensorPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<AddCensorPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  AddCensorPipelineResponseBodyPipeline() {}

  explicit AddCensorPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        AddCensorPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<AddCensorPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~AddCensorPipelineResponseBodyPipeline() = default;
};
class AddCensorPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddCensorPipelineResponseBodyPipeline> pipeline{};

  AddCensorPipelineResponseBody() {}

  explicit AddCensorPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        AddCensorPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<AddCensorPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~AddCensorPipelineResponseBody() = default;
};
class AddCensorPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddCensorPipelineResponseBody> body{};

  AddCensorPipelineResponse() {}

  explicit AddCensorPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCensorPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCensorPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~AddCensorPipelineResponse() = default;
};
class SearchWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> state{};
  shared_ptr<string> ownerAccount{};

  SearchWaterMarkTemplateRequest() {}

  explicit SearchWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SearchWaterMarkTemplateRequest() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> dy{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> duration{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> name{};
  shared_ptr<string> dy{};
  shared_ptr<string> id{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate>> waterMarkTemplate{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMarkTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*waterMarkTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMarkTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMarkTemplate"].type()) {
        vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMarkTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMarkTemplate = make_shared<vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate>>(expect1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList() = default;
};
class SearchWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList> waterMarkTemplateList{};

  SearchWaterMarkTemplateResponseBody() {}

  explicit SearchWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (waterMarkTemplateList) {
      res["WaterMarkTemplateList"] = waterMarkTemplateList ? boost::any(waterMarkTemplateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("WaterMarkTemplateList") != m.end() && !m["WaterMarkTemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplateList"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplateList"]));
        waterMarkTemplateList = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList>(model1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBody() = default;
};
class SearchWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SearchWaterMarkTemplateResponseBody> body{};

  SearchWaterMarkTemplateResponse() {}

  explicit SearchWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponse() = default;
};
class SubmitAsrJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> asrConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitAsrJobRequest() {}

  explicit SubmitAsrJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (asrConfig) {
      res["AsrConfig"] = boost::any(*asrConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      asrConfig = make_shared<string>(boost::any_cast<string>(m["AsrConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitAsrJobRequest() = default;
};
class SubmitAsrJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitAsrJobResponseBody() {}

  explicit SubmitAsrJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitAsrJobResponseBody() = default;
};
class SubmitAsrJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitAsrJobResponseBody> body{};

  SubmitAsrJobResponse() {}

  explicit SubmitAsrJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAsrJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAsrJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAsrJobResponse() = default;
};
class AddMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};
  shared_ptr<string> ownerAccount{};

  AddMediaWorkflowRequest() {}

  explicit AddMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddMediaWorkflowRequest() = default;
};
class AddMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<string> triggerMode{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};

  AddMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit AddMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~AddMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class AddMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};

  AddMediaWorkflowResponseBody() {}

  explicit AddMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        AddMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<AddMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
  }


  virtual ~AddMediaWorkflowResponseBody() = default;
};
class AddMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddMediaWorkflowResponseBody> body{};

  AddMediaWorkflowResponse() {}

  explicit AddMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaWorkflowResponse() = default;
};
class QueryAsrJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryAsrJobListRequest() {}

  explicit QueryAsrJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryAsrJobListRequest() = default;
};
class QueryAsrJobListResponseBodyJobListJobAsrConfig : public Darabonba::Model {
public:
  shared_ptr<string> scene{};

  QueryAsrJobListResponseBodyJobListJobAsrConfig() {}

  explicit QueryAsrJobListResponseBodyJobListJobAsrConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
  }


  virtual ~QueryAsrJobListResponseBodyJobListJobAsrConfig() = default;
};
class QueryAsrJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryAsrJobListResponseBodyJobListJobInput() {}

  explicit QueryAsrJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryAsrJobListResponseBodyJobListJobInput() = default;
};
class QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> channelId{};
  shared_ptr<string> text{};
  shared_ptr<string> speechRate{};

  QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText() {}

  explicit QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<string>(boost::any_cast<string>(m["SpeechRate"]));
    }
  }


  virtual ~QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText() = default;
};
class QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText>> asrText{};

  QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList() {}

  explicit QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrText) {
      vector<boost::any> temp1;
      for(auto item1:*asrText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AsrText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrText") != m.end() && !m["AsrText"].empty()) {
      if (typeid(vector<boost::any>) == m["AsrText"].type()) {
        vector<QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AsrText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        asrText = make_shared<vector<QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText>>(expect1);
      }
    }
  }


  virtual ~QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList() = default;
};
class QueryAsrJobListResponseBodyJobListJobAsrResult : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList> asrTextList{};

  QueryAsrJobListResponseBodyJobListJobAsrResult() {}

  explicit QueryAsrJobListResponseBodyJobListJobAsrResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (asrTextList) {
      res["AsrTextList"] = asrTextList ? boost::any(asrTextList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("AsrTextList") != m.end() && !m["AsrTextList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrTextList"].type()) {
        QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrTextList"]));
        asrTextList = make_shared<QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList>(model1);
      }
    }
  }


  virtual ~QueryAsrJobListResponseBodyJobListJobAsrResult() = default;
};
class QueryAsrJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryAsrJobListResponseBodyJobListJobAsrConfig> asrConfig{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryAsrJobListResponseBodyJobListJobInput> input{};
  shared_ptr<string> id{};
  shared_ptr<QueryAsrJobListResponseBodyJobListJobAsrResult> asrResult{};

  QueryAsrJobListResponseBodyJobListJob() {}

  explicit QueryAsrJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (asrConfig) {
      res["AsrConfig"] = asrConfig ? boost::any(asrConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (asrResult) {
      res["AsrResult"] = asrResult ? boost::any(asrResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrConfig"].type()) {
        QueryAsrJobListResponseBodyJobListJobAsrConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrConfig"]));
        asrConfig = make_shared<QueryAsrJobListResponseBodyJobListJobAsrConfig>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryAsrJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryAsrJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("AsrResult") != m.end() && !m["AsrResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrResult"].type()) {
        QueryAsrJobListResponseBodyJobListJobAsrResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrResult"]));
        asrResult = make_shared<QueryAsrJobListResponseBodyJobListJobAsrResult>(model1);
      }
    }
  }


  virtual ~QueryAsrJobListResponseBodyJobListJob() = default;
};
class QueryAsrJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAsrJobListResponseBodyJobListJob>> job{};

  QueryAsrJobListResponseBodyJobList() {}

  explicit QueryAsrJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryAsrJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAsrJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryAsrJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryAsrJobListResponseBodyJobList() = default;
};
class QueryAsrJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryAsrJobListResponseBodyNonExistIds() {}

  explicit QueryAsrJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryAsrJobListResponseBodyNonExistIds() = default;
};
class QueryAsrJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryAsrJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryAsrJobListResponseBodyNonExistIds> nonExistIds{};

  QueryAsrJobListResponseBody() {}

  explicit QueryAsrJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryAsrJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryAsrJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryAsrJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryAsrJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryAsrJobListResponseBody() = default;
};
class QueryAsrJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryAsrJobListResponseBody> body{};

  QueryAsrJobListResponse() {}

  explicit QueryAsrJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAsrJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAsrJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAsrJobListResponse() = default;
};
class SubmitVideoPoseJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> input{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> userData{};

  SubmitVideoPoseJobRequest() {}

  explicit SubmitVideoPoseJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitVideoPoseJobRequest() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile> dataFile{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile> videoFile{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataFile) {
      res["DataFile"] = dataFile ? boost::any(dataFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoFile) {
      res["VideoFile"] = videoFile ? boost::any(videoFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataFile") != m.end() && !m["DataFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataFile"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataFile"]));
        dataFile = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile>(model1);
      }
    }
    if (m.find("VideoFile") != m.end() && !m["VideoFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoFile"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoFile"]));
        videoFile = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile>(model1);
      }
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobInput : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobInput() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobInput() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> sar{};
  shared_ptr<string> height{};
  shared_ptr<string> codecTagString{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> width{};
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> rotate{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> codecTagString{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJobProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams> streams{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  SubmitVideoPoseJobResponseBodyVideoPoseJobProperties() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJobProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJobProperties() = default;
};
class SubmitVideoPoseJobResponseBodyVideoPoseJob : public Darabonba::Model {
public:
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig> outputConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobInput> input{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJobProperties> properties{};

  SubmitVideoPoseJobResponseBodyVideoPoseJob() {}

  explicit SubmitVideoPoseJobResponseBodyVideoPoseJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputConfig) {
      res["OutputConfig"] = outputConfig ? boost::any(outputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputConfig"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputConfig"]));
        outputConfig = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobInput>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJobProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJobProperties>(model1);
      }
    }
  }


  virtual ~SubmitVideoPoseJobResponseBodyVideoPoseJob() = default;
};
class SubmitVideoPoseJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitVideoPoseJobResponseBodyVideoPoseJob> videoPoseJob{};

  SubmitVideoPoseJobResponseBody() {}

  explicit SubmitVideoPoseJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (videoPoseJob) {
      res["VideoPoseJob"] = videoPoseJob ? boost::any(videoPoseJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VideoPoseJob") != m.end() && !m["VideoPoseJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoPoseJob"].type()) {
        SubmitVideoPoseJobResponseBodyVideoPoseJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoPoseJob"]));
        videoPoseJob = make_shared<SubmitVideoPoseJobResponseBodyVideoPoseJob>(model1);
      }
    }
  }


  virtual ~SubmitVideoPoseJobResponseBody() = default;
};
class SubmitVideoPoseJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitVideoPoseJobResponseBody> body{};

  SubmitVideoPoseJobResponse() {}

  explicit SubmitVideoPoseJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitVideoPoseJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitVideoPoseJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitVideoPoseJobResponse() = default;
};
class RegisterMediaDetailPersonRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> category{};
  shared_ptr<string> personName{};
  shared_ptr<string> images{};
  shared_ptr<string> personLib{};
  shared_ptr<string> ownerAccount{};

  RegisterMediaDetailPersonRequest() {}

  explicit RegisterMediaDetailPersonRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (personName) {
      res["PersonName"] = boost::any(*personName);
    }
    if (images) {
      res["Images"] = boost::any(*images);
    }
    if (personLib) {
      res["PersonLib"] = boost::any(*personLib);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("PersonName") != m.end() && !m["PersonName"].empty()) {
      personName = make_shared<string>(boost::any_cast<string>(m["PersonName"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      images = make_shared<string>(boost::any_cast<string>(m["Images"]));
    }
    if (m.find("PersonLib") != m.end() && !m["PersonLib"].empty()) {
      personLib = make_shared<string>(boost::any_cast<string>(m["PersonLib"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~RegisterMediaDetailPersonRequest() = default;
};
class RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile() {}

  explicit RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile() = default;
};
class RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage : public Darabonba::Model {
public:
  shared_ptr<string> quality{};
  shared_ptr<RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile> imageFile{};
  shared_ptr<string> personName{};
  shared_ptr<string> gender{};
  shared_ptr<string> faceId{};
  shared_ptr<string> target{};
  shared_ptr<string> imageId{};

  RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage() {}

  explicit RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    if (imageFile) {
      res["ImageFile"] = imageFile ? boost::any(imageFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (personName) {
      res["PersonName"] = boost::any(*personName);
    }
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<string>(boost::any_cast<string>(m["Quality"]));
    }
    if (m.find("ImageFile") != m.end() && !m["ImageFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageFile"].type()) {
        RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageFile"]));
        imageFile = make_shared<RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile>(model1);
      }
    }
    if (m.find("PersonName") != m.end() && !m["PersonName"].empty()) {
      personName = make_shared<string>(boost::any_cast<string>(m["PersonName"]));
    }
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
  }


  virtual ~RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage() = default;
};
class RegisterMediaDetailPersonResponseBodyRegisteredPersonages : public Darabonba::Model {
public:
  shared_ptr<vector<RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage>> registeredPersonage{};

  RegisterMediaDetailPersonResponseBodyRegisteredPersonages() {}

  explicit RegisterMediaDetailPersonResponseBodyRegisteredPersonages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (registeredPersonage) {
      vector<boost::any> temp1;
      for(auto item1:*registeredPersonage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegisteredPersonage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegisteredPersonage") != m.end() && !m["RegisteredPersonage"].empty()) {
      if (typeid(vector<boost::any>) == m["RegisteredPersonage"].type()) {
        vector<RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegisteredPersonage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registeredPersonage = make_shared<vector<RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage>>(expect1);
      }
    }
  }


  virtual ~RegisterMediaDetailPersonResponseBodyRegisteredPersonages() = default;
};
class RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile() {}

  explicit RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile() = default;
};
class RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage : public Darabonba::Model {
public:
  shared_ptr<RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile> imageFile{};
  shared_ptr<string> success{};
  shared_ptr<string> code{};

  RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage() {}

  explicit RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageFile) {
      res["ImageFile"] = imageFile ? boost::any(imageFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageFile") != m.end() && !m["ImageFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageFile"].type()) {
        RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageFile"]));
        imageFile = make_shared<RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage() = default;
};
class RegisterMediaDetailPersonResponseBodyFailedImages : public Darabonba::Model {
public:
  shared_ptr<vector<RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage>> failedImage{};

  RegisterMediaDetailPersonResponseBodyFailedImages() {}

  explicit RegisterMediaDetailPersonResponseBodyFailedImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedImage) {
      vector<boost::any> temp1;
      for(auto item1:*failedImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedImage") != m.end() && !m["FailedImage"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedImage"].type()) {
        vector<RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedImage = make_shared<vector<RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage>>(expect1);
      }
    }
  }


  virtual ~RegisterMediaDetailPersonResponseBodyFailedImages() = default;
};
class RegisterMediaDetailPersonResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<RegisterMediaDetailPersonResponseBodyRegisteredPersonages> registeredPersonages{};
  shared_ptr<RegisterMediaDetailPersonResponseBodyFailedImages> failedImages{};

  RegisterMediaDetailPersonResponseBody() {}

  explicit RegisterMediaDetailPersonResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (registeredPersonages) {
      res["RegisteredPersonages"] = registeredPersonages ? boost::any(registeredPersonages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failedImages) {
      res["FailedImages"] = failedImages ? boost::any(failedImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RegisteredPersonages") != m.end() && !m["RegisteredPersonages"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegisteredPersonages"].type()) {
        RegisterMediaDetailPersonResponseBodyRegisteredPersonages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegisteredPersonages"]));
        registeredPersonages = make_shared<RegisterMediaDetailPersonResponseBodyRegisteredPersonages>(model1);
      }
    }
    if (m.find("FailedImages") != m.end() && !m["FailedImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedImages"].type()) {
        RegisterMediaDetailPersonResponseBodyFailedImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedImages"]));
        failedImages = make_shared<RegisterMediaDetailPersonResponseBodyFailedImages>(model1);
      }
    }
  }


  virtual ~RegisterMediaDetailPersonResponseBody() = default;
};
class RegisterMediaDetailPersonResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RegisterMediaDetailPersonResponseBody> body{};

  RegisterMediaDetailPersonResponse() {}

  explicit RegisterMediaDetailPersonResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterMediaDetailPersonResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterMediaDetailPersonResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterMediaDetailPersonResponse() = default;
};
class QueryCensorJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryCensorJobListRequest() {}

  explicit QueryCensorJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryCensorJobListRequest() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> object{};
  shared_ptr<string> label{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop>> top{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (top) {
      vector<boost::any> temp1;
      for(auto item1:*top){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Top"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      if (typeid(vector<boost::any>) == m["Top"].type()) {
        vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Top"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        top = make_shared<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<long> count{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter>> counter{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (counter) {
      vector<boost::any> temp1;
      for(auto item1:*counter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Counter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Counter") != m.end() && !m["Counter"].empty()) {
      if (typeid(vector<boost::any>) == m["Counter"].type()) {
        vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Counter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counter = make_shared<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult : public Darabonba::Model {
public:
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList> terrorismTopList{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> averageScore{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList> terrorismCounterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismTopList) {
      res["TerrorismTopList"] = terrorismTopList ? boost::any(terrorismTopList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (terrorismCounterList) {
      res["TerrorismCounterList"] = terrorismCounterList ? boost::any(terrorismCounterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismTopList") != m.end() && !m["TerrorismTopList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismTopList"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismTopList"]));
        terrorismTopList = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("TerrorismCounterList") != m.end() && !m["TerrorismCounterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismCounterList"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismCounterList"]));
        terrorismCounterList = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList>(model1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> imageBucket{};
  shared_ptr<string> result{};
  shared_ptr<string> imageLocation{};
  shared_ptr<string> imageObject{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageBucket) {
      res["ImageBucket"] = boost::any(*imageBucket);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (imageLocation) {
      res["ImageLocation"] = boost::any(*imageLocation);
    }
    if (imageObject) {
      res["ImageObject"] = boost::any(*imageObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageBucket") != m.end() && !m["ImageBucket"].empty()) {
      imageBucket = make_shared<string>(boost::any_cast<string>(m["ImageBucket"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ImageLocation") != m.end() && !m["ImageLocation"].empty()) {
      imageLocation = make_shared<string>(boost::any_cast<string>(m["ImageLocation"]));
    }
    if (m.find("ImageObject") != m.end() && !m["ImageObject"].empty()) {
      imageObject = make_shared<string>(boost::any_cast<string>(m["ImageObject"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult>> imageCensorResult{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*imageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageCensorResult") != m.end() && !m["ImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageCensorResult"].type()) {
        vector<QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageCensorResult = make_shared<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobInput() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobInput() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig : public Darabonba::Model {
public:
  shared_ptr<string> interval{};
  shared_ptr<string> saveType{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile> outputFile{};
  shared_ptr<string> scenes{};
  shared_ptr<string> bizType{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scenes) {
      res["Scenes"] = boost::any(*scenes);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      scenes = make_shared<string>(boost::any_cast<string>(m["Scenes"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<long> count{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter>> counter{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (counter) {
      vector<boost::any> temp1;
      for(auto item1:*counter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Counter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Counter") != m.end() && !m["Counter"].empty()) {
      if (typeid(vector<boost::any>) == m["Counter"].type()) {
        vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Counter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counter = make_shared<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> object{};
  shared_ptr<string> label{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop>> top{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (top) {
      vector<boost::any> temp1;
      for(auto item1:*top){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Top"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      if (typeid(vector<boost::any>) == m["Top"].type()) {
        vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Top"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        top = make_shared<vector<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult : public Darabonba::Model {
public:
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList> pornCounterList{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> averageScore{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList> pornTopList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};

  QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornCounterList) {
      res["PornCounterList"] = pornCounterList ? boost::any(pornCounterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (pornTopList) {
      res["PornTopList"] = pornTopList ? boost::any(pornTopList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornCounterList") != m.end() && !m["PornCounterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornCounterList"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornCounterList"]));
        pornCounterList = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("PornTopList") != m.end() && !m["PornTopList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornTopList"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornTopList"]));
        pornTopList = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList>(model1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult() = default;
};
class QueryCensorJobListResponseBodyCensorJobListCensorJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult> censorTerrorismResult{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults> imageCensorResults{};
  shared_ptr<string> titleCensorResult{};
  shared_ptr<string> message{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobInput> input{};
  shared_ptr<string> barrageCensorResult{};
  shared_ptr<string> descCensorResult{};
  shared_ptr<string> resultSaveObject{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig> censorConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult> censorPornResult{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> id{};

  QueryCensorJobListResponseBodyCensorJobListCensorJob() {}

  explicit QueryCensorJobListResponseBodyCensorJobListCensorJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (censorTerrorismResult) {
      res["CensorTerrorismResult"] = censorTerrorismResult ? boost::any(censorTerrorismResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageCensorResults) {
      res["ImageCensorResults"] = imageCensorResults ? boost::any(imageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = boost::any(*titleCensorResult);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = boost::any(*barrageCensorResult);
    }
    if (descCensorResult) {
      res["DescCensorResult"] = boost::any(*descCensorResult);
    }
    if (resultSaveObject) {
      res["ResultSaveObject"] = boost::any(*resultSaveObject);
    }
    if (censorConfig) {
      res["CensorConfig"] = censorConfig ? boost::any(censorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (censorPornResult) {
      res["CensorPornResult"] = censorPornResult ? boost::any(censorPornResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("CensorTerrorismResult") != m.end() && !m["CensorTerrorismResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorTerrorismResult"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorTerrorismResult"]));
        censorTerrorismResult = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult>(model1);
      }
    }
    if (m.find("ImageCensorResults") != m.end() && !m["ImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageCensorResults"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageCensorResults"]));
        imageCensorResults = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults>(model1);
      }
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      titleCensorResult = make_shared<string>(boost::any_cast<string>(m["TitleCensorResult"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobInput>(model1);
      }
    }
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      barrageCensorResult = make_shared<string>(boost::any_cast<string>(m["BarrageCensorResult"]));
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      descCensorResult = make_shared<string>(boost::any_cast<string>(m["DescCensorResult"]));
    }
    if (m.find("ResultSaveObject") != m.end() && !m["ResultSaveObject"].empty()) {
      resultSaveObject = make_shared<string>(boost::any_cast<string>(m["ResultSaveObject"]));
    }
    if (m.find("CensorConfig") != m.end() && !m["CensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorConfig"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorConfig"]));
        censorConfig = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CensorPornResult") != m.end() && !m["CensorPornResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorPornResult"].type()) {
        QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorPornResult"]));
        censorPornResult = make_shared<QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobListCensorJob() = default;
};
class QueryCensorJobListResponseBodyCensorJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyCensorJobListCensorJob>> censorJob{};

  QueryCensorJobListResponseBodyCensorJobList() {}

  explicit QueryCensorJobListResponseBodyCensorJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorJob) {
      vector<boost::any> temp1;
      for(auto item1:*censorJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorJob") != m.end() && !m["CensorJob"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorJob"].type()) {
        vector<QueryCensorJobListResponseBodyCensorJobListCensorJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyCensorJobListCensorJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorJob = make_shared<vector<QueryCensorJobListResponseBodyCensorJobListCensorJob>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyCensorJobList() = default;
};
class QueryCensorJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryCensorJobListResponseBodyNonExistIds() {}

  explicit QueryCensorJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryCensorJobListResponseBodyNonExistIds() = default;
};
class QueryCensorJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryCensorJobListResponseBodyCensorJobList> censorJobList{};
  shared_ptr<QueryCensorJobListResponseBodyNonExistIds> nonExistIds{};

  QueryCensorJobListResponseBody() {}

  explicit QueryCensorJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (censorJobList) {
      res["CensorJobList"] = censorJobList ? boost::any(censorJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CensorJobList") != m.end() && !m["CensorJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorJobList"].type()) {
        QueryCensorJobListResponseBodyCensorJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorJobList"]));
        censorJobList = make_shared<QueryCensorJobListResponseBodyCensorJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryCensorJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryCensorJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBody() = default;
};
class QueryCensorJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryCensorJobListResponseBody> body{};

  QueryCensorJobListResponse() {}

  explicit QueryCensorJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCensorJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCensorJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCensorJobListResponse() = default;
};
class SubmitFpCompareJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> masterMedia{};
  shared_ptr<string> queryMedia{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> matchedFrameStorage{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitFpCompareJobRequest() {}

  explicit SubmitFpCompareJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (masterMedia) {
      res["MasterMedia"] = boost::any(*masterMedia);
    }
    if (queryMedia) {
      res["QueryMedia"] = boost::any(*queryMedia);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (matchedFrameStorage) {
      res["MatchedFrameStorage"] = boost::any(*matchedFrameStorage);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MasterMedia") != m.end() && !m["MasterMedia"].empty()) {
      masterMedia = make_shared<string>(boost::any_cast<string>(m["MasterMedia"]));
    }
    if (m.find("QueryMedia") != m.end() && !m["QueryMedia"].empty()) {
      queryMedia = make_shared<string>(boost::any_cast<string>(m["QueryMedia"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("MatchedFrameStorage") != m.end() && !m["MatchedFrameStorage"].empty()) {
      matchedFrameStorage = make_shared<string>(boost::any_cast<string>(m["MatchedFrameStorage"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitFpCompareJobRequest() = default;
};
class SubmitFpCompareJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitFpCompareJobResponseBody() {}

  explicit SubmitFpCompareJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitFpCompareJobResponseBody() = default;
};
class SubmitFpCompareJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitFpCompareJobResponseBody> body{};

  SubmitFpCompareJobResponse() {}

  explicit SubmitFpCompareJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFpCompareJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFpCompareJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFpCompareJobResponse() = default;
};
class DeleteCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> ownerAccount{};

  DeleteCategoryRequest() {}

  explicit DeleteCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteCategoryRequest() = default;
};
class DeleteCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCategoryResponseBody() {}

  explicit DeleteCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCategoryResponseBody() = default;
};
class DeleteCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteCategoryResponseBody> body{};

  DeleteCategoryResponse() {}

  explicit DeleteCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCategoryResponse() = default;
};
class QuerySnapshotJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snapshotJobIds{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> state{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  QuerySnapshotJobListRequest() {}

  explicit QuerySnapshotJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snapshotJobIds) {
      res["SnapshotJobIds"] = boost::any(*snapshotJobIds);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnapshotJobIds") != m.end() && !m["SnapshotJobIds"].empty()) {
      snapshotJobIds = make_shared<string>(boost::any_cast<string>(m["SnapshotJobIds"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QuerySnapshotJobListRequest() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut : public Darabonba::Model {
public:
  shared_ptr<string> padding{};
  shared_ptr<string> color{};
  shared_ptr<string> cellSelStep{};
  shared_ptr<string> cellHeight{};
  shared_ptr<string> cellWidth{};
  shared_ptr<string> margin{};
  shared_ptr<string> columns{};
  shared_ptr<string> isKeepCellPic{};
  shared_ptr<string> lines{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (cellSelStep) {
      res["CellSelStep"] = boost::any(*cellSelStep);
    }
    if (cellHeight) {
      res["CellHeight"] = boost::any(*cellHeight);
    }
    if (cellWidth) {
      res["CellWidth"] = boost::any(*cellWidth);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (isKeepCellPic) {
      res["IsKeepCellPic"] = boost::any(*isKeepCellPic);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<string>(boost::any_cast<string>(m["Padding"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("CellSelStep") != m.end() && !m["CellSelStep"].empty()) {
      cellSelStep = make_shared<string>(boost::any_cast<string>(m["CellSelStep"]));
    }
    if (m.find("CellHeight") != m.end() && !m["CellHeight"].empty()) {
      cellHeight = make_shared<string>(boost::any_cast<string>(m["CellHeight"]));
    }
    if (m.find("CellWidth") != m.end() && !m["CellWidth"].empty()) {
      cellWidth = make_shared<string>(boost::any_cast<string>(m["CellWidth"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<string>(boost::any_cast<string>(m["Margin"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["Columns"]));
    }
    if (m.find("IsKeepCellPic") != m.end() && !m["IsKeepCellPic"].empty()) {
      isKeepCellPic = make_shared<string>(boost::any_cast<string>(m["IsKeepCellPic"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut> tileOut{};
  shared_ptr<string> interval{};
  shared_ptr<string> frameType{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile> outputFile{};
  shared_ptr<string> num{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile> tileOutputFile{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (tileOut) {
      res["TileOut"] = tileOut ? boost::any(tileOut->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (frameType) {
      res["FrameType"] = boost::any(*frameType);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (tileOutputFile) {
      res["TileOutputFile"] = tileOutputFile ? boost::any(tileOutputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("TileOut") != m.end() && !m["TileOut"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOut"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOut"]));
        tileOut = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut>(model1);
      }
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("FrameType") != m.end() && !m["FrameType"].empty()) {
      frameType = make_shared<string>(boost::any_cast<string>(m["FrameType"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile>(model1);
      }
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<string>(boost::any_cast<string>(m["Num"]));
    }
    if (m.find("TileOutputFile") != m.end() && !m["TileOutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOutputFile"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOutputFile"]));
        tileOutputFile = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile>(model1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig> snapshotConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> message{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput> input{};
  shared_ptr<string> count{};
  shared_ptr<string> tileCount{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> id{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = snapshotConfig ? boost::any(snapshotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (tileCount) {
      res["TileCount"] = boost::any(*tileCount);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotConfig"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotConfig"]));
        snapshotConfig = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("TileCount") != m.end() && !m["TileCount"].empty()) {
      tileCount = make_shared<string>(boost::any_cast<string>(m["TileCount"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob>> snapshotJob{};

  QuerySnapshotJobListResponseBodySnapshotJobList() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotJob) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotJob"].type()) {
        vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotJob = make_shared<vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob>>(expect1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobList() = default;
};
class QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds() {}

  explicit QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds() = default;
};
class QuerySnapshotJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobList> snapshotJobList{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds> nonExistSnapshotJobIds{};
  shared_ptr<string> nextPageToken{};

  QuerySnapshotJobListResponseBody() {}

  explicit QuerySnapshotJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotJobList) {
      res["SnapshotJobList"] = snapshotJobList ? boost::any(snapshotJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistSnapshotJobIds) {
      res["NonExistSnapshotJobIds"] = nonExistSnapshotJobIds ? boost::any(nonExistSnapshotJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotJobList") != m.end() && !m["SnapshotJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJobList"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJobList"]));
        snapshotJobList = make_shared<QuerySnapshotJobListResponseBodySnapshotJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistSnapshotJobIds") != m.end() && !m["NonExistSnapshotJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistSnapshotJobIds"].type()) {
        QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistSnapshotJobIds"]));
        nonExistSnapshotJobIds = make_shared<QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBody() = default;
};
class QuerySnapshotJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySnapshotJobListResponseBody> body{};

  QuerySnapshotJobListResponse() {}

  explicit QuerySnapshotJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySnapshotJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySnapshotJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponse() = default;
};
class DetectImageSyncRequest : public Darabonba::Model {
public:
  shared_ptr<string> image{};

  DetectImageSyncRequest() {}

  explicit DetectImageSyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["Image"] = boost::any(*image);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
  }


  virtual ~DetectImageSyncRequest() = default;
};
class DetectImageSyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  DetectImageSyncResponseBody() {}

  explicit DetectImageSyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DetectImageSyncResponseBody() = default;
};
class DetectImageSyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DetectImageSyncResponseBody> body{};

  DetectImageSyncResponse() {}

  explicit DetectImageSyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageSyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageSyncResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageSyncResponse() = default;
};
class QueryTagJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tagJobIds{};
  shared_ptr<string> ownerAccount{};

  QueryTagJobListRequest() {}

  explicit QueryTagJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tagJobIds) {
      res["TagJobIds"] = boost::any(*tagJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TagJobIds") != m.end() && !m["TagJobIds"].empty()) {
      tagJobIds = make_shared<string>(boost::any_cast<string>(m["TagJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryTagJobListRequest() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> label{};

  QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult>> tagAnResult{};

  QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagAnResult) {
      vector<boost::any> temp1;
      for(auto item1:*tagAnResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagAnResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagAnResult") != m.end() && !m["TagAnResult"].empty()) {
      if (typeid(vector<boost::any>) == m["TagAnResult"].type()) {
        vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagAnResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagAnResult = make_shared<vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult>>(expect1);
      }
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> name{};
  shared_ptr<string> target{};

  QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace>> tagFace{};

  QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagFace) {
      vector<boost::any> temp1;
      for(auto item1:*tagFace){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagFace"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagFace") != m.end() && !m["TagFace"].empty()) {
      if (typeid(vector<boost::any>) == m["TagFace"].type()) {
        vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagFace"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagFace = make_shared<vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace>>(expect1);
      }
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult : public Darabonba::Model {
public:
  shared_ptr<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces> tagFaces{};
  shared_ptr<string> time{};

  QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagFaces) {
      res["TagFaces"] = tagFaces ? boost::any(tagFaces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagFaces") != m.end() && !m["TagFaces"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagFaces"].type()) {
        QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagFaces"]));
        tagFaces = make_shared<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces>(model1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult>> tagFrResult{};

  QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagFrResult) {
      vector<boost::any> temp1;
      for(auto item1:*tagFrResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagFrResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagFrResult") != m.end() && !m["TagFrResult"].empty()) {
      if (typeid(vector<boost::any>) == m["TagFrResult"].type()) {
        vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagFrResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagFrResult = make_shared<vector<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult>>(expect1);
      }
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult : public Darabonba::Model {
public:
  shared_ptr<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults> tagAnResults{};
  shared_ptr<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults> tagFrResults{};
  shared_ptr<string> details{};

  QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagAnResults) {
      res["TagAnResults"] = tagAnResults ? boost::any(tagAnResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tagFrResults) {
      res["TagFrResults"] = tagFrResults ? boost::any(tagFrResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagAnResults") != m.end() && !m["TagAnResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagAnResults"].type()) {
        QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagAnResults"]));
        tagAnResults = make_shared<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults>(model1);
      }
    }
    if (m.find("TagFrResults") != m.end() && !m["TagFrResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagFrResults"].type()) {
        QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagFrResults"]));
        tagFrResults = make_shared<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults>(model1);
      }
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryTagJobListResponseBodyTagJobListTagJobInput() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJobInput() = default;
};
class QueryTagJobListResponseBodyTagJobListTagJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult> videoTagResult{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryTagJobListResponseBodyTagJobListTagJobInput> input{};
  shared_ptr<string> id{};

  QueryTagJobListResponseBodyTagJobListTagJob() {}

  explicit QueryTagJobListResponseBodyTagJobListTagJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (videoTagResult) {
      res["VideoTagResult"] = videoTagResult ? boost::any(videoTagResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VideoTagResult") != m.end() && !m["VideoTagResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTagResult"].type()) {
        QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTagResult"]));
        videoTagResult = make_shared<QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryTagJobListResponseBodyTagJobListTagJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryTagJobListResponseBodyTagJobListTagJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobListTagJob() = default;
};
class QueryTagJobListResponseBodyTagJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTagJobListResponseBodyTagJobListTagJob>> tagJob{};

  QueryTagJobListResponseBodyTagJobList() {}

  explicit QueryTagJobListResponseBodyTagJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagJob) {
      vector<boost::any> temp1;
      for(auto item1:*tagJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagJob") != m.end() && !m["TagJob"].empty()) {
      if (typeid(vector<boost::any>) == m["TagJob"].type()) {
        vector<QueryTagJobListResponseBodyTagJobListTagJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTagJobListResponseBodyTagJobListTagJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagJob = make_shared<vector<QueryTagJobListResponseBodyTagJobListTagJob>>(expect1);
      }
    }
  }


  virtual ~QueryTagJobListResponseBodyTagJobList() = default;
};
class QueryTagJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryTagJobListResponseBodyNonExistIds() {}

  explicit QueryTagJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTagJobListResponseBodyNonExistIds() = default;
};
class QueryTagJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTagJobListResponseBodyTagJobList> tagJobList{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryTagJobListResponseBodyNonExistIds> nonExistIds{};

  QueryTagJobListResponseBody() {}

  explicit QueryTagJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagJobList) {
      res["TagJobList"] = tagJobList ? boost::any(tagJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagJobList") != m.end() && !m["TagJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagJobList"].type()) {
        QueryTagJobListResponseBodyTagJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagJobList"]));
        tagJobList = make_shared<QueryTagJobListResponseBodyTagJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryTagJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryTagJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryTagJobListResponseBody() = default;
};
class QueryTagJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryTagJobListResponseBody> body{};

  QueryTagJobListResponse() {}

  explicit QueryTagJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTagJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTagJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTagJobListResponse() = default;
};
class SubmitFpDBDeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> userData{};
  shared_ptr<string> delType{};
  shared_ptr<string> ownerAccount{};

  SubmitFpDBDeleteJobRequest() {}

  explicit SubmitFpDBDeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (delType) {
      res["DelType"] = boost::any(*delType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("DelType") != m.end() && !m["DelType"].empty()) {
      delType = make_shared<string>(boost::any_cast<string>(m["DelType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitFpDBDeleteJobRequest() = default;
};
class SubmitFpDBDeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitFpDBDeleteJobResponseBody() {}

  explicit SubmitFpDBDeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitFpDBDeleteJobResponseBody() = default;
};
class SubmitFpDBDeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitFpDBDeleteJobResponseBody> body{};

  SubmitFpDBDeleteJobResponse() {}

  explicit SubmitFpDBDeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFpDBDeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFpDBDeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFpDBDeleteJobResponse() = default;
};
class GetJobInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetJobInfoRequest() {}

  explicit GetJobInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["jobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("jobId") != m.end() && !m["jobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["jobId"]));
    }
  }


  virtual ~GetJobInfoRequest() = default;
};
class GetJobInfoResponseBodyMtsTransferJob : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> finishedTime{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> userData{};
  shared_ptr<string> extend{};
  shared_ptr<string> requestJson{};

  GetJobInfoResponseBodyMtsTransferJob() {}

  explicit GetJobInfoResponseBodyMtsTransferJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (requestJson) {
      res["RequestJson"] = boost::any(*requestJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<string>(boost::any_cast<string>(m["FinishedTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("RequestJson") != m.end() && !m["RequestJson"].empty()) {
      requestJson = make_shared<string>(boost::any_cast<string>(m["RequestJson"]));
    }
  }


  virtual ~GetJobInfoResponseBodyMtsTransferJob() = default;
};
class GetJobInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetJobInfoResponseBodyMtsTransferJob> mtsTransferJob{};

  GetJobInfoResponseBody() {}

  explicit GetJobInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mtsTransferJob) {
      res["MtsTransferJob"] = mtsTransferJob ? boost::any(mtsTransferJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MtsTransferJob") != m.end() && !m["MtsTransferJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MtsTransferJob"].type()) {
        GetJobInfoResponseBodyMtsTransferJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MtsTransferJob"]));
        mtsTransferJob = make_shared<GetJobInfoResponseBodyMtsTransferJob>(model1);
      }
    }
  }


  virtual ~GetJobInfoResponseBody() = default;
};
class GetJobInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJobInfoResponseBody> body{};

  GetJobInfoResponse() {}

  explicit GetJobInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobInfoResponse() = default;
};
class AddMediaTagRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> tag{};
  shared_ptr<string> ownerAccount{};

  AddMediaTagRequest() {}

  explicit AddMediaTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddMediaTagRequest() = default;
};
class AddMediaTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddMediaTagResponseBody() {}

  explicit AddMediaTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMediaTagResponseBody() = default;
};
class AddMediaTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddMediaTagResponseBody> body{};

  AddMediaTagResponse() {}

  explicit AddMediaTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaTagResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaTagResponse() = default;
};
class UnbindInputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> bucket{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> ownerAccount{};

  UnbindInputBucketRequest() {}

  explicit UnbindInputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UnbindInputBucketRequest() = default;
};
class UnbindInputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindInputBucketResponseBody() {}

  explicit UnbindInputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindInputBucketResponseBody() = default;
};
class UnbindInputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindInputBucketResponseBody> body{};

  UnbindInputBucketResponse() {}

  explicit UnbindInputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindInputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindInputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindInputBucketResponse() = default;
};
class QueryMediaWorkflowExecutionListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> runIds{};
  shared_ptr<string> ownerAccount{};

  QueryMediaWorkflowExecutionListRequest() {}

  explicit QueryMediaWorkflowExecutionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (runIds) {
      res["RunIds"] = boost::any(*runIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RunIds") != m.end() && !m["RunIds"].empty()) {
      runIds = make_shared<string>(boost::any_cast<string>(m["RunIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListRequest() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> type{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult> MNSMessageResult{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult>(model1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>> activity{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activity) {
      vector<boost::any> temp1;
      for(auto item1:*activity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activity") != m.end() && !m["Activity"].empty()) {
      if (typeid(vector<boost::any>) == m["Activity"].type()) {
        vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activity = make_shared<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput : public Darabonba::Model {
public:
  shared_ptr<string> userData{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile> inputFile{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile>(model1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList> activityList{};
  shared_ptr<string> name{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput> input{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> runId{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (activityList) {
      res["ActivityList"] = activityList ? boost::any(activityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ActivityList") != m.end() && !m["ActivityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityList"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityList"]));
        activityList = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["RunId"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>> mediaWorkflowExecution{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecution) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflowExecution){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflowExecution"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecution") != m.end() && !m["MediaWorkflowExecution"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflowExecution"].type()) {
        vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflowExecution"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflowExecution = make_shared<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList() = default;
};
class QueryMediaWorkflowExecutionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds> nonExistRunIds{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList> mediaWorkflowExecutionList{};
  shared_ptr<string> requestId{};

  QueryMediaWorkflowExecutionListResponseBody() {}

  explicit QueryMediaWorkflowExecutionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistRunIds) {
      res["NonExistRunIds"] = nonExistRunIds ? boost::any(nonExistRunIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowExecutionList) {
      res["MediaWorkflowExecutionList"] = mediaWorkflowExecutionList ? boost::any(mediaWorkflowExecutionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistRunIds") != m.end() && !m["NonExistRunIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistRunIds"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistRunIds"]));
        nonExistRunIds = make_shared<QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds>(model1);
      }
    }
    if (m.find("MediaWorkflowExecutionList") != m.end() && !m["MediaWorkflowExecutionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowExecutionList"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowExecutionList"]));
        mediaWorkflowExecutionList = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBody() = default;
};
class QueryMediaWorkflowExecutionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBody> body{};

  QueryMediaWorkflowExecutionListResponse() {}

  explicit QueryMediaWorkflowExecutionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaWorkflowExecutionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaWorkflowExecutionListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponse() = default;
};
class SubmitComplexJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> inputs{};
  shared_ptr<string> complexConfigs{};
  shared_ptr<string> transcodeOutput{};
  shared_ptr<string> outputBucket{};
  shared_ptr<string> outputLocation{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitComplexJobRequest() {}

  explicit SubmitComplexJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (inputs) {
      res["Inputs"] = boost::any(*inputs);
    }
    if (complexConfigs) {
      res["ComplexConfigs"] = boost::any(*complexConfigs);
    }
    if (transcodeOutput) {
      res["TranscodeOutput"] = boost::any(*transcodeOutput);
    }
    if (outputBucket) {
      res["OutputBucket"] = boost::any(*outputBucket);
    }
    if (outputLocation) {
      res["OutputLocation"] = boost::any(*outputLocation);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["Inputs"]));
    }
    if (m.find("ComplexConfigs") != m.end() && !m["ComplexConfigs"].empty()) {
      complexConfigs = make_shared<string>(boost::any_cast<string>(m["ComplexConfigs"]));
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      transcodeOutput = make_shared<string>(boost::any_cast<string>(m["TranscodeOutput"]));
    }
    if (m.find("OutputBucket") != m.end() && !m["OutputBucket"].empty()) {
      outputBucket = make_shared<string>(boost::any_cast<string>(m["OutputBucket"]));
    }
    if (m.find("OutputLocation") != m.end() && !m["OutputLocation"].empty()) {
      outputLocation = make_shared<string>(boost::any_cast<string>(m["OutputLocation"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitComplexJobRequest() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> duration{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> id{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> referPos{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> dy{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark>> waterMark{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> sizeSupport{};
  shared_ptr<bool> md5Support{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS> TS{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> level{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume> volume{};
  shared_ptr<string> bitrate{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> duration{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge>> merge{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> alpha{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile> inputFile{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> seek{};
  shared_ptr<string> duration{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan> timeSpan{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif> gif{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment> segment{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList> subtitleList{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> sar{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> height{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> width{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams> streams{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties() = default;
};
class SubmitComplexJobResponseBodyComplexJobTranscodeOutput : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo> video{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig> transConfig{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption> encryption{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList> waterMarkList{};
  shared_ptr<string> deWatermark{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> priority{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList> mergeList{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso> superReso{};
  shared_ptr<string> userData{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark> digiWaterMark{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile> outputFile{};
  shared_ptr<string> rotate{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer> container{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip> clip{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig> muxConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties> properties{};

  SubmitComplexJobResponseBodyComplexJobTranscodeOutput() {}

  explicit SubmitComplexJobResponseBodyComplexJobTranscodeOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption>(model1);
      }
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer>(model1);
      }
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobTranscodeOutput() = default;
};
class SubmitComplexJobResponseBodyComplexJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  SubmitComplexJobResponseBodyComplexJobMNSMessageResult() {}

  explicit SubmitComplexJobResponseBodyComplexJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobMNSMessageResult() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> t{};
  shared_ptr<string> l{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (t) {
      res["T"] = boost::any(*t);
    }
    if (l) {
      res["L"] = boost::any(*l);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
    if (m.find("L") != m.end() && !m["L"].empty()) {
      l = make_shared<string>(boost::any_cast<string>(m["L"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo> clipsConfigVideo{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfigVideo) {
      res["ClipsConfigVideo"] = clipsConfigVideo ? boost::any(clipsConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfigVideo") != m.end() && !m["ClipsConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfigVideo"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfigVideo"]));
        clipsConfigVideo = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig> clipsConfig{};
  shared_ptr<string> out{};
  shared_ptr<string> in{};
  shared_ptr<string> clipID{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfig) {
      res["ClipsConfig"] = clipsConfig ? boost::any(clipsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (clipID) {
      res["clipID"] = boost::any(*clipID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfig") != m.end() && !m["ClipsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfig"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfig"]));
        clipsConfig = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig>(model1);
      }
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("clipID") != m.end() && !m["clipID"].empty()) {
      clipID = make_shared<string>(boost::any_cast<string>(m["clipID"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip>> clip{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> order{};
  shared_ptr<string> id{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips> clips{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clips) {
      res["Clips"] = clips ? boost::any(clips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clips"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clips"]));
        clips = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack>> track{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (track) {
      vector<boost::any> temp1;
      for(auto item1:*track){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Track"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Track") != m.end() && !m["Track"].empty()) {
      if (typeid(vector<boost::any>) == m["Track"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Track"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        track = make_shared<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> channelLayout{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> channels{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> width{};
  shared_ptr<string> renderRatio{};
  shared_ptr<string> isGpuData{};
  shared_ptr<string> height{};
  shared_ptr<string> isOneTrackData{};
  shared_ptr<string> fps{};
  shared_ptr<string> reclosePrec{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (renderRatio) {
      res["RenderRatio"] = boost::any(*renderRatio);
    }
    if (isGpuData) {
      res["IsGpuData"] = boost::any(*isGpuData);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isOneTrackData) {
      res["IsOneTrackData"] = boost::any(*isOneTrackData);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (reclosePrec) {
      res["ReclosePrec"] = boost::any(*reclosePrec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("RenderRatio") != m.end() && !m["RenderRatio"].empty()) {
      renderRatio = make_shared<string>(boost::any_cast<string>(m["RenderRatio"]));
    }
    if (m.find("IsGpuData") != m.end() && !m["IsGpuData"].empty()) {
      isGpuData = make_shared<string>(boost::any_cast<string>(m["IsGpuData"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsOneTrackData") != m.end() && !m["IsOneTrackData"].empty()) {
      isOneTrackData = make_shared<string>(boost::any_cast<string>(m["IsOneTrackData"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("ReclosePrec") != m.end() && !m["ReclosePrec"].empty()) {
      reclosePrec = make_shared<string>(boost::any_cast<string>(m["ReclosePrec"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio> timelineConfigAudio{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo> timelineConfigVideo{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timelineConfigAudio) {
      res["TimelineConfigAudio"] = timelineConfigAudio ? boost::any(timelineConfigAudio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfigVideo) {
      res["TimelineConfigVideo"] = timelineConfigVideo ? boost::any(timelineConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimelineConfigAudio") != m.end() && !m["TimelineConfigAudio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigAudio"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigAudio"]));
        timelineConfigAudio = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio>(model1);
      }
    }
    if (m.find("TimelineConfigVideo") != m.end() && !m["TimelineConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigVideo"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigVideo"]));
        timelineConfigVideo = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList> trackList{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig> timelineConfig{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trackList) {
      res["TrackList"] = trackList ? boost::any(trackList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfig) {
      res["TimelineConfig"] = timelineConfig ? boost::any(timelineConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrackList") != m.end() && !m["TrackList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrackList"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrackList"]));
        trackList = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList>(model1);
      }
    }
    if (m.find("TimelineConfig") != m.end() && !m["TimelineConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfig"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfig"]));
        timelineConfig = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> effectConfig{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (effectConfig) {
      res["EffectConfig"] = boost::any(*effectConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("EffectConfig") != m.end() && !m["EffectConfig"].empty()) {
      effectConfig = make_shared<string>(boost::any_cast<string>(m["EffectConfig"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect>> effect{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      vector<boost::any> temp1;
      for(auto item1:*effect){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Effect"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      if (typeid(vector<boost::any>) == m["Effect"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Effect"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effect = make_shared<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> sourceID{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects> effects{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceStrmMap{};
  shared_ptr<string> out{};
  shared_ptr<string> in{};
  shared_ptr<string> id{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (sourceID) {
      res["SourceID"] = boost::any(*sourceID);
    }
    if (effects) {
      res["Effects"] = effects ? boost::any(effects->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceStrmMap) {
      res["SourceStrmMap"] = boost::any(*sourceStrmMap);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SourceID") != m.end() && !m["SourceID"].empty()) {
      sourceID = make_shared<string>(boost::any_cast<string>(m["SourceID"]));
    }
    if (m.find("Effects") != m.end() && !m["Effects"].empty()) {
      if (typeid(map<string, boost::any>) == m["Effects"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Effects"]));
        effects = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects>(model1);
      }
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceStrmMap") != m.end() && !m["SourceStrmMap"].empty()) {
      sourceStrmMap = make_shared<string>(boost::any_cast<string>(m["SourceStrmMap"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip>> clip{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline> timeline{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList> clipList{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clipList) {
      res["ClipList"] = clipList ? boost::any(clipList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline>(model1);
      }
    }
    if (m.find("ClipList") != m.end() && !m["ClipList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipList"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipList"]));
        clipList = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing> editing{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editing) {
      res["Editing"] = editing ? boost::any(editing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Editing") != m.end() && !m["Editing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Editing"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Editing"]));
        editing = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs() = default;
};
class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs>> complexEditingConfigs{};

  SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs() {}

  explicit SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complexEditingConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*complexEditingConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComplexEditingConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplexEditingConfigs") != m.end() && !m["ComplexEditingConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ComplexEditingConfigs"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComplexEditingConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        complexEditingConfigs = make_shared<vector<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs() = default;
};
class SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile() {}

  explicit SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile() = default;
};
class SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> isNormalSar{};
  shared_ptr<string> deinterlaceMethod{};

  SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig() {}

  explicit SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isNormalSar) {
      res["IsNormalSar"] = boost::any(*isNormalSar);
    }
    if (deinterlaceMethod) {
      res["DeinterlaceMethod"] = boost::any(*deinterlaceMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsNormalSar") != m.end() && !m["IsNormalSar"].empty()) {
      isNormalSar = make_shared<string>(boost::any_cast<string>(m["IsNormalSar"]));
    }
    if (m.find("DeinterlaceMethod") != m.end() && !m["DeinterlaceMethod"].empty()) {
      deinterlaceMethod = make_shared<string>(boost::any_cast<string>(m["DeinterlaceMethod"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig() = default;
};
class SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile> inputFile{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig> inputConfig{};
  shared_ptr<string> id{};

  SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput() {}

  explicit SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile>(model1);
      }
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput() = default;
};
class SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput>> editingInput{};

  SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs() {}

  explicit SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInput) {
      vector<boost::any> temp1;
      for(auto item1:*editingInput){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EditingInput"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInput") != m.end() && !m["EditingInput"].empty()) {
      if (typeid(vector<boost::any>) == m["EditingInput"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EditingInput"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        editingInput = make_shared<vector<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs() = default;
};
class SubmitComplexJobResponseBodyComplexJobInputsInputs : public Darabonba::Model {
public:
  shared_ptr<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs> editingInputs{};

  SubmitComplexJobResponseBodyComplexJobInputsInputs() {}

  explicit SubmitComplexJobResponseBodyComplexJobInputsInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInputs) {
      res["EditingInputs"] = editingInputs ? boost::any(editingInputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInputs") != m.end() && !m["EditingInputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingInputs"].type()) {
        SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingInputs"]));
        editingInputs = make_shared<SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobInputsInputs() = default;
};
class SubmitComplexJobResponseBodyComplexJobInputs : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitComplexJobResponseBodyComplexJobInputsInputs>> inputs{};

  SubmitComplexJobResponseBodyComplexJobInputs() {}

  explicit SubmitComplexJobResponseBodyComplexJobInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<SubmitComplexJobResponseBodyComplexJobInputsInputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitComplexJobResponseBodyComplexJobInputsInputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<SubmitComplexJobResponseBodyComplexJobInputsInputs>>(expect1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJobInputs() = default;
};
class SubmitComplexJobResponseBodyComplexJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobTranscodeOutput> transcodeOutput{};
  shared_ptr<string> message{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs> complexEditingConfigs{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJobInputs> inputs{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> pipelineId{};

  SubmitComplexJobResponseBodyComplexJob() {}

  explicit SubmitComplexJobResponseBodyComplexJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transcodeOutput) {
      res["transcodeOutput"] = transcodeOutput ? boost::any(transcodeOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (complexEditingConfigs) {
      res["ComplexEditingConfigs"] = complexEditingConfigs ? boost::any(complexEditingConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputs) {
      res["Inputs"] = inputs ? boost::any(inputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("transcodeOutput") != m.end() && !m["transcodeOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["transcodeOutput"].type()) {
        SubmitComplexJobResponseBodyComplexJobTranscodeOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transcodeOutput"]));
        transcodeOutput = make_shared<SubmitComplexJobResponseBodyComplexJobTranscodeOutput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitComplexJobResponseBodyComplexJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitComplexJobResponseBodyComplexJobMNSMessageResult>(model1);
      }
    }
    if (m.find("ComplexEditingConfigs") != m.end() && !m["ComplexEditingConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplexEditingConfigs"].type()) {
        SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplexEditingConfigs"]));
        complexEditingConfigs = make_shared<SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs>(model1);
      }
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inputs"].type()) {
        SubmitComplexJobResponseBodyComplexJobInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inputs"]));
        inputs = make_shared<SubmitComplexJobResponseBodyComplexJobInputs>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~SubmitComplexJobResponseBodyComplexJob() = default;
};
class SubmitComplexJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitComplexJobResponseBodyComplexJob> complexJob{};

  SubmitComplexJobResponseBody() {}

  explicit SubmitComplexJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (complexJob) {
      res["ComplexJob"] = complexJob ? boost::any(complexJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ComplexJob") != m.end() && !m["ComplexJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplexJob"].type()) {
        SubmitComplexJobResponseBodyComplexJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplexJob"]));
        complexJob = make_shared<SubmitComplexJobResponseBodyComplexJob>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponseBody() = default;
};
class SubmitComplexJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitComplexJobResponseBody> body{};

  SubmitComplexJobResponse() {}

  explicit SubmitComplexJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitComplexJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitComplexJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitComplexJobResponse() = default;
};
class AddAsrPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};

  AddAsrPipelineRequest() {}

  explicit AddAsrPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddAsrPipelineRequest() = default;
};
class AddAsrPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  AddAsrPipelineResponseBodyPipelineNotifyConfig() {}

  explicit AddAsrPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~AddAsrPipelineResponseBodyPipelineNotifyConfig() = default;
};
class AddAsrPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<AddAsrPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  AddAsrPipelineResponseBodyPipeline() {}

  explicit AddAsrPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        AddAsrPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<AddAsrPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~AddAsrPipelineResponseBodyPipeline() = default;
};
class AddAsrPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddAsrPipelineResponseBodyPipeline> pipeline{};

  AddAsrPipelineResponseBody() {}

  explicit AddAsrPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        AddAsrPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<AddAsrPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~AddAsrPipelineResponseBody() = default;
};
class AddAsrPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddAsrPipelineResponseBody> body{};

  AddAsrPipelineResponse() {}

  explicit AddAsrPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAsrPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAsrPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~AddAsrPipelineResponse() = default;
};
class CancelJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};

  CancelJobRequest() {}

  explicit CancelJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CancelJobRequest() = default;
};
class CancelJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  CancelJobResponseBody() {}

  explicit CancelJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelJobResponseBody() = default;
};
class CancelJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelJobResponseBody> body{};

  CancelJobResponse() {}

  explicit CancelJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelJobResponse() = default;
};
class ListAllCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};

  ListAllCategoryRequest() {}

  explicit ListAllCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListAllCategoryRequest() = default;
};
class ListAllCategoryResponseBodyCategoryListCategory : public Darabonba::Model {
public:
  shared_ptr<string> cateName{};
  shared_ptr<string> parentId{};
  shared_ptr<string> cateId{};
  shared_ptr<string> level{};

  ListAllCategoryResponseBodyCategoryListCategory() {}

  explicit ListAllCategoryResponseBodyCategoryListCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<string>(boost::any_cast<string>(m["CateId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~ListAllCategoryResponseBodyCategoryListCategory() = default;
};
class ListAllCategoryResponseBodyCategoryList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAllCategoryResponseBodyCategoryListCategory>> category{};

  ListAllCategoryResponseBodyCategoryList() {}

  explicit ListAllCategoryResponseBodyCategoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<ListAllCategoryResponseBodyCategoryListCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllCategoryResponseBodyCategoryListCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<ListAllCategoryResponseBodyCategoryListCategory>>(expect1);
      }
    }
  }


  virtual ~ListAllCategoryResponseBodyCategoryList() = default;
};
class ListAllCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAllCategoryResponseBodyCategoryList> categoryList{};
  shared_ptr<string> requestId{};

  ListAllCategoryResponseBody() {}

  explicit ListAllCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryList) {
      res["CategoryList"] = categoryList ? boost::any(categoryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryList") != m.end() && !m["CategoryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CategoryList"].type()) {
        ListAllCategoryResponseBodyCategoryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CategoryList"]));
        categoryList = make_shared<ListAllCategoryResponseBodyCategoryList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAllCategoryResponseBody() = default;
};
class ListAllCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAllCategoryResponseBody> body{};

  ListAllCategoryResponse() {}

  explicit ListAllCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllCategoryResponse() = default;
};
class ListFpShotDBRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> fpDBIds{};
  shared_ptr<string> ownerAccount{};

  ListFpShotDBRequest() {}

  explicit ListFpShotDBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (fpDBIds) {
      res["FpDBIds"] = boost::any(*fpDBIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("FpDBIds") != m.end() && !m["FpDBIds"].empty()) {
      fpDBIds = make_shared<string>(boost::any_cast<string>(m["FpDBIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListFpShotDBRequest() = default;
};
class ListFpShotDBResponseBodyFpShotDBListFpShotDB : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> modelId{};
  shared_ptr<string> fpDBId{};

  ListFpShotDBResponseBodyFpShotDBListFpShotDB() {}

  explicit ListFpShotDBResponseBodyFpShotDBListFpShotDB(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<long>(boost::any_cast<long>(m["ModelId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
  }


  virtual ~ListFpShotDBResponseBodyFpShotDBListFpShotDB() = default;
};
class ListFpShotDBResponseBodyFpShotDBList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFpShotDBResponseBodyFpShotDBListFpShotDB>> fpShotDB{};

  ListFpShotDBResponseBodyFpShotDBList() {}

  explicit ListFpShotDBResponseBodyFpShotDBList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotDB) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotDB){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotDB"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotDB") != m.end() && !m["FpShotDB"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotDB"].type()) {
        vector<ListFpShotDBResponseBodyFpShotDBListFpShotDB> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotDB"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFpShotDBResponseBodyFpShotDBListFpShotDB model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotDB = make_shared<vector<ListFpShotDBResponseBodyFpShotDBListFpShotDB>>(expect1);
      }
    }
  }


  virtual ~ListFpShotDBResponseBodyFpShotDBList() = default;
};
class ListFpShotDBResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  ListFpShotDBResponseBodyNonExistIds() {}

  explicit ListFpShotDBResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFpShotDBResponseBodyNonExistIds() = default;
};
class ListFpShotDBResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFpShotDBResponseBodyFpShotDBList> fpShotDBList{};
  shared_ptr<string> requestId{};
  shared_ptr<ListFpShotDBResponseBodyNonExistIds> nonExistIds{};

  ListFpShotDBResponseBody() {}

  explicit ListFpShotDBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotDBList) {
      res["FpShotDBList"] = fpShotDBList ? boost::any(fpShotDBList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotDBList") != m.end() && !m["FpShotDBList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotDBList"].type()) {
        ListFpShotDBResponseBodyFpShotDBList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotDBList"]));
        fpShotDBList = make_shared<ListFpShotDBResponseBodyFpShotDBList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        ListFpShotDBResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<ListFpShotDBResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~ListFpShotDBResponseBody() = default;
};
class ListFpShotDBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFpShotDBResponseBody> body{};

  ListFpShotDBResponse() {}

  explicit ListFpShotDBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFpShotDBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFpShotDBResponseBody>(model1);
      }
    }
  }


  virtual ~ListFpShotDBResponse() = default;
};
class AddSmarttagTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> templateName{};
  shared_ptr<string> industry{};
  shared_ptr<string> scene{};
  shared_ptr<string> analyseTypes{};
  shared_ptr<string> faceCategoryIds{};
  shared_ptr<bool> isDefault{};

  AddSmarttagTemplateRequest() {}

  explicit AddSmarttagTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (analyseTypes) {
      res["AnalyseTypes"] = boost::any(*analyseTypes);
    }
    if (faceCategoryIds) {
      res["FaceCategoryIds"] = boost::any(*faceCategoryIds);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("AnalyseTypes") != m.end() && !m["AnalyseTypes"].empty()) {
      analyseTypes = make_shared<string>(boost::any_cast<string>(m["AnalyseTypes"]));
    }
    if (m.find("FaceCategoryIds") != m.end() && !m["FaceCategoryIds"].empty()) {
      faceCategoryIds = make_shared<string>(boost::any_cast<string>(m["FaceCategoryIds"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
  }


  virtual ~AddSmarttagTemplateRequest() = default;
};
class AddSmarttagTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  AddSmarttagTemplateResponseBody() {}

  explicit AddSmarttagTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~AddSmarttagTemplateResponseBody() = default;
};
class AddSmarttagTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddSmarttagTemplateResponseBody> body{};

  AddSmarttagTemplateResponse() {}

  explicit AddSmarttagTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSmarttagTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSmarttagTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddSmarttagTemplateResponse() = default;
};
class LogicalDeleteResourceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> interrupt{};
  shared_ptr<string> invoker{};
  shared_ptr<string> pk{};
  shared_ptr<string> bid{};
  shared_ptr<long> hid{};
  shared_ptr<string> country{};
  shared_ptr<string> taskIdentifier{};
  shared_ptr<string> taskExtraData{};
  shared_ptr<string> gmtWakeup{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};

  LogicalDeleteResourceRequest() {}

  explicit LogicalDeleteResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interrupt) {
      res["Interrupt"] = boost::any(*interrupt);
    }
    if (invoker) {
      res["Invoker"] = boost::any(*invoker);
    }
    if (pk) {
      res["Pk"] = boost::any(*pk);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (hid) {
      res["Hid"] = boost::any(*hid);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (taskIdentifier) {
      res["TaskIdentifier"] = boost::any(*taskIdentifier);
    }
    if (taskExtraData) {
      res["TaskExtraData"] = boost::any(*taskExtraData);
    }
    if (gmtWakeup) {
      res["GmtWakeup"] = boost::any(*gmtWakeup);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interrupt") != m.end() && !m["Interrupt"].empty()) {
      interrupt = make_shared<bool>(boost::any_cast<bool>(m["Interrupt"]));
    }
    if (m.find("Invoker") != m.end() && !m["Invoker"].empty()) {
      invoker = make_shared<string>(boost::any_cast<string>(m["Invoker"]));
    }
    if (m.find("Pk") != m.end() && !m["Pk"].empty()) {
      pk = make_shared<string>(boost::any_cast<string>(m["Pk"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Hid") != m.end() && !m["Hid"].empty()) {
      hid = make_shared<long>(boost::any_cast<long>(m["Hid"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("TaskIdentifier") != m.end() && !m["TaskIdentifier"].empty()) {
      taskIdentifier = make_shared<string>(boost::any_cast<string>(m["TaskIdentifier"]));
    }
    if (m.find("TaskExtraData") != m.end() && !m["TaskExtraData"].empty()) {
      taskExtraData = make_shared<string>(boost::any_cast<string>(m["TaskExtraData"]));
    }
    if (m.find("GmtWakeup") != m.end() && !m["GmtWakeup"].empty()) {
      gmtWakeup = make_shared<string>(boost::any_cast<string>(m["GmtWakeup"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~LogicalDeleteResourceRequest() = default;
};
class LogicalDeleteResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> gmtWakeup{};
  shared_ptr<long> hid{};
  shared_ptr<string> invoker{};
  shared_ptr<string> message{};
  shared_ptr<string> taskIdentifier{};
  shared_ptr<string> taskExtraData{};
  shared_ptr<string> country{};
  shared_ptr<string> pk{};
  shared_ptr<string> bid{};
  shared_ptr<bool> success{};
  shared_ptr<bool> interrupt{};

  LogicalDeleteResourceResponseBody() {}

  explicit LogicalDeleteResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtWakeup) {
      res["GmtWakeup"] = boost::any(*gmtWakeup);
    }
    if (hid) {
      res["Hid"] = boost::any(*hid);
    }
    if (invoker) {
      res["Invoker"] = boost::any(*invoker);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (taskIdentifier) {
      res["TaskIdentifier"] = boost::any(*taskIdentifier);
    }
    if (taskExtraData) {
      res["TaskExtraData"] = boost::any(*taskExtraData);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (pk) {
      res["Pk"] = boost::any(*pk);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (interrupt) {
      res["Interrupt"] = boost::any(*interrupt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtWakeup") != m.end() && !m["GmtWakeup"].empty()) {
      gmtWakeup = make_shared<string>(boost::any_cast<string>(m["GmtWakeup"]));
    }
    if (m.find("Hid") != m.end() && !m["Hid"].empty()) {
      hid = make_shared<long>(boost::any_cast<long>(m["Hid"]));
    }
    if (m.find("Invoker") != m.end() && !m["Invoker"].empty()) {
      invoker = make_shared<string>(boost::any_cast<string>(m["Invoker"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("TaskIdentifier") != m.end() && !m["TaskIdentifier"].empty()) {
      taskIdentifier = make_shared<string>(boost::any_cast<string>(m["TaskIdentifier"]));
    }
    if (m.find("TaskExtraData") != m.end() && !m["TaskExtraData"].empty()) {
      taskExtraData = make_shared<string>(boost::any_cast<string>(m["TaskExtraData"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Pk") != m.end() && !m["Pk"].empty()) {
      pk = make_shared<string>(boost::any_cast<string>(m["Pk"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Interrupt") != m.end() && !m["Interrupt"].empty()) {
      interrupt = make_shared<bool>(boost::any_cast<bool>(m["Interrupt"]));
    }
  }


  virtual ~LogicalDeleteResourceResponseBody() = default;
};
class LogicalDeleteResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<LogicalDeleteResourceResponseBody> body{};

  LogicalDeleteResourceResponse() {}

  explicit LogicalDeleteResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LogicalDeleteResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LogicalDeleteResourceResponseBody>(model1);
      }
    }
  }


  virtual ~LogicalDeleteResourceResponse() = default;
};
class ListMediaWorkflowExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> inputFileURL{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> ownerAccount{};

  ListMediaWorkflowExecutionsRequest() {}

  explicit ListMediaWorkflowExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (inputFileURL) {
      res["InputFileURL"] = boost::any(*inputFileURL);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("InputFileURL") != m.end() && !m["InputFileURL"].empty()) {
      inputFileURL = make_shared<string>(boost::any_cast<string>(m["InputFileURL"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsRequest() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> type{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult> MNSMessageResult{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult>(model1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>> activity{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activity) {
      vector<boost::any> temp1;
      for(auto item1:*activity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activity") != m.end() && !m["Activity"].empty()) {
      if (typeid(vector<boost::any>) == m["Activity"].type()) {
        vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activity = make_shared<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>>(expect1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput : public Darabonba::Model {
public:
  shared_ptr<string> userData{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile> inputFile{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile>(model1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList> activityList{};
  shared_ptr<string> name{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput> input{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> runId{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (activityList) {
      res["ActivityList"] = activityList ? boost::any(activityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ActivityList") != m.end() && !m["ActivityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityList"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityList"]));
        activityList = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["RunId"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>> mediaWorkflowExecution{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecution) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflowExecution){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflowExecution"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecution") != m.end() && !m["MediaWorkflowExecution"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflowExecution"].type()) {
        vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflowExecution"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflowExecution = make_shared<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>>(expect1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList() = default;
};
class ListMediaWorkflowExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList> mediaWorkflowExecutionList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};

  ListMediaWorkflowExecutionsResponseBody() {}

  explicit ListMediaWorkflowExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecutionList) {
      res["MediaWorkflowExecutionList"] = mediaWorkflowExecutionList ? boost::any(mediaWorkflowExecutionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecutionList") != m.end() && !m["MediaWorkflowExecutionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowExecutionList"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowExecutionList"]));
        mediaWorkflowExecutionList = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBody() = default;
};
class ListMediaWorkflowExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBody> body{};

  ListMediaWorkflowExecutionsResponse() {}

  explicit ListMediaWorkflowExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaWorkflowExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaWorkflowExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponse() = default;
};
class SubmitInnerJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> video{};
  shared_ptr<string> images{};
  shared_ptr<long> uid{};
  shared_ptr<string> config{};

  SubmitInnerJobRequest() {}

  explicit SubmitInnerJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    if (images) {
      res["Images"] = boost::any(*images);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      images = make_shared<string>(boost::any_cast<string>(m["Images"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<long>(boost::any_cast<long>(m["Uid"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
  }


  virtual ~SubmitInnerJobRequest() = default;
};
class SubmitInnerJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitInnerJobResponseBody() {}

  explicit SubmitInnerJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitInnerJobResponseBody() = default;
};
class SubmitInnerJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitInnerJobResponseBody> body{};

  SubmitInnerJobResponse() {}

  explicit SubmitInnerJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitInnerJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitInnerJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitInnerJobResponse() = default;
};
class QueryMediaDetailJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryMediaDetailJobListRequest() {}

  explicit QueryMediaDetailJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMediaDetailJobListRequest() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> name{};
  shared_ptr<string> target{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive>> sensitive{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sensitive) {
      vector<boost::any> temp1;
      for(auto item1:*sensitive){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sensitive"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sensitive") != m.end() && !m["Sensitive"].empty()) {
      if (typeid(vector<boost::any>) == m["Sensitive"].type()) {
        vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sensitive"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitive = make_shared<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive>>(expect1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> name{};
  shared_ptr<string> target{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician>> politician{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (politician) {
      vector<boost::any> temp1;
      for(auto item1:*politician){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Politician"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Politician") != m.end() && !m["Politician"].empty()) {
      if (typeid(vector<boost::any>) == m["Politician"].type()) {
        vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Politician"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        politician = make_shared<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician>>(expect1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> minScore{};
  shared_ptr<string> startTime{};
  shared_ptr<string> avgScore{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> endTarget{};
  shared_ptr<string> startTarget{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (minScore) {
      res["MinScore"] = boost::any(*minScore);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (avgScore) {
      res["AvgScore"] = boost::any(*avgScore);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (endTarget) {
      res["EndTarget"] = boost::any(*endTarget);
    }
    if (startTarget) {
      res["StartTarget"] = boost::any(*startTarget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MinScore") != m.end() && !m["MinScore"].empty()) {
      minScore = make_shared<string>(boost::any_cast<string>(m["MinScore"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("AvgScore") != m.end() && !m["AvgScore"].empty()) {
      avgScore = make_shared<string>(boost::any_cast<string>(m["AvgScore"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("EndTarget") != m.end() && !m["EndTarget"].empty()) {
      endTarget = make_shared<string>(boost::any_cast<string>(m["EndTarget"]));
    }
    if (m.find("StartTarget") != m.end() && !m["StartTarget"].empty()) {
      startTarget = make_shared<string>(boost::any_cast<string>(m["StartTarget"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip>> clip{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip>>(expect1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips> clips{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (clips) {
      res["Clips"] = clips ? boost::any(clips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clips"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clips"]));
        clips = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips>(model1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom>> custom{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (custom) {
      vector<boost::any> temp1;
      for(auto item1:*custom){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Custom"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Custom") != m.end() && !m["Custom"].empty()) {
      if (typeid(vector<boost::any>) == m["Custom"].type()) {
        vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Custom"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        custom = make_shared<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom>>(expect1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> category{};
  shared_ptr<string> tag{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo>> frameTagInfo{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameTagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*frameTagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameTagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameTagInfo") != m.end() && !m["FrameTagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameTagInfo"].type()) {
        vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameTagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameTagInfo = make_shared<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo>>(expect1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> name{};
  shared_ptr<string> target{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity>> celebrity{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (celebrity) {
      vector<boost::any> temp1;
      for(auto item1:*celebrity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Celebrity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Celebrity") != m.end() && !m["Celebrity"].empty()) {
      if (typeid(vector<boost::any>) == m["Celebrity"].type()) {
        vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Celebrity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        celebrity = make_shared<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity>>(expect1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives> sensitives{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians> politicians{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags> frameTags{};
  shared_ptr<string> imageUrl{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms> customs{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos> frameTagInfos{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities> celebrities{};
  shared_ptr<string> ocrText{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (sensitives) {
      res["Sensitives"] = sensitives ? boost::any(sensitives->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (politicians) {
      res["Politicians"] = politicians ? boost::any(politicians->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (frameTags) {
      res["FrameTags"] = frameTags ? boost::any(frameTags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (customs) {
      res["Customs"] = customs ? boost::any(customs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (frameTagInfos) {
      res["FrameTagInfos"] = frameTagInfos ? boost::any(frameTagInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (celebrities) {
      res["Celebrities"] = celebrities ? boost::any(celebrities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ocrText) {
      res["OcrText"] = boost::any(*ocrText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Sensitives") != m.end() && !m["Sensitives"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sensitives"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sensitives"]));
        sensitives = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives>(model1);
      }
    }
    if (m.find("Politicians") != m.end() && !m["Politicians"].empty()) {
      if (typeid(map<string, boost::any>) == m["Politicians"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Politicians"]));
        politicians = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians>(model1);
      }
    }
    if (m.find("FrameTags") != m.end() && !m["FrameTags"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrameTags"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrameTags"]));
        frameTags = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags>(model1);
      }
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Customs") != m.end() && !m["Customs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Customs"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Customs"]));
        customs = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms>(model1);
      }
    }
    if (m.find("FrameTagInfos") != m.end() && !m["FrameTagInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrameTagInfos"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrameTagInfos"]));
        frameTagInfos = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos>(model1);
      }
    }
    if (m.find("Celebrities") != m.end() && !m["Celebrities"].empty()) {
      if (typeid(map<string, boost::any>) == m["Celebrities"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Celebrities"]));
        celebrities = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities>(model1);
      }
    }
    if (m.find("OcrText") != m.end() && !m["OcrText"].empty()) {
      ocrText = make_shared<string>(boost::any_cast<string>(m["OcrText"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult>> mediaDetailRecgResult{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaDetailRecgResult) {
      vector<boost::any> temp1;
      for(auto item1:*mediaDetailRecgResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaDetailRecgResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaDetailRecgResult") != m.end() && !m["MediaDetailRecgResult"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaDetailRecgResult"].type()) {
        vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaDetailRecgResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaDetailRecgResult = make_shared<vector<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults> mediaDetailRecgResults{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags> tags{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (mediaDetailRecgResults) {
      res["MediaDetailRecgResults"] = mediaDetailRecgResults ? boost::any(mediaDetailRecgResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("MediaDetailRecgResults") != m.end() && !m["MediaDetailRecgResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaDetailRecgResults"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaDetailRecgResults"]));
        mediaDetailRecgResults = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags>(model1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig : public Darabonba::Model {
public:
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile> outputFile{};
  shared_ptr<string> scenario{};
  shared_ptr<string> detailType{};

  QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (detailType) {
      res["DetailType"] = boost::any(*detailType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile>(model1);
      }
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("DetailType") != m.end() && !m["DetailType"].empty()) {
      detailType = make_shared<string>(boost::any_cast<string>(m["DetailType"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMediaDetailJobListResponseBodyJobListJobInput() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJobInput() = default;
};
class QueryMediaDetailJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult> mediaDetailResult{};
  shared_ptr<string> message{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig> mediaDetailConfig{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobListJobInput> input{};
  shared_ptr<string> id{};

  QueryMediaDetailJobListResponseBodyJobListJob() {}

  explicit QueryMediaDetailJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaDetailResult) {
      res["MediaDetailResult"] = mediaDetailResult ? boost::any(mediaDetailResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (mediaDetailConfig) {
      res["MediaDetailConfig"] = mediaDetailConfig ? boost::any(mediaDetailConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaDetailResult") != m.end() && !m["MediaDetailResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaDetailResult"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaDetailResult"]));
        mediaDetailResult = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MediaDetailConfig") != m.end() && !m["MediaDetailConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaDetailConfig"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaDetailConfig"]));
        mediaDetailConfig = make_shared<QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaDetailJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaDetailJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobListJob() = default;
};
class QueryMediaDetailJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaDetailJobListResponseBodyJobListJob>> job{};

  QueryMediaDetailJobListResponseBodyJobList() {}

  explicit QueryMediaDetailJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryMediaDetailJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaDetailJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryMediaDetailJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyJobList() = default;
};
class QueryMediaDetailJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaDetailJobListResponseBodyNonExistIds() {}

  explicit QueryMediaDetailJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaDetailJobListResponseBodyNonExistIds() = default;
};
class QueryMediaDetailJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryMediaDetailJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryMediaDetailJobListResponseBodyNonExistIds> nonExistIds{};

  QueryMediaDetailJobListResponseBody() {}

  explicit QueryMediaDetailJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryMediaDetailJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryMediaDetailJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryMediaDetailJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryMediaDetailJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponseBody() = default;
};
class QueryMediaDetailJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaDetailJobListResponseBody> body{};

  QueryMediaDetailJobListResponse() {}

  explicit QueryMediaDetailJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaDetailJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaDetailJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaDetailJobListResponse() = default;
};
class UpdatePornPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};

  UpdatePornPipelineRequest() {}

  explicit UpdatePornPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdatePornPipelineRequest() = default;
};
class UpdatePornPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  UpdatePornPipelineResponseBodyPipelineNotifyConfig() {}

  explicit UpdatePornPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~UpdatePornPipelineResponseBodyPipelineNotifyConfig() = default;
};
class UpdatePornPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<UpdatePornPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  UpdatePornPipelineResponseBodyPipeline() {}

  explicit UpdatePornPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        UpdatePornPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<UpdatePornPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdatePornPipelineResponseBodyPipeline() = default;
};
class UpdatePornPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdatePornPipelineResponseBodyPipeline> pipeline{};

  UpdatePornPipelineResponseBody() {}

  explicit UpdatePornPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        UpdatePornPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<UpdatePornPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~UpdatePornPipelineResponseBody() = default;
};
class UpdatePornPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdatePornPipelineResponseBody> body{};

  UpdatePornPipelineResponse() {}

  explicit UpdatePornPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePornPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePornPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePornPipelineResponse() = default;
};
class DeleteWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> ownerAccount{};

  DeleteWaterMarkTemplateRequest() {}

  explicit DeleteWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteWaterMarkTemplateRequest() = default;
};
class DeleteWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> waterMarkTemplateId{};

  DeleteWaterMarkTemplateResponseBody() {}

  explicit DeleteWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
  }


  virtual ~DeleteWaterMarkTemplateResponseBody() = default;
};
class DeleteWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteWaterMarkTemplateResponseBody> body{};

  DeleteWaterMarkTemplateResponse() {}

  explicit DeleteWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWaterMarkTemplateResponse() = default;
};
class SubmitVideoQualityJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> userId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> modelId{};
  shared_ptr<string> input{};
  shared_ptr<string> output{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> scheduleParams{};
  shared_ptr<string> userData{};
  shared_ptr<string> notifyUrl{};

  SubmitVideoQualityJobRequest() {}

  explicit SubmitVideoQualityJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (scheduleParams) {
      res["ScheduleParams"] = boost::any(*scheduleParams);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("ScheduleParams") != m.end() && !m["ScheduleParams"].empty()) {
      scheduleParams = make_shared<string>(boost::any_cast<string>(m["ScheduleParams"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
  }


  virtual ~SubmitVideoQualityJobRequest() = default;
};
class SubmitVideoQualityJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> jobId{};

  SubmitVideoQualityJobResponseBody() {}

  explicit SubmitVideoQualityJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitVideoQualityJobResponseBody() = default;
};
class SubmitVideoQualityJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitVideoQualityJobResponseBody> body{};

  SubmitVideoQualityJobResponse() {}

  explicit SubmitVideoQualityJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitVideoQualityJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitVideoQualityJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitVideoQualityJobResponse() = default;
};
class AddCoverPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> ownerAccount{};

  AddCoverPipelineRequest() {}

  explicit AddCoverPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddCoverPipelineRequest() = default;
};
class AddCoverPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  AddCoverPipelineResponseBodyPipelineNotifyConfig() {}

  explicit AddCoverPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~AddCoverPipelineResponseBodyPipelineNotifyConfig() = default;
};
class AddCoverPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<AddCoverPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  AddCoverPipelineResponseBodyPipeline() {}

  explicit AddCoverPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        AddCoverPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<AddCoverPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~AddCoverPipelineResponseBodyPipeline() = default;
};
class AddCoverPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddCoverPipelineResponseBodyPipeline> pipeline{};

  AddCoverPipelineResponseBody() {}

  explicit AddCoverPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        AddCoverPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<AddCoverPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~AddCoverPipelineResponseBody() = default;
};
class AddCoverPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddCoverPipelineResponseBody> body{};

  AddCoverPipelineResponse() {}

  explicit AddCoverPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCoverPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCoverPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~AddCoverPipelineResponse() = default;
};
class SubmitURLUploadJobRequestTargetStorage : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> objectKey{};
  shared_ptr<string> bucketOwnerId{};
  shared_ptr<string> objectRoleName{};
  shared_ptr<string> s3Provider{};
  shared_ptr<string> s3Endpoint{};
  shared_ptr<string> s3AccessKey{};
  shared_ptr<string> s3SecretKey{};
  shared_ptr<string> s3SessionToken{};

  SubmitURLUploadJobRequestTargetStorage() {}

  explicit SubmitURLUploadJobRequestTargetStorage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    if (bucketOwnerId) {
      res["BucketOwnerId"] = boost::any(*bucketOwnerId);
    }
    if (objectRoleName) {
      res["ObjectRoleName"] = boost::any(*objectRoleName);
    }
    if (s3Provider) {
      res["S3Provider"] = boost::any(*s3Provider);
    }
    if (s3Endpoint) {
      res["S3Endpoint"] = boost::any(*s3Endpoint);
    }
    if (s3AccessKey) {
      res["S3AccessKey"] = boost::any(*s3AccessKey);
    }
    if (s3SecretKey) {
      res["S3SecretKey"] = boost::any(*s3SecretKey);
    }
    if (s3SessionToken) {
      res["S3SessionToken"] = boost::any(*s3SessionToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
    if (m.find("BucketOwnerId") != m.end() && !m["BucketOwnerId"].empty()) {
      bucketOwnerId = make_shared<string>(boost::any_cast<string>(m["BucketOwnerId"]));
    }
    if (m.find("ObjectRoleName") != m.end() && !m["ObjectRoleName"].empty()) {
      objectRoleName = make_shared<string>(boost::any_cast<string>(m["ObjectRoleName"]));
    }
    if (m.find("S3Provider") != m.end() && !m["S3Provider"].empty()) {
      s3Provider = make_shared<string>(boost::any_cast<string>(m["S3Provider"]));
    }
    if (m.find("S3Endpoint") != m.end() && !m["S3Endpoint"].empty()) {
      s3Endpoint = make_shared<string>(boost::any_cast<string>(m["S3Endpoint"]));
    }
    if (m.find("S3AccessKey") != m.end() && !m["S3AccessKey"].empty()) {
      s3AccessKey = make_shared<string>(boost::any_cast<string>(m["S3AccessKey"]));
    }
    if (m.find("S3SecretKey") != m.end() && !m["S3SecretKey"].empty()) {
      s3SecretKey = make_shared<string>(boost::any_cast<string>(m["S3SecretKey"]));
    }
    if (m.find("S3SessionToken") != m.end() && !m["S3SessionToken"].empty()) {
      s3SessionToken = make_shared<string>(boost::any_cast<string>(m["S3SessionToken"]));
    }
  }


  virtual ~SubmitURLUploadJobRequestTargetStorage() = default;
};
class SubmitURLUploadJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> sourceFileURL{};
  shared_ptr<SubmitURLUploadJobRequestTargetStorage> targetStorage{};
  shared_ptr<string> userData{};
  shared_ptr<string> notify{};

  SubmitURLUploadJobRequest() {}

  explicit SubmitURLUploadJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sourceFileURL) {
      res["SourceFileURL"] = boost::any(*sourceFileURL);
    }
    if (targetStorage) {
      res["TargetStorage"] = targetStorage ? boost::any(targetStorage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (notify) {
      res["Notify"] = boost::any(*notify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SourceFileURL") != m.end() && !m["SourceFileURL"].empty()) {
      sourceFileURL = make_shared<string>(boost::any_cast<string>(m["SourceFileURL"]));
    }
    if (m.find("TargetStorage") != m.end() && !m["TargetStorage"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetStorage"].type()) {
        SubmitURLUploadJobRequestTargetStorage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetStorage"]));
        targetStorage = make_shared<SubmitURLUploadJobRequestTargetStorage>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      notify = make_shared<string>(boost::any_cast<string>(m["Notify"]));
    }
  }


  virtual ~SubmitURLUploadJobRequest() = default;
};
class SubmitURLUploadJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> sourceFileURL{};
  shared_ptr<string> targetStorageShrink{};
  shared_ptr<string> userData{};
  shared_ptr<string> notify{};

  SubmitURLUploadJobShrinkRequest() {}

  explicit SubmitURLUploadJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sourceFileURL) {
      res["SourceFileURL"] = boost::any(*sourceFileURL);
    }
    if (targetStorageShrink) {
      res["TargetStorage"] = boost::any(*targetStorageShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (notify) {
      res["Notify"] = boost::any(*notify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SourceFileURL") != m.end() && !m["SourceFileURL"].empty()) {
      sourceFileURL = make_shared<string>(boost::any_cast<string>(m["SourceFileURL"]));
    }
    if (m.find("TargetStorage") != m.end() && !m["TargetStorage"].empty()) {
      targetStorageShrink = make_shared<string>(boost::any_cast<string>(m["TargetStorage"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      notify = make_shared<string>(boost::any_cast<string>(m["Notify"]));
    }
  }


  virtual ~SubmitURLUploadJobShrinkRequest() = default;
};
class SubmitURLUploadJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitURLUploadJobResponseBody() {}

  explicit SubmitURLUploadJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitURLUploadJobResponseBody() = default;
};
class SubmitURLUploadJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitURLUploadJobResponseBody> body{};

  SubmitURLUploadJobResponse() {}

  explicit SubmitURLUploadJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitURLUploadJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitURLUploadJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitURLUploadJobResponse() = default;
};
class QueryMediaListByURLRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> fileURLs{};
  shared_ptr<bool> includePlayList{};
  shared_ptr<bool> includeSnapshotList{};
  shared_ptr<bool> includeMediaInfo{};
  shared_ptr<bool> includeSummaryList{};
  shared_ptr<string> ownerAccount{};

  QueryMediaListByURLRequest() {}

  explicit QueryMediaListByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (fileURLs) {
      res["FileURLs"] = boost::any(*fileURLs);
    }
    if (includePlayList) {
      res["IncludePlayList"] = boost::any(*includePlayList);
    }
    if (includeSnapshotList) {
      res["IncludeSnapshotList"] = boost::any(*includeSnapshotList);
    }
    if (includeMediaInfo) {
      res["IncludeMediaInfo"] = boost::any(*includeMediaInfo);
    }
    if (includeSummaryList) {
      res["IncludeSummaryList"] = boost::any(*includeSummaryList);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("FileURLs") != m.end() && !m["FileURLs"].empty()) {
      fileURLs = make_shared<string>(boost::any_cast<string>(m["FileURLs"]));
    }
    if (m.find("IncludePlayList") != m.end() && !m["IncludePlayList"].empty()) {
      includePlayList = make_shared<bool>(boost::any_cast<bool>(m["IncludePlayList"]));
    }
    if (m.find("IncludeSnapshotList") != m.end() && !m["IncludeSnapshotList"].empty()) {
      includeSnapshotList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSnapshotList"]));
    }
    if (m.find("IncludeMediaInfo") != m.end() && !m["IncludeMediaInfo"].empty()) {
      includeMediaInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeMediaInfo"]));
    }
    if (m.find("IncludeSummaryList") != m.end() && !m["IncludeSummaryList"].empty()) {
      includeSummaryList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSummaryList"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMediaListByURLRequest() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  QueryMediaListByURLResponseBodyMediaListMediaTags() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaTags() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay : public Darabonba::Model {
public:
  shared_ptr<string> encryption{};
  shared_ptr<string> height{};
  shared_ptr<string> bitrate{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> width{};
  shared_ptr<string> size{};
  shared_ptr<string> fps{};
  shared_ptr<string> duration{};
  shared_ptr<string> activityName{};
  shared_ptr<string> format{};
  shared_ptr<string> mediaWorkflowName{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryption) {
      res["Encryption"] = boost::any(*encryption);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["Encryption"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay>> play{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (play) {
      vector<boost::any> temp1;
      for(auto item1:*play){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Play"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Play") != m.end() && !m["Play"].empty()) {
      if (typeid(vector<boost::any>) == m["Play"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Play"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        play = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> activityName{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile> file{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary>> summary{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> sar{};
  shared_ptr<string> height{};
  shared_ptr<string> codecTagString{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> width{};
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> rotate{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList> videoStreamList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList> subtitleStreamList{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfo : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams> streams{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat> format{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfo() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfo() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> activityName{};
  shared_ptr<string> count{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile> file{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot>> snapshot{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaListByURLResponseBodyMediaListMediaRunIdList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaRunIdList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> cateId{};
  shared_ptr<string> height{};
  shared_ptr<string> censorState{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaTags> tags{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaPlayList> playList{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> mediaId{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaFile> file{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSummaryList> summaryList{};
  shared_ptr<string> publishState{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfo> mediaInfo{};
  shared_ptr<string> description{};
  shared_ptr<string> size{};
  shared_ptr<string> width{};
  shared_ptr<string> coverURL{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSnapshotList> snapshotList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> title{};
  shared_ptr<string> format{};

  QueryMediaListByURLResponseBodyMediaListMedia() {}

  explicit QueryMediaListByURLResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playList) {
      res["PlayList"] = playList ? boost::any(playList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summaryList) {
      res["SummaryList"] = summaryList ? boost::any(summaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (snapshotList) {
      res["SnapshotList"] = snapshotList ? boost::any(snapshotList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryMediaListByURLResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("PlayList") != m.end() && !m["PlayList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaPlayList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayList"]));
        playList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaPlayList>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("SummaryList") != m.end() && !m["SummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SummaryList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SummaryList"]));
        summaryList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSummaryList>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfo>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("SnapshotList") != m.end() && !m["SnapshotList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSnapshotList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotList"]));
        snapshotList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSnapshotList>(model1);
      }
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMedia() = default;
};
class QueryMediaListByURLResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMedia>> media{};

  QueryMediaListByURLResponseBodyMediaList() {}

  explicit QueryMediaListByURLResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaList() = default;
};
class QueryMediaListByURLResponseBodyNonExistFileURLs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileURL{};

  QueryMediaListByURLResponseBodyNonExistFileURLs() {}

  explicit QueryMediaListByURLResponseBodyNonExistFileURLs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileURL"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileURL"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileURL = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyNonExistFileURLs() = default;
};
class QueryMediaListByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaList> mediaList{};
  shared_ptr<QueryMediaListByURLResponseBodyNonExistFileURLs> nonExistFileURLs{};
  shared_ptr<string> requestId{};

  QueryMediaListByURLResponseBody() {}

  explicit QueryMediaListByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistFileURLs) {
      res["NonExistFileURLs"] = nonExistFileURLs ? boost::any(nonExistFileURLs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        QueryMediaListByURLResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<QueryMediaListByURLResponseBodyMediaList>(model1);
      }
    }
    if (m.find("NonExistFileURLs") != m.end() && !m["NonExistFileURLs"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistFileURLs"].type()) {
        QueryMediaListByURLResponseBodyNonExistFileURLs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistFileURLs"]));
        nonExistFileURLs = make_shared<QueryMediaListByURLResponseBodyNonExistFileURLs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBody() = default;
};
class QueryMediaListByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaListByURLResponseBody> body{};

  QueryMediaListByURLResponse() {}

  explicit QueryMediaListByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaListByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaListByURLResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponse() = default;
};
class SubmitMediaFpDeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitMediaFpDeleteJobRequest() {}

  explicit SubmitMediaFpDeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitMediaFpDeleteJobRequest() = default;
};
class SubmitMediaFpDeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitMediaFpDeleteJobResponseBody() {}

  explicit SubmitMediaFpDeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitMediaFpDeleteJobResponseBody() = default;
};
class SubmitMediaFpDeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitMediaFpDeleteJobResponseBody> body{};

  SubmitMediaFpDeleteJobResponse() {}

  explicit SubmitMediaFpDeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaFpDeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaFpDeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaFpDeleteJobResponse() = default;
};
class DeactivateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};

  DeactivateMediaWorkflowRequest() {}

  explicit DeactivateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeactivateMediaWorkflowRequest() = default;
};
class DeactivateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};

  DeactivateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit DeactivateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~DeactivateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class DeactivateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeactivateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};

  DeactivateMediaWorkflowResponseBody() {}

  explicit DeactivateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        DeactivateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<DeactivateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
  }


  virtual ~DeactivateMediaWorkflowResponseBody() = default;
};
class DeactivateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeactivateMediaWorkflowResponseBody> body{};

  DeactivateMediaWorkflowResponse() {}

  explicit DeactivateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactivateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactivateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~DeactivateMediaWorkflowResponse() = default;
};
class PhysicalDeleteResourceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> interrupt{};
  shared_ptr<string> invoker{};
  shared_ptr<string> pk{};
  shared_ptr<string> bid{};
  shared_ptr<long> hid{};
  shared_ptr<string> country{};
  shared_ptr<string> taskIdentifier{};
  shared_ptr<string> taskExtraData{};
  shared_ptr<string> gmtWakeup{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};

  PhysicalDeleteResourceRequest() {}

  explicit PhysicalDeleteResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interrupt) {
      res["Interrupt"] = boost::any(*interrupt);
    }
    if (invoker) {
      res["Invoker"] = boost::any(*invoker);
    }
    if (pk) {
      res["Pk"] = boost::any(*pk);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (hid) {
      res["Hid"] = boost::any(*hid);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (taskIdentifier) {
      res["TaskIdentifier"] = boost::any(*taskIdentifier);
    }
    if (taskExtraData) {
      res["TaskExtraData"] = boost::any(*taskExtraData);
    }
    if (gmtWakeup) {
      res["GmtWakeup"] = boost::any(*gmtWakeup);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interrupt") != m.end() && !m["Interrupt"].empty()) {
      interrupt = make_shared<bool>(boost::any_cast<bool>(m["Interrupt"]));
    }
    if (m.find("Invoker") != m.end() && !m["Invoker"].empty()) {
      invoker = make_shared<string>(boost::any_cast<string>(m["Invoker"]));
    }
    if (m.find("Pk") != m.end() && !m["Pk"].empty()) {
      pk = make_shared<string>(boost::any_cast<string>(m["Pk"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Hid") != m.end() && !m["Hid"].empty()) {
      hid = make_shared<long>(boost::any_cast<long>(m["Hid"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("TaskIdentifier") != m.end() && !m["TaskIdentifier"].empty()) {
      taskIdentifier = make_shared<string>(boost::any_cast<string>(m["TaskIdentifier"]));
    }
    if (m.find("TaskExtraData") != m.end() && !m["TaskExtraData"].empty()) {
      taskExtraData = make_shared<string>(boost::any_cast<string>(m["TaskExtraData"]));
    }
    if (m.find("GmtWakeup") != m.end() && !m["GmtWakeup"].empty()) {
      gmtWakeup = make_shared<string>(boost::any_cast<string>(m["GmtWakeup"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~PhysicalDeleteResourceRequest() = default;
};
class PhysicalDeleteResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> gmtWakeup{};
  shared_ptr<long> hid{};
  shared_ptr<string> invoker{};
  shared_ptr<string> message{};
  shared_ptr<string> taskIdentifier{};
  shared_ptr<string> taskExtraData{};
  shared_ptr<string> country{};
  shared_ptr<string> pk{};
  shared_ptr<string> bid{};
  shared_ptr<bool> success{};
  shared_ptr<bool> interrupt{};

  PhysicalDeleteResourceResponseBody() {}

  explicit PhysicalDeleteResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtWakeup) {
      res["GmtWakeup"] = boost::any(*gmtWakeup);
    }
    if (hid) {
      res["Hid"] = boost::any(*hid);
    }
    if (invoker) {
      res["Invoker"] = boost::any(*invoker);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (taskIdentifier) {
      res["TaskIdentifier"] = boost::any(*taskIdentifier);
    }
    if (taskExtraData) {
      res["TaskExtraData"] = boost::any(*taskExtraData);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (pk) {
      res["Pk"] = boost::any(*pk);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (interrupt) {
      res["Interrupt"] = boost::any(*interrupt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtWakeup") != m.end() && !m["GmtWakeup"].empty()) {
      gmtWakeup = make_shared<string>(boost::any_cast<string>(m["GmtWakeup"]));
    }
    if (m.find("Hid") != m.end() && !m["Hid"].empty()) {
      hid = make_shared<long>(boost::any_cast<long>(m["Hid"]));
    }
    if (m.find("Invoker") != m.end() && !m["Invoker"].empty()) {
      invoker = make_shared<string>(boost::any_cast<string>(m["Invoker"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("TaskIdentifier") != m.end() && !m["TaskIdentifier"].empty()) {
      taskIdentifier = make_shared<string>(boost::any_cast<string>(m["TaskIdentifier"]));
    }
    if (m.find("TaskExtraData") != m.end() && !m["TaskExtraData"].empty()) {
      taskExtraData = make_shared<string>(boost::any_cast<string>(m["TaskExtraData"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Pk") != m.end() && !m["Pk"].empty()) {
      pk = make_shared<string>(boost::any_cast<string>(m["Pk"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Interrupt") != m.end() && !m["Interrupt"].empty()) {
      interrupt = make_shared<bool>(boost::any_cast<bool>(m["Interrupt"]));
    }
  }


  virtual ~PhysicalDeleteResourceResponseBody() = default;
};
class PhysicalDeleteResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PhysicalDeleteResourceResponseBody> body{};

  PhysicalDeleteResourceResponse() {}

  explicit PhysicalDeleteResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PhysicalDeleteResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PhysicalDeleteResourceResponseBody>(model1);
      }
    }
  }


  virtual ~PhysicalDeleteResourceResponse() = default;
};
class DeleteMCTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> ownerAccount{};

  DeleteMCTemplateRequest() {}

  explicit DeleteMCTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteMCTemplateRequest() = default;
};
class DeleteMCTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  DeleteMCTemplateResponseBody() {}

  explicit DeleteMCTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteMCTemplateResponseBody() = default;
};
class DeleteMCTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMCTemplateResponseBody> body{};

  DeleteMCTemplateResponse() {}

  explicit DeleteMCTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMCTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMCTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMCTemplateResponse() = default;
};
class UpdatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> ownerAccount{};

  UpdatePipelineRequest() {}

  explicit UpdatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdatePipelineRequest() = default;
};
class UpdatePipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> mqTopic{};
  shared_ptr<string> queueName{};
  shared_ptr<string> mqTag{};
  shared_ptr<string> topic{};

  UpdatePipelineResponseBodyPipelineNotifyConfig() {}

  explicit UpdatePipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mqTopic) {
      res["MqTopic"] = boost::any(*mqTopic);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (mqTag) {
      res["MqTag"] = boost::any(*mqTag);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MqTopic") != m.end() && !m["MqTopic"].empty()) {
      mqTopic = make_shared<string>(boost::any_cast<string>(m["MqTopic"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("MqTag") != m.end() && !m["MqTag"].empty()) {
      mqTag = make_shared<string>(boost::any_cast<string>(m["MqTag"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~UpdatePipelineResponseBodyPipelineNotifyConfig() = default;
};
class UpdatePipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> speed{};
  shared_ptr<string> state{};
  shared_ptr<UpdatePipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> role{};
  shared_ptr<string> id{};
  shared_ptr<long> quotaAllocate{};

  UpdatePipelineResponseBodyPipeline() {}

  explicit UpdatePipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (quotaAllocate) {
      res["QuotaAllocate"] = boost::any(*quotaAllocate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        UpdatePipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<UpdatePipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("QuotaAllocate") != m.end() && !m["QuotaAllocate"].empty()) {
      quotaAllocate = make_shared<long>(boost::any_cast<long>(m["QuotaAllocate"]));
    }
  }


  virtual ~UpdatePipelineResponseBodyPipeline() = default;
};
class UpdatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdatePipelineResponseBodyPipeline> pipeline{};

  UpdatePipelineResponseBody() {}

  explicit UpdatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        UpdatePipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<UpdatePipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~UpdatePipelineResponseBody() = default;
};
class UpdatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdatePipelineResponseBody> body{};

  UpdatePipelineResponse() {}

  explicit UpdatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineResponse() = default;
};
class DeleteMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaIds{};
  shared_ptr<string> ownerAccount{};

  DeleteMediaRequest() {}

  explicit DeleteMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteMediaRequest() = default;
};
class DeleteMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaResponseBody() {}

  explicit DeleteMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaResponseBody() = default;
};
class DeleteMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMediaResponseBody> body{};

  DeleteMediaResponse() {}

  explicit DeleteMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaResponse() = default;
};
class QueryFpCompareJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryFpCompareJobListRequest() {}

  explicit QueryFpCompareJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryFpCompareJobListRequest() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage : public Darabonba::Model {
public:
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames> masterMediaFrames{};
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile> matchedFramesDescFile{};
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames> queryMediaFrames{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (masterMediaFrames) {
      res["MasterMediaFrames"] = masterMediaFrames ? boost::any(masterMediaFrames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (matchedFramesDescFile) {
      res["MatchedFramesDescFile"] = matchedFramesDescFile ? boost::any(matchedFramesDescFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryMediaFrames) {
      res["QueryMediaFrames"] = queryMediaFrames ? boost::any(queryMediaFrames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MasterMediaFrames") != m.end() && !m["MasterMediaFrames"].empty()) {
      if (typeid(map<string, boost::any>) == m["MasterMediaFrames"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MasterMediaFrames"]));
        masterMediaFrames = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames>(model1);
      }
    }
    if (m.find("MatchedFramesDescFile") != m.end() && !m["MatchedFramesDescFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["MatchedFramesDescFile"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MatchedFramesDescFile"]));
        matchedFramesDescFile = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile>(model1);
      }
    }
    if (m.find("QueryMediaFrames") != m.end() && !m["QueryMediaFrames"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryMediaFrames"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryMediaFrames"]));
        queryMediaFrames = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames>(model1);
      }
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment : public Darabonba::Model {
public:
  shared_ptr<string> queryStartTime{};
  shared_ptr<string> queryEndFrame{};
  shared_ptr<string> score{};
  shared_ptr<string> totalMatchFrameNum{};
  shared_ptr<string> masterEndTime{};
  shared_ptr<string> masterStartTime{};
  shared_ptr<string> queryStartFrame{};
  shared_ptr<string> masterEndFrame{};
  shared_ptr<string> masterStartFrame{};
  shared_ptr<string> queryEndTime{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryStartTime) {
      res["QueryStartTime"] = boost::any(*queryStartTime);
    }
    if (queryEndFrame) {
      res["QueryEndFrame"] = boost::any(*queryEndFrame);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (totalMatchFrameNum) {
      res["TotalMatchFrameNum"] = boost::any(*totalMatchFrameNum);
    }
    if (masterEndTime) {
      res["MasterEndTime"] = boost::any(*masterEndTime);
    }
    if (masterStartTime) {
      res["MasterStartTime"] = boost::any(*masterStartTime);
    }
    if (queryStartFrame) {
      res["QueryStartFrame"] = boost::any(*queryStartFrame);
    }
    if (masterEndFrame) {
      res["MasterEndFrame"] = boost::any(*masterEndFrame);
    }
    if (masterStartFrame) {
      res["MasterStartFrame"] = boost::any(*masterStartFrame);
    }
    if (queryEndTime) {
      res["QueryEndTime"] = boost::any(*queryEndTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryStartTime") != m.end() && !m["QueryStartTime"].empty()) {
      queryStartTime = make_shared<string>(boost::any_cast<string>(m["QueryStartTime"]));
    }
    if (m.find("QueryEndFrame") != m.end() && !m["QueryEndFrame"].empty()) {
      queryEndFrame = make_shared<string>(boost::any_cast<string>(m["QueryEndFrame"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("TotalMatchFrameNum") != m.end() && !m["TotalMatchFrameNum"].empty()) {
      totalMatchFrameNum = make_shared<string>(boost::any_cast<string>(m["TotalMatchFrameNum"]));
    }
    if (m.find("MasterEndTime") != m.end() && !m["MasterEndTime"].empty()) {
      masterEndTime = make_shared<string>(boost::any_cast<string>(m["MasterEndTime"]));
    }
    if (m.find("MasterStartTime") != m.end() && !m["MasterStartTime"].empty()) {
      masterStartTime = make_shared<string>(boost::any_cast<string>(m["MasterStartTime"]));
    }
    if (m.find("QueryStartFrame") != m.end() && !m["QueryStartFrame"].empty()) {
      queryStartFrame = make_shared<string>(boost::any_cast<string>(m["QueryStartFrame"]));
    }
    if (m.find("MasterEndFrame") != m.end() && !m["MasterEndFrame"].empty()) {
      masterEndFrame = make_shared<string>(boost::any_cast<string>(m["MasterEndFrame"]));
    }
    if (m.find("MasterStartFrame") != m.end() && !m["MasterStartFrame"].empty()) {
      masterStartFrame = make_shared<string>(boost::any_cast<string>(m["MasterStartFrame"]));
    }
    if (m.find("QueryEndTime") != m.end() && !m["QueryEndTime"].empty()) {
      queryEndTime = make_shared<string>(boost::any_cast<string>(m["QueryEndTime"]));
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment>> mediaMatchSegment{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaMatchSegment) {
      vector<boost::any> temp1;
      for(auto item1:*mediaMatchSegment){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaMatchSegment"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaMatchSegment") != m.end() && !m["MediaMatchSegment"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaMatchSegment"].type()) {
        vector<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaMatchSegment"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaMatchSegment = make_shared<vector<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment>>(expect1);
      }
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo : public Darabonba::Model {
public:
  shared_ptr<string> audioSampleRate{};
  shared_ptr<string> audioBitRate{};
  shared_ptr<string> fpNum{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> totalVideoFrame{};
  shared_ptr<string> fps{};
  shared_ptr<string> duration{};
  shared_ptr<string> audioChannels{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSampleRate) {
      res["AudioSampleRate"] = boost::any(*audioSampleRate);
    }
    if (audioBitRate) {
      res["AudioBitRate"] = boost::any(*audioBitRate);
    }
    if (fpNum) {
      res["FpNum"] = boost::any(*fpNum);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (totalVideoFrame) {
      res["TotalVideoFrame"] = boost::any(*totalVideoFrame);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (audioChannels) {
      res["AudioChannels"] = boost::any(*audioChannels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSampleRate") != m.end() && !m["AudioSampleRate"].empty()) {
      audioSampleRate = make_shared<string>(boost::any_cast<string>(m["AudioSampleRate"]));
    }
    if (m.find("AudioBitRate") != m.end() && !m["AudioBitRate"].empty()) {
      audioBitRate = make_shared<string>(boost::any_cast<string>(m["AudioBitRate"]));
    }
    if (m.find("FpNum") != m.end() && !m["FpNum"].empty()) {
      fpNum = make_shared<string>(boost::any_cast<string>(m["FpNum"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("TotalVideoFrame") != m.end() && !m["TotalVideoFrame"].empty()) {
      totalVideoFrame = make_shared<string>(boost::any_cast<string>(m["TotalVideoFrame"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("AudioChannels") != m.end() && !m["AudioChannels"].empty()) {
      audioChannels = make_shared<string>(boost::any_cast<string>(m["AudioChannels"]));
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo : public Darabonba::Model {
public:
  shared_ptr<string> audioSampleRate{};
  shared_ptr<string> audioBitRate{};
  shared_ptr<string> fpNum{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> totalVideoFrame{};
  shared_ptr<string> fps{};
  shared_ptr<string> duration{};
  shared_ptr<string> audioChannels{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSampleRate) {
      res["AudioSampleRate"] = boost::any(*audioSampleRate);
    }
    if (audioBitRate) {
      res["AudioBitRate"] = boost::any(*audioBitRate);
    }
    if (fpNum) {
      res["FpNum"] = boost::any(*fpNum);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (totalVideoFrame) {
      res["TotalVideoFrame"] = boost::any(*totalVideoFrame);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (audioChannels) {
      res["AudioChannels"] = boost::any(*audioChannels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSampleRate") != m.end() && !m["AudioSampleRate"].empty()) {
      audioSampleRate = make_shared<string>(boost::any_cast<string>(m["AudioSampleRate"]));
    }
    if (m.find("AudioBitRate") != m.end() && !m["AudioBitRate"].empty()) {
      audioBitRate = make_shared<string>(boost::any_cast<string>(m["AudioBitRate"]));
    }
    if (m.find("FpNum") != m.end() && !m["FpNum"].empty()) {
      fpNum = make_shared<string>(boost::any_cast<string>(m["FpNum"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("TotalVideoFrame") != m.end() && !m["TotalVideoFrame"].empty()) {
      totalVideoFrame = make_shared<string>(boost::any_cast<string>(m["TotalVideoFrame"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("AudioChannels") != m.end() && !m["AudioChannels"].empty()) {
      audioChannels = make_shared<string>(boost::any_cast<string>(m["AudioChannels"]));
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult : public Darabonba::Model {
public:
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments> mediaMatchSegments{};
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo> queryMediaInfo{};
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo> masterMediaInfo{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaMatchSegments) {
      res["MediaMatchSegments"] = mediaMatchSegments ? boost::any(mediaMatchSegments->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryMediaInfo) {
      res["QueryMediaInfo"] = queryMediaInfo ? boost::any(queryMediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterMediaInfo) {
      res["MasterMediaInfo"] = masterMediaInfo ? boost::any(masterMediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaMatchSegments") != m.end() && !m["MediaMatchSegments"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaMatchSegments"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaMatchSegments"]));
        mediaMatchSegments = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments>(model1);
      }
    }
    if (m.find("QueryMediaInfo") != m.end() && !m["QueryMediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryMediaInfo"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryMediaInfo"]));
        queryMediaInfo = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo>(model1);
      }
    }
    if (m.find("MasterMediaInfo") != m.end() && !m["MasterMediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MasterMediaInfo"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MasterMediaInfo"]));
        masterMediaInfo = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo>(model1);
      }
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob : public Darabonba::Model {
public:
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile> masterFile{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<string> message{};
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile> queryFile{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage> matchFrameStorage{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> id{};
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult> fpCompareResult{};

  QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (masterFile) {
      res["MasterFile"] = masterFile ? boost::any(masterFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (queryFile) {
      res["QueryFile"] = queryFile ? boost::any(queryFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (matchFrameStorage) {
      res["MatchFrameStorage"] = matchFrameStorage ? boost::any(matchFrameStorage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (fpCompareResult) {
      res["FpCompareResult"] = fpCompareResult ? boost::any(fpCompareResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MasterFile") != m.end() && !m["MasterFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["MasterFile"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MasterFile"]));
        masterFile = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("QueryFile") != m.end() && !m["QueryFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryFile"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryFile"]));
        queryFile = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile>(model1);
      }
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MatchFrameStorage") != m.end() && !m["MatchFrameStorage"].empty()) {
      if (typeid(map<string, boost::any>) == m["MatchFrameStorage"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MatchFrameStorage"]));
        matchFrameStorage = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("FpCompareResult") != m.end() && !m["FpCompareResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpCompareResult"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpCompareResult"]));
        fpCompareResult = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult>(model1);
      }
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob() = default;
};
class QueryFpCompareJobListResponseBodyFpCompareJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob>> fpCompareJob{};

  QueryFpCompareJobListResponseBodyFpCompareJobList() {}

  explicit QueryFpCompareJobListResponseBodyFpCompareJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpCompareJob) {
      vector<boost::any> temp1;
      for(auto item1:*fpCompareJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpCompareJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpCompareJob") != m.end() && !m["FpCompareJob"].empty()) {
      if (typeid(vector<boost::any>) == m["FpCompareJob"].type()) {
        vector<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpCompareJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpCompareJob = make_shared<vector<QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob>>(expect1);
      }
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyFpCompareJobList() = default;
};
class QueryFpCompareJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFpCompareJobListResponseBodyNonExistIds() {}

  explicit QueryFpCompareJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFpCompareJobListResponseBodyNonExistIds() = default;
};
class QueryFpCompareJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryFpCompareJobListResponseBodyFpCompareJobList> fpCompareJobList{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryFpCompareJobListResponseBodyNonExistIds> nonExistIds{};

  QueryFpCompareJobListResponseBody() {}

  explicit QueryFpCompareJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpCompareJobList) {
      res["FpCompareJobList"] = fpCompareJobList ? boost::any(fpCompareJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpCompareJobList") != m.end() && !m["FpCompareJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpCompareJobList"].type()) {
        QueryFpCompareJobListResponseBodyFpCompareJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpCompareJobList"]));
        fpCompareJobList = make_shared<QueryFpCompareJobListResponseBodyFpCompareJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryFpCompareJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryFpCompareJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryFpCompareJobListResponseBody() = default;
};
class QueryFpCompareJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryFpCompareJobListResponseBody> body{};

  QueryFpCompareJobListResponse() {}

  explicit QueryFpCompareJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFpCompareJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFpCompareJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFpCompareJobListResponse() = default;
};
class BindOutputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> bucket{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> ownerAccount{};

  BindOutputBucketRequest() {}

  explicit BindOutputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~BindOutputBucketRequest() = default;
};
class BindOutputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindOutputBucketResponseBody() {}

  explicit BindOutputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindOutputBucketResponseBody() = default;
};
class BindOutputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindOutputBucketResponseBody> body{};

  BindOutputBucketResponse() {}

  explicit BindOutputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindOutputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindOutputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~BindOutputBucketResponse() = default;
};
class AddPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> ownerAccount{};

  AddPipelineRequest() {}

  explicit AddPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddPipelineRequest() = default;
};
class AddPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> mqTopic{};
  shared_ptr<string> queueName{};
  shared_ptr<string> mqTag{};
  shared_ptr<string> topic{};

  AddPipelineResponseBodyPipelineNotifyConfig() {}

  explicit AddPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mqTopic) {
      res["MqTopic"] = boost::any(*mqTopic);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (mqTag) {
      res["MqTag"] = boost::any(*mqTag);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MqTopic") != m.end() && !m["MqTopic"].empty()) {
      mqTopic = make_shared<string>(boost::any_cast<string>(m["MqTopic"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("MqTag") != m.end() && !m["MqTag"].empty()) {
      mqTag = make_shared<string>(boost::any_cast<string>(m["MqTag"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~AddPipelineResponseBodyPipelineNotifyConfig() = default;
};
class AddPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> speed{};
  shared_ptr<string> state{};
  shared_ptr<long> speedLevel{};
  shared_ptr<AddPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<long> quotaAllocate{};

  AddPipelineResponseBodyPipeline() {}

  explicit AddPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (quotaAllocate) {
      res["QuotaAllocate"] = boost::any(*quotaAllocate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        AddPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<AddPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("QuotaAllocate") != m.end() && !m["QuotaAllocate"].empty()) {
      quotaAllocate = make_shared<long>(boost::any_cast<long>(m["QuotaAllocate"]));
    }
  }


  virtual ~AddPipelineResponseBodyPipeline() = default;
};
class AddPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddPipelineResponseBodyPipeline> pipeline{};

  AddPipelineResponseBody() {}

  explicit AddPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        AddPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<AddPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~AddPipelineResponseBody() = default;
};
class AddPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddPipelineResponseBody> body{};

  AddPipelineResponse() {}

  explicit AddPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~AddPipelineResponse() = default;
};
class QueryMCJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> state{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  QueryMCJobListRequest() {}

  explicit QueryMCJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMCJobListRequest() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText>> pornText{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornText) {
      vector<boost::any> temp1;
      for(auto item1:*pornText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PornText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornText") != m.end() && !m["PornText"].empty()) {
      if (typeid(vector<boost::any>) == m["PornText"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PornText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pornText = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo>> pornVideo{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornVideo) {
      vector<boost::any> temp1;
      for(auto item1:*pornVideo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PornVideo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornVideo") != m.end() && !m["PornVideo"].empty()) {
      if (typeid(vector<boost::any>) == m["PornVideo"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PornVideo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pornVideo = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio>> pornAudio{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornAudio) {
      vector<boost::any> temp1;
      for(auto item1:*pornAudio){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PornAudio"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornAudio") != m.end() && !m["PornAudio"].empty()) {
      if (typeid(vector<boost::any>) == m["PornAudio"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PornAudio"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pornAudio = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> url{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornImages : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage>> pornImage{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornImages() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornImage) {
      vector<boost::any> temp1;
      for(auto item1:*pornImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PornImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornImage") != m.end() && !m["PornImage"].empty()) {
      if (typeid(vector<boost::any>) == m["PornImage"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PornImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pornImage = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornImages() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr>> pornOcr{};

  QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornOcr) {
      vector<boost::any> temp1;
      for(auto item1:*pornOcr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PornOcr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornOcr") != m.end() && !m["PornOcr"].empty()) {
      if (typeid(vector<boost::any>) == m["PornOcr"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PornOcr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pornOcr = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPornResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts> pornTexts{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos> pornVideos{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios> pornAudios{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPornResultPornImages> pornImages{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs> pornOcrs{};

  QueryMCJobListResponseBodyJobListJobResultPornResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPornResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornTexts) {
      res["PornTexts"] = pornTexts ? boost::any(pornTexts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pornVideos) {
      res["PornVideos"] = pornVideos ? boost::any(pornVideos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pornAudios) {
      res["PornAudios"] = pornAudios ? boost::any(pornAudios->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pornImages) {
      res["PornImages"] = pornImages ? boost::any(pornImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pornOcrs) {
      res["PornOcrs"] = pornOcrs ? boost::any(pornOcrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornTexts") != m.end() && !m["PornTexts"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornTexts"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornTexts"]));
        pornTexts = make_shared<QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts>(model1);
      }
    }
    if (m.find("PornVideos") != m.end() && !m["PornVideos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornVideos"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornVideos"]));
        pornVideos = make_shared<QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos>(model1);
      }
    }
    if (m.find("PornAudios") != m.end() && !m["PornAudios"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornAudios"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornAudios"]));
        pornAudios = make_shared<QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios>(model1);
      }
    }
    if (m.find("PornImages") != m.end() && !m["PornImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornImages"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPornResultPornImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornImages"]));
        pornImages = make_shared<QueryMCJobListResponseBodyJobListJobResultPornResultPornImages>(model1);
      }
    }
    if (m.find("PornOcrs") != m.end() && !m["PornOcrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornOcrs"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornOcrs"]));
        pornOcrs = make_shared<QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPornResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr>> adOcr{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adOcr) {
      vector<boost::any> temp1;
      for(auto item1:*adOcr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdOcr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdOcr") != m.end() && !m["AdOcr"].empty()) {
      if (typeid(vector<boost::any>) == m["AdOcr"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdOcr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adOcr = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText>> adText{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adText) {
      vector<boost::any> temp1;
      for(auto item1:*adText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdText") != m.end() && !m["AdText"].empty()) {
      if (typeid(vector<boost::any>) == m["AdText"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adText = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> url{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdImages : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage>> adImage{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdImages() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adImage) {
      vector<boost::any> temp1;
      for(auto item1:*adImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdImage") != m.end() && !m["AdImage"].empty()) {
      if (typeid(vector<boost::any>) == m["AdImage"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adImage = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdImages() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio>> adAudio{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adAudio) {
      vector<boost::any> temp1;
      for(auto item1:*adAudio){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdAudio"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdAudio") != m.end() && !m["AdAudio"].empty()) {
      if (typeid(vector<boost::any>) == m["AdAudio"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdAudio"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adAudio = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo>> adVideo{};

  QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adVideo) {
      vector<boost::any> temp1;
      for(auto item1:*adVideo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdVideo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdVideo") != m.end() && !m["AdVideo"].empty()) {
      if (typeid(vector<boost::any>) == m["AdVideo"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdVideo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adVideo = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAdResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs> adOcrs{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts> adTexts{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAdResultAdImages> adImages{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios> adAudios{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos> adVideos{};

  QueryMCJobListResponseBodyJobListJobResultAdResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAdResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adOcrs) {
      res["AdOcrs"] = adOcrs ? boost::any(adOcrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (adTexts) {
      res["AdTexts"] = adTexts ? boost::any(adTexts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (adImages) {
      res["AdImages"] = adImages ? boost::any(adImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (adAudios) {
      res["AdAudios"] = adAudios ? boost::any(adAudios->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (adVideos) {
      res["AdVideos"] = adVideos ? boost::any(adVideos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdOcrs") != m.end() && !m["AdOcrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdOcrs"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdOcrs"]));
        adOcrs = make_shared<QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs>(model1);
      }
    }
    if (m.find("AdTexts") != m.end() && !m["AdTexts"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdTexts"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdTexts"]));
        adTexts = make_shared<QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts>(model1);
      }
    }
    if (m.find("AdImages") != m.end() && !m["AdImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdImages"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAdResultAdImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdImages"]));
        adImages = make_shared<QueryMCJobListResponseBodyJobListJobResultAdResultAdImages>(model1);
      }
    }
    if (m.find("AdAudios") != m.end() && !m["AdAudios"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdAudios"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdAudios"]));
        adAudios = make_shared<QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios>(model1);
      }
    }
    if (m.find("AdVideos") != m.end() && !m["AdVideos"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdVideos"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdVideos"]));
        adVideos = make_shared<QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAdResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> url{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage>> logoImage{};

  QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logoImage) {
      vector<boost::any> temp1;
      for(auto item1:*logoImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogoImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogoImage") != m.end() && !m["LogoImage"].empty()) {
      if (typeid(vector<boost::any>) == m["LogoImage"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogoImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logoImage = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo>> logoVideo{};

  QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logoVideo) {
      vector<boost::any> temp1;
      for(auto item1:*logoVideo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogoVideo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogoVideo") != m.end() && !m["LogoVideo"].empty()) {
      if (typeid(vector<boost::any>) == m["LogoVideo"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogoVideo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logoVideo = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLogoResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages> logoImages{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos> logoVideos{};

  QueryMCJobListResponseBodyJobListJobResultLogoResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLogoResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logoImages) {
      res["LogoImages"] = logoImages ? boost::any(logoImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logoVideos) {
      res["LogoVideos"] = logoVideos ? boost::any(logoVideos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogoImages") != m.end() && !m["LogoImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogoImages"].type()) {
        QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogoImages"]));
        logoImages = make_shared<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages>(model1);
      }
    }
    if (m.find("LogoVideos") != m.end() && !m["LogoVideos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogoVideos"].type()) {
        QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogoVideos"]));
        logoVideos = make_shared<QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLogoResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> url{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage() {}

  explicit QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage() = default;
};
class QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage>> qrcodeImage{};

  QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages() {}

  explicit QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qrcodeImage) {
      vector<boost::any> temp1;
      for(auto item1:*qrcodeImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QrcodeImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QrcodeImage") != m.end() && !m["QrcodeImage"].empty()) {
      if (typeid(vector<boost::any>) == m["QrcodeImage"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QrcodeImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qrcodeImage = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages() = default;
};
class QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo() {}

  explicit QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo() = default;
};
class QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo>> qrcodeVideo{};

  QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos() {}

  explicit QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qrcodeVideo) {
      vector<boost::any> temp1;
      for(auto item1:*qrcodeVideo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QrcodeVideo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QrcodeVideo") != m.end() && !m["QrcodeVideo"].empty()) {
      if (typeid(vector<boost::any>) == m["QrcodeVideo"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QrcodeVideo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qrcodeVideo = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos() = default;
};
class QueryMCJobListResponseBodyJobListJobResultQrcodeResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages> qrcodeImages{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos> qrcodeVideos{};

  QueryMCJobListResponseBodyJobListJobResultQrcodeResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultQrcodeResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qrcodeImages) {
      res["QrcodeImages"] = qrcodeImages ? boost::any(qrcodeImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (qrcodeVideos) {
      res["QrcodeVideos"] = qrcodeVideos ? boost::any(qrcodeVideos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QrcodeImages") != m.end() && !m["QrcodeImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["QrcodeImages"].type()) {
        QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QrcodeImages"]));
        qrcodeImages = make_shared<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages>(model1);
      }
    }
    if (m.find("QrcodeVideos") != m.end() && !m["QrcodeVideos"].empty()) {
      if (typeid(map<string, boost::any>) == m["QrcodeVideos"].type()) {
        QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QrcodeVideos"]));
        qrcodeVideos = make_shared<QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultQrcodeResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr>> politicsOcr{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (politicsOcr) {
      vector<boost::any> temp1;
      for(auto item1:*politicsOcr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PoliticsOcr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PoliticsOcr") != m.end() && !m["PoliticsOcr"].empty()) {
      if (typeid(vector<boost::any>) == m["PoliticsOcr"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PoliticsOcr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        politicsOcr = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo>> politicsVideo{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (politicsVideo) {
      vector<boost::any> temp1;
      for(auto item1:*politicsVideo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PoliticsVideo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PoliticsVideo") != m.end() && !m["PoliticsVideo"].empty()) {
      if (typeid(vector<boost::any>) == m["PoliticsVideo"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PoliticsVideo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        politicsVideo = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> url{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage>> politicsImage{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (politicsImage) {
      vector<boost::any> temp1;
      for(auto item1:*politicsImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PoliticsImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PoliticsImage") != m.end() && !m["PoliticsImage"].empty()) {
      if (typeid(vector<boost::any>) == m["PoliticsImage"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PoliticsImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        politicsImage = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText>> politicsText{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (politicsText) {
      vector<boost::any> temp1;
      for(auto item1:*politicsText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PoliticsText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PoliticsText") != m.end() && !m["PoliticsText"].empty()) {
      if (typeid(vector<boost::any>) == m["PoliticsText"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PoliticsText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        politicsText = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio>> politicsAudio{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (politicsAudio) {
      vector<boost::any> temp1;
      for(auto item1:*politicsAudio){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PoliticsAudio"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PoliticsAudio") != m.end() && !m["PoliticsAudio"].empty()) {
      if (typeid(vector<boost::any>) == m["PoliticsAudio"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PoliticsAudio"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        politicsAudio = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios() = default;
};
class QueryMCJobListResponseBodyJobListJobResultPoliticsResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs> politicsOcrs{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos> politicsVideos{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages> politicsImages{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts> politicsTexts{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios> politicsAudios{};

  QueryMCJobListResponseBodyJobListJobResultPoliticsResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultPoliticsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (politicsOcrs) {
      res["PoliticsOcrs"] = politicsOcrs ? boost::any(politicsOcrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (politicsVideos) {
      res["PoliticsVideos"] = politicsVideos ? boost::any(politicsVideos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (politicsImages) {
      res["PoliticsImages"] = politicsImages ? boost::any(politicsImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (politicsTexts) {
      res["PoliticsTexts"] = politicsTexts ? boost::any(politicsTexts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (politicsAudios) {
      res["PoliticsAudios"] = politicsAudios ? boost::any(politicsAudios->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PoliticsOcrs") != m.end() && !m["PoliticsOcrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["PoliticsOcrs"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PoliticsOcrs"]));
        politicsOcrs = make_shared<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs>(model1);
      }
    }
    if (m.find("PoliticsVideos") != m.end() && !m["PoliticsVideos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PoliticsVideos"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PoliticsVideos"]));
        politicsVideos = make_shared<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos>(model1);
      }
    }
    if (m.find("PoliticsImages") != m.end() && !m["PoliticsImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["PoliticsImages"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PoliticsImages"]));
        politicsImages = make_shared<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages>(model1);
      }
    }
    if (m.find("PoliticsTexts") != m.end() && !m["PoliticsTexts"].empty()) {
      if (typeid(map<string, boost::any>) == m["PoliticsTexts"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PoliticsTexts"]));
        politicsTexts = make_shared<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts>(model1);
      }
    }
    if (m.find("PoliticsAudios") != m.end() && !m["PoliticsAudios"].empty()) {
      if (typeid(map<string, boost::any>) == m["PoliticsAudios"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PoliticsAudios"]));
        politicsAudios = make_shared<QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultPoliticsResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> url{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage>> liveImage{};

  QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveImage) {
      vector<boost::any> temp1;
      for(auto item1:*liveImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveImage") != m.end() && !m["LiveImage"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveImage"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveImage = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo>> liveVideo{};

  QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveVideo) {
      vector<boost::any> temp1;
      for(auto item1:*liveVideo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveVideo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveVideo") != m.end() && !m["LiveVideo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveVideo"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveVideo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveVideo = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos() = default;
};
class QueryMCJobListResponseBodyJobListJobResultLiveResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages> liveImages{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos> liveVideos{};

  QueryMCJobListResponseBodyJobListJobResultLiveResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultLiveResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveImages) {
      res["LiveImages"] = liveImages ? boost::any(liveImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (liveVideos) {
      res["LiveVideos"] = liveVideos ? boost::any(liveVideos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveImages") != m.end() && !m["LiveImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveImages"].type()) {
        QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveImages"]));
        liveImages = make_shared<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages>(model1);
      }
    }
    if (m.find("LiveVideos") != m.end() && !m["LiveVideos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveVideos"].type()) {
        QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveVideos"]));
        liveVideos = make_shared<QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultLiveResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr>> abuseOcr{};

  QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abuseOcr) {
      vector<boost::any> temp1;
      for(auto item1:*abuseOcr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AbuseOcr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbuseOcr") != m.end() && !m["AbuseOcr"].empty()) {
      if (typeid(vector<boost::any>) == m["AbuseOcr"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AbuseOcr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        abuseOcr = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio>> abuseAudio{};

  QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abuseAudio) {
      vector<boost::any> temp1;
      for(auto item1:*abuseAudio){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AbuseAudio"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbuseAudio") != m.end() && !m["AbuseAudio"].empty()) {
      if (typeid(vector<boost::any>) == m["AbuseAudio"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AbuseAudio"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        abuseAudio = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText>> abuseText{};

  QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abuseText) {
      vector<boost::any> temp1;
      for(auto item1:*abuseText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AbuseText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbuseText") != m.end() && !m["AbuseText"].empty()) {
      if (typeid(vector<boost::any>) == m["AbuseText"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AbuseText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        abuseText = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts() = default;
};
class QueryMCJobListResponseBodyJobListJobResultAbuseResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs> abuseOcrs{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios> abuseAudios{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts> abuseTexts{};

  QueryMCJobListResponseBodyJobListJobResultAbuseResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultAbuseResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abuseOcrs) {
      res["AbuseOcrs"] = abuseOcrs ? boost::any(abuseOcrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (abuseAudios) {
      res["AbuseAudios"] = abuseAudios ? boost::any(abuseAudios->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (abuseTexts) {
      res["AbuseTexts"] = abuseTexts ? boost::any(abuseTexts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbuseOcrs") != m.end() && !m["AbuseOcrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["AbuseOcrs"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AbuseOcrs"]));
        abuseOcrs = make_shared<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs>(model1);
      }
    }
    if (m.find("AbuseAudios") != m.end() && !m["AbuseAudios"].empty()) {
      if (typeid(map<string, boost::any>) == m["AbuseAudios"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AbuseAudios"]));
        abuseAudios = make_shared<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios>(model1);
      }
    }
    if (m.find("AbuseTexts") != m.end() && !m["AbuseTexts"].empty()) {
      if (typeid(map<string, boost::any>) == m["AbuseTexts"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AbuseTexts"]));
        abuseTexts = make_shared<QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultAbuseResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText() {}

  explicit QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText() = default;
};
class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText>> spamText{};

  QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts() {}

  explicit QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spamText) {
      vector<boost::any> temp1;
      for(auto item1:*spamText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpamText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpamText") != m.end() && !m["SpamText"].empty()) {
      if (typeid(vector<boost::any>) == m["SpamText"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpamText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spamText = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts() = default;
};
class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio() {}

  explicit QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio() = default;
};
class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio>> spamAudio{};

  QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios() {}

  explicit QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spamAudio) {
      vector<boost::any> temp1;
      for(auto item1:*spamAudio){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpamAudio"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpamAudio") != m.end() && !m["SpamAudio"].empty()) {
      if (typeid(vector<boost::any>) == m["SpamAudio"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpamAudio"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spamAudio = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios() = default;
};
class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr() {}

  explicit QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr() = default;
};
class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr>> spamOcr{};

  QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs() {}

  explicit QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spamOcr) {
      vector<boost::any> temp1;
      for(auto item1:*spamOcr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpamOcr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpamOcr") != m.end() && !m["SpamOcr"].empty()) {
      if (typeid(vector<boost::any>) == m["SpamOcr"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpamOcr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spamOcr = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs() = default;
};
class QueryMCJobListResponseBodyJobListJobResultSpamResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts> spamTexts{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios> spamAudios{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs> spamOcrs{};

  QueryMCJobListResponseBodyJobListJobResultSpamResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultSpamResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spamTexts) {
      res["SpamTexts"] = spamTexts ? boost::any(spamTexts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spamAudios) {
      res["SpamAudios"] = spamAudios ? boost::any(spamAudios->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spamOcrs) {
      res["SpamOcrs"] = spamOcrs ? boost::any(spamOcrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpamTexts") != m.end() && !m["SpamTexts"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpamTexts"].type()) {
        QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpamTexts"]));
        spamTexts = make_shared<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts>(model1);
      }
    }
    if (m.find("SpamAudios") != m.end() && !m["SpamAudios"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpamAudios"].type()) {
        QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpamAudios"]));
        spamAudios = make_shared<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios>(model1);
      }
    }
    if (m.find("SpamOcrs") != m.end() && !m["SpamOcrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpamOcrs"].type()) {
        QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpamOcrs"]));
        spamOcrs = make_shared<QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultSpamResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio() {}

  explicit QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio() = default;
};
class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio>> contrabandAudio{};

  QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios() {}

  explicit QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contrabandAudio) {
      vector<boost::any> temp1;
      for(auto item1:*contrabandAudio){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContrabandAudio"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContrabandAudio") != m.end() && !m["ContrabandAudio"].empty()) {
      if (typeid(vector<boost::any>) == m["ContrabandAudio"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContrabandAudio"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contrabandAudio = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios() = default;
};
class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr() {}

  explicit QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr() = default;
};
class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr>> contrabandOcr{};

  QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs() {}

  explicit QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contrabandOcr) {
      vector<boost::any> temp1;
      for(auto item1:*contrabandOcr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContrabandOcr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContrabandOcr") != m.end() && !m["ContrabandOcr"].empty()) {
      if (typeid(vector<boost::any>) == m["ContrabandOcr"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContrabandOcr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contrabandOcr = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs() = default;
};
class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText() {}

  explicit QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText() = default;
};
class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText>> contrabandText{};

  QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts() {}

  explicit QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contrabandText) {
      vector<boost::any> temp1;
      for(auto item1:*contrabandText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContrabandText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContrabandText") != m.end() && !m["ContrabandText"].empty()) {
      if (typeid(vector<boost::any>) == m["ContrabandText"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContrabandText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contrabandText = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts() = default;
};
class QueryMCJobListResponseBodyJobListJobResultContrabandResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios> contrabandAudios{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs> contrabandOcrs{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts> contrabandTexts{};

  QueryMCJobListResponseBodyJobListJobResultContrabandResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultContrabandResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contrabandAudios) {
      res["ContrabandAudios"] = contrabandAudios ? boost::any(contrabandAudios->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contrabandOcrs) {
      res["ContrabandOcrs"] = contrabandOcrs ? boost::any(contrabandOcrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contrabandTexts) {
      res["ContrabandTexts"] = contrabandTexts ? boost::any(contrabandTexts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContrabandAudios") != m.end() && !m["ContrabandAudios"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContrabandAudios"].type()) {
        QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContrabandAudios"]));
        contrabandAudios = make_shared<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios>(model1);
      }
    }
    if (m.find("ContrabandOcrs") != m.end() && !m["ContrabandOcrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContrabandOcrs"].type()) {
        QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContrabandOcrs"]));
        contrabandOcrs = make_shared<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs>(model1);
      }
    }
    if (m.find("ContrabandTexts") != m.end() && !m["ContrabandTexts"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContrabandTexts"].type()) {
        QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContrabandTexts"]));
        contrabandTexts = make_shared<QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultContrabandResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr>> terrorismOcr{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismOcr) {
      vector<boost::any> temp1;
      for(auto item1:*terrorismOcr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TerrorismOcr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismOcr") != m.end() && !m["TerrorismOcr"].empty()) {
      if (typeid(vector<boost::any>) == m["TerrorismOcr"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TerrorismOcr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        terrorismOcr = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio>> terrorismAudio{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismAudio) {
      vector<boost::any> temp1;
      for(auto item1:*terrorismAudio){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TerrorismAudio"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismAudio") != m.end() && !m["TerrorismAudio"].empty()) {
      if (typeid(vector<boost::any>) == m["TerrorismAudio"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TerrorismAudio"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        terrorismAudio = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> object{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo>> terrorismVideo{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismVideo) {
      vector<boost::any> temp1;
      for(auto item1:*terrorismVideo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TerrorismVideo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismVideo") != m.end() && !m["TerrorismVideo"].empty()) {
      if (typeid(vector<boost::any>) == m["TerrorismVideo"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TerrorismVideo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        terrorismVideo = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText>> terrorismText{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismText) {
      vector<boost::any> temp1;
      for(auto item1:*terrorismText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TerrorismText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismText") != m.end() && !m["TerrorismText"].empty()) {
      if (typeid(vector<boost::any>) == m["TerrorismText"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TerrorismText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        terrorismText = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<string> score{};
  shared_ptr<string> url{};
  shared_ptr<string> text{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage>> terrorismImage{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismImage) {
      vector<boost::any> temp1;
      for(auto item1:*terrorismImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TerrorismImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismImage") != m.end() && !m["TerrorismImage"].empty()) {
      if (typeid(vector<boost::any>) == m["TerrorismImage"].type()) {
        vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TerrorismImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        terrorismImage = make_shared<vector<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages() = default;
};
class QueryMCJobListResponseBodyJobListJobResultTerrorismResult : public Darabonba::Model {
public:
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs> terrorismOcrs{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios> terrorismAudios{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos> terrorismVideos{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts> terrorismTexts{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages> terrorismImages{};

  QueryMCJobListResponseBodyJobListJobResultTerrorismResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResultTerrorismResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismOcrs) {
      res["TerrorismOcrs"] = terrorismOcrs ? boost::any(terrorismOcrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (terrorismAudios) {
      res["TerrorismAudios"] = terrorismAudios ? boost::any(terrorismAudios->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (terrorismVideos) {
      res["TerrorismVideos"] = terrorismVideos ? boost::any(terrorismVideos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (terrorismTexts) {
      res["TerrorismTexts"] = terrorismTexts ? boost::any(terrorismTexts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (terrorismImages) {
      res["TerrorismImages"] = terrorismImages ? boost::any(terrorismImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismOcrs") != m.end() && !m["TerrorismOcrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismOcrs"].type()) {
        QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismOcrs"]));
        terrorismOcrs = make_shared<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs>(model1);
      }
    }
    if (m.find("TerrorismAudios") != m.end() && !m["TerrorismAudios"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismAudios"].type()) {
        QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismAudios"]));
        terrorismAudios = make_shared<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios>(model1);
      }
    }
    if (m.find("TerrorismVideos") != m.end() && !m["TerrorismVideos"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismVideos"].type()) {
        QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismVideos"]));
        terrorismVideos = make_shared<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos>(model1);
      }
    }
    if (m.find("TerrorismTexts") != m.end() && !m["TerrorismTexts"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismTexts"].type()) {
        QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismTexts"]));
        terrorismTexts = make_shared<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts>(model1);
      }
    }
    if (m.find("TerrorismImages") != m.end() && !m["TerrorismImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismImages"].type()) {
        QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismImages"]));
        terrorismImages = make_shared<QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResultTerrorismResult() = default;
};
class QueryMCJobListResponseBodyJobListJobResult : public Darabonba::Model {
public:
  shared_ptr<string> suggestion{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPornResult> pornResult{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAdResult> adResult{};
  shared_ptr<string> score{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultLogoResult> logoResult{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultQrcodeResult> qrcodeResult{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultPoliticsResult> politicsResult{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultLiveResult> liveResult{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultAbuseResult> abuseResult{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultSpamResult> spamResult{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultContrabandResult> contrabandResult{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResultTerrorismResult> terrorismResult{};

  QueryMCJobListResponseBodyJobListJobResult() {}

  explicit QueryMCJobListResponseBodyJobListJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (pornResult) {
      res["PornResult"] = pornResult ? boost::any(pornResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (adResult) {
      res["AdResult"] = adResult ? boost::any(adResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (logoResult) {
      res["LogoResult"] = logoResult ? boost::any(logoResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (qrcodeResult) {
      res["QrcodeResult"] = qrcodeResult ? boost::any(qrcodeResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (politicsResult) {
      res["PoliticsResult"] = politicsResult ? boost::any(politicsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (liveResult) {
      res["LiveResult"] = liveResult ? boost::any(liveResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (abuseResult) {
      res["AbuseResult"] = abuseResult ? boost::any(abuseResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spamResult) {
      res["SpamResult"] = spamResult ? boost::any(spamResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contrabandResult) {
      res["ContrabandResult"] = contrabandResult ? boost::any(contrabandResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (terrorismResult) {
      res["TerrorismResult"] = terrorismResult ? boost::any(terrorismResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("PornResult") != m.end() && !m["PornResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPornResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornResult"]));
        pornResult = make_shared<QueryMCJobListResponseBodyJobListJobResultPornResult>(model1);
      }
    }
    if (m.find("AdResult") != m.end() && !m["AdResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAdResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdResult"]));
        adResult = make_shared<QueryMCJobListResponseBodyJobListJobResultAdResult>(model1);
      }
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("LogoResult") != m.end() && !m["LogoResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogoResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultLogoResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogoResult"]));
        logoResult = make_shared<QueryMCJobListResponseBodyJobListJobResultLogoResult>(model1);
      }
    }
    if (m.find("QrcodeResult") != m.end() && !m["QrcodeResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["QrcodeResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultQrcodeResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QrcodeResult"]));
        qrcodeResult = make_shared<QueryMCJobListResponseBodyJobListJobResultQrcodeResult>(model1);
      }
    }
    if (m.find("PoliticsResult") != m.end() && !m["PoliticsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PoliticsResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultPoliticsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PoliticsResult"]));
        politicsResult = make_shared<QueryMCJobListResponseBodyJobListJobResultPoliticsResult>(model1);
      }
    }
    if (m.find("LiveResult") != m.end() && !m["LiveResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultLiveResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveResult"]));
        liveResult = make_shared<QueryMCJobListResponseBodyJobListJobResultLiveResult>(model1);
      }
    }
    if (m.find("AbuseResult") != m.end() && !m["AbuseResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AbuseResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultAbuseResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AbuseResult"]));
        abuseResult = make_shared<QueryMCJobListResponseBodyJobListJobResultAbuseResult>(model1);
      }
    }
    if (m.find("SpamResult") != m.end() && !m["SpamResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpamResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultSpamResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpamResult"]));
        spamResult = make_shared<QueryMCJobListResponseBodyJobListJobResultSpamResult>(model1);
      }
    }
    if (m.find("ContrabandResult") != m.end() && !m["ContrabandResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContrabandResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultContrabandResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContrabandResult"]));
        contrabandResult = make_shared<QueryMCJobListResponseBodyJobListJobResultContrabandResult>(model1);
      }
    }
    if (m.find("TerrorismResult") != m.end() && !m["TerrorismResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismResult"].type()) {
        QueryMCJobListResponseBodyJobListJobResultTerrorismResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismResult"]));
        terrorismResult = make_shared<QueryMCJobListResponseBodyJobListJobResultTerrorismResult>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJobResult() = default;
};
class QueryMCJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> resultOutputFile{};
  shared_ptr<QueryMCJobListResponseBodyJobListJobResult> result{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};

  QueryMCJobListResponseBodyJobListJob() {}

  explicit QueryMCJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (resultOutputFile) {
      res["ResultOutputFile"] = boost::any(*resultOutputFile);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ResultOutputFile") != m.end() && !m["ResultOutputFile"].empty()) {
      resultOutputFile = make_shared<string>(boost::any_cast<string>(m["ResultOutputFile"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        QueryMCJobListResponseBodyJobListJobResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<QueryMCJobListResponseBodyJobListJobResult>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~QueryMCJobListResponseBodyJobListJob() = default;
};
class QueryMCJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMCJobListResponseBodyJobListJob>> job{};

  QueryMCJobListResponseBodyJobList() {}

  explicit QueryMCJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryMCJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMCJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryMCJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBodyJobList() = default;
};
class QueryMCJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMCJobListResponseBodyNonExistIds() {}

  explicit QueryMCJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMCJobListResponseBodyNonExistIds() = default;
};
class QueryMCJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMCJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryMCJobListResponseBodyNonExistIds> nonExistIds{};

  QueryMCJobListResponseBody() {}

  explicit QueryMCJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryMCJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryMCJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryMCJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryMCJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponseBody() = default;
};
class QueryMCJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMCJobListResponseBody> body{};

  QueryMCJobListResponse() {}

  explicit QueryMCJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMCJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMCJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMCJobListResponse() = default;
};
class QueryMediaListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaIds{};
  shared_ptr<bool> includePlayList{};
  shared_ptr<bool> includeSnapshotList{};
  shared_ptr<bool> includeMediaInfo{};
  shared_ptr<bool> includeSummaryList{};
  shared_ptr<string> ownerAccount{};

  QueryMediaListRequest() {}

  explicit QueryMediaListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (includePlayList) {
      res["IncludePlayList"] = boost::any(*includePlayList);
    }
    if (includeSnapshotList) {
      res["IncludeSnapshotList"] = boost::any(*includeSnapshotList);
    }
    if (includeMediaInfo) {
      res["IncludeMediaInfo"] = boost::any(*includeMediaInfo);
    }
    if (includeSummaryList) {
      res["IncludeSummaryList"] = boost::any(*includeSummaryList);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("IncludePlayList") != m.end() && !m["IncludePlayList"].empty()) {
      includePlayList = make_shared<bool>(boost::any_cast<bool>(m["IncludePlayList"]));
    }
    if (m.find("IncludeSnapshotList") != m.end() && !m["IncludeSnapshotList"].empty()) {
      includeSnapshotList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSnapshotList"]));
    }
    if (m.find("IncludeMediaInfo") != m.end() && !m["IncludeMediaInfo"].empty()) {
      includeMediaInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeMediaInfo"]));
    }
    if (m.find("IncludeSummaryList") != m.end() && !m["IncludeSummaryList"].empty()) {
      includeSummaryList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSummaryList"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMediaListRequest() = default;
};
class QueryMediaListResponseBodyNonExistMediaIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaId{};

  QueryMediaListResponseBodyNonExistMediaIds() {}

  explicit QueryMediaListResponseBodyNonExistMediaIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyNonExistMediaIds() = default;
};
class QueryMediaListResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  QueryMediaListResponseBodyMediaListMediaTags() {}

  explicit QueryMediaListResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaTags() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayListPlayFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaPlayListPlayFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayListPlayFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayListPlayFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayListPlay : public Darabonba::Model {
public:
  shared_ptr<string> encryption{};
  shared_ptr<string> height{};
  shared_ptr<string> bitrate{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaPlayListPlayFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> width{};
  shared_ptr<string> size{};
  shared_ptr<string> fps{};
  shared_ptr<string> duration{};
  shared_ptr<string> activityName{};
  shared_ptr<string> format{};
  shared_ptr<string> mediaWorkflowName{};

  QueryMediaListResponseBodyMediaListMediaPlayListPlay() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayListPlay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryption) {
      res["Encryption"] = boost::any(*encryption);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["Encryption"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaPlayListPlayFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaPlayListPlayFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayListPlay() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay>> play{};

  QueryMediaListResponseBodyMediaListMediaPlayList() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (play) {
      vector<boost::any> temp1;
      for(auto item1:*play){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Play"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Play") != m.end() && !m["Play"].empty()) {
      if (typeid(vector<boost::any>) == m["Play"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Play"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaPlayListPlay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        play = make_shared<vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayList() = default;
};
class QueryMediaListResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryListSummary : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> activityName{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile> file{};

  QueryMediaListResponseBodyMediaListMediaSummaryListSummary() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryListSummary() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary>> summary{};

  QueryMediaListResponseBodyMediaListMediaSummaryList() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaSummaryListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> sar{};
  shared_ptr<string> height{};
  shared_ptr<string> codecTagString{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> width{};
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> rotate{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList> videoStreamList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList> subtitleStreamList{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreams() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreams() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoFormat() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoFormat() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfo : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreams> streams{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoFormat> format{};

  QueryMediaListResponseBodyMediaListMediaMediaInfo() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoFormat>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfo() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> activityName{};
  shared_ptr<string> count{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile> file{};

  QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot>> snapshot{};

  QueryMediaListResponseBodyMediaListMediaSnapshotList() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotList() = default;
};
class QueryMediaListResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaListResponseBodyMediaListMediaRunIdList() {}

  explicit QueryMediaListResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaRunIdList() = default;
};
class QueryMediaListResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> cateId{};
  shared_ptr<string> height{};
  shared_ptr<string> censorState{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaTags> tags{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaPlayList> playList{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> mediaId{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaFile> file{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSummaryList> summaryList{};
  shared_ptr<string> publishState{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfo> mediaInfo{};
  shared_ptr<string> description{};
  shared_ptr<string> size{};
  shared_ptr<string> width{};
  shared_ptr<string> coverURL{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSnapshotList> snapshotList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> title{};
  shared_ptr<string> format{};

  QueryMediaListResponseBodyMediaListMedia() {}

  explicit QueryMediaListResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playList) {
      res["PlayList"] = playList ? boost::any(playList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summaryList) {
      res["SummaryList"] = summaryList ? boost::any(summaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (snapshotList) {
      res["SnapshotList"] = snapshotList ? boost::any(snapshotList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryMediaListResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryMediaListResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("PlayList") != m.end() && !m["PlayList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayList"].type()) {
        QueryMediaListResponseBodyMediaListMediaPlayList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayList"]));
        playList = make_shared<QueryMediaListResponseBodyMediaListMediaPlayList>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("SummaryList") != m.end() && !m["SummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SummaryList"].type()) {
        QueryMediaListResponseBodyMediaListMediaSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SummaryList"]));
        summaryList = make_shared<QueryMediaListResponseBodyMediaListMediaSummaryList>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfo>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("SnapshotList") != m.end() && !m["SnapshotList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotList"].type()) {
        QueryMediaListResponseBodyMediaListMediaSnapshotList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotList"]));
        snapshotList = make_shared<QueryMediaListResponseBodyMediaListMediaSnapshotList>(model1);
      }
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        QueryMediaListResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<QueryMediaListResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMedia() = default;
};
class QueryMediaListResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMedia>> media{};

  QueryMediaListResponseBodyMediaList() {}

  explicit QueryMediaListResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<QueryMediaListResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<QueryMediaListResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaList() = default;
};
class QueryMediaListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyNonExistMediaIds> nonExistMediaIds{};
  shared_ptr<QueryMediaListResponseBodyMediaList> mediaList{};
  shared_ptr<string> requestId{};

  QueryMediaListResponseBody() {}

  explicit QueryMediaListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistMediaIds) {
      res["NonExistMediaIds"] = nonExistMediaIds ? boost::any(nonExistMediaIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistMediaIds") != m.end() && !m["NonExistMediaIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaIds"].type()) {
        QueryMediaListResponseBodyNonExistMediaIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaIds"]));
        nonExistMediaIds = make_shared<QueryMediaListResponseBodyNonExistMediaIds>(model1);
      }
    }
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        QueryMediaListResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<QueryMediaListResponseBodyMediaList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaListResponseBody() = default;
};
class QueryMediaListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaListResponseBody> body{};

  QueryMediaListResponse() {}

  explicit QueryMediaListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponse() = default;
};
class QueryFpDBDeleteJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryFpDBDeleteJobListRequest() {}

  explicit QueryFpDBDeleteJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryFpDBDeleteJobListRequest() = default;
};
class QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> delType{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> id{};

  QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob() {}

  explicit QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (delType) {
      res["DelType"] = boost::any(*delType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("DelType") != m.end() && !m["DelType"].empty()) {
      delType = make_shared<string>(boost::any_cast<string>(m["DelType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob() = default;
};
class QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob>> fpDBDeleteJob{};

  QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList() {}

  explicit QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpDBDeleteJob) {
      vector<boost::any> temp1;
      for(auto item1:*fpDBDeleteJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpDBDeleteJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpDBDeleteJob") != m.end() && !m["FpDBDeleteJob"].empty()) {
      if (typeid(vector<boost::any>) == m["FpDBDeleteJob"].type()) {
        vector<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpDBDeleteJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpDBDeleteJob = make_shared<vector<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob>>(expect1);
      }
    }
  }


  virtual ~QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList() = default;
};
class QueryFpDBDeleteJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFpDBDeleteJobListResponseBodyNonExistIds() {}

  explicit QueryFpDBDeleteJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFpDBDeleteJobListResponseBodyNonExistIds() = default;
};
class QueryFpDBDeleteJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList> fpDBDeleteJobList{};
  shared_ptr<QueryFpDBDeleteJobListResponseBodyNonExistIds> nonExistIds{};

  QueryFpDBDeleteJobListResponseBody() {}

  explicit QueryFpDBDeleteJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (fpDBDeleteJobList) {
      res["FpDBDeleteJobList"] = fpDBDeleteJobList ? boost::any(fpDBDeleteJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FpDBDeleteJobList") != m.end() && !m["FpDBDeleteJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpDBDeleteJobList"].type()) {
        QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpDBDeleteJobList"]));
        fpDBDeleteJobList = make_shared<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryFpDBDeleteJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryFpDBDeleteJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryFpDBDeleteJobListResponseBody() = default;
};
class QueryFpDBDeleteJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryFpDBDeleteJobListResponseBody> body{};

  QueryFpDBDeleteJobListResponse() {}

  explicit QueryFpDBDeleteJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFpDBDeleteJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFpDBDeleteJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFpDBDeleteJobListResponse() = default;
};
class RegisterCustomFaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> personId{};
  shared_ptr<string> imageUrl{};

  RegisterCustomFaceRequest() {}

  explicit RegisterCustomFaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
  }


  virtual ~RegisterCustomFaceRequest() = default;
};
class RegisterCustomFaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> faceId{};
  shared_ptr<string> requestId{};

  RegisterCustomFaceResponseBody() {}

  explicit RegisterCustomFaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterCustomFaceResponseBody() = default;
};
class RegisterCustomFaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RegisterCustomFaceResponseBody> body{};

  RegisterCustomFaceResponse() {}

  explicit RegisterCustomFaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterCustomFaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterCustomFaceResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterCustomFaceResponse() = default;
};
class SubmitMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<bool> async{};
  shared_ptr<string> ownerAccount{};

  SubmitMediaInfoJobRequest() {}

  explicit SubmitMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequest() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> sar{};
  shared_ptr<string> height{};
  shared_ptr<string> codecTagString{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> width{};
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> rotate{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};
  shared_ptr<string> colorRange{};
  shared_ptr<string> colorTransfer{};
  shared_ptr<string> colorPrimaries{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (colorRange) {
      res["ColorRange"] = boost::any(*colorRange);
    }
    if (colorTransfer) {
      res["ColorTransfer"] = boost::any(*colorTransfer);
    }
    if (colorPrimaries) {
      res["ColorPrimaries"] = boost::any(*colorPrimaries);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("ColorRange") != m.end() && !m["ColorRange"].empty()) {
      colorRange = make_shared<string>(boost::any_cast<string>(m["ColorRange"]));
    }
    if (m.find("ColorTransfer") != m.end() && !m["ColorTransfer"].empty()) {
      colorTransfer = make_shared<string>(boost::any_cast<string>(m["ColorTransfer"]));
    }
    if (m.find("ColorPrimaries") != m.end() && !m["ColorPrimaries"].empty()) {
      colorPrimaries = make_shared<string>(boost::any_cast<string>(m["ColorPrimaries"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> codecTagString{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams> streams{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobProperties() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobProperties() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<bool> async{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobProperties> properties{};

  SubmitMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobProperties>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class SubmitMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  SubmitMediaInfoJobResponseBody() {}

  explicit SubmitMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBody() = default;
};
class SubmitMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitMediaInfoJobResponseBody> body{};

  SubmitMediaInfoJobResponse() {}

  explicit SubmitMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponse() = default;
};
class QueryPornJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryPornJobListRequest() {}

  explicit QueryPornJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryPornJobListRequest() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJobPornConfig : public Darabonba::Model {
public:
  shared_ptr<string> interval{};
  shared_ptr<QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile> outputFile{};
  shared_ptr<string> bizType{};

  QueryPornJobListResponseBodyPornJobListPornJobPornConfig() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJobPornConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile>(model1);
      }
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJobPornConfig() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<long> count{};

  QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter>> counter{};

  QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (counter) {
      vector<boost::any> temp1;
      for(auto item1:*counter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Counter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Counter") != m.end() && !m["Counter"].empty()) {
      if (typeid(vector<boost::any>) == m["Counter"].type()) {
        vector<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Counter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counter = make_shared<vector<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter>>(expect1);
      }
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> object{};
  shared_ptr<string> label{};

  QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop>> top{};

  QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (top) {
      vector<boost::any> temp1;
      for(auto item1:*top){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Top"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      if (typeid(vector<boost::any>) == m["Top"].type()) {
        vector<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Top"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        top = make_shared<vector<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop>>(expect1);
      }
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult : public Darabonba::Model {
public:
  shared_ptr<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList> pornCounterList{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> averageScore{};
  shared_ptr<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList> pornTopList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};

  QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornCounterList) {
      res["PornCounterList"] = pornCounterList ? boost::any(pornCounterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (pornTopList) {
      res["PornTopList"] = pornTopList ? boost::any(pornTopList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornCounterList") != m.end() && !m["PornCounterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornCounterList"].type()) {
        QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornCounterList"]));
        pornCounterList = make_shared<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("PornTopList") != m.end() && !m["PornTopList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornTopList"].type()) {
        QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornTopList"]));
        pornTopList = make_shared<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList>(model1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryPornJobListResponseBodyPornJobListPornJobInput() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJobInput() = default;
};
class QueryPornJobListResponseBodyPornJobListPornJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<QueryPornJobListResponseBodyPornJobListPornJobPornConfig> pornConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult> censorPornResult{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryPornJobListResponseBodyPornJobListPornJobInput> input{};
  shared_ptr<string> id{};

  QueryPornJobListResponseBodyPornJobListPornJob() {}

  explicit QueryPornJobListResponseBodyPornJobListPornJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (pornConfig) {
      res["PornConfig"] = pornConfig ? boost::any(pornConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (censorPornResult) {
      res["CensorPornResult"] = censorPornResult ? boost::any(censorPornResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("PornConfig") != m.end() && !m["PornConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornConfig"].type()) {
        QueryPornJobListResponseBodyPornJobListPornJobPornConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornConfig"]));
        pornConfig = make_shared<QueryPornJobListResponseBodyPornJobListPornJobPornConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("CensorPornResult") != m.end() && !m["CensorPornResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorPornResult"].type()) {
        QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorPornResult"]));
        censorPornResult = make_shared<QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryPornJobListResponseBodyPornJobListPornJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryPornJobListResponseBodyPornJobListPornJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobListPornJob() = default;
};
class QueryPornJobListResponseBodyPornJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPornJobListResponseBodyPornJobListPornJob>> pornJob{};

  QueryPornJobListResponseBodyPornJobList() {}

  explicit QueryPornJobListResponseBodyPornJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pornJob) {
      vector<boost::any> temp1;
      for(auto item1:*pornJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PornJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PornJob") != m.end() && !m["PornJob"].empty()) {
      if (typeid(vector<boost::any>) == m["PornJob"].type()) {
        vector<QueryPornJobListResponseBodyPornJobListPornJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PornJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPornJobListResponseBodyPornJobListPornJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pornJob = make_shared<vector<QueryPornJobListResponseBodyPornJobListPornJob>>(expect1);
      }
    }
  }


  virtual ~QueryPornJobListResponseBodyPornJobList() = default;
};
class QueryPornJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryPornJobListResponseBodyNonExistIds() {}

  explicit QueryPornJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryPornJobListResponseBodyNonExistIds() = default;
};
class QueryPornJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryPornJobListResponseBodyPornJobList> pornJobList{};
  shared_ptr<QueryPornJobListResponseBodyNonExistIds> nonExistIds{};

  QueryPornJobListResponseBody() {}

  explicit QueryPornJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pornJobList) {
      res["PornJobList"] = pornJobList ? boost::any(pornJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PornJobList") != m.end() && !m["PornJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornJobList"].type()) {
        QueryPornJobListResponseBodyPornJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornJobList"]));
        pornJobList = make_shared<QueryPornJobListResponseBodyPornJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryPornJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryPornJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryPornJobListResponseBody() = default;
};
class QueryPornJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryPornJobListResponseBody> body{};

  QueryPornJobListResponse() {}

  explicit QueryPornJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPornJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPornJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPornJobListResponse() = default;
};
class UpdateCategoryNameRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> ownerAccount{};

  UpdateCategoryNameRequest() {}

  explicit UpdateCategoryNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<string>(boost::any_cast<string>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateCategoryNameRequest() = default;
};
class UpdateCategoryNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCategoryNameResponseBody() {}

  explicit UpdateCategoryNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCategoryNameResponseBody() = default;
};
class UpdateCategoryNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateCategoryNameResponseBody> body{};

  UpdateCategoryNameResponse() {}

  explicit UpdateCategoryNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCategoryNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCategoryNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCategoryNameResponse() = default;
};
class DeleteMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};

  DeleteMediaWorkflowRequest() {}

  explicit DeleteMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteMediaWorkflowRequest() = default;
};
class DeleteMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};

  DeleteMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit DeleteMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~DeleteMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class DeleteMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};

  DeleteMediaWorkflowResponseBody() {}

  explicit DeleteMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        DeleteMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<DeleteMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
  }


  virtual ~DeleteMediaWorkflowResponseBody() = default;
};
class DeleteMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMediaWorkflowResponseBody> body{};

  DeleteMediaWorkflowResponse() {}

  explicit DeleteMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaWorkflowResponse() = default;
};
class QueryMcuJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> jobIds{};

  QueryMcuJobRequest() {}

  explicit QueryMcuJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
  }


  virtual ~QueryMcuJobRequest() = default;
};
class QueryMcuJobResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMcuJobResponseBodyNonExistJobIds() {}

  explicit QueryMcuJobResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMcuJobResponseBodyNonExistJobIds() = default;
};
class QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> category{};
  shared_ptr<string> tag{};

  QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo() {}

  explicit QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo() = default;
};
class QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo>> frameTagInfo{};

  QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos() {}

  explicit QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameTagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*frameTagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameTagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameTagInfo") != m.end() && !m["FrameTagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameTagInfo"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameTagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameTagInfo = make_shared<vector<QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos() = default;
};
class QueryMcuJobResponseBodyJobResultJobTagResultTag : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> imageUrl{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos> frameTagInfos{};
  shared_ptr<string> imageId{};

  QueryMcuJobResponseBodyJobResultJobTagResultTag() {}

  explicit QueryMcuJobResponseBodyJobResultJobTagResultTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (frameTagInfos) {
      res["FrameTagInfos"] = frameTagInfos ? boost::any(frameTagInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("FrameTagInfos") != m.end() && !m["FrameTagInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrameTagInfos"].type()) {
        QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrameTagInfos"]));
        frameTagInfos = make_shared<QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos>(model1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobTagResultTag() = default;
};
class QueryMcuJobResponseBodyJobResultJobTagResult : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJobTagResultTag>> tag{};

  QueryMcuJobResponseBodyJobResultJobTagResult() {}

  explicit QueryMcuJobResponseBodyJobResultJobTagResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJobTagResultTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJobTagResultTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryMcuJobResponseBodyJobResultJobTagResultTag>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobTagResult() = default;
};
class QueryMcuJobResponseBodyJobResultJobOcrResultOcr : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> ocrText{};
  shared_ptr<string> imageId{};

  QueryMcuJobResponseBodyJobResultJobOcrResultOcr() {}

  explicit QueryMcuJobResponseBodyJobResultJobOcrResultOcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (ocrText) {
      res["OcrText"] = boost::any(*ocrText);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("OcrText") != m.end() && !m["OcrText"].empty()) {
      ocrText = make_shared<string>(boost::any_cast<string>(m["OcrText"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobOcrResultOcr() = default;
};
class QueryMcuJobResponseBodyJobResultJobOcrResult : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJobOcrResultOcr>> ocr{};

  QueryMcuJobResponseBodyJobResultJobOcrResult() {}

  explicit QueryMcuJobResponseBodyJobResultJobOcrResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ocr) {
      vector<boost::any> temp1;
      for(auto item1:*ocr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ocr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ocr") != m.end() && !m["Ocr"].empty()) {
      if (typeid(vector<boost::any>) == m["Ocr"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJobOcrResultOcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ocr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJobOcrResultOcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ocr = make_shared<vector<QueryMcuJobResponseBodyJobResultJobOcrResultOcr>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobOcrResult() = default;
};
class QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask() {}

  explicit QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask() = default;
};
class QueryMcuJobResponseBodyJobResultJobSubTaskInfo : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask>> subTask{};

  QueryMcuJobResponseBodyJobResultJobSubTaskInfo() {}

  explicit QueryMcuJobResponseBodyJobResultJobSubTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subTask) {
      vector<boost::any> temp1;
      for(auto item1:*subTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubTask") != m.end() && !m["SubTask"].empty()) {
      if (typeid(vector<boost::any>) == m["SubTask"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subTask = make_shared<vector<QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobSubTaskInfo() = default;
};
class QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> label{};

  QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory() {}

  explicit QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory() = default;
};
class QueryMcuJobResponseBodyJobResultJobCategoryResultCategories : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory>> category{};

  QueryMcuJobResponseBodyJobResultJobCategoryResultCategories() {}

  explicit QueryMcuJobResponseBodyJobResultJobCategoryResultCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobCategoryResultCategories() = default;
};
class QueryMcuJobResponseBodyJobResultJobCategoryResult : public Darabonba::Model {
public:
  shared_ptr<QueryMcuJobResponseBodyJobResultJobCategoryResultCategories> categories{};
  shared_ptr<string> details{};

  QueryMcuJobResponseBodyJobResultJobCategoryResult() {}

  explicit QueryMcuJobResponseBodyJobResultJobCategoryResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = categories ? boost::any(categories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(map<string, boost::any>) == m["Categories"].type()) {
        QueryMcuJobResponseBodyJobResultJobCategoryResultCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Categories"]));
        categories = make_shared<QueryMcuJobResponseBodyJobResultJobCategoryResultCategories>(model1);
      }
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobCategoryResult() = default;
};
class QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> name{};
  shared_ptr<string> target{};

  QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity() {}

  explicit QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity() = default;
};
class QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity>> celebrity{};

  QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities() {}

  explicit QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (celebrity) {
      vector<boost::any> temp1;
      for(auto item1:*celebrity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Celebrity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Celebrity") != m.end() && !m["Celebrity"].empty()) {
      if (typeid(vector<boost::any>) == m["Celebrity"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Celebrity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        celebrity = make_shared<vector<QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities() = default;
};
class QueryMcuJobResponseBodyJobResultJobFaceResultFace : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> imageUrl{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities> celebrities{};
  shared_ptr<string> imageId{};

  QueryMcuJobResponseBodyJobResultJobFaceResultFace() {}

  explicit QueryMcuJobResponseBodyJobResultJobFaceResultFace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (celebrities) {
      res["Celebrities"] = celebrities ? boost::any(celebrities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Celebrities") != m.end() && !m["Celebrities"].empty()) {
      if (typeid(map<string, boost::any>) == m["Celebrities"].type()) {
        QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Celebrities"]));
        celebrities = make_shared<QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities>(model1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobFaceResultFace() = default;
};
class QueryMcuJobResponseBodyJobResultJobFaceResult : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJobFaceResultFace>> face{};

  QueryMcuJobResponseBodyJobResultJobFaceResult() {}

  explicit QueryMcuJobResponseBodyJobResultJobFaceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (face) {
      vector<boost::any> temp1;
      for(auto item1:*face){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Face"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Face") != m.end() && !m["Face"].empty()) {
      if (typeid(vector<boost::any>) == m["Face"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJobFaceResultFace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Face"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJobFaceResultFace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        face = make_shared<vector<QueryMcuJobResponseBodyJobResultJobFaceResultFace>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobFaceResult() = default;
};
class QueryMcuJobResponseBodyJobResultJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMcuJobResponseBodyJobResultJobInput() {}

  explicit QueryMcuJobResponseBodyJobResultJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobInput() = default;
};
class QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> channelId{};
  shared_ptr<string> text{};
  shared_ptr<string> speechRate{};

  QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText() {}

  explicit QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<string>(boost::any_cast<string>(m["SpeechRate"]));
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText() = default;
};
class QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText>> asrText{};

  QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList() {}

  explicit QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrText) {
      vector<boost::any> temp1;
      for(auto item1:*asrText){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AsrText"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrText") != m.end() && !m["AsrText"].empty()) {
      if (typeid(vector<boost::any>) == m["AsrText"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AsrText"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        asrText = make_shared<vector<QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList() = default;
};
class QueryMcuJobResponseBodyJobResultJobAsrResult : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList> asrTextList{};

  QueryMcuJobResponseBodyJobResultJobAsrResult() {}

  explicit QueryMcuJobResponseBodyJobResultJobAsrResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (asrTextList) {
      res["AsrTextList"] = asrTextList ? boost::any(asrTextList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("AsrTextList") != m.end() && !m["AsrTextList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrTextList"].type()) {
        QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrTextList"]));
        asrTextList = make_shared<QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList>(model1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJobAsrResult() = default;
};
class QueryMcuJobResponseBodyJobResultJob : public Darabonba::Model {
public:
  shared_ptr<QueryMcuJobResponseBodyJobResultJobTagResult> tagResult{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobOcrResult> ocrResult{};
  shared_ptr<string> template_{};
  shared_ptr<string> userData{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobSubTaskInfo> subTaskInfo{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobCategoryResult> categoryResult{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobFaceResult> faceResult{};
  shared_ptr<string> templateId{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobInput> input{};
  shared_ptr<QueryMcuJobResponseBodyJobResultJobAsrResult> asrResult{};

  QueryMcuJobResponseBodyJobResultJob() {}

  explicit QueryMcuJobResponseBodyJobResultJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResult) {
      res["TagResult"] = tagResult ? boost::any(tagResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ocrResult) {
      res["OcrResult"] = ocrResult ? boost::any(ocrResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (subTaskInfo) {
      res["SubTaskInfo"] = subTaskInfo ? boost::any(subTaskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (categoryResult) {
      res["CategoryResult"] = categoryResult ? boost::any(categoryResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (faceResult) {
      res["FaceResult"] = faceResult ? boost::any(faceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (asrResult) {
      res["AsrResult"] = asrResult ? boost::any(asrResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResult") != m.end() && !m["TagResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResult"].type()) {
        QueryMcuJobResponseBodyJobResultJobTagResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResult"]));
        tagResult = make_shared<QueryMcuJobResponseBodyJobResultJobTagResult>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OcrResult") != m.end() && !m["OcrResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OcrResult"].type()) {
        QueryMcuJobResponseBodyJobResultJobOcrResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OcrResult"]));
        ocrResult = make_shared<QueryMcuJobResponseBodyJobResultJobOcrResult>(model1);
      }
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("SubTaskInfo") != m.end() && !m["SubTaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubTaskInfo"].type()) {
        QueryMcuJobResponseBodyJobResultJobSubTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubTaskInfo"]));
        subTaskInfo = make_shared<QueryMcuJobResponseBodyJobResultJobSubTaskInfo>(model1);
      }
    }
    if (m.find("CategoryResult") != m.end() && !m["CategoryResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CategoryResult"].type()) {
        QueryMcuJobResponseBodyJobResultJobCategoryResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CategoryResult"]));
        categoryResult = make_shared<QueryMcuJobResponseBodyJobResultJobCategoryResult>(model1);
      }
    }
    if (m.find("FaceResult") != m.end() && !m["FaceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["FaceResult"].type()) {
        QueryMcuJobResponseBodyJobResultJobFaceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FaceResult"]));
        faceResult = make_shared<QueryMcuJobResponseBodyJobResultJobFaceResult>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMcuJobResponseBodyJobResultJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMcuJobResponseBodyJobResultJobInput>(model1);
      }
    }
    if (m.find("AsrResult") != m.end() && !m["AsrResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrResult"].type()) {
        QueryMcuJobResponseBodyJobResultJobAsrResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrResult"]));
        asrResult = make_shared<QueryMcuJobResponseBodyJobResultJobAsrResult>(model1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResultJob() = default;
};
class QueryMcuJobResponseBodyJobResult : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMcuJobResponseBodyJobResultJob>> job{};

  QueryMcuJobResponseBodyJobResult() {}

  explicit QueryMcuJobResponseBodyJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryMcuJobResponseBodyJobResultJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMcuJobResponseBodyJobResultJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryMcuJobResponseBodyJobResultJob>>(expect1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBodyJobResult() = default;
};
class QueryMcuJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMcuJobResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryMcuJobResponseBodyJobResult> jobResult{};

  QueryMcuJobResponseBody() {}

  explicit QueryMcuJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobResult) {
      res["JobResult"] = jobResult ? boost::any(jobResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QueryMcuJobResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QueryMcuJobResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobResult") != m.end() && !m["JobResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobResult"].type()) {
        QueryMcuJobResponseBodyJobResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobResult"]));
        jobResult = make_shared<QueryMcuJobResponseBodyJobResult>(model1);
      }
    }
  }


  virtual ~QueryMcuJobResponseBody() = default;
};
class QueryMcuJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMcuJobResponseBody> body{};

  QueryMcuJobResponse() {}

  explicit QueryMcuJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMcuJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMcuJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMcuJobResponse() = default;
};
class ListCoverPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> state{};
  shared_ptr<string> ownerAccount{};

  ListCoverPipelineRequest() {}

  explicit ListCoverPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ListCoverPipelineRequest() = default;
};
class ListCoverPipelineResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<long> quotaNum{};
  shared_ptr<long> userId{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> extendConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> quotaUsed{};

  ListCoverPipelineResponseBodyPipelineListPipeline() {}

  explicit ListCoverPipelineResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (quotaNum) {
      res["quotaNum"] = boost::any(*quotaNum);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (extendConfig) {
      res["ExtendConfig"] = boost::any(*extendConfig);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (quotaUsed) {
      res["quotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("quotaNum") != m.end() && !m["quotaNum"].empty()) {
      quotaNum = make_shared<long>(boost::any_cast<long>(m["quotaNum"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("ExtendConfig") != m.end() && !m["ExtendConfig"].empty()) {
      extendConfig = make_shared<string>(boost::any_cast<string>(m["ExtendConfig"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("quotaUsed") != m.end() && !m["quotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["quotaUsed"]));
    }
  }


  virtual ~ListCoverPipelineResponseBodyPipelineListPipeline() = default;
};
class ListCoverPipelineResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<ListCoverPipelineResponseBodyPipelineListPipeline>> pipeline{};

  ListCoverPipelineResponseBodyPipelineList() {}

  explicit ListCoverPipelineResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<ListCoverPipelineResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCoverPipelineResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<ListCoverPipelineResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~ListCoverPipelineResponseBodyPipelineList() = default;
};
class ListCoverPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<ListCoverPipelineResponseBodyPipelineList> pipelineList{};

  ListCoverPipelineResponseBody() {}

  explicit ListCoverPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        ListCoverPipelineResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<ListCoverPipelineResponseBodyPipelineList>(model1);
      }
    }
  }


  virtual ~ListCoverPipelineResponseBody() = default;
};
class ListCoverPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCoverPipelineResponseBody> body{};

  ListCoverPipelineResponse() {}

  explicit ListCoverPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCoverPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCoverPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~ListCoverPipelineResponse() = default;
};
class SubmitBeautifyJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> beautifyConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<bool> async{};
  shared_ptr<string> ownerAccount{};

  SubmitBeautifyJobsRequest() {}

  explicit SubmitBeautifyJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (beautifyConfig) {
      res["BeautifyConfig"] = boost::any(*beautifyConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("BeautifyConfig") != m.end() && !m["BeautifyConfig"].empty()) {
      beautifyConfig = make_shared<string>(boost::any_cast<string>(m["BeautifyConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitBeautifyJobsRequest() = default;
};
class SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile() {}

  explicit SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile() = default;
};
class SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile> outputFile{};

  SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig() {}

  explicit SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile>(model1);
      }
    }
  }


  virtual ~SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig() = default;
};
class SubmitBeautifyJobsResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitBeautifyJobsResponseBodyJobListJobInput() {}

  explicit SubmitBeautifyJobsResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitBeautifyJobsResponseBodyJobListJobInput() = default;
};
class SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult() {}

  explicit SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult() = default;
};
class SubmitBeautifyJobsResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig> beautifyConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitBeautifyJobsResponseBodyJobListJobInput> input{};
  shared_ptr<SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> id{};

  SubmitBeautifyJobsResponseBodyJobListJob() {}

  explicit SubmitBeautifyJobsResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (beautifyConfig) {
      res["BeautifyConfig"] = beautifyConfig ? boost::any(beautifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("BeautifyConfig") != m.end() && !m["BeautifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BeautifyConfig"].type()) {
        SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BeautifyConfig"]));
        beautifyConfig = make_shared<SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitBeautifyJobsResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitBeautifyJobsResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SubmitBeautifyJobsResponseBodyJobListJob() = default;
};
class SubmitBeautifyJobsResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitBeautifyJobsResponseBodyJobListJob>> job{};

  SubmitBeautifyJobsResponseBodyJobList() {}

  explicit SubmitBeautifyJobsResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<SubmitBeautifyJobsResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitBeautifyJobsResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<SubmitBeautifyJobsResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~SubmitBeautifyJobsResponseBodyJobList() = default;
};
class SubmitBeautifyJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitBeautifyJobsResponseBodyJobList> jobList{};

  SubmitBeautifyJobsResponseBody() {}

  explicit SubmitBeautifyJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        SubmitBeautifyJobsResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<SubmitBeautifyJobsResponseBodyJobList>(model1);
      }
    }
  }


  virtual ~SubmitBeautifyJobsResponseBody() = default;
};
class SubmitBeautifyJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitBeautifyJobsResponseBody> body{};

  SubmitBeautifyJobsResponse() {}

  explicit SubmitBeautifyJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitBeautifyJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitBeautifyJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitBeautifyJobsResponse() = default;
};
class QueryImageSearchJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryImageSearchJobListRequest() {}

  explicit QueryImageSearchJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryImageSearchJobListRequest() = default;
};
class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots : public Darabonba::Model {
public:
  shared_ptr<string> matchedFrame{};
  shared_ptr<string> matchedTimestamp{};
  shared_ptr<string> similarity{};

  QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots() {}

  explicit QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchedFrame) {
      res["MatchedFrame"] = boost::any(*matchedFrame);
    }
    if (matchedTimestamp) {
      res["MatchedTimestamp"] = boost::any(*matchedTimestamp);
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchedFrame") != m.end() && !m["MatchedFrame"].empty()) {
      matchedFrame = make_shared<string>(boost::any_cast<string>(m["MatchedFrame"]));
    }
    if (m.find("MatchedTimestamp") != m.end() && !m["MatchedTimestamp"].empty()) {
      matchedTimestamp = make_shared<string>(boost::any_cast<string>(m["MatchedTimestamp"]));
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots() = default;
};
class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots : public Darabonba::Model {
public:
  shared_ptr<vector<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots>> imageSearchShots{};

  QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots() {}

  explicit QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageSearchShots) {
      vector<boost::any> temp1;
      for(auto item1:*imageSearchShots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageSearchShots"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageSearchShots") != m.end() && !m["ImageSearchShots"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageSearchShots"].type()) {
        vector<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageSearchShots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageSearchShots = make_shared<vector<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots>>(expect1);
      }
    }
  }


  virtual ~QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots() = default;
};
class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult : public Darabonba::Model {
public:
  shared_ptr<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots> imageSearchShots{};

  QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult() {}

  explicit QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageSearchShots) {
      res["ImageSearchShots"] = imageSearchShots ? boost::any(imageSearchShots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageSearchShots") != m.end() && !m["ImageSearchShots"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageSearchShots"].type()) {
        QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageSearchShots"]));
        imageSearchShots = make_shared<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots>(model1);
      }
    }
  }


  virtual ~QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult() = default;
};
class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage() {}

  explicit QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage() = default;
};
class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo() {}

  explicit QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo() = default;
};
class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult> result{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage> inputImage{};
  shared_ptr<string> id{};
  shared_ptr<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo> inputVideo{};

  QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob() {}

  explicit QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (inputImage) {
      res["inputImage"] = inputImage ? boost::any(inputImage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputVideo) {
      res["InputVideo"] = inputVideo ? boost::any(inputVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("inputImage") != m.end() && !m["inputImage"].empty()) {
      if (typeid(map<string, boost::any>) == m["inputImage"].type()) {
        QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["inputImage"]));
        inputImage = make_shared<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InputVideo") != m.end() && !m["InputVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputVideo"].type()) {
        QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputVideo"]));
        inputVideo = make_shared<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo>(model1);
      }
    }
  }


  virtual ~QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob() = default;
};
class QueryImageSearchJobListResponseBodyImageSearchJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob>> imageSearchJob{};

  QueryImageSearchJobListResponseBodyImageSearchJobList() {}

  explicit QueryImageSearchJobListResponseBodyImageSearchJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageSearchJob) {
      vector<boost::any> temp1;
      for(auto item1:*imageSearchJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageSearchJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageSearchJob") != m.end() && !m["ImageSearchJob"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageSearchJob"].type()) {
        vector<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageSearchJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageSearchJob = make_shared<vector<QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob>>(expect1);
      }
    }
  }


  virtual ~QueryImageSearchJobListResponseBodyImageSearchJobList() = default;
};
class QueryImageSearchJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryImageSearchJobListResponseBodyNonExistIds() {}

  explicit QueryImageSearchJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryImageSearchJobListResponseBodyNonExistIds() = default;
};
class QueryImageSearchJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryImageSearchJobListResponseBodyImageSearchJobList> imageSearchJobList{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryImageSearchJobListResponseBodyNonExistIds> nonExistIds{};

  QueryImageSearchJobListResponseBody() {}

  explicit QueryImageSearchJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageSearchJobList) {
      res["ImageSearchJobList"] = imageSearchJobList ? boost::any(imageSearchJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageSearchJobList") != m.end() && !m["ImageSearchJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageSearchJobList"].type()) {
        QueryImageSearchJobListResponseBodyImageSearchJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageSearchJobList"]));
        imageSearchJobList = make_shared<QueryImageSearchJobListResponseBodyImageSearchJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryImageSearchJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryImageSearchJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryImageSearchJobListResponseBody() = default;
};
class QueryImageSearchJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryImageSearchJobListResponseBody> body{};

  QueryImageSearchJobListResponse() {}

  explicit QueryImageSearchJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryImageSearchJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryImageSearchJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryImageSearchJobListResponse() = default;
};
class SubmitVideoSummaryJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> videoSummaryConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitVideoSummaryJobRequest() {}

  explicit SubmitVideoSummaryJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (videoSummaryConfig) {
      res["VideoSummaryConfig"] = boost::any(*videoSummaryConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("VideoSummaryConfig") != m.end() && !m["VideoSummaryConfig"].empty()) {
      videoSummaryConfig = make_shared<string>(boost::any_cast<string>(m["VideoSummaryConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitVideoSummaryJobRequest() = default;
};
class SubmitVideoSummaryJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitVideoSummaryJobResponseBody() {}

  explicit SubmitVideoSummaryJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitVideoSummaryJobResponseBody() = default;
};
class SubmitVideoSummaryJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitVideoSummaryJobResponseBody> body{};

  SubmitVideoSummaryJobResponse() {}

  explicit SubmitVideoSummaryJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitVideoSummaryJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitVideoSummaryJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitVideoSummaryJobResponse() = default;
};
class SubmitMediaDetailJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> mediaDetailConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitMediaDetailJobRequest() {}

  explicit SubmitMediaDetailJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (mediaDetailConfig) {
      res["MediaDetailConfig"] = boost::any(*mediaDetailConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("MediaDetailConfig") != m.end() && !m["MediaDetailConfig"].empty()) {
      mediaDetailConfig = make_shared<string>(boost::any_cast<string>(m["MediaDetailConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitMediaDetailJobRequest() = default;
};
class SubmitMediaDetailJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitMediaDetailJobResponseBody() {}

  explicit SubmitMediaDetailJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitMediaDetailJobResponseBody() = default;
};
class SubmitMediaDetailJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitMediaDetailJobResponseBody> body{};

  SubmitMediaDetailJobResponse() {}

  explicit SubmitMediaDetailJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaDetailJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaDetailJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaDetailJobResponse() = default;
};
class QueryFpImportResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageIndex{};
  shared_ptr<string> ownerAccount{};

  QueryFpImportResultRequest() {}

  explicit QueryFpImportResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryFpImportResultRequest() = default;
};
class QueryFpImportResultResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryFpImportResultResponseBodyPageInfo() {}

  explicit QueryFpImportResultResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryFpImportResultResponseBodyPageInfo() = default;
};
class QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo : public Darabonba::Model {
public:
  shared_ptr<long> logStartTime{};
  shared_ptr<string> logPath{};
  shared_ptr<long> createTime{};
  shared_ptr<long> logSize{};
  shared_ptr<string> logName{};
  shared_ptr<long> logEndTime{};

  QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo() {}

  explicit QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logStartTime) {
      res["LogStartTime"] = boost::any(*logStartTime);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logEndTime) {
      res["LogEndTime"] = boost::any(*logEndTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogStartTime") != m.end() && !m["LogStartTime"].empty()) {
      logStartTime = make_shared<long>(boost::any_cast<long>(m["LogStartTime"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogEndTime") != m.end() && !m["LogEndTime"].empty()) {
      logEndTime = make_shared<long>(boost::any_cast<long>(m["LogEndTime"]));
    }
  }


  virtual ~QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo() = default;
};
class QueryFpImportResultResponseBodyFpResultLogInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo>> fpResultLogInfo{};

  QueryFpImportResultResponseBodyFpResultLogInfoList() {}

  explicit QueryFpImportResultResponseBodyFpResultLogInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpResultLogInfo) {
      vector<boost::any> temp1;
      for(auto item1:*fpResultLogInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpResultLogInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpResultLogInfo") != m.end() && !m["FpResultLogInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["FpResultLogInfo"].type()) {
        vector<QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpResultLogInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpResultLogInfo = make_shared<vector<QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo>>(expect1);
      }
    }
  }


  virtual ~QueryFpImportResultResponseBodyFpResultLogInfoList() = default;
};
class QueryFpImportResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryFpImportResultResponseBodyPageInfo> pageInfo{};
  shared_ptr<QueryFpImportResultResponseBodyFpResultLogInfoList> fpResultLogInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> logCount{};

  QueryFpImportResultResponseBody() {}

  explicit QueryFpImportResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fpResultLogInfoList) {
      res["FpResultLogInfoList"] = fpResultLogInfoList ? boost::any(fpResultLogInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        QueryFpImportResultResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<QueryFpImportResultResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("FpResultLogInfoList") != m.end() && !m["FpResultLogInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpResultLogInfoList"].type()) {
        QueryFpImportResultResponseBodyFpResultLogInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpResultLogInfoList"]));
        fpResultLogInfoList = make_shared<QueryFpImportResultResponseBodyFpResultLogInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
  }


  virtual ~QueryFpImportResultResponseBody() = default;
};
class QueryFpImportResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryFpImportResultResponseBody> body{};

  QueryFpImportResultResponse() {}

  explicit QueryFpImportResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFpImportResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFpImportResultResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFpImportResultResponse() = default;
};
class QueryWaterMarkTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateIds{};
  shared_ptr<string> ownerAccount{};

  QueryWaterMarkTemplateListRequest() {}

  explicit QueryWaterMarkTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateIds) {
      res["WaterMarkTemplateIds"] = boost::any(*waterMarkTemplateIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateIds") != m.end() && !m["WaterMarkTemplateIds"].empty()) {
      waterMarkTemplateIds = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListRequest() = default;
};
class QueryWaterMarkTemplateListResponseBodyNonExistWids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryWaterMarkTemplateListResponseBodyNonExistWids() {}

  explicit QueryWaterMarkTemplateListResponseBodyNonExistWids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyNonExistWids() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> dy{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> duration{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> name{};
  shared_ptr<string> dy{};
  shared_ptr<string> id{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate>> waterMarkTemplate{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMarkTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*waterMarkTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMarkTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMarkTemplate"].type()) {
        vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMarkTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMarkTemplate = make_shared<vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList() = default;
};
class QueryWaterMarkTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyNonExistWids> nonExistWids{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList> waterMarkTemplateList{};

  QueryWaterMarkTemplateListResponseBody() {}

  explicit QueryWaterMarkTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistWids) {
      res["NonExistWids"] = nonExistWids ? boost::any(nonExistWids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkTemplateList) {
      res["WaterMarkTemplateList"] = waterMarkTemplateList ? boost::any(waterMarkTemplateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistWids") != m.end() && !m["NonExistWids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistWids"].type()) {
        QueryWaterMarkTemplateListResponseBodyNonExistWids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistWids"]));
        nonExistWids = make_shared<QueryWaterMarkTemplateListResponseBodyNonExistWids>(model1);
      }
    }
    if (m.find("WaterMarkTemplateList") != m.end() && !m["WaterMarkTemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplateList"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplateList"]));
        waterMarkTemplateList = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList>(model1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBody() = default;
};
class QueryWaterMarkTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryWaterMarkTemplateListResponseBody> body{};

  QueryWaterMarkTemplateListResponse() {}

  explicit QueryWaterMarkTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryWaterMarkTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryWaterMarkTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponse() = default;
};
class QueryMediaInfoJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaInfoJobIds{};
  shared_ptr<string> ownerAccount{};

  QueryMediaInfoJobListRequest() {}

  explicit QueryMediaInfoJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaInfoJobIds) {
      res["MediaInfoJobIds"] = boost::any(*mediaInfoJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaInfoJobIds") != m.end() && !m["MediaInfoJobIds"].empty()) {
      mediaInfoJobIds = make_shared<string>(boost::any_cast<string>(m["MediaInfoJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMediaInfoJobListRequest() = default;
};
class QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds() {}

  explicit QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> sar{};
  shared_ptr<string> height{};
  shared_ptr<string> codecTagString{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> width{};
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> rotate{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};
  shared_ptr<string> colorRange{};
  shared_ptr<string> colorTransfer{};
  shared_ptr<string> colorPrimaries{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (colorRange) {
      res["ColorRange"] = boost::any(*colorRange);
    }
    if (colorTransfer) {
      res["ColorTransfer"] = boost::any(*colorTransfer);
    }
    if (colorPrimaries) {
      res["ColorPrimaries"] = boost::any(*colorPrimaries);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("ColorRange") != m.end() && !m["ColorRange"].empty()) {
      colorRange = make_shared<string>(boost::any_cast<string>(m["ColorRange"]));
    }
    if (m.find("ColorTransfer") != m.end() && !m["ColorTransfer"].empty()) {
      colorTransfer = make_shared<string>(boost::any_cast<string>(m["ColorTransfer"]));
    }
    if (m.find("ColorPrimaries") != m.end() && !m["ColorPrimaries"].empty()) {
      colorPrimaries = make_shared<string>(boost::any_cast<string>(m["ColorPrimaries"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> codecTagString{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams> streams{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<bool> async{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput> input{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties> properties{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties>(model1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob>> mediaInfoJob{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfoJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfoJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfoJob"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfoJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfoJob = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobList() = default;
};
class QueryMediaInfoJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds> nonExistMediaInfoJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobList> mediaInfoJobList{};

  QueryMediaInfoJobListResponseBody() {}

  explicit QueryMediaInfoJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistMediaInfoJobIds) {
      res["NonExistMediaInfoJobIds"] = nonExistMediaInfoJobIds ? boost::any(nonExistMediaInfoJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mediaInfoJobList) {
      res["MediaInfoJobList"] = mediaInfoJobList ? boost::any(mediaInfoJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistMediaInfoJobIds") != m.end() && !m["NonExistMediaInfoJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaInfoJobIds"].type()) {
        QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaInfoJobIds"]));
        nonExistMediaInfoJobIds = make_shared<QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MediaInfoJobList") != m.end() && !m["MediaInfoJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJobList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJobList"]));
        mediaInfoJobList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobList>(model1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBody() = default;
};
class QueryMediaInfoJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaInfoJobListResponseBody> body{};

  QueryMediaInfoJobListResponse() {}

  explicit QueryMediaInfoJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaInfoJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaInfoJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponse() = default;
};
class QueryMediaFpDeleteJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryMediaFpDeleteJobListRequest() {}

  explicit QueryMediaFpDeleteJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryMediaFpDeleteJobListRequest() = default;
};
class QueryMediaFpDeleteJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaFpDeleteJobListResponseBodyNonExistIds() {}

  explicit QueryMediaFpDeleteJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaFpDeleteJobListResponseBodyNonExistIds() = default;
};
class QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> id{};

  QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob() {}

  explicit QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob() = default;
};
class QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob>> mediaFpDeleteJob{};

  QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList() {}

  explicit QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaFpDeleteJob) {
      vector<boost::any> temp1;
      for(auto item1:*mediaFpDeleteJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaFpDeleteJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaFpDeleteJob") != m.end() && !m["MediaFpDeleteJob"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaFpDeleteJob"].type()) {
        vector<QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaFpDeleteJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaFpDeleteJob = make_shared<vector<QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob>>(expect1);
      }
    }
  }


  virtual ~QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList() = default;
};
class QueryMediaFpDeleteJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryMediaFpDeleteJobListResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList> mediaFpDeleteJobList{};

  QueryMediaFpDeleteJobListResponseBody() {}

  explicit QueryMediaFpDeleteJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaFpDeleteJobList) {
      res["MediaFpDeleteJobList"] = mediaFpDeleteJobList ? boost::any(mediaFpDeleteJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryMediaFpDeleteJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryMediaFpDeleteJobListResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("MediaFpDeleteJobList") != m.end() && !m["MediaFpDeleteJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaFpDeleteJobList"].type()) {
        QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaFpDeleteJobList"]));
        mediaFpDeleteJobList = make_shared<QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList>(model1);
      }
    }
  }


  virtual ~QueryMediaFpDeleteJobListResponseBody() = default;
};
class QueryMediaFpDeleteJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryMediaFpDeleteJobListResponseBody> body{};

  QueryMediaFpDeleteJobListResponse() {}

  explicit QueryMediaFpDeleteJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaFpDeleteJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaFpDeleteJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaFpDeleteJobListResponse() = default;
};
class ReportTagJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> tag{};
  shared_ptr<string> result{};
  shared_ptr<string> ownerAccount{};

  ReportTagJobResultRequest() {}

  explicit ReportTagJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportTagJobResultRequest() = default;
};
class ReportTagJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportTagJobResultResponseBody() {}

  explicit ReportTagJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportTagJobResultResponseBody() = default;
};
class ReportTagJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportTagJobResultResponseBody> body{};

  ReportTagJobResultResponse() {}

  explicit ReportTagJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportTagJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportTagJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportTagJobResultResponse() = default;
};
class AddPornPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};

  AddPornPipelineRequest() {}

  explicit AddPornPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddPornPipelineRequest() = default;
};
class AddPornPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  AddPornPipelineResponseBodyPipelineNotifyConfig() {}

  explicit AddPornPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~AddPornPipelineResponseBodyPipelineNotifyConfig() = default;
};
class AddPornPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<AddPornPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  AddPornPipelineResponseBodyPipeline() {}

  explicit AddPornPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        AddPornPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<AddPornPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~AddPornPipelineResponseBodyPipeline() = default;
};
class AddPornPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddPornPipelineResponseBodyPipeline> pipeline{};

  AddPornPipelineResponseBody() {}

  explicit AddPornPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        AddPornPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<AddPornPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~AddPornPipelineResponseBody() = default;
};
class AddPornPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddPornPipelineResponseBody> body{};

  AddPornPipelineResponse() {}

  explicit AddPornPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPornPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPornPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~AddPornPipelineResponse() = default;
};
class QueryPornPipelineListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineIds{};
  shared_ptr<string> ownerAccount{};

  QueryPornPipelineListRequest() {}

  explicit QueryPornPipelineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineIds) {
      res["PipelineIds"] = boost::any(*pipelineIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineIds") != m.end() && !m["PipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["PipelineIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryPornPipelineListRequest() = default;
};
class QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class QueryPornPipelineListResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  QueryPornPipelineListResponseBodyPipelineListPipeline() {}

  explicit QueryPornPipelineListResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryPornPipelineListResponseBodyPipelineListPipeline() = default;
};
class QueryPornPipelineListResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPornPipelineListResponseBodyPipelineListPipeline>> pipeline{};

  QueryPornPipelineListResponseBodyPipelineList() {}

  explicit QueryPornPipelineListResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<QueryPornPipelineListResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPornPipelineListResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<QueryPornPipelineListResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~QueryPornPipelineListResponseBodyPipelineList() = default;
};
class QueryPornPipelineListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryPornPipelineListResponseBodyNonExistIds() {}

  explicit QueryPornPipelineListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryPornPipelineListResponseBodyNonExistIds() = default;
};
class QueryPornPipelineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryPornPipelineListResponseBodyPipelineList> pipelineList{};
  shared_ptr<QueryPornPipelineListResponseBodyNonExistIds> nonExistIds{};

  QueryPornPipelineListResponseBody() {}

  explicit QueryPornPipelineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        QueryPornPipelineListResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<QueryPornPipelineListResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryPornPipelineListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryPornPipelineListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryPornPipelineListResponseBody() = default;
};
class QueryPornPipelineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryPornPipelineListResponseBody> body{};

  QueryPornPipelineListResponse() {}

  explicit QueryPornPipelineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPornPipelineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPornPipelineListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPornPipelineListResponse() = default;
};
class QueryTerrorismJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryTerrorismJobListRequest() {}

  explicit QueryTerrorismJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryTerrorismJobListRequest() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> object{};
  shared_ptr<string> label{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop>> top{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (top) {
      vector<boost::any> temp1;
      for(auto item1:*top){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Top"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      if (typeid(vector<boost::any>) == m["Top"].type()) {
        vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Top"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        top = make_shared<vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop>>(expect1);
      }
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<long> count{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter>> counter{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (counter) {
      vector<boost::any> temp1;
      for(auto item1:*counter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Counter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Counter") != m.end() && !m["Counter"].empty()) {
      if (typeid(vector<boost::any>) == m["Counter"].type()) {
        vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Counter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counter = make_shared<vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter>>(expect1);
      }
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult : public Darabonba::Model {
public:
  shared_ptr<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList> terrorismTopList{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> averageScore{};
  shared_ptr<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList> terrorismCounterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismTopList) {
      res["TerrorismTopList"] = terrorismTopList ? boost::any(terrorismTopList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (terrorismCounterList) {
      res["TerrorismCounterList"] = terrorismCounterList ? boost::any(terrorismCounterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismTopList") != m.end() && !m["TerrorismTopList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismTopList"].type()) {
        QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismTopList"]));
        terrorismTopList = make_shared<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("TerrorismCounterList") != m.end() && !m["TerrorismCounterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismCounterList"].type()) {
        QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismCounterList"]));
        terrorismCounterList = make_shared<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList>(model1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig : public Darabonba::Model {
public:
  shared_ptr<string> interval{};
  shared_ptr<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile> outputFile{};
  shared_ptr<string> bizType{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile>(model1);
      }
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult> censorTerrorismResult{};
  shared_ptr<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig> terrorismConfig{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput> input{};
  shared_ptr<string> id{};

  QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (censorTerrorismResult) {
      res["CensorTerrorismResult"] = censorTerrorismResult ? boost::any(censorTerrorismResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (terrorismConfig) {
      res["TerrorismConfig"] = terrorismConfig ? boost::any(terrorismConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("CensorTerrorismResult") != m.end() && !m["CensorTerrorismResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorTerrorismResult"].type()) {
        QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorTerrorismResult"]));
        censorTerrorismResult = make_shared<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult>(model1);
      }
    }
    if (m.find("TerrorismConfig") != m.end() && !m["TerrorismConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismConfig"].type()) {
        QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismConfig"]));
        terrorismConfig = make_shared<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob() = default;
};
class QueryTerrorismJobListResponseBodyTerrorismJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob>> terrorismJob{};

  QueryTerrorismJobListResponseBodyTerrorismJobList() {}

  explicit QueryTerrorismJobListResponseBodyTerrorismJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (terrorismJob) {
      vector<boost::any> temp1;
      for(auto item1:*terrorismJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TerrorismJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TerrorismJob") != m.end() && !m["TerrorismJob"].empty()) {
      if (typeid(vector<boost::any>) == m["TerrorismJob"].type()) {
        vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TerrorismJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        terrorismJob = make_shared<vector<QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob>>(expect1);
      }
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyTerrorismJobList() = default;
};
class QueryTerrorismJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryTerrorismJobListResponseBodyNonExistIds() {}

  explicit QueryTerrorismJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTerrorismJobListResponseBodyNonExistIds() = default;
};
class QueryTerrorismJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryTerrorismJobListResponseBodyTerrorismJobList> terrorismJobList{};
  shared_ptr<QueryTerrorismJobListResponseBodyNonExistIds> nonExistIds{};

  QueryTerrorismJobListResponseBody() {}

  explicit QueryTerrorismJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (terrorismJobList) {
      res["TerrorismJobList"] = terrorismJobList ? boost::any(terrorismJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TerrorismJobList") != m.end() && !m["TerrorismJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismJobList"].type()) {
        QueryTerrorismJobListResponseBodyTerrorismJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismJobList"]));
        terrorismJobList = make_shared<QueryTerrorismJobListResponseBodyTerrorismJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryTerrorismJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryTerrorismJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryTerrorismJobListResponseBody() = default;
};
class QueryTerrorismJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryTerrorismJobListResponseBody> body{};

  QueryTerrorismJobListResponse() {}

  explicit QueryTerrorismJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTerrorismJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTerrorismJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTerrorismJobListResponse() = default;
};
class SubmitJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> outputs{};
  shared_ptr<string> outputBucket{};
  shared_ptr<string> outputLocation{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  SubmitJobsRequest() {}

  explicit SubmitJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (outputs) {
      res["Outputs"] = boost::any(*outputs);
    }
    if (outputBucket) {
      res["OutputBucket"] = boost::any(*outputBucket);
    }
    if (outputLocation) {
      res["OutputLocation"] = boost::any(*outputLocation);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
    if (m.find("OutputBucket") != m.end() && !m["OutputBucket"].empty()) {
      outputBucket = make_shared<string>(boost::any_cast<string>(m["OutputBucket"]));
    }
    if (m.find("OutputLocation") != m.end() && !m["OutputLocation"].empty()) {
      outputLocation = make_shared<string>(boost::any_cast<string>(m["OutputLocation"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitJobsRequest() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> resoPriority{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> id{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> referPos{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> dy{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark>> waterMark{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> sizeSupport{};
  shared_ptr<bool> md5Support{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS> TS{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> level{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume> volume{};
  shared_ptr<string> bitrate{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume>(model1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> duration{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge>> merge{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};
  shared_ptr<string> message{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> alpha{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile> inputFile{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<string> start{};
  shared_ptr<string> amixURL{};
  shared_ptr<string> duration{};
  shared_ptr<string> mixDurMode{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (amixURL) {
      res["AmixURL"] = boost::any(*amixURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mixDurMode) {
      res["MixDurMode"] = boost::any(*mixDurMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("AmixURL") != m.end() && !m["AmixURL"].empty()) {
      amixURL = make_shared<string>(boost::any_cast<string>(m["AmixURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MixDurMode") != m.end() && !m["MixDurMode"].empty()) {
      mixDurMode = make_shared<string>(boost::any_cast<string>(m["MixDurMode"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix>> amix{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amix) {
      vector<boost::any> temp1;
      for(auto item1:*amix){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Amix"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amix") != m.end() && !m["Amix"].empty()) {
      if (typeid(vector<boost::any>) == m["Amix"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Amix"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        amix = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> seek{};
  shared_ptr<string> duration{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan> timeSpan{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputClip() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputClip() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> openUrl{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening>> opening{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp> webp{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif> gif{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment> segment{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp>(model1);
      }
    }
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> bgColor{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> tailUrl{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate>> tailSlate{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList> subtitleList{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> sar{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> height{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> width{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams> streams{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutput : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo> video{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig> transConfig{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption> encryption{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList> waterMarkList{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<string> deWatermark{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> priority{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList> mergeList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso> superReso{};
  shared_ptr<string> userData{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark> digiWaterMark{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile> outputFile{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList> amixList{};
  shared_ptr<string> rotate{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer> container{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputClip> clip{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList> openingList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig> muxConfig{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties> properties{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (amixList) {
      res["AmixList"] = amixList ? boost::any(amixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption>(model1);
      }
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList>(model1);
      }
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile>(model1);
      }
    }
    if (m.find("AmixList") != m.end() && !m["AmixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AmixList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AmixList"]));
        amixList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer>(model1);
      }
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputClip>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitJobsResponseBodyJobResultListJobResultJobInput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobInput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobInput> input{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult> MNSMessageResult{};

  SubmitJobsResponseBodyJobResultListJobResultJob() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJob() = default;
};
class SubmitJobsResponseBodyJobResultListJobResult : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJob> job{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  SubmitJobsResponseBodyJobResultListJobResult() {}

  explicit SubmitJobsResponseBodyJobResultListJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<SubmitJobsResponseBodyJobResultListJobResultJob>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResult() = default;
};
class SubmitJobsResponseBodyJobResultList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResult>> jobResult{};

  SubmitJobsResponseBodyJobResultList() {}

  explicit SubmitJobsResponseBodyJobResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResult) {
      vector<boost::any> temp1;
      for(auto item1:*jobResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResult") != m.end() && !m["JobResult"].empty()) {
      if (typeid(vector<boost::any>) == m["JobResult"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobResult = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResult>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultList() = default;
};
class SubmitJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultList> jobResultList{};
  shared_ptr<string> requestId{};

  SubmitJobsResponseBody() {}

  explicit SubmitJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResultList) {
      res["JobResultList"] = jobResultList ? boost::any(jobResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResultList") != m.end() && !m["JobResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobResultList"].type()) {
        SubmitJobsResponseBodyJobResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobResultList"]));
        jobResultList = make_shared<SubmitJobsResponseBodyJobResultList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitJobsResponseBody() = default;
};
class SubmitJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitJobsResponseBody> body{};

  SubmitJobsResponse() {}

  explicit SubmitJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponse() = default;
};
class RefreshCdnDomainConfigsCacheRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> domains{};

  RefreshCdnDomainConfigsCacheRequest() {}

  explicit RefreshCdnDomainConfigsCacheRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      domains = make_shared<string>(boost::any_cast<string>(m["Domains"]));
    }
  }


  virtual ~RefreshCdnDomainConfigsCacheRequest() = default;
};
class RefreshCdnDomainConfigsCacheResponseBodySucessDomains : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  RefreshCdnDomainConfigsCacheResponseBodySucessDomains() {}

  explicit RefreshCdnDomainConfigsCacheResponseBodySucessDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RefreshCdnDomainConfigsCacheResponseBodySucessDomains() = default;
};
class RefreshCdnDomainConfigsCacheResponseBodyFailedDomains : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  RefreshCdnDomainConfigsCacheResponseBodyFailedDomains() {}

  explicit RefreshCdnDomainConfigsCacheResponseBodyFailedDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RefreshCdnDomainConfigsCacheResponseBodyFailedDomains() = default;
};
class RefreshCdnDomainConfigsCacheResponseBody : public Darabonba::Model {
public:
  shared_ptr<RefreshCdnDomainConfigsCacheResponseBodySucessDomains> sucessDomains{};
  shared_ptr<RefreshCdnDomainConfigsCacheResponseBodyFailedDomains> failedDomains{};
  shared_ptr<string> requestId{};

  RefreshCdnDomainConfigsCacheResponseBody() {}

  explicit RefreshCdnDomainConfigsCacheResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sucessDomains) {
      res["SucessDomains"] = sucessDomains ? boost::any(sucessDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failedDomains) {
      res["FailedDomains"] = failedDomains ? boost::any(failedDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SucessDomains") != m.end() && !m["SucessDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["SucessDomains"].type()) {
        RefreshCdnDomainConfigsCacheResponseBodySucessDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SucessDomains"]));
        sucessDomains = make_shared<RefreshCdnDomainConfigsCacheResponseBodySucessDomains>(model1);
      }
    }
    if (m.find("FailedDomains") != m.end() && !m["FailedDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedDomains"].type()) {
        RefreshCdnDomainConfigsCacheResponseBodyFailedDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedDomains"]));
        failedDomains = make_shared<RefreshCdnDomainConfigsCacheResponseBodyFailedDomains>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshCdnDomainConfigsCacheResponseBody() = default;
};
class RefreshCdnDomainConfigsCacheResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RefreshCdnDomainConfigsCacheResponseBody> body{};

  RefreshCdnDomainConfigsCacheResponse() {}

  explicit RefreshCdnDomainConfigsCacheResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshCdnDomainConfigsCacheResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshCdnDomainConfigsCacheResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshCdnDomainConfigsCacheResponse() = default;
};
class QueryFpFileDeleteJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryFpFileDeleteJobListRequest() {}

  explicit QueryFpFileDeleteJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryFpFileDeleteJobListRequest() = default;
};
class QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> id{};
  shared_ptr<string> fileIds{};

  QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob() {}

  explicit QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
  }


  virtual ~QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob() = default;
};
class QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob>> fpFileDeleteJob{};

  QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList() {}

  explicit QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpFileDeleteJob) {
      vector<boost::any> temp1;
      for(auto item1:*fpFileDeleteJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpFileDeleteJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpFileDeleteJob") != m.end() && !m["FpFileDeleteJob"].empty()) {
      if (typeid(vector<boost::any>) == m["FpFileDeleteJob"].type()) {
        vector<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpFileDeleteJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpFileDeleteJob = make_shared<vector<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob>>(expect1);
      }
    }
  }


  virtual ~QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList() = default;
};
class QueryFpFileDeleteJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFpFileDeleteJobListResponseBodyNonExistIds() {}

  explicit QueryFpFileDeleteJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFpFileDeleteJobListResponseBodyNonExistIds() = default;
};
class QueryFpFileDeleteJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList> fpFileDeleteJobList{};
  shared_ptr<QueryFpFileDeleteJobListResponseBodyNonExistIds> nonExistIds{};

  QueryFpFileDeleteJobListResponseBody() {}

  explicit QueryFpFileDeleteJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (fpFileDeleteJobList) {
      res["FpFileDeleteJobList"] = fpFileDeleteJobList ? boost::any(fpFileDeleteJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FpFileDeleteJobList") != m.end() && !m["FpFileDeleteJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpFileDeleteJobList"].type()) {
        QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpFileDeleteJobList"]));
        fpFileDeleteJobList = make_shared<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryFpFileDeleteJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryFpFileDeleteJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryFpFileDeleteJobListResponseBody() = default;
};
class QueryFpFileDeleteJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryFpFileDeleteJobListResponseBody> body{};

  QueryFpFileDeleteJobListResponse() {}

  explicit QueryFpFileDeleteJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFpFileDeleteJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFpFileDeleteJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFpFileDeleteJobListResponse() = default;
};
class SubmitImageSearchJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> inputVideo{};
  shared_ptr<string> inputImage{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> config{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitImageSearchJobRequest() {}

  explicit SubmitImageSearchJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (inputVideo) {
      res["InputVideo"] = boost::any(*inputVideo);
    }
    if (inputImage) {
      res["InputImage"] = boost::any(*inputImage);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("InputVideo") != m.end() && !m["InputVideo"].empty()) {
      inputVideo = make_shared<string>(boost::any_cast<string>(m["InputVideo"]));
    }
    if (m.find("InputImage") != m.end() && !m["InputImage"].empty()) {
      inputImage = make_shared<string>(boost::any_cast<string>(m["InputImage"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitImageSearchJobRequest() = default;
};
class SubmitImageSearchJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitImageSearchJobResponseBody() {}

  explicit SubmitImageSearchJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitImageSearchJobResponseBody() = default;
};
class SubmitImageSearchJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitImageSearchJobResponseBody> body{};

  SubmitImageSearchJobResponse() {}

  explicit SubmitImageSearchJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitImageSearchJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitImageSearchJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitImageSearchJobResponse() = default;
};
class UpdateMediaWorkflowTriggerModeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> triggerMode{};
  shared_ptr<string> ownerAccount{};

  UpdateMediaWorkflowTriggerModeRequest() {}

  explicit UpdateMediaWorkflowTriggerModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeRequest() = default;
};
class UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> state{};
  shared_ptr<string> triggerMode{};
  shared_ptr<string> name{};
  shared_ptr<string> topology{};

  UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow() {}

  explicit UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow() = default;
};
class UpdateMediaWorkflowTriggerModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow> mediaWorkflow{};

  UpdateMediaWorkflowTriggerModeResponseBody() {}

  explicit UpdateMediaWorkflowTriggerModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow>(model1);
      }
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponseBody() = default;
};
class UpdateMediaWorkflowTriggerModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMediaWorkflowTriggerModeResponseBody> body{};

  UpdateMediaWorkflowTriggerModeResponse() {}

  explicit UpdateMediaWorkflowTriggerModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaWorkflowTriggerModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaWorkflowTriggerModeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponse() = default;
};
class SetAuthConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> key1{};
  shared_ptr<string> key2{};

  SetAuthConfigRequest() {}

  explicit SetAuthConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (key1) {
      res["Key1"] = boost::any(*key1);
    }
    if (key2) {
      res["Key2"] = boost::any(*key2);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Key1") != m.end() && !m["Key1"].empty()) {
      key1 = make_shared<string>(boost::any_cast<string>(m["Key1"]));
    }
    if (m.find("Key2") != m.end() && !m["Key2"].empty()) {
      key2 = make_shared<string>(boost::any_cast<string>(m["Key2"]));
    }
  }


  virtual ~SetAuthConfigRequest() = default;
};
class SetAuthConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> key2{};
  shared_ptr<string> key1{};
  shared_ptr<string> requestId{};

  SetAuthConfigResponseBody() {}

  explicit SetAuthConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key2) {
      res["Key2"] = boost::any(*key2);
    }
    if (key1) {
      res["Key1"] = boost::any(*key1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key2") != m.end() && !m["Key2"].empty()) {
      key2 = make_shared<string>(boost::any_cast<string>(m["Key2"]));
    }
    if (m.find("Key1") != m.end() && !m["Key1"].empty()) {
      key1 = make_shared<string>(boost::any_cast<string>(m["Key1"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetAuthConfigResponseBody() = default;
};
class SetAuthConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetAuthConfigResponseBody> body{};

  SetAuthConfigResponse() {}

  explicit SetAuthConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetAuthConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetAuthConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetAuthConfigResponse() = default;
};
class UpdateCensorPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};

  UpdateCensorPipelineRequest() {}

  explicit UpdateCensorPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateCensorPipelineRequest() = default;
};
class UpdateCensorPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  UpdateCensorPipelineResponseBodyPipelineNotifyConfig() {}

  explicit UpdateCensorPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~UpdateCensorPipelineResponseBodyPipelineNotifyConfig() = default;
};
class UpdateCensorPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<UpdateCensorPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  UpdateCensorPipelineResponseBodyPipeline() {}

  explicit UpdateCensorPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        UpdateCensorPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<UpdateCensorPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateCensorPipelineResponseBodyPipeline() = default;
};
class UpdateCensorPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateCensorPipelineResponseBodyPipeline> pipeline{};

  UpdateCensorPipelineResponseBody() {}

  explicit UpdateCensorPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        UpdateCensorPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<UpdateCensorPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~UpdateCensorPipelineResponseBody() = default;
};
class UpdateCensorPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateCensorPipelineResponseBody> body{};

  UpdateCensorPipelineResponse() {}

  explicit UpdateCensorPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCensorPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCensorPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCensorPipelineResponse() = default;
};
class SubmitSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> snapshotConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  SubmitSnapshotJobRequest() {}

  explicit SubmitSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = boost::any(*snapshotConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      snapshotConfig = make_shared<string>(boost::any_cast<string>(m["SnapshotConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitSnapshotJobRequest() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut : public Darabonba::Model {
public:
  shared_ptr<string> padding{};
  shared_ptr<string> color{};
  shared_ptr<string> cellSelStep{};
  shared_ptr<string> cellHeight{};
  shared_ptr<string> cellWidth{};
  shared_ptr<string> margin{};
  shared_ptr<string> columns{};
  shared_ptr<string> isKeepCellPic{};
  shared_ptr<string> lines{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (cellSelStep) {
      res["CellSelStep"] = boost::any(*cellSelStep);
    }
    if (cellHeight) {
      res["CellHeight"] = boost::any(*cellHeight);
    }
    if (cellWidth) {
      res["CellWidth"] = boost::any(*cellWidth);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (isKeepCellPic) {
      res["IsKeepCellPic"] = boost::any(*isKeepCellPic);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<string>(boost::any_cast<string>(m["Padding"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("CellSelStep") != m.end() && !m["CellSelStep"].empty()) {
      cellSelStep = make_shared<string>(boost::any_cast<string>(m["CellSelStep"]));
    }
    if (m.find("CellHeight") != m.end() && !m["CellHeight"].empty()) {
      cellHeight = make_shared<string>(boost::any_cast<string>(m["CellHeight"]));
    }
    if (m.find("CellWidth") != m.end() && !m["CellWidth"].empty()) {
      cellWidth = make_shared<string>(boost::any_cast<string>(m["CellWidth"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<string>(boost::any_cast<string>(m["Margin"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["Columns"]));
    }
    if (m.find("IsKeepCellPic") != m.end() && !m["IsKeepCellPic"].empty()) {
      isKeepCellPic = make_shared<string>(boost::any_cast<string>(m["IsKeepCellPic"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut> tileOut{};
  shared_ptr<string> interval{};
  shared_ptr<string> frameType{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile> outputFile{};
  shared_ptr<string> num{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile> tileOutputFile{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (tileOut) {
      res["TileOut"] = tileOut ? boost::any(tileOut->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (frameType) {
      res["FrameType"] = boost::any(*frameType);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (tileOutputFile) {
      res["TileOutputFile"] = tileOutputFile ? boost::any(tileOutputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("TileOut") != m.end() && !m["TileOut"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOut"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOut"]));
        tileOut = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut>(model1);
      }
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("FrameType") != m.end() && !m["FrameType"].empty()) {
      frameType = make_shared<string>(boost::any_cast<string>(m["FrameType"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile>(model1);
      }
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<string>(boost::any_cast<string>(m["Num"]));
    }
    if (m.find("TileOutputFile") != m.end() && !m["TileOutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOutputFile"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOutputFile"]));
        tileOutputFile = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobInput : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitSnapshotJobResponseBodySnapshotJobInput() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobInput() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig> snapshotConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> message{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobInput> input{};
  shared_ptr<string> count{};
  shared_ptr<string> tileCount{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> id{};

  SubmitSnapshotJobResponseBodySnapshotJob() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = snapshotConfig ? boost::any(snapshotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (tileCount) {
      res["TileCount"] = boost::any(*tileCount);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotConfig"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotConfig"]));
        snapshotConfig = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSnapshotJobResponseBodySnapshotJobInput>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("TileCount") != m.end() && !m["TileCount"].empty()) {
      tileCount = make_shared<string>(boost::any_cast<string>(m["TileCount"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJob() = default;
};
class SubmitSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJob> snapshotJob{};

  SubmitSnapshotJobResponseBody() {}

  explicit SubmitSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotJob) {
      res["SnapshotJob"] = snapshotJob ? boost::any(snapshotJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJob"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJob"]));
        snapshotJob = make_shared<SubmitSnapshotJobResponseBodySnapshotJob>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponseBody() = default;
};
class SubmitSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitSnapshotJobResponseBody> body{};

  SubmitSnapshotJobResponse() {}

  explicit SubmitSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponse() = default;
};
class ListCustomPersonsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> personId{};

  ListCustomPersonsRequest() {}

  explicit ListCustomPersonsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
  }


  virtual ~ListCustomPersonsRequest() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace : public Darabonba::Model {
public:
  shared_ptr<string> imageUrl{};
  shared_ptr<string> faceId{};

  ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace>> face{};

  ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (face) {
      vector<boost::any> temp1;
      for(auto item1:*face){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Face"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Face") != m.end() && !m["Face"].empty()) {
      if (typeid(vector<boost::any>) == m["Face"].type()) {
        vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Face"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        face = make_shared<vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace>>(expect1);
      }
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson : public Darabonba::Model {
public:
  shared_ptr<string> personName{};
  shared_ptr<string> personDescription{};
  shared_ptr<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces> faces{};
  shared_ptr<string> personId{};

  ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (personName) {
      res["PersonName"] = boost::any(*personName);
    }
    if (personDescription) {
      res["PersonDescription"] = boost::any(*personDescription);
    }
    if (faces) {
      res["Faces"] = faces ? boost::any(faces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PersonName") != m.end() && !m["PersonName"].empty()) {
      personName = make_shared<string>(boost::any_cast<string>(m["PersonName"]));
    }
    if (m.find("PersonDescription") != m.end() && !m["PersonDescription"].empty()) {
      personDescription = make_shared<string>(boost::any_cast<string>(m["PersonDescription"]));
    }
    if (m.find("Faces") != m.end() && !m["Faces"].empty()) {
      if (typeid(map<string, boost::any>) == m["Faces"].type()) {
        ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Faces"]));
        faces = make_shared<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces>(model1);
      }
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategoryPersons : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson>> person{};

  ListCustomPersonsResponseBodyCategoriesCategoryPersons() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategoryPersons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (person) {
      vector<boost::any> temp1;
      for(auto item1:*person){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Person"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Person") != m.end() && !m["Person"].empty()) {
      if (typeid(vector<boost::any>) == m["Person"].type()) {
        vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Person"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        person = make_shared<vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson>>(expect1);
      }
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategoryPersons() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategory : public Darabonba::Model {
public:
  shared_ptr<ListCustomPersonsResponseBodyCategoriesCategoryPersons> persons{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> categoryDescription{};

  ListCustomPersonsResponseBodyCategoriesCategory() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (persons) {
      res["Persons"] = persons ? boost::any(persons->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (categoryDescription) {
      res["CategoryDescription"] = boost::any(*categoryDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Persons") != m.end() && !m["Persons"].empty()) {
      if (typeid(map<string, boost::any>) == m["Persons"].type()) {
        ListCustomPersonsResponseBodyCategoriesCategoryPersons model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Persons"]));
        persons = make_shared<ListCustomPersonsResponseBodyCategoriesCategoryPersons>(model1);
      }
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("CategoryDescription") != m.end() && !m["CategoryDescription"].empty()) {
      categoryDescription = make_shared<string>(boost::any_cast<string>(m["CategoryDescription"]));
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategory() = default;
};
class ListCustomPersonsResponseBodyCategories : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomPersonsResponseBodyCategoriesCategory>> category{};

  ListCustomPersonsResponseBodyCategories() {}

  explicit ListCustomPersonsResponseBodyCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<ListCustomPersonsResponseBodyCategoriesCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomPersonsResponseBodyCategoriesCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<ListCustomPersonsResponseBodyCategoriesCategory>>(expect1);
      }
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategories() = default;
};
class ListCustomPersonsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListCustomPersonsResponseBodyCategories> categories{};

  ListCustomPersonsResponseBody() {}

  explicit ListCustomPersonsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (categories) {
      res["Categories"] = categories ? boost::any(categories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(map<string, boost::any>) == m["Categories"].type()) {
        ListCustomPersonsResponseBodyCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Categories"]));
        categories = make_shared<ListCustomPersonsResponseBodyCategories>(model1);
      }
    }
  }


  virtual ~ListCustomPersonsResponseBody() = default;
};
class ListCustomPersonsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCustomPersonsResponseBody> body{};

  ListCustomPersonsResponse() {}

  explicit ListCustomPersonsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomPersonsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomPersonsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomPersonsResponse() = default;
};
class QueryFacerecogJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> facerecogJobIds{};
  shared_ptr<string> ownerAccount{};

  QueryFacerecogJobListRequest() {}

  explicit QueryFacerecogJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (facerecogJobIds) {
      res["FacerecogJobIds"] = boost::any(*facerecogJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("FacerecogJobIds") != m.end() && !m["FacerecogJobIds"].empty()) {
      facerecogJobIds = make_shared<string>(boost::any_cast<string>(m["FacerecogJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryFacerecogJobListRequest() = default;
};
class QueryFacerecogJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFacerecogJobListResponseBodyNonExistIds() {}

  explicit QueryFacerecogJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyNonExistIds() = default;
};
class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace : public Darabonba::Model {
public:
  shared_ptr<string> score{};
  shared_ptr<string> name{};
  shared_ptr<string> target{};

  QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace() {}

  explicit QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace() = default;
};
class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace>> face{};

  QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces() {}

  explicit QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (face) {
      vector<boost::any> temp1;
      for(auto item1:*face){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Face"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Face") != m.end() && !m["Face"].empty()) {
      if (typeid(vector<boost::any>) == m["Face"].type()) {
        vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Face"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        face = make_shared<vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace>>(expect1);
      }
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces() = default;
};
class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces> faces{};

  QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog() {}

  explicit QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (faces) {
      res["Faces"] = faces ? boost::any(faces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Faces") != m.end() && !m["Faces"].empty()) {
      if (typeid(map<string, boost::any>) == m["Faces"].type()) {
        QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Faces"]));
        faces = make_shared<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces>(model1);
      }
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog() = default;
};
class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog>> facerecog{};

  QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs() {}

  explicit QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (facerecog) {
      vector<boost::any> temp1;
      for(auto item1:*facerecog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Facerecog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Facerecog") != m.end() && !m["Facerecog"].empty()) {
      if (typeid(vector<boost::any>) == m["Facerecog"].type()) {
        vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Facerecog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        facerecog = make_shared<vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog>>(expect1);
      }
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs() = default;
};
class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult : public Darabonba::Model {
public:
  shared_ptr<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs> facerecogs{};

  QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult() {}

  explicit QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (facerecogs) {
      res["Facerecogs"] = facerecogs ? boost::any(facerecogs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Facerecogs") != m.end() && !m["Facerecogs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Facerecogs"].type()) {
        QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Facerecogs"]));
        facerecogs = make_shared<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs>(model1);
      }
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult() = default;
};
class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput() {}

  explicit QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput() = default;
};
class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult> videoFacerecogResult{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput> input{};
  shared_ptr<string> id{};

  QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob() {}

  explicit QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (videoFacerecogResult) {
      res["VideoFacerecogResult"] = videoFacerecogResult ? boost::any(videoFacerecogResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("VideoFacerecogResult") != m.end() && !m["VideoFacerecogResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoFacerecogResult"].type()) {
        QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoFacerecogResult"]));
        videoFacerecogResult = make_shared<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob() = default;
};
class QueryFacerecogJobListResponseBodyFacerecogJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob>> facerecogJob{};

  QueryFacerecogJobListResponseBodyFacerecogJobList() {}

  explicit QueryFacerecogJobListResponseBodyFacerecogJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (facerecogJob) {
      vector<boost::any> temp1;
      for(auto item1:*facerecogJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FacerecogJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FacerecogJob") != m.end() && !m["FacerecogJob"].empty()) {
      if (typeid(vector<boost::any>) == m["FacerecogJob"].type()) {
        vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FacerecogJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        facerecogJob = make_shared<vector<QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob>>(expect1);
      }
    }
  }


  virtual ~QueryFacerecogJobListResponseBodyFacerecogJobList() = default;
};
class QueryFacerecogJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryFacerecogJobListResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<QueryFacerecogJobListResponseBodyFacerecogJobList> facerecogJobList{};

  QueryFacerecogJobListResponseBody() {}

  explicit QueryFacerecogJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (facerecogJobList) {
      res["FacerecogJobList"] = facerecogJobList ? boost::any(facerecogJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryFacerecogJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryFacerecogJobListResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("FacerecogJobList") != m.end() && !m["FacerecogJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FacerecogJobList"].type()) {
        QueryFacerecogJobListResponseBodyFacerecogJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FacerecogJobList"]));
        facerecogJobList = make_shared<QueryFacerecogJobListResponseBodyFacerecogJobList>(model1);
      }
    }
  }


  virtual ~QueryFacerecogJobListResponseBody() = default;
};
class QueryFacerecogJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryFacerecogJobListResponseBody> body{};

  QueryFacerecogJobListResponse() {}

  explicit QueryFacerecogJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFacerecogJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFacerecogJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFacerecogJobListResponse() = default;
};
class CreateInferenceServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> testId{};
  shared_ptr<string> modelType{};
  shared_ptr<string> modelPath{};
  shared_ptr<string> functionName{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> userData{};

  CreateInferenceServerRequest() {}

  explicit CreateInferenceServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testId) {
      res["TestId"] = boost::any(*testId);
    }
    if (modelType) {
      res["ModelType"] = boost::any(*modelType);
    }
    if (modelPath) {
      res["ModelPath"] = boost::any(*modelPath);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestId") != m.end() && !m["TestId"].empty()) {
      testId = make_shared<string>(boost::any_cast<string>(m["TestId"]));
    }
    if (m.find("ModelType") != m.end() && !m["ModelType"].empty()) {
      modelType = make_shared<string>(boost::any_cast<string>(m["ModelType"]));
    }
    if (m.find("ModelPath") != m.end() && !m["ModelPath"].empty()) {
      modelPath = make_shared<string>(boost::any_cast<string>(m["ModelPath"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateInferenceServerRequest() = default;
};
class CreateInferenceServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};

  CreateInferenceServerResponseBody() {}

  explicit CreateInferenceServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~CreateInferenceServerResponseBody() = default;
};
class CreateInferenceServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateInferenceServerResponseBody> body{};

  CreateInferenceServerResponse() {}

  explicit CreateInferenceServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInferenceServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInferenceServerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInferenceServerResponse() = default;
};
class ReportMediaDetailJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> tag{};
  shared_ptr<string> results{};
  shared_ptr<string> ownerAccount{};

  ReportMediaDetailJobResultRequest() {}

  explicit ReportMediaDetailJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (results) {
      res["Results"] = boost::any(*results);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      results = make_shared<string>(boost::any_cast<string>(m["Results"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportMediaDetailJobResultRequest() = default;
};
class ReportMediaDetailJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportMediaDetailJobResultResponseBody() {}

  explicit ReportMediaDetailJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportMediaDetailJobResultResponseBody() = default;
};
class ReportMediaDetailJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportMediaDetailJobResultResponseBody> body{};

  ReportMediaDetailJobResultResponse() {}

  explicit ReportMediaDetailJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportMediaDetailJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportMediaDetailJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportMediaDetailJobResultResponse() = default;
};
class SubmitAnnotationJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> annotationConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  SubmitAnnotationJobRequest() {}

  explicit SubmitAnnotationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (annotationConfig) {
      res["AnnotationConfig"] = boost::any(*annotationConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("AnnotationConfig") != m.end() && !m["AnnotationConfig"].empty()) {
      annotationConfig = make_shared<string>(boost::any_cast<string>(m["AnnotationConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitAnnotationJobRequest() = default;
};
class SubmitAnnotationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitAnnotationJobResponseBody() {}

  explicit SubmitAnnotationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitAnnotationJobResponseBody() = default;
};
class SubmitAnnotationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitAnnotationJobResponseBody> body{};

  SubmitAnnotationJobResponse() {}

  explicit SubmitAnnotationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAnnotationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAnnotationJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAnnotationJobResponse() = default;
};
class RegisterMediaDetailScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> scenario{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};

  RegisterMediaDetailScenarioRequest() {}

  explicit RegisterMediaDetailScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~RegisterMediaDetailScenarioRequest() = default;
};
class RegisterMediaDetailScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> scenarioId{};
  shared_ptr<string> requestId{};

  RegisterMediaDetailScenarioResponseBody() {}

  explicit RegisterMediaDetailScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterMediaDetailScenarioResponseBody() = default;
};
class RegisterMediaDetailScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RegisterMediaDetailScenarioResponseBody> body{};

  RegisterMediaDetailScenarioResponse() {}

  explicit RegisterMediaDetailScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterMediaDetailScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterMediaDetailScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterMediaDetailScenarioResponse() = default;
};
class QueryVideoSplitJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryVideoSplitJobListRequest() {}

  explicit QueryVideoSplitJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryVideoSplitJobListRequest() = default;
};
class QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> path{};

  QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit() {}

  explicit QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit() = default;
};
class QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit>> videoSplit{};

  QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList() {}

  explicit QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoSplit) {
      vector<boost::any> temp1;
      for(auto item1:*videoSplit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoSplit"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoSplit") != m.end() && !m["VideoSplit"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoSplit"].type()) {
        vector<QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoSplit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoSplit = make_shared<vector<QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit>>(expect1);
      }
    }
  }


  virtual ~QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList() = default;
};
class QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult : public Darabonba::Model {
public:
  shared_ptr<QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList> videoSplitList{};

  QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult() {}

  explicit QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoSplitList) {
      res["VideoSplitList"] = videoSplitList ? boost::any(videoSplitList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoSplitList") != m.end() && !m["VideoSplitList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoSplitList"].type()) {
        QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoSplitList"]));
        videoSplitList = make_shared<QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList>(model1);
      }
    }
  }


  virtual ~QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult() = default;
};
class QueryVideoSplitJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryVideoSplitJobListResponseBodyJobListJobInput() {}

  explicit QueryVideoSplitJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryVideoSplitJobListResponseBodyJobListJobInput() = default;
};
class QueryVideoSplitJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult> videoSplitResult{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryVideoSplitJobListResponseBodyJobListJobInput> input{};
  shared_ptr<string> id{};

  QueryVideoSplitJobListResponseBodyJobListJob() {}

  explicit QueryVideoSplitJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (videoSplitResult) {
      res["VideoSplitResult"] = videoSplitResult ? boost::any(videoSplitResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("VideoSplitResult") != m.end() && !m["VideoSplitResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoSplitResult"].type()) {
        QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoSplitResult"]));
        videoSplitResult = make_shared<QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryVideoSplitJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryVideoSplitJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryVideoSplitJobListResponseBodyJobListJob() = default;
};
class QueryVideoSplitJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoSplitJobListResponseBodyJobListJob>> job{};

  QueryVideoSplitJobListResponseBodyJobList() {}

  explicit QueryVideoSplitJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryVideoSplitJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoSplitJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryVideoSplitJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryVideoSplitJobListResponseBodyJobList() = default;
};
class QueryVideoSplitJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryVideoSplitJobListResponseBodyNonExistIds() {}

  explicit QueryVideoSplitJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryVideoSplitJobListResponseBodyNonExistIds() = default;
};
class QueryVideoSplitJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryVideoSplitJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryVideoSplitJobListResponseBodyNonExistIds> nonExistIds{};

  QueryVideoSplitJobListResponseBody() {}

  explicit QueryVideoSplitJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryVideoSplitJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryVideoSplitJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryVideoSplitJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryVideoSplitJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryVideoSplitJobListResponseBody() = default;
};
class QueryVideoSplitJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryVideoSplitJobListResponseBody> body{};

  QueryVideoSplitJobListResponse() {}

  explicit QueryVideoSplitJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryVideoSplitJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryVideoSplitJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryVideoSplitJobListResponse() = default;
};
class ReportAnnotationJobResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> annotation{};
  shared_ptr<string> details{};
  shared_ptr<string> ownerAccount{};

  ReportAnnotationJobResultRequest() {}

  explicit ReportAnnotationJobResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReportAnnotationJobResultRequest() = default;
};
class ReportAnnotationJobResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  ReportAnnotationJobResultResponseBody() {}

  explicit ReportAnnotationJobResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReportAnnotationJobResultResponseBody() = default;
};
class ReportAnnotationJobResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReportAnnotationJobResultResponseBody> body{};

  ReportAnnotationJobResultResponse() {}

  explicit ReportAnnotationJobResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReportAnnotationJobResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReportAnnotationJobResultResponseBody>(model1);
      }
    }
  }


  virtual ~ReportAnnotationJobResultResponse() = default;
};
class BindInputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> bucket{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> ownerAccount{};

  BindInputBucketRequest() {}

  explicit BindInputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~BindInputBucketRequest() = default;
};
class BindInputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindInputBucketResponseBody() {}

  explicit BindInputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindInputBucketResponseBody() = default;
};
class BindInputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindInputBucketResponseBody> body{};

  BindInputBucketResponse() {}

  explicit BindInputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindInputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindInputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~BindInputBucketResponse() = default;
};
class QueryPipelineListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineIds{};
  shared_ptr<string> ownerAccount{};

  QueryPipelineListRequest() {}

  explicit QueryPipelineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineIds) {
      res["PipelineIds"] = boost::any(*pipelineIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineIds") != m.end() && !m["PipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["PipelineIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryPipelineListRequest() = default;
};
class QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> mqTopic{};
  shared_ptr<string> queueName{};
  shared_ptr<string> mqTag{};
  shared_ptr<string> topic{};

  QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mqTopic) {
      res["MqTopic"] = boost::any(*mqTopic);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (mqTag) {
      res["MqTag"] = boost::any(*mqTag);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MqTopic") != m.end() && !m["MqTopic"].empty()) {
      mqTopic = make_shared<string>(boost::any_cast<string>(m["MqTopic"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("MqTag") != m.end() && !m["MqTag"].empty()) {
      mqTag = make_shared<string>(boost::any_cast<string>(m["MqTag"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class QueryPipelineListResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> speed{};
  shared_ptr<string> state{};
  shared_ptr<long> speedLevel{};
  shared_ptr<QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<long> quotaAllocate{};

  QueryPipelineListResponseBodyPipelineListPipeline() {}

  explicit QueryPipelineListResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (quotaAllocate) {
      res["QuotaAllocate"] = boost::any(*quotaAllocate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("QuotaAllocate") != m.end() && !m["QuotaAllocate"].empty()) {
      quotaAllocate = make_shared<long>(boost::any_cast<long>(m["QuotaAllocate"]));
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineListPipeline() = default;
};
class QueryPipelineListResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPipelineListResponseBodyPipelineListPipeline>> pipeline{};

  QueryPipelineListResponseBodyPipelineList() {}

  explicit QueryPipelineListResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<QueryPipelineListResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPipelineListResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<QueryPipelineListResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineList() = default;
};
class QueryPipelineListResponseBodyNonExistPids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryPipelineListResponseBodyNonExistPids() {}

  explicit QueryPipelineListResponseBodyNonExistPids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryPipelineListResponseBodyNonExistPids() = default;
};
class QueryPipelineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryPipelineListResponseBodyPipelineList> pipelineList{};
  shared_ptr<QueryPipelineListResponseBodyNonExistPids> nonExistPids{};

  QueryPipelineListResponseBody() {}

  explicit QueryPipelineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistPids) {
      res["NonExistPids"] = nonExistPids ? boost::any(nonExistPids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        QueryPipelineListResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<QueryPipelineListResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("NonExistPids") != m.end() && !m["NonExistPids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistPids"].type()) {
        QueryPipelineListResponseBodyNonExistPids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistPids"]));
        nonExistPids = make_shared<QueryPipelineListResponseBodyNonExistPids>(model1);
      }
    }
  }


  virtual ~QueryPipelineListResponseBody() = default;
};
class QueryPipelineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryPipelineListResponseBody> body{};

  QueryPipelineListResponse() {}

  explicit QueryPipelineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPipelineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPipelineListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPipelineListResponse() = default;
};
class UpdateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> name{};
  shared_ptr<string> container{};
  shared_ptr<string> video{};
  shared_ptr<string> audio{};
  shared_ptr<string> muxConfig{};
  shared_ptr<string> transConfig{};
  shared_ptr<string> ownerAccount{};

  UpdateTemplateRequest() {}

  explicit UpdateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    if (audio) {
      res["Audio"] = boost::any(*audio);
    }
    if (muxConfig) {
      res["MuxConfig"] = boost::any(*muxConfig);
    }
    if (transConfig) {
      res["TransConfig"] = boost::any(*transConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      audio = make_shared<string>(boost::any_cast<string>(m["Audio"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      muxConfig = make_shared<string>(boost::any_cast<string>(m["MuxConfig"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      transConfig = make_shared<string>(boost::any_cast<string>(m["TransConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateTemplateRequest() = default;
};
class UpdateTemplateResponseBodyTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  UpdateTemplateResponseBodyTemplateVideoBitrateBnd() {}

  explicit UpdateTemplateResponseBodyTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateVideoBitrateBnd() = default;
};
class UpdateTemplateResponseBodyTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> longShortMode{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<UpdateTemplateResponseBodyTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> pad{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> crop{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> remove{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> resoPriority{};

  UpdateTemplateResponseBodyTemplateVideo() {}

  explicit UpdateTemplateResponseBodyTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        UpdateTemplateResponseBodyTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<UpdateTemplateResponseBodyTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateVideo() = default;
};
class UpdateTemplateResponseBodyTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> transMode{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckAudioBitrateFail{};

  UpdateTemplateResponseBodyTemplateTransConfig() {}

  explicit UpdateTemplateResponseBodyTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateTransConfig() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  UpdateTemplateResponseBodyTemplateMuxConfigWebp() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigWebp() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> ditherMode{};
  shared_ptr<string> loop{};
  shared_ptr<string> isCustomPalette{};

  UpdateTemplateResponseBodyTemplateMuxConfigGif() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigGif() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  UpdateTemplateResponseBodyTemplateMuxConfigSegment() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigSegment() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigWebp> webp{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigGif> gif{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigSegment> segment{};

  UpdateTemplateResponseBodyTemplateMuxConfig() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigWebp>(model1);
      }
    }
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfig() = default;
};
class UpdateTemplateResponseBodyTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<string> bitrate{};

  UpdateTemplateResponseBodyTemplateAudio() {}

  explicit UpdateTemplateResponseBodyTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateAudio() = default;
};
class UpdateTemplateResponseBodyTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  UpdateTemplateResponseBodyTemplateContainer() {}

  explicit UpdateTemplateResponseBodyTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateContainer() = default;
};
class UpdateTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<UpdateTemplateResponseBodyTemplateVideo> video{};
  shared_ptr<UpdateTemplateResponseBodyTemplateTransConfig> transConfig{};
  shared_ptr<string> state{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<UpdateTemplateResponseBodyTemplateAudio> audio{};
  shared_ptr<string> id{};
  shared_ptr<UpdateTemplateResponseBodyTemplateContainer> container{};

  UpdateTemplateResponseBodyTemplate() {}

  explicit UpdateTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        UpdateTemplateResponseBodyTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<UpdateTemplateResponseBodyTemplateVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        UpdateTemplateResponseBodyTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<UpdateTemplateResponseBodyTemplateTransConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<UpdateTemplateResponseBodyTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        UpdateTemplateResponseBodyTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<UpdateTemplateResponseBodyTemplateAudio>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        UpdateTemplateResponseBodyTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<UpdateTemplateResponseBodyTemplateContainer>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplate() = default;
};
class UpdateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateTemplateResponseBodyTemplate> template_{};

  UpdateTemplateResponseBody() {}

  explicit UpdateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        UpdateTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<UpdateTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBody() = default;
};
class UpdateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateTemplateResponseBody> body{};

  UpdateTemplateResponse() {}

  explicit UpdateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponse() = default;
};
class UpdateCoverPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> ownerAccount{};

  UpdateCoverPipelineRequest() {}

  explicit UpdateCoverPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateCoverPipelineRequest() = default;
};
class UpdateCoverPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  UpdateCoverPipelineResponseBodyPipelineNotifyConfig() {}

  explicit UpdateCoverPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~UpdateCoverPipelineResponseBodyPipelineNotifyConfig() = default;
};
class UpdateCoverPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<UpdateCoverPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  UpdateCoverPipelineResponseBodyPipeline() {}

  explicit UpdateCoverPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        UpdateCoverPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<UpdateCoverPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateCoverPipelineResponseBodyPipeline() = default;
};
class UpdateCoverPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateCoverPipelineResponseBodyPipeline> pipeline{};

  UpdateCoverPipelineResponseBody() {}

  explicit UpdateCoverPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        UpdateCoverPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<UpdateCoverPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~UpdateCoverPipelineResponseBody() = default;
};
class UpdateCoverPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateCoverPipelineResponseBody> body{};

  UpdateCoverPipelineResponse() {}

  explicit UpdateCoverPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCoverPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCoverPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCoverPipelineResponse() = default;
};
class UpdateTerrorismPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<long> priority{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};

  UpdateTerrorismPipelineRequest() {}

  explicit UpdateTerrorismPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~UpdateTerrorismPipelineRequest() = default;
};
class UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<string> queue{};

  UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig() {}

  explicit UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
  }


  virtual ~UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig() = default;
};
class UpdateTerrorismPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  UpdateTerrorismPipelineResponseBodyPipeline() {}

  explicit UpdateTerrorismPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateTerrorismPipelineResponseBodyPipeline() = default;
};
class UpdateTerrorismPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateTerrorismPipelineResponseBodyPipeline> pipeline{};

  UpdateTerrorismPipelineResponseBody() {}

  explicit UpdateTerrorismPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        UpdateTerrorismPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<UpdateTerrorismPipelineResponseBodyPipeline>(model1);
      }
    }
  }


  virtual ~UpdateTerrorismPipelineResponseBody() = default;
};
class UpdateTerrorismPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateTerrorismPipelineResponseBody> body{};

  UpdateTerrorismPipelineResponse() {}

  explicit UpdateTerrorismPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTerrorismPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTerrorismPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTerrorismPipelineResponse() = default;
};
class QueryInferenceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryInferenceJobRequest() {}

  explicit QueryInferenceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryInferenceJobRequest() = default;
};
class QueryInferenceJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> result{};
  shared_ptr<string> jobId{};
  shared_ptr<long> userId{};
  shared_ptr<string> message{};
  shared_ptr<long> jobTime{};
  shared_ptr<string> jobParams{};

  QueryInferenceJobResponseBodyJob() {}

  explicit QueryInferenceJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (jobTime) {
      res["JobTime"] = boost::any(*jobTime);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("JobTime") != m.end() && !m["JobTime"].empty()) {
      jobTime = make_shared<long>(boost::any_cast<long>(m["JobTime"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
  }


  virtual ~QueryInferenceJobResponseBodyJob() = default;
};
class QueryInferenceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryInferenceJobResponseBodyJob> job{};
  shared_ptr<string> code{};

  QueryInferenceJobResponseBody() {}

  explicit QueryInferenceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        QueryInferenceJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<QueryInferenceJobResponseBodyJob>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~QueryInferenceJobResponseBody() = default;
};
class QueryInferenceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryInferenceJobResponseBody> body{};

  QueryInferenceJobResponse() {}

  explicit QueryInferenceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryInferenceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryInferenceJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryInferenceJobResponse() = default;
};
class QueryVideoPoseJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};

  QueryVideoPoseJobListRequest() {}

  explicit QueryVideoPoseJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryVideoPoseJobListRequest() = default;
};
class QueryVideoPoseJobListResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryVideoPoseJobListResponseBodyNonExistJobIds() {}

  explicit QueryVideoPoseJobListResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyNonExistJobIds() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobOutputConfig : public Darabonba::Model {
public:
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile> dataFile{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile> videoFile{};

  QueryVideoPoseJobListResponseBodyJobListJobOutputConfig() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobOutputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataFile) {
      res["DataFile"] = dataFile ? boost::any(dataFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoFile) {
      res["VideoFile"] = videoFile ? boost::any(videoFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataFile") != m.end() && !m["DataFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataFile"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataFile"]));
        dataFile = make_shared<QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile>(model1);
      }
    }
    if (m.find("VideoFile") != m.end() && !m["VideoFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoFile"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoFile"]));
        videoFile = make_shared<QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile>(model1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobOutputConfig() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> roleArn{};
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryVideoPoseJobListResponseBodyJobListJobInput() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobInput() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> preloadTime{};
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> sar{};
  shared_ptr<string> height{};
  shared_ptr<string> codecTagString{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> width{};
  shared_ptr<string> index{};
  shared_ptr<string> timebase{};
  shared_ptr<string> avgFPS{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> rotate{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> startTime{};
  shared_ptr<string> dar{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> level{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> lang{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> channels{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> timebase{};
  shared_ptr<string> index{};
  shared_ptr<string> startTime{};
  shared_ptr<string> codecName{};
  shared_ptr<string> lang{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> codecTagString{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList> videoStreamList{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList> subtitleStreamList{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList>(model1);
      }
    }
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> size{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> duration{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> formatName{};

  QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJobProperties : public Darabonba::Model {
public:
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> fileFormat{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams> streams{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat> format{};
  shared_ptr<string> fileSize{};

  QueryVideoPoseJobListResponseBodyJobListJobProperties() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJobProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat>(model1);
      }
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJobProperties() = default;
};
class QueryVideoPoseJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobOutputConfig> outputConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobInput> input{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobListJobProperties> properties{};

  QueryVideoPoseJobListResponseBodyJobListJob() {}

  explicit QueryVideoPoseJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputConfig) {
      res["OutputConfig"] = outputConfig ? boost::any(outputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputConfig"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobOutputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputConfig"]));
        outputConfig = make_shared<QueryVideoPoseJobListResponseBodyJobListJobOutputConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryVideoPoseJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryVideoPoseJobListResponseBodyJobListJobProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryVideoPoseJobListResponseBodyJobListJobProperties>(model1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobListJob() = default;
};
class QueryVideoPoseJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryVideoPoseJobListResponseBodyJobListJob>> job{};

  QueryVideoPoseJobListResponseBodyJobList() {}

  explicit QueryVideoPoseJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryVideoPoseJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryVideoPoseJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryVideoPoseJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponseBodyJobList() = default;
};
class QueryVideoPoseJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryVideoPoseJobListResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryVideoPoseJobListResponseBodyJobList> jobList{};

  QueryVideoPoseJobListResponseBody() {}

  explicit QueryVideoPoseJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QueryVideoPoseJobListResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QueryVideoPoseJobListResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryVideoPoseJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryVideoPoseJobListResponseBodyJobList>(model1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponseBody() = default;
};
class QueryVideoPoseJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryVideoPoseJobListResponseBody> body{};

  QueryVideoPoseJobListResponse() {}

  explicit QueryVideoPoseJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryVideoPoseJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryVideoPoseJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryVideoPoseJobListResponse() = default;
};
class SubmitAnalysisJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> analysisConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> ownerAccount{};

  SubmitAnalysisJobRequest() {}

  explicit SubmitAnalysisJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (analysisConfig) {
      res["AnalysisConfig"] = boost::any(*analysisConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      analysisConfig = make_shared<string>(boost::any_cast<string>(m["AnalysisConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitAnalysisJobRequest() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl : public Darabonba::Model {
public:
  shared_ptr<string> methodStreaming{};
  shared_ptr<string> rateQuality{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodStreaming) {
      res["MethodStreaming"] = boost::any(*methodStreaming);
    }
    if (rateQuality) {
      res["RateQuality"] = boost::any(*rateQuality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodStreaming") != m.end() && !m["MethodStreaming"].empty()) {
      methodStreaming = make_shared<string>(boost::any_cast<string>(m["MethodStreaming"]));
    }
    if (m.find("RateQuality") != m.end() && !m["RateQuality"].empty()) {
      rateQuality = make_shared<string>(boost::any_cast<string>(m["RateQuality"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop : public Darabonba::Model {
public:
  shared_ptr<string> top{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> left{};
  shared_ptr<string> mode{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (top) {
      res["Top"] = boost::any(*top);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl : public Darabonba::Model {
public:
  shared_ptr<string> deinterlace{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop> crop{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deinterlace) {
      res["Deinterlace"] = boost::any(*deinterlace);
    }
    if (crop) {
      res["Crop"] = crop ? boost::any(crop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deinterlace") != m.end() && !m["Deinterlace"].empty()) {
      deinterlace = make_shared<string>(boost::any_cast<string>(m["Deinterlace"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Crop"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Crop"]));
        crop = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl> qualityControl{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl> propertiesControl{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qualityControl) {
      res["QualityControl"] = qualityControl ? boost::any(qualityControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertiesControl) {
      res["PropertiesControl"] = propertiesControl ? boost::any(propertiesControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QualityControl") != m.end() && !m["QualityControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["QualityControl"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QualityControl"]));
        qualityControl = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl>(model1);
      }
    }
    if (m.find("PropertiesControl") != m.end() && !m["PropertiesControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertiesControl"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertiesControl"]));
        propertiesControl = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};

  SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bufsize{};
  shared_ptr<string> degrain{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> codec{};
  shared_ptr<string> height{};
  shared_ptr<string> qscale{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> profile{};
  shared_ptr<string> crf{};
  shared_ptr<string> gop{};
  shared_ptr<string> width{};
  shared_ptr<string> fps{};
  shared_ptr<string> preset{};
  shared_ptr<string> scanMode{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> transMode{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> loop{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment> segment{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> profile{};
  shared_ptr<string> codec{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> qscale{};
  shared_ptr<string> channels{};
  shared_ptr<string> bitrate{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo> video{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<string> state{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio> audio{};
  shared_ptr<string> id{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer> container{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate>> template_{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateList() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateList() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobInputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  SubmitAnalysisJobResponseBodyAnalysisJobInputFile() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobInputFile() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<long> percent{};
  shared_ptr<string> state{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig> analysisConfig{};
  shared_ptr<string> message{};
  shared_ptr<string> priority{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateList> templateList{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobInputFile> inputFile{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> id{};

  SubmitAnalysisJobResponseBodyAnalysisJob() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (analysisConfig) {
      res["AnalysisConfig"] = analysisConfig ? boost::any(analysisConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisConfig"]));
        analysisConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult>(model1);
      }
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateList>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobInputFile>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJob() = default;
};
class SubmitAnalysisJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJob> analysisJob{};

  SubmitAnalysisJobResponseBody() {}

  explicit SubmitAnalysisJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (analysisJob) {
      res["AnalysisJob"] = analysisJob ? boost::any(analysisJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AnalysisJob") != m.end() && !m["AnalysisJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisJob"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisJob"]));
        analysisJob = make_shared<SubmitAnalysisJobResponseBodyAnalysisJob>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBody() = default;
};
class SubmitAnalysisJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitAnalysisJobResponseBody> body{};

  SubmitAnalysisJobResponse() {}

  explicit SubmitAnalysisJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAnalysisJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAnalysisJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponse() = default;
};
class SubmitVideoSplitJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> input{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> videoSplitConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> ownerAccount{};

  SubmitVideoSplitJobRequest() {}

  explicit SubmitVideoSplitJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (videoSplitConfig) {
      res["VideoSplitConfig"] = boost::any(*videoSplitConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("VideoSplitConfig") != m.end() && !m["VideoSplitConfig"].empty()) {
      videoSplitConfig = make_shared<string>(boost::any_cast<string>(m["VideoSplitConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SubmitVideoSplitJobRequest() = default;
};
class SubmitVideoSplitJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> jobId{};

  SubmitVideoSplitJobResponseBody() {}

  explicit SubmitVideoSplitJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitVideoSplitJobResponseBody() = default;
};
class SubmitVideoSplitJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitVideoSplitJobResponseBody> body{};

  SubmitVideoSplitJobResponse() {}

  explicit SubmitVideoSplitJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitVideoSplitJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitVideoSplitJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitVideoSplitJobResponse() = default;
};
class PlayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> formats{};
  shared_ptr<string> authInfo{};
  shared_ptr<long> authTimeout{};
  shared_ptr<string> rand{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> hlsUriToken{};
  shared_ptr<string> terminal{};

  PlayInfoRequest() {}

  explicit PlayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (formats) {
      res["Formats"] = boost::any(*formats);
    }
    if (authInfo) {
      res["AuthInfo"] = boost::any(*authInfo);
    }
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (rand) {
      res["Rand"] = boost::any(*rand);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (hlsUriToken) {
      res["HlsUriToken"] = boost::any(*hlsUriToken);
    }
    if (terminal) {
      res["Terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Formats") != m.end() && !m["Formats"].empty()) {
      formats = make_shared<string>(boost::any_cast<string>(m["Formats"]));
    }
    if (m.find("AuthInfo") != m.end() && !m["AuthInfo"].empty()) {
      authInfo = make_shared<string>(boost::any_cast<string>(m["AuthInfo"]));
    }
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("Rand") != m.end() && !m["Rand"].empty()) {
      rand = make_shared<string>(boost::any_cast<string>(m["Rand"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("HlsUriToken") != m.end() && !m["HlsUriToken"].empty()) {
      hlsUriToken = make_shared<string>(boost::any_cast<string>(m["HlsUriToken"]));
    }
    if (m.find("Terminal") != m.end() && !m["Terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["Terminal"]));
    }
  }


  virtual ~PlayInfoRequest() = default;
};
class PlayInfoResponseBodyNotFoundCDNDomain : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  PlayInfoResponseBodyNotFoundCDNDomain() {}

  explicit PlayInfoResponseBodyNotFoundCDNDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PlayInfoResponseBodyNotFoundCDNDomain() = default;
};
class PlayInfoResponseBodyPlayInfoListPlayInfo : public Darabonba::Model {
public:
  shared_ptr<string> downloadType{};
  shared_ptr<string> width{};
  shared_ptr<string> definition{};
  shared_ptr<string> rand{};
  shared_ptr<string> url{};
  shared_ptr<string> complexity{};
  shared_ptr<string> encryption{};
  shared_ptr<string> fps{};
  shared_ptr<string> encryptionType{};
  shared_ptr<string> height{};
  shared_ptr<string> activityName{};
  shared_ptr<string> size{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> plaintext{};
  shared_ptr<string> duration{};
  shared_ptr<string> format{};

  PlayInfoResponseBodyPlayInfoListPlayInfo() {}

  explicit PlayInfoResponseBodyPlayInfoListPlayInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadType) {
      res["downloadType"] = boost::any(*downloadType);
    }
    if (width) {
      res["width"] = boost::any(*width);
    }
    if (definition) {
      res["definition"] = boost::any(*definition);
    }
    if (rand) {
      res["rand"] = boost::any(*rand);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (complexity) {
      res["complexity"] = boost::any(*complexity);
    }
    if (encryption) {
      res["encryption"] = boost::any(*encryption);
    }
    if (fps) {
      res["fps"] = boost::any(*fps);
    }
    if (encryptionType) {
      res["encryptionType"] = boost::any(*encryptionType);
    }
    if (height) {
      res["height"] = boost::any(*height);
    }
    if (activityName) {
      res["activityName"] = boost::any(*activityName);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (bitrate) {
      res["bitrate"] = boost::any(*bitrate);
    }
    if (plaintext) {
      res["plaintext"] = boost::any(*plaintext);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (format) {
      res["format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("downloadType") != m.end() && !m["downloadType"].empty()) {
      downloadType = make_shared<string>(boost::any_cast<string>(m["downloadType"]));
    }
    if (m.find("width") != m.end() && !m["width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["width"]));
    }
    if (m.find("definition") != m.end() && !m["definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["definition"]));
    }
    if (m.find("rand") != m.end() && !m["rand"].empty()) {
      rand = make_shared<string>(boost::any_cast<string>(m["rand"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("complexity") != m.end() && !m["complexity"].empty()) {
      complexity = make_shared<string>(boost::any_cast<string>(m["complexity"]));
    }
    if (m.find("encryption") != m.end() && !m["encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["encryption"]));
    }
    if (m.find("fps") != m.end() && !m["fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["fps"]));
    }
    if (m.find("encryptionType") != m.end() && !m["encryptionType"].empty()) {
      encryptionType = make_shared<string>(boost::any_cast<string>(m["encryptionType"]));
    }
    if (m.find("height") != m.end() && !m["height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["height"]));
    }
    if (m.find("activityName") != m.end() && !m["activityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["activityName"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["size"]));
    }
    if (m.find("bitrate") != m.end() && !m["bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["bitrate"]));
    }
    if (m.find("plaintext") != m.end() && !m["plaintext"].empty()) {
      plaintext = make_shared<string>(boost::any_cast<string>(m["plaintext"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["duration"]));
    }
    if (m.find("format") != m.end() && !m["format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["format"]));
    }
  }


  virtual ~PlayInfoResponseBodyPlayInfoListPlayInfo() = default;
};
class PlayInfoResponseBodyPlayInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<PlayInfoResponseBodyPlayInfoListPlayInfo>> playInfo{};

  PlayInfoResponseBodyPlayInfoList() {}

  explicit PlayInfoResponseBodyPlayInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (playInfo) {
      vector<boost::any> temp1;
      for(auto item1:*playInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlayInfo") != m.end() && !m["PlayInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayInfo"].type()) {
        vector<PlayInfoResponseBodyPlayInfoListPlayInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PlayInfoResponseBodyPlayInfoListPlayInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playInfo = make_shared<vector<PlayInfoResponseBodyPlayInfoListPlayInfo>>(expect1);
      }
    }
  }


  virtual ~PlayInfoResponseBodyPlayInfoList() = default;
};
class PlayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<PlayInfoResponseBodyNotFoundCDNDomain> notFoundCDNDomain{};
  shared_ptr<PlayInfoResponseBodyPlayInfoList> playInfoList{};

  PlayInfoResponseBody() {}

  explicit PlayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (notFoundCDNDomain) {
      res["NotFoundCDNDomain"] = notFoundCDNDomain ? boost::any(notFoundCDNDomain->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playInfoList) {
      res["PlayInfoList"] = playInfoList ? boost::any(playInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NotFoundCDNDomain") != m.end() && !m["NotFoundCDNDomain"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotFoundCDNDomain"].type()) {
        PlayInfoResponseBodyNotFoundCDNDomain model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotFoundCDNDomain"]));
        notFoundCDNDomain = make_shared<PlayInfoResponseBodyNotFoundCDNDomain>(model1);
      }
    }
    if (m.find("PlayInfoList") != m.end() && !m["PlayInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayInfoList"].type()) {
        PlayInfoResponseBodyPlayInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayInfoList"]));
        playInfoList = make_shared<PlayInfoResponseBodyPlayInfoList>(model1);
      }
    }
  }


  virtual ~PlayInfoResponseBody() = default;
};
class PlayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PlayInfoResponseBody> body{};

  PlayInfoResponse() {}

  explicit PlayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PlayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PlayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~PlayInfoResponse() = default;
};
class SubmitSubtitleJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> userData{};

  SubmitSubtitleJobRequest() {}

  explicit SubmitSubtitleJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSubtitleJobRequest() = default;
};
class SubmitSubtitleJobResponseBodySubtitleJob : public Darabonba::Model {
public:
  shared_ptr<string> outputConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userData{};
  shared_ptr<string> inputConfig{};

  SubmitSubtitleJobResponseBodySubtitleJob() {}

  explicit SubmitSubtitleJobResponseBodySubtitleJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
  }


  virtual ~SubmitSubtitleJobResponseBodySubtitleJob() = default;
};
class SubmitSubtitleJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitSubtitleJobResponseBodySubtitleJob> subtitleJob{};

  SubmitSubtitleJobResponseBody() {}

  explicit SubmitSubtitleJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subtitleJob) {
      res["SubtitleJob"] = subtitleJob ? boost::any(subtitleJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubtitleJob") != m.end() && !m["SubtitleJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleJob"].type()) {
        SubmitSubtitleJobResponseBodySubtitleJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleJob"]));
        subtitleJob = make_shared<SubmitSubtitleJobResponseBodySubtitleJob>(model1);
      }
    }
  }


  virtual ~SubmitSubtitleJobResponseBody() = default;
};
class SubmitSubtitleJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitSubtitleJobResponseBody> body{};

  SubmitSubtitleJobResponse() {}

  explicit SubmitSubtitleJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSubtitleJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSubtitleJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSubtitleJobResponse() = default;
};
class QueryCoverJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> coverJobIds{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> state{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> ownerAccount{};

  QueryCoverJobListRequest() {}

  explicit QueryCoverJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (coverJobIds) {
      res["CoverJobIds"] = boost::any(*coverJobIds);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CoverJobIds") != m.end() && !m["CoverJobIds"].empty()) {
      coverJobIds = make_shared<string>(boost::any_cast<string>(m["CoverJobIds"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~QueryCoverJobListRequest() = default;
};
class QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> score{};
  shared_ptr<string> url{};

  QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage() {}

  explicit QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage() = default;
};
class QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage>> coverImage{};

  QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList() {}

  explicit QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverImage) {
      vector<boost::any> temp1;
      for(auto item1:*coverImage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverImage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverImage") != m.end() && !m["CoverImage"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverImage"].type()) {
        vector<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverImage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverImage = make_shared<vector<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage>>(expect1);
      }
    }
  }


  virtual ~QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList() = default;
};
class QueryCoverJobListResponseBodyCoverJobListCoverJobInput : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryCoverJobListResponseBodyCoverJobListCoverJobInput() {}

  explicit QueryCoverJobListResponseBodyCoverJobListCoverJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryCoverJobListResponseBodyCoverJobListCoverJobInput() = default;
};
class QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> object{};
  shared_ptr<string> location{};
  shared_ptr<string> bucket{};

  QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile() {}

  explicit QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile() = default;
};
class QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig : public Darabonba::Model {
public:
  shared_ptr<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile> outputFile{};

  QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig() {}

  explicit QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile>(model1);
      }
    }
  }


  virtual ~QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig() = default;
};
class QueryCoverJobListResponseBodyCoverJobListCoverJob : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> state{};
  shared_ptr<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList> coverImageList{};
  shared_ptr<string> userData{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryCoverJobListResponseBodyCoverJobListCoverJobInput> input{};
  shared_ptr<string> id{};
  shared_ptr<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig> coverConfig{};

  QueryCoverJobListResponseBodyCoverJobListCoverJob() {}

  explicit QueryCoverJobListResponseBodyCoverJobListCoverJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (coverImageList) {
      res["CoverImageList"] = coverImageList ? boost::any(coverImageList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (coverConfig) {
      res["CoverConfig"] = coverConfig ? boost::any(coverConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("CoverImageList") != m.end() && !m["CoverImageList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverImageList"].type()) {
        QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverImageList"]));
        coverImageList = make_shared<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryCoverJobListResponseBodyCoverJobListCoverJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryCoverJobListResponseBodyCoverJobListCoverJobInput>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("CoverConfig") != m.end() && !m["CoverConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverConfig"].type()) {
        QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverConfig"]));
        coverConfig = make_shared<QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig>(model1);
      }
    }
  }


  virtual ~QueryCoverJobListResponseBodyCoverJobListCoverJob() = default;
};
class QueryCoverJobListResponseBodyCoverJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCoverJobListResponseBodyCoverJobListCoverJob>> coverJob{};

  QueryCoverJobListResponseBodyCoverJobList() {}

  explicit QueryCoverJobListResponseBodyCoverJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverJob) {
      vector<boost::any> temp1;
      for(auto item1:*coverJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverJob") != m.end() && !m["CoverJob"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverJob"].type()) {
        vector<QueryCoverJobListResponseBodyCoverJobListCoverJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCoverJobListResponseBodyCoverJobListCoverJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverJob = make_shared<vector<QueryCoverJobListResponseBodyCoverJobListCoverJob>>(expect1);
      }
    }
  }


  virtual ~QueryCoverJobListResponseBodyCoverJobList() = default;
};
class QueryCoverJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryCoverJobListResponseBodyNonExistIds() {}

  explicit QueryCoverJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryCoverJobListResponseBodyNonExistIds() = default;
};
class QueryCoverJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryCoverJobListResponseBodyCoverJobList> coverJobList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryCoverJobListResponseBodyNonExistIds> nonExistIds{};

  QueryCoverJobListResponseBody() {}

  explicit QueryCoverJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverJobList) {
      res["CoverJobList"] = coverJobList ? boost::any(coverJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverJobList") != m.end() && !m["CoverJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverJobList"].type()) {
        QueryCoverJobListResponseBodyCoverJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverJobList"]));
        coverJobList = make_shared<QueryCoverJobListResponseBodyCoverJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryCoverJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryCoverJobListResponseBodyNonExistIds>(model1);
      }
    }
  }


  virtual ~QueryCoverJobListResponseBody() = default;
};
class QueryCoverJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryCoverJobListResponseBody> body{};

  QueryCoverJobListResponse() {}

  explicit QueryCoverJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCoverJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCoverJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCoverJobListResponse() = default;
};
class AddWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> config{};
  shared_ptr<string> ownerAccount{};

  AddWaterMarkTemplateRequest() {}

  explicit AddWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddWaterMarkTemplateRequest() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<string> dy{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> duration{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<string> dx{};
  shared_ptr<string> width{};
  shared_ptr<string> height{};
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> name{};
  shared_ptr<string> dy{};
  shared_ptr<string> id{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplate() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplate() = default;
};
class AddWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplate> waterMarkTemplate{};
  shared_ptr<string> requestId{};

  AddWaterMarkTemplateResponseBody() {}

  explicit AddWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMarkTemplate) {
      res["WaterMarkTemplate"] = waterMarkTemplate ? boost::any(waterMarkTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplate"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplate"]));
        waterMarkTemplate = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBody() = default;
};
class AddWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddWaterMarkTemplateResponseBody> body{};

  AddWaterMarkTemplateResponse() {}

  explicit AddWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddWaterMarkTemplateResponse() = default;
};
class PlayerAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ownerAccount{};

  PlayerAuthRequest() {}

  explicit PlayerAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~PlayerAuthRequest() = default;
};
class PlayerAuthResponseBodySwitchListSwitch : public Darabonba::Model {
public:
  shared_ptr<string> functionId{};
  shared_ptr<string> functionName{};
  shared_ptr<string> state{};
  shared_ptr<string> switchId{};

  PlayerAuthResponseBodySwitchListSwitch() {}

  explicit PlayerAuthResponseBodySwitchListSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionId) {
      res["FunctionId"] = boost::any(*functionId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (switchId) {
      res["SwitchId"] = boost::any(*switchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionId") != m.end() && !m["FunctionId"].empty()) {
      functionId = make_shared<string>(boost::any_cast<string>(m["FunctionId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SwitchId") != m.end() && !m["SwitchId"].empty()) {
      switchId = make_shared<string>(boost::any_cast<string>(m["SwitchId"]));
    }
  }


  virtual ~PlayerAuthResponseBodySwitchListSwitch() = default;
};
class PlayerAuthResponseBodySwitchList : public Darabonba::Model {
public:
  shared_ptr<vector<PlayerAuthResponseBodySwitchListSwitch>> switch_{};

  PlayerAuthResponseBodySwitchList() {}

  explicit PlayerAuthResponseBodySwitchList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (switch_) {
      vector<boost::any> temp1;
      for(auto item1:*switch_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Switch"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Switch") != m.end() && !m["Switch"].empty()) {
      if (typeid(vector<boost::any>) == m["Switch"].type()) {
        vector<PlayerAuthResponseBodySwitchListSwitch> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Switch"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PlayerAuthResponseBodySwitchListSwitch model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        switch_ = make_shared<vector<PlayerAuthResponseBodySwitchListSwitch>>(expect1);
      }
    }
  }


  virtual ~PlayerAuthResponseBodySwitchList() = default;
};
class PlayerAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> logURL{};
  shared_ptr<PlayerAuthResponseBodySwitchList> switchList{};

  PlayerAuthResponseBody() {}

  explicit PlayerAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (logURL) {
      res["LogURL"] = boost::any(*logURL);
    }
    if (switchList) {
      res["SwitchList"] = switchList ? boost::any(switchList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LogURL") != m.end() && !m["LogURL"].empty()) {
      logURL = make_shared<string>(boost::any_cast<string>(m["LogURL"]));
    }
    if (m.find("SwitchList") != m.end() && !m["SwitchList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SwitchList"].type()) {
        PlayerAuthResponseBodySwitchList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SwitchList"]));
        switchList = make_shared<PlayerAuthResponseBodySwitchList>(model1);
      }
    }
  }


  virtual ~PlayerAuthResponseBody() = default;
};
class PlayerAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PlayerAuthResponseBody> body{};

  PlayerAuthResponse() {}

  explicit PlayerAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PlayerAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PlayerAuthResponseBody>(model1);
      }
    }
  }


  virtual ~PlayerAuthResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  QueryAuthConfigResponse queryAuthConfigWithOptions(shared_ptr<QueryAuthConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAuthConfigResponse queryAuthConfig(shared_ptr<QueryAuthConfigRequest> request);
  QueryAsrPipelineListResponse queryAsrPipelineListWithOptions(shared_ptr<QueryAsrPipelineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAsrPipelineListResponse queryAsrPipelineList(shared_ptr<QueryAsrPipelineListRequest> request);
  SubmitMediaCensorJobResponse submitMediaCensorJobWithOptions(shared_ptr<SubmitMediaCensorJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaCensorJobResponse submitMediaCensorJob(shared_ptr<SubmitMediaCensorJobRequest> request);
  CreateSessionResponse createSessionWithOptions(shared_ptr<CreateSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSessionResponse createSession(shared_ptr<CreateSessionRequest> request);
  ListAsrPipelineResponse listAsrPipelineWithOptions(shared_ptr<ListAsrPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAsrPipelineResponse listAsrPipeline(shared_ptr<ListAsrPipelineRequest> request);
  ListJobResponse listJobWithOptions(shared_ptr<ListJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobResponse listJob(shared_ptr<ListJobRequest> request);
  QueryIProductionJobListResponse queryIProductionJobListWithOptions(shared_ptr<QueryIProductionJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIProductionJobListResponse queryIProductionJobList(shared_ptr<QueryIProductionJobListRequest> request);
  UpdateMediaPublishStateResponse updateMediaPublishStateWithOptions(shared_ptr<UpdateMediaPublishStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaPublishStateResponse updateMediaPublishState(shared_ptr<UpdateMediaPublishStateRequest> request);
  SubmitFpFileDeleteJobResponse submitFpFileDeleteJobWithOptions(shared_ptr<SubmitFpFileDeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFpFileDeleteJobResponse submitFpFileDeleteJob(shared_ptr<SubmitFpFileDeleteJobRequest> request);
  QueryAnalysisJobListResponse queryAnalysisJobListWithOptions(shared_ptr<QueryAnalysisJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAnalysisJobListResponse queryAnalysisJobList(shared_ptr<QueryAnalysisJobListRequest> request);
  SubmitInferenceJobResponse submitInferenceJobWithOptions(shared_ptr<SubmitInferenceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitInferenceJobResponse submitInferenceJob(shared_ptr<SubmitInferenceJobRequest> request);
  ReportCensorJobResultResponse reportCensorJobResultWithOptions(shared_ptr<ReportCensorJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportCensorJobResultResponse reportCensorJobResult(shared_ptr<ReportCensorJobResultRequest> request);
  DeleteMcuJobResponse deleteMcuJobWithOptions(shared_ptr<DeleteMcuJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcuJobResponse deleteMcuJob(shared_ptr<DeleteMcuJobRequest> request);
  QueryInferenceServerResponse queryInferenceServerWithOptions(shared_ptr<QueryInferenceServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryInferenceServerResponse queryInferenceServer(shared_ptr<QueryInferenceServerRequest> request);
  CheckResourceResponse checkResourceWithOptions(shared_ptr<CheckResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckResourceResponse checkResource(shared_ptr<CheckResourceRequest> request);
  ListTerrorismPipelineResponse listTerrorismPipelineWithOptions(shared_ptr<ListTerrorismPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTerrorismPipelineResponse listTerrorismPipeline(shared_ptr<ListTerrorismPipelineRequest> request);
  ReportTerrorismJobResultResponse reportTerrorismJobResultWithOptions(shared_ptr<ReportTerrorismJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportTerrorismJobResultResponse reportTerrorismJobResult(shared_ptr<ReportTerrorismJobResultRequest> request);
  ListAllMediaBucketResponse listAllMediaBucketWithOptions(shared_ptr<ListAllMediaBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllMediaBucketResponse listAllMediaBucket(shared_ptr<ListAllMediaBucketRequest> request);
  SearchPipelineResponse searchPipelineWithOptions(shared_ptr<SearchPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchPipelineResponse searchPipeline(shared_ptr<SearchPipelineRequest> request);
  UnbindOutputBucketResponse unbindOutputBucketWithOptions(shared_ptr<UnbindOutputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindOutputBucketResponse unbindOutputBucket(shared_ptr<UnbindOutputBucketRequest> request);
  UpdateMediaCategoryResponse updateMediaCategoryWithOptions(shared_ptr<UpdateMediaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaCategoryResponse updateMediaCategory(shared_ptr<UpdateMediaCategoryRequest> request);
  QueryComplexJobListResponse queryComplexJobListWithOptions(shared_ptr<QueryComplexJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryComplexJobListResponse queryComplexJobList(shared_ptr<QueryComplexJobListRequest> request);
  ListInferenceJobResponse listInferenceJobWithOptions(shared_ptr<ListInferenceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInferenceJobResponse listInferenceJob(shared_ptr<ListInferenceJobRequest> request);
  QueryJobListResponse queryJobListWithOptions(shared_ptr<QueryJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobListResponse queryJobList(shared_ptr<QueryJobListRequest> request);
  SearchMediaWorkflowResponse searchMediaWorkflowWithOptions(shared_ptr<SearchMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaWorkflowResponse searchMediaWorkflow(shared_ptr<SearchMediaWorkflowRequest> request);
  QueryCoverPipelineListResponse queryCoverPipelineListWithOptions(shared_ptr<QueryCoverPipelineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCoverPipelineListResponse queryCoverPipelineList(shared_ptr<QueryCoverPipelineListRequest> request);
  QueryFpShotJobListResponse queryFpShotJobListWithOptions(shared_ptr<QueryFpShotJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFpShotJobListResponse queryFpShotJobList(shared_ptr<QueryFpShotJobListRequest> request);
  DeleteMediaTagResponse deleteMediaTagWithOptions(shared_ptr<DeleteMediaTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaTagResponse deleteMediaTag(shared_ptr<DeleteMediaTagRequest> request);
  DeletePipelineResponse deletePipelineWithOptions(shared_ptr<DeletePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelineResponse deletePipeline(shared_ptr<DeletePipelineRequest> request);
  UpdateSmarttagTemplateResponse updateSmarttagTemplateWithOptions(shared_ptr<UpdateSmarttagTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSmarttagTemplateResponse updateSmarttagTemplate(shared_ptr<UpdateSmarttagTemplateRequest> request);
  UpdateAsrPipelineResponse updateAsrPipelineWithOptions(shared_ptr<UpdateAsrPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAsrPipelineResponse updateAsrPipeline(shared_ptr<UpdateAsrPipelineRequest> request);
  QueryVideoQualityJobResponse queryVideoQualityJobWithOptions(shared_ptr<QueryVideoQualityJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryVideoQualityJobResponse queryVideoQualityJob(shared_ptr<QueryVideoQualityJobRequest> request);
  DecryptKeyResponse decryptKeyWithOptions(shared_ptr<DecryptKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DecryptKeyResponse decryptKey(shared_ptr<DecryptKeyRequest> request);
  DeleteTemplateResponse deleteTemplateWithOptions(shared_ptr<DeleteTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTemplateResponse deleteTemplate(shared_ptr<DeleteTemplateRequest> request);
  QueryTemplateListResponse queryTemplateListWithOptions(shared_ptr<QueryTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTemplateListResponse queryTemplateList(shared_ptr<QueryTemplateListRequest> request);
  ReportFacerecogJobResultResponse reportFacerecogJobResultWithOptions(shared_ptr<ReportFacerecogJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportFacerecogJobResultResponse reportFacerecogJobResult(shared_ptr<ReportFacerecogJobResultRequest> request);
  QueryMCTemplateListResponse queryMCTemplateListWithOptions(shared_ptr<QueryMCTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMCTemplateListResponse queryMCTemplateList(shared_ptr<QueryMCTemplateListRequest> request);
  UpdateMediaResponse updateMediaWithOptions(shared_ptr<UpdateMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaResponse updateMedia(shared_ptr<UpdateMediaRequest> request);
  ListCensorPipelineResponse listCensorPipelineWithOptions(shared_ptr<ListCensorPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCensorPipelineResponse listCensorPipeline(shared_ptr<ListCensorPipelineRequest> request);
  QuerySubtitleJobListResponse querySubtitleJobListWithOptions(shared_ptr<QuerySubtitleJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySubtitleJobListResponse querySubtitleJobList(shared_ptr<QuerySubtitleJobListRequest> request);
  QueryVideoGifJobListResponse queryVideoGifJobListWithOptions(shared_ptr<QueryVideoGifJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryVideoGifJobListResponse queryVideoGifJobList(shared_ptr<QueryVideoGifJobListRequest> request);
  QueryEditingJobListResponse queryEditingJobListWithOptions(shared_ptr<QueryEditingJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEditingJobListResponse queryEditingJobList(shared_ptr<QueryEditingJobListRequest> request);
  UpdateMCTemplateResponse updateMCTemplateWithOptions(shared_ptr<UpdateMCTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMCTemplateResponse updateMCTemplate(shared_ptr<UpdateMCTemplateRequest> request);
  ReportCoverJobResultResponse reportCoverJobResultWithOptions(shared_ptr<ReportCoverJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportCoverJobResultResponse reportCoverJobResult(shared_ptr<ReportCoverJobResultRequest> request);
  SubmitImageQualityJobResponse submitImageQualityJobWithOptions(shared_ptr<SubmitImageQualityJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitImageQualityJobResponse submitImageQualityJob(shared_ptr<SubmitImageQualityJobRequest> request);
  AddMCTemplateResponse addMCTemplateWithOptions(shared_ptr<AddMCTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMCTemplateResponse addMCTemplate(shared_ptr<AddMCTemplateRequest> request);
  SearchTemplateResponse searchTemplateWithOptions(shared_ptr<SearchTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTemplateResponse searchTemplate(shared_ptr<SearchTemplateRequest> request);
  UpdateMcuTemplateResponse updateMcuTemplateWithOptions(shared_ptr<UpdateMcuTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMcuTemplateResponse updateMcuTemplate(shared_ptr<UpdateMcuTemplateRequest> request);
  SubmitFacerecogJobResponse submitFacerecogJobWithOptions(shared_ptr<SubmitFacerecogJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFacerecogJobResponse submitFacerecogJob(shared_ptr<SubmitFacerecogJobRequest> request);
  SubmitEditingJobsResponse submitEditingJobsWithOptions(shared_ptr<SubmitEditingJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitEditingJobsResponse submitEditingJobs(shared_ptr<SubmitEditingJobsRequest> request);
  ReportVideoSplitJobResultResponse reportVideoSplitJobResultWithOptions(shared_ptr<ReportVideoSplitJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportVideoSplitJobResultResponse reportVideoSplitJobResult(shared_ptr<ReportVideoSplitJobResultRequest> request);
  QueryMediaCensorJobDetailResponse queryMediaCensorJobDetailWithOptions(shared_ptr<QueryMediaCensorJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaCensorJobDetailResponse queryMediaCensorJobDetail(shared_ptr<QueryMediaCensorJobDetailRequest> request);
  TagCustomPersonResponse tagCustomPersonWithOptions(shared_ptr<TagCustomPersonRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagCustomPersonResponse tagCustomPerson(shared_ptr<TagCustomPersonRequest> request);
  CreateMcuTemplateResponse createMcuTemplateWithOptions(shared_ptr<CreateMcuTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMcuTemplateResponse createMcuTemplate(shared_ptr<CreateMcuTemplateRequest> request);
  ListFpShotNotaryResponse listFpShotNotaryWithOptions(shared_ptr<ListFpShotNotaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFpShotNotaryResponse listFpShotNotary(shared_ptr<ListFpShotNotaryRequest> request);
  ReportFpShotJobResultResponse reportFpShotJobResultWithOptions(shared_ptr<ReportFpShotJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportFpShotJobResultResponse reportFpShotJobResult(shared_ptr<ReportFpShotJobResultRequest> request);
  SubmitVideoGifJobResponse submitVideoGifJobWithOptions(shared_ptr<SubmitVideoGifJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitVideoGifJobResponse submitVideoGifJob(shared_ptr<SubmitVideoGifJobRequest> request);
  QueryAnnotationJobListResponse queryAnnotationJobListWithOptions(shared_ptr<QueryAnnotationJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAnnotationJobListResponse queryAnnotationJobList(shared_ptr<QueryAnnotationJobListRequest> request);
  SubmitPornJobResponse submitPornJobWithOptions(shared_ptr<SubmitPornJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitPornJobResponse submitPornJob(shared_ptr<SubmitPornJobRequest> request);
  DescribeMtsUserResourcePackageResponse describeMtsUserResourcePackageWithOptions(shared_ptr<DescribeMtsUserResourcePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMtsUserResourcePackageResponse describeMtsUserResourcePackage(shared_ptr<DescribeMtsUserResourcePackageRequest> request);
  AddTemplateResponse addTemplateWithOptions(shared_ptr<AddTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTemplateResponse addTemplate(shared_ptr<AddTemplateRequest> request);
  SubmitMCJobResponse submitMCJobWithOptions(shared_ptr<SubmitMCJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMCJobResponse submitMCJob(shared_ptr<SubmitMCJobRequest> request);
  ReportPornJobResultResponse reportPornJobResultWithOptions(shared_ptr<ReportPornJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportPornJobResultResponse reportPornJobResult(shared_ptr<ReportPornJobResultRequest> request);
  UpdateMediaWorkflowResponse updateMediaWorkflowWithOptions(shared_ptr<UpdateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaWorkflowResponse updateMediaWorkflow(shared_ptr<UpdateMediaWorkflowRequest> request);
  DeleteSmarttagTemplateResponse deleteSmarttagTemplateWithOptions(shared_ptr<DeleteSmarttagTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSmarttagTemplateResponse deleteSmarttagTemplate(shared_ptr<DeleteSmarttagTemplateRequest> request);
  QueryMediaWorkflowListResponse queryMediaWorkflowListWithOptions(shared_ptr<QueryMediaWorkflowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaWorkflowListResponse queryMediaWorkflowList(shared_ptr<QueryMediaWorkflowListRequest> request);
  SubmitIProductionJobResponse submitIProductionJobWithOptions(shared_ptr<SubmitIProductionJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitIProductionJobResponse submitIProductionJob(shared_ptr<SubmitIProductionJobRequest> request);
  GetLicenseResponse getLicenseWithOptions(shared_ptr<GetLicenseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLicenseResponse getLicense(shared_ptr<GetLicenseRequest> request);
  QueryVideoSummaryJobListResponse queryVideoSummaryJobListWithOptions(shared_ptr<QueryVideoSummaryJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryVideoSummaryJobListResponse queryVideoSummaryJobList(shared_ptr<QueryVideoSummaryJobListRequest> request);
  SubmitSmarttagJobResponse submitSmarttagJobWithOptions(shared_ptr<SubmitSmarttagJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSmarttagJobResponse submitSmarttagJob(shared_ptr<SubmitSmarttagJobRequest> request);
  QuerySmarttagJobResponse querySmarttagJobWithOptions(shared_ptr<QuerySmarttagJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmarttagJobResponse querySmarttagJob(shared_ptr<QuerySmarttagJobRequest> request);
  UpdateMediaCoverResponse updateMediaCoverWithOptions(shared_ptr<UpdateMediaCoverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaCoverResponse updateMediaCover(shared_ptr<UpdateMediaCoverRequest> request);
  QueryIProductionJobResponse queryIProductionJobWithOptions(shared_ptr<QueryIProductionJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIProductionJobResponse queryIProductionJob(shared_ptr<QueryIProductionJobRequest> request);
  ListMediaResponse listMediaWithOptions(shared_ptr<ListMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaResponse listMedia(shared_ptr<ListMediaRequest> request);
  GetPackageResponse getPackageWithOptions(shared_ptr<GetPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPackageResponse getPackage(shared_ptr<GetPackageRequest> request);
  UpdateWaterMarkTemplateResponse updateWaterMarkTemplateWithOptions(shared_ptr<UpdateWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWaterMarkTemplateResponse updateWaterMarkTemplate(shared_ptr<UpdateWaterMarkTemplateRequest> request);
  QueryMcuTemplateResponse queryMcuTemplateWithOptions(shared_ptr<QueryMcuTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMcuTemplateResponse queryMcuTemplate(shared_ptr<QueryMcuTemplateRequest> request);
  ActivateMediaWorkflowResponse activateMediaWorkflowWithOptions(shared_ptr<ActivateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActivateMediaWorkflowResponse activateMediaWorkflow(shared_ptr<ActivateMediaWorkflowRequest> request);
  SearchMediaResponse searchMediaWithOptions(shared_ptr<SearchMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaResponse searchMedia(shared_ptr<SearchMediaRequest> request);
  SubmitTerrorismJobResponse submitTerrorismJobWithOptions(shared_ptr<SubmitTerrorismJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTerrorismJobResponse submitTerrorismJob(shared_ptr<SubmitTerrorismJobRequest> request);
  AddCategoryResponse addCategoryWithOptions(shared_ptr<AddCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCategoryResponse addCategory(shared_ptr<AddCategoryRequest> request);
  QueryInnerJobResponse queryInnerJobWithOptions(shared_ptr<QueryInnerJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryInnerJobResponse queryInnerJob(shared_ptr<QueryInnerJobRequest> request);
  ListFpShotFilesResponse listFpShotFilesWithOptions(shared_ptr<ListFpShotFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFpShotFilesResponse listFpShotFiles(shared_ptr<ListFpShotFilesRequest> request);
  QueryTerrorismPipelineListResponse queryTerrorismPipelineListWithOptions(shared_ptr<QueryTerrorismPipelineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTerrorismPipelineListResponse queryTerrorismPipelineList(shared_ptr<QueryTerrorismPipelineListRequest> request);
  AddMediaResponse addMediaWithOptions(shared_ptr<AddMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaResponse addMedia(shared_ptr<AddMediaRequest> request);
  StopIProductionJobResponse stopIProductionJobWithOptions(shared_ptr<StopIProductionJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopIProductionJobResponse stopIProductionJob(shared_ptr<StopIProductionJobRequest> request);
  DeleteMcuTemplateResponse deleteMcuTemplateWithOptions(shared_ptr<DeleteMcuTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMcuTemplateResponse deleteMcuTemplate(shared_ptr<DeleteMcuTemplateRequest> request);
  QueryMediaCensorJobListResponse queryMediaCensorJobListWithOptions(shared_ptr<QueryMediaCensorJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaCensorJobListResponse queryMediaCensorJobList(shared_ptr<QueryMediaCensorJobListRequest> request);
  ListPornPipelineResponse listPornPipelineWithOptions(shared_ptr<ListPornPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPornPipelineResponse listPornPipeline(shared_ptr<ListPornPipelineRequest> request);
  AddTerrorismPipelineResponse addTerrorismPipelineWithOptions(shared_ptr<AddTerrorismPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTerrorismPipelineResponse addTerrorismPipeline(shared_ptr<AddTerrorismPipelineRequest> request);
  CreateFpShotDBResponse createFpShotDBWithOptions(shared_ptr<CreateFpShotDBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFpShotDBResponse createFpShotDB(shared_ptr<CreateFpShotDBRequest> request);
  UnregisterCustomFaceResponse unregisterCustomFaceWithOptions(shared_ptr<UnregisterCustomFaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnregisterCustomFaceResponse unregisterCustomFace(shared_ptr<UnregisterCustomFaceRequest> request);
  QuerySmarttagTemplateListResponse querySmarttagTemplateListWithOptions(shared_ptr<QuerySmarttagTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmarttagTemplateListResponse querySmarttagTemplateList(shared_ptr<QuerySmarttagTemplateListRequest> request);
  SubmitFpShotJobResponse submitFpShotJobWithOptions(shared_ptr<SubmitFpShotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFpShotJobResponse submitFpShotJob(shared_ptr<SubmitFpShotJobRequest> request);
  QueryCensorPipelineListResponse queryCensorPipelineListWithOptions(shared_ptr<QueryCensorPipelineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCensorPipelineListResponse queryCensorPipelineList(shared_ptr<QueryCensorPipelineListRequest> request);
  SubmitMcuJobResponse submitMcuJobWithOptions(shared_ptr<SubmitMcuJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMcuJobResponse submitMcuJob(shared_ptr<SubmitMcuJobRequest> request);
  CategoryTreeResponse categoryTreeWithOptions(shared_ptr<CategoryTreeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CategoryTreeResponse categoryTree(shared_ptr<CategoryTreeRequest> request);
  SubmitTagJobResponse submitTagJobWithOptions(shared_ptr<SubmitTagJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTagJobResponse submitTagJob(shared_ptr<SubmitTagJobRequest> request);
  SubmitCoverJobResponse submitCoverJobWithOptions(shared_ptr<SubmitCoverJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCoverJobResponse submitCoverJob(shared_ptr<SubmitCoverJobRequest> request);
  AddCensorPipelineResponse addCensorPipelineWithOptions(shared_ptr<AddCensorPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCensorPipelineResponse addCensorPipeline(shared_ptr<AddCensorPipelineRequest> request);
  SearchWaterMarkTemplateResponse searchWaterMarkTemplateWithOptions(shared_ptr<SearchWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchWaterMarkTemplateResponse searchWaterMarkTemplate(shared_ptr<SearchWaterMarkTemplateRequest> request);
  SubmitAsrJobResponse submitAsrJobWithOptions(shared_ptr<SubmitAsrJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAsrJobResponse submitAsrJob(shared_ptr<SubmitAsrJobRequest> request);
  AddMediaWorkflowResponse addMediaWorkflowWithOptions(shared_ptr<AddMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaWorkflowResponse addMediaWorkflow(shared_ptr<AddMediaWorkflowRequest> request);
  QueryAsrJobListResponse queryAsrJobListWithOptions(shared_ptr<QueryAsrJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAsrJobListResponse queryAsrJobList(shared_ptr<QueryAsrJobListRequest> request);
  SubmitVideoPoseJobResponse submitVideoPoseJobWithOptions(shared_ptr<SubmitVideoPoseJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitVideoPoseJobResponse submitVideoPoseJob(shared_ptr<SubmitVideoPoseJobRequest> request);
  RegisterMediaDetailPersonResponse registerMediaDetailPersonWithOptions(shared_ptr<RegisterMediaDetailPersonRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterMediaDetailPersonResponse registerMediaDetailPerson(shared_ptr<RegisterMediaDetailPersonRequest> request);
  QueryCensorJobListResponse queryCensorJobListWithOptions(shared_ptr<QueryCensorJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCensorJobListResponse queryCensorJobList(shared_ptr<QueryCensorJobListRequest> request);
  SubmitFpCompareJobResponse submitFpCompareJobWithOptions(shared_ptr<SubmitFpCompareJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFpCompareJobResponse submitFpCompareJob(shared_ptr<SubmitFpCompareJobRequest> request);
  DeleteCategoryResponse deleteCategoryWithOptions(shared_ptr<DeleteCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCategoryResponse deleteCategory(shared_ptr<DeleteCategoryRequest> request);
  QuerySnapshotJobListResponse querySnapshotJobListWithOptions(shared_ptr<QuerySnapshotJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySnapshotJobListResponse querySnapshotJobList(shared_ptr<QuerySnapshotJobListRequest> request);
  DetectImageSyncResponse detectImageSyncWithOptions(shared_ptr<DetectImageSyncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageSyncResponse detectImageSync(shared_ptr<DetectImageSyncRequest> request);
  QueryTagJobListResponse queryTagJobListWithOptions(shared_ptr<QueryTagJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTagJobListResponse queryTagJobList(shared_ptr<QueryTagJobListRequest> request);
  SubmitFpDBDeleteJobResponse submitFpDBDeleteJobWithOptions(shared_ptr<SubmitFpDBDeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFpDBDeleteJobResponse submitFpDBDeleteJob(shared_ptr<SubmitFpDBDeleteJobRequest> request);
  GetJobInfoResponse getJobInfoWithOptions(shared_ptr<GetJobInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobInfoResponse getJobInfo(shared_ptr<GetJobInfoRequest> request);
  AddMediaTagResponse addMediaTagWithOptions(shared_ptr<AddMediaTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaTagResponse addMediaTag(shared_ptr<AddMediaTagRequest> request);
  UnbindInputBucketResponse unbindInputBucketWithOptions(shared_ptr<UnbindInputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindInputBucketResponse unbindInputBucket(shared_ptr<UnbindInputBucketRequest> request);
  QueryMediaWorkflowExecutionListResponse queryMediaWorkflowExecutionListWithOptions(shared_ptr<QueryMediaWorkflowExecutionListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaWorkflowExecutionListResponse queryMediaWorkflowExecutionList(shared_ptr<QueryMediaWorkflowExecutionListRequest> request);
  SubmitComplexJobResponse submitComplexJobWithOptions(shared_ptr<SubmitComplexJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitComplexJobResponse submitComplexJob(shared_ptr<SubmitComplexJobRequest> request);
  AddAsrPipelineResponse addAsrPipelineWithOptions(shared_ptr<AddAsrPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAsrPipelineResponse addAsrPipeline(shared_ptr<AddAsrPipelineRequest> request);
  CancelJobResponse cancelJobWithOptions(shared_ptr<CancelJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelJobResponse cancelJob(shared_ptr<CancelJobRequest> request);
  ListAllCategoryResponse listAllCategoryWithOptions(shared_ptr<ListAllCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllCategoryResponse listAllCategory(shared_ptr<ListAllCategoryRequest> request);
  ListFpShotDBResponse listFpShotDBWithOptions(shared_ptr<ListFpShotDBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFpShotDBResponse listFpShotDB(shared_ptr<ListFpShotDBRequest> request);
  AddSmarttagTemplateResponse addSmarttagTemplateWithOptions(shared_ptr<AddSmarttagTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSmarttagTemplateResponse addSmarttagTemplate(shared_ptr<AddSmarttagTemplateRequest> request);
  LogicalDeleteResourceResponse logicalDeleteResourceWithOptions(shared_ptr<LogicalDeleteResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LogicalDeleteResourceResponse logicalDeleteResource(shared_ptr<LogicalDeleteResourceRequest> request);
  ListMediaWorkflowExecutionsResponse listMediaWorkflowExecutionsWithOptions(shared_ptr<ListMediaWorkflowExecutionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaWorkflowExecutionsResponse listMediaWorkflowExecutions(shared_ptr<ListMediaWorkflowExecutionsRequest> request);
  SubmitInnerJobResponse submitInnerJobWithOptions(shared_ptr<SubmitInnerJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitInnerJobResponse submitInnerJob(shared_ptr<SubmitInnerJobRequest> request);
  QueryMediaDetailJobListResponse queryMediaDetailJobListWithOptions(shared_ptr<QueryMediaDetailJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaDetailJobListResponse queryMediaDetailJobList(shared_ptr<QueryMediaDetailJobListRequest> request);
  UpdatePornPipelineResponse updatePornPipelineWithOptions(shared_ptr<UpdatePornPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePornPipelineResponse updatePornPipeline(shared_ptr<UpdatePornPipelineRequest> request);
  DeleteWaterMarkTemplateResponse deleteWaterMarkTemplateWithOptions(shared_ptr<DeleteWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWaterMarkTemplateResponse deleteWaterMarkTemplate(shared_ptr<DeleteWaterMarkTemplateRequest> request);
  SubmitVideoQualityJobResponse submitVideoQualityJobWithOptions(shared_ptr<SubmitVideoQualityJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitVideoQualityJobResponse submitVideoQualityJob(shared_ptr<SubmitVideoQualityJobRequest> request);
  AddCoverPipelineResponse addCoverPipelineWithOptions(shared_ptr<AddCoverPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCoverPipelineResponse addCoverPipeline(shared_ptr<AddCoverPipelineRequest> request);
  SubmitURLUploadJobResponse submitURLUploadJobWithOptions(shared_ptr<SubmitURLUploadJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitURLUploadJobResponse submitURLUploadJob(shared_ptr<SubmitURLUploadJobRequest> request);
  QueryMediaListByURLResponse queryMediaListByURLWithOptions(shared_ptr<QueryMediaListByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaListByURLResponse queryMediaListByURL(shared_ptr<QueryMediaListByURLRequest> request);
  SubmitMediaFpDeleteJobResponse submitMediaFpDeleteJobWithOptions(shared_ptr<SubmitMediaFpDeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaFpDeleteJobResponse submitMediaFpDeleteJob(shared_ptr<SubmitMediaFpDeleteJobRequest> request);
  DeactivateMediaWorkflowResponse deactivateMediaWorkflowWithOptions(shared_ptr<DeactivateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactivateMediaWorkflowResponse deactivateMediaWorkflow(shared_ptr<DeactivateMediaWorkflowRequest> request);
  PhysicalDeleteResourceResponse physicalDeleteResourceWithOptions(shared_ptr<PhysicalDeleteResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PhysicalDeleteResourceResponse physicalDeleteResource(shared_ptr<PhysicalDeleteResourceRequest> request);
  DeleteMCTemplateResponse deleteMCTemplateWithOptions(shared_ptr<DeleteMCTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMCTemplateResponse deleteMCTemplate(shared_ptr<DeleteMCTemplateRequest> request);
  UpdatePipelineResponse updatePipelineWithOptions(shared_ptr<UpdatePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineResponse updatePipeline(shared_ptr<UpdatePipelineRequest> request);
  DeleteMediaResponse deleteMediaWithOptions(shared_ptr<DeleteMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaResponse deleteMedia(shared_ptr<DeleteMediaRequest> request);
  QueryFpCompareJobListResponse queryFpCompareJobListWithOptions(shared_ptr<QueryFpCompareJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFpCompareJobListResponse queryFpCompareJobList(shared_ptr<QueryFpCompareJobListRequest> request);
  BindOutputBucketResponse bindOutputBucketWithOptions(shared_ptr<BindOutputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindOutputBucketResponse bindOutputBucket(shared_ptr<BindOutputBucketRequest> request);
  AddPipelineResponse addPipelineWithOptions(shared_ptr<AddPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPipelineResponse addPipeline(shared_ptr<AddPipelineRequest> request);
  QueryMCJobListResponse queryMCJobListWithOptions(shared_ptr<QueryMCJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMCJobListResponse queryMCJobList(shared_ptr<QueryMCJobListRequest> request);
  QueryMediaListResponse queryMediaListWithOptions(shared_ptr<QueryMediaListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaListResponse queryMediaList(shared_ptr<QueryMediaListRequest> request);
  QueryFpDBDeleteJobListResponse queryFpDBDeleteJobListWithOptions(shared_ptr<QueryFpDBDeleteJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFpDBDeleteJobListResponse queryFpDBDeleteJobList(shared_ptr<QueryFpDBDeleteJobListRequest> request);
  RegisterCustomFaceResponse registerCustomFaceWithOptions(shared_ptr<RegisterCustomFaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterCustomFaceResponse registerCustomFace(shared_ptr<RegisterCustomFaceRequest> request);
  SubmitMediaInfoJobResponse submitMediaInfoJobWithOptions(shared_ptr<SubmitMediaInfoJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaInfoJobResponse submitMediaInfoJob(shared_ptr<SubmitMediaInfoJobRequest> request);
  QueryPornJobListResponse queryPornJobListWithOptions(shared_ptr<QueryPornJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPornJobListResponse queryPornJobList(shared_ptr<QueryPornJobListRequest> request);
  UpdateCategoryNameResponse updateCategoryNameWithOptions(shared_ptr<UpdateCategoryNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCategoryNameResponse updateCategoryName(shared_ptr<UpdateCategoryNameRequest> request);
  DeleteMediaWorkflowResponse deleteMediaWorkflowWithOptions(shared_ptr<DeleteMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaWorkflowResponse deleteMediaWorkflow(shared_ptr<DeleteMediaWorkflowRequest> request);
  QueryMcuJobResponse queryMcuJobWithOptions(shared_ptr<QueryMcuJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMcuJobResponse queryMcuJob(shared_ptr<QueryMcuJobRequest> request);
  ListCoverPipelineResponse listCoverPipelineWithOptions(shared_ptr<ListCoverPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCoverPipelineResponse listCoverPipeline(shared_ptr<ListCoverPipelineRequest> request);
  SubmitBeautifyJobsResponse submitBeautifyJobsWithOptions(shared_ptr<SubmitBeautifyJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitBeautifyJobsResponse submitBeautifyJobs(shared_ptr<SubmitBeautifyJobsRequest> request);
  QueryImageSearchJobListResponse queryImageSearchJobListWithOptions(shared_ptr<QueryImageSearchJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryImageSearchJobListResponse queryImageSearchJobList(shared_ptr<QueryImageSearchJobListRequest> request);
  SubmitVideoSummaryJobResponse submitVideoSummaryJobWithOptions(shared_ptr<SubmitVideoSummaryJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitVideoSummaryJobResponse submitVideoSummaryJob(shared_ptr<SubmitVideoSummaryJobRequest> request);
  SubmitMediaDetailJobResponse submitMediaDetailJobWithOptions(shared_ptr<SubmitMediaDetailJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaDetailJobResponse submitMediaDetailJob(shared_ptr<SubmitMediaDetailJobRequest> request);
  QueryFpImportResultResponse queryFpImportResultWithOptions(shared_ptr<QueryFpImportResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFpImportResultResponse queryFpImportResult(shared_ptr<QueryFpImportResultRequest> request);
  QueryWaterMarkTemplateListResponse queryWaterMarkTemplateListWithOptions(shared_ptr<QueryWaterMarkTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryWaterMarkTemplateListResponse queryWaterMarkTemplateList(shared_ptr<QueryWaterMarkTemplateListRequest> request);
  QueryMediaInfoJobListResponse queryMediaInfoJobListWithOptions(shared_ptr<QueryMediaInfoJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaInfoJobListResponse queryMediaInfoJobList(shared_ptr<QueryMediaInfoJobListRequest> request);
  QueryMediaFpDeleteJobListResponse queryMediaFpDeleteJobListWithOptions(shared_ptr<QueryMediaFpDeleteJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaFpDeleteJobListResponse queryMediaFpDeleteJobList(shared_ptr<QueryMediaFpDeleteJobListRequest> request);
  ReportTagJobResultResponse reportTagJobResultWithOptions(shared_ptr<ReportTagJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportTagJobResultResponse reportTagJobResult(shared_ptr<ReportTagJobResultRequest> request);
  AddPornPipelineResponse addPornPipelineWithOptions(shared_ptr<AddPornPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPornPipelineResponse addPornPipeline(shared_ptr<AddPornPipelineRequest> request);
  QueryPornPipelineListResponse queryPornPipelineListWithOptions(shared_ptr<QueryPornPipelineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPornPipelineListResponse queryPornPipelineList(shared_ptr<QueryPornPipelineListRequest> request);
  QueryTerrorismJobListResponse queryTerrorismJobListWithOptions(shared_ptr<QueryTerrorismJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTerrorismJobListResponse queryTerrorismJobList(shared_ptr<QueryTerrorismJobListRequest> request);
  SubmitJobsResponse submitJobsWithOptions(shared_ptr<SubmitJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitJobsResponse submitJobs(shared_ptr<SubmitJobsRequest> request);
  RefreshCdnDomainConfigsCacheResponse refreshCdnDomainConfigsCacheWithOptions(shared_ptr<RefreshCdnDomainConfigsCacheRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshCdnDomainConfigsCacheResponse refreshCdnDomainConfigsCache(shared_ptr<RefreshCdnDomainConfigsCacheRequest> request);
  QueryFpFileDeleteJobListResponse queryFpFileDeleteJobListWithOptions(shared_ptr<QueryFpFileDeleteJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFpFileDeleteJobListResponse queryFpFileDeleteJobList(shared_ptr<QueryFpFileDeleteJobListRequest> request);
  SubmitImageSearchJobResponse submitImageSearchJobWithOptions(shared_ptr<SubmitImageSearchJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitImageSearchJobResponse submitImageSearchJob(shared_ptr<SubmitImageSearchJobRequest> request);
  UpdateMediaWorkflowTriggerModeResponse updateMediaWorkflowTriggerModeWithOptions(shared_ptr<UpdateMediaWorkflowTriggerModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaWorkflowTriggerModeResponse updateMediaWorkflowTriggerMode(shared_ptr<UpdateMediaWorkflowTriggerModeRequest> request);
  SetAuthConfigResponse setAuthConfigWithOptions(shared_ptr<SetAuthConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetAuthConfigResponse setAuthConfig(shared_ptr<SetAuthConfigRequest> request);
  UpdateCensorPipelineResponse updateCensorPipelineWithOptions(shared_ptr<UpdateCensorPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCensorPipelineResponse updateCensorPipeline(shared_ptr<UpdateCensorPipelineRequest> request);
  SubmitSnapshotJobResponse submitSnapshotJobWithOptions(shared_ptr<SubmitSnapshotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSnapshotJobResponse submitSnapshotJob(shared_ptr<SubmitSnapshotJobRequest> request);
  ListCustomPersonsResponse listCustomPersonsWithOptions(shared_ptr<ListCustomPersonsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomPersonsResponse listCustomPersons(shared_ptr<ListCustomPersonsRequest> request);
  QueryFacerecogJobListResponse queryFacerecogJobListWithOptions(shared_ptr<QueryFacerecogJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFacerecogJobListResponse queryFacerecogJobList(shared_ptr<QueryFacerecogJobListRequest> request);
  CreateInferenceServerResponse createInferenceServerWithOptions(shared_ptr<CreateInferenceServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInferenceServerResponse createInferenceServer(shared_ptr<CreateInferenceServerRequest> request);
  ReportMediaDetailJobResultResponse reportMediaDetailJobResultWithOptions(shared_ptr<ReportMediaDetailJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportMediaDetailJobResultResponse reportMediaDetailJobResult(shared_ptr<ReportMediaDetailJobResultRequest> request);
  SubmitAnnotationJobResponse submitAnnotationJobWithOptions(shared_ptr<SubmitAnnotationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAnnotationJobResponse submitAnnotationJob(shared_ptr<SubmitAnnotationJobRequest> request);
  RegisterMediaDetailScenarioResponse registerMediaDetailScenarioWithOptions(shared_ptr<RegisterMediaDetailScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterMediaDetailScenarioResponse registerMediaDetailScenario(shared_ptr<RegisterMediaDetailScenarioRequest> request);
  QueryVideoSplitJobListResponse queryVideoSplitJobListWithOptions(shared_ptr<QueryVideoSplitJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryVideoSplitJobListResponse queryVideoSplitJobList(shared_ptr<QueryVideoSplitJobListRequest> request);
  ReportAnnotationJobResultResponse reportAnnotationJobResultWithOptions(shared_ptr<ReportAnnotationJobResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReportAnnotationJobResultResponse reportAnnotationJobResult(shared_ptr<ReportAnnotationJobResultRequest> request);
  BindInputBucketResponse bindInputBucketWithOptions(shared_ptr<BindInputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindInputBucketResponse bindInputBucket(shared_ptr<BindInputBucketRequest> request);
  QueryPipelineListResponse queryPipelineListWithOptions(shared_ptr<QueryPipelineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPipelineListResponse queryPipelineList(shared_ptr<QueryPipelineListRequest> request);
  UpdateTemplateResponse updateTemplateWithOptions(shared_ptr<UpdateTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTemplateResponse updateTemplate(shared_ptr<UpdateTemplateRequest> request);
  UpdateCoverPipelineResponse updateCoverPipelineWithOptions(shared_ptr<UpdateCoverPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCoverPipelineResponse updateCoverPipeline(shared_ptr<UpdateCoverPipelineRequest> request);
  UpdateTerrorismPipelineResponse updateTerrorismPipelineWithOptions(shared_ptr<UpdateTerrorismPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTerrorismPipelineResponse updateTerrorismPipeline(shared_ptr<UpdateTerrorismPipelineRequest> request);
  QueryInferenceJobResponse queryInferenceJobWithOptions(shared_ptr<QueryInferenceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryInferenceJobResponse queryInferenceJob(shared_ptr<QueryInferenceJobRequest> request);
  QueryVideoPoseJobListResponse queryVideoPoseJobListWithOptions(shared_ptr<QueryVideoPoseJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryVideoPoseJobListResponse queryVideoPoseJobList(shared_ptr<QueryVideoPoseJobListRequest> request);
  SubmitAnalysisJobResponse submitAnalysisJobWithOptions(shared_ptr<SubmitAnalysisJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAnalysisJobResponse submitAnalysisJob(shared_ptr<SubmitAnalysisJobRequest> request);
  SubmitVideoSplitJobResponse submitVideoSplitJobWithOptions(shared_ptr<SubmitVideoSplitJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitVideoSplitJobResponse submitVideoSplitJob(shared_ptr<SubmitVideoSplitJobRequest> request);
  PlayInfoResponse playInfoWithOptions(shared_ptr<PlayInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PlayInfoResponse playInfo(shared_ptr<PlayInfoRequest> request);
  SubmitSubtitleJobResponse submitSubtitleJobWithOptions(shared_ptr<SubmitSubtitleJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSubtitleJobResponse submitSubtitleJob(shared_ptr<SubmitSubtitleJobRequest> request);
  QueryCoverJobListResponse queryCoverJobListWithOptions(shared_ptr<QueryCoverJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCoverJobListResponse queryCoverJobList(shared_ptr<QueryCoverJobListRequest> request);
  AddWaterMarkTemplateResponse addWaterMarkTemplateWithOptions(shared_ptr<AddWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWaterMarkTemplateResponse addWaterMarkTemplate(shared_ptr<AddWaterMarkTemplateRequest> request);
  PlayerAuthResponse playerAuthWithOptions(shared_ptr<PlayerAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PlayerAuthResponse playerAuth(shared_ptr<PlayerAuthRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Mts20140618

#endif
