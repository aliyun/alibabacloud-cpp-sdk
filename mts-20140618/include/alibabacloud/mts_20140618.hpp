// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_MTS20140618_H_
#define ALIBABACLOUD_MTS20140618_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Mts20140618 {
class ActivateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ActivateMediaWorkflowRequest() {}

  explicit ActivateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ActivateMediaWorkflowRequest() = default;
};
class ActivateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};

  ActivateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit ActivateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~ActivateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class ActivateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<ActivateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  ActivateMediaWorkflowResponseBody() {}

  explicit ActivateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        ActivateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<ActivateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActivateMediaWorkflowResponseBody() = default;
};
class ActivateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActivateMediaWorkflowResponseBody> body{};

  ActivateMediaWorkflowResponse() {}

  explicit ActivateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateMediaWorkflowResponse() = default;
};
class AddMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> fileURL{};
  shared_ptr<bool> inputUnbind{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowUserData{};
  shared_ptr<string> overrideParams{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};

  AddMediaRequest() {}

  explicit AddMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (inputUnbind) {
      res["InputUnbind"] = boost::any(*inputUnbind);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowUserData) {
      res["MediaWorkflowUserData"] = boost::any(*mediaWorkflowUserData);
    }
    if (overrideParams) {
      res["OverrideParams"] = boost::any(*overrideParams);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("InputUnbind") != m.end() && !m["InputUnbind"].empty()) {
      inputUnbind = make_shared<bool>(boost::any_cast<bool>(m["InputUnbind"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowUserData") != m.end() && !m["MediaWorkflowUserData"].empty()) {
      mediaWorkflowUserData = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowUserData"]));
    }
    if (m.find("OverrideParams") != m.end() && !m["OverrideParams"].empty()) {
      overrideParams = make_shared<string>(boost::any_cast<string>(m["OverrideParams"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~AddMediaRequest() = default;
};
class AddMediaResponseBodyMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  AddMediaResponseBodyMediaFile() {}

  explicit AddMediaResponseBodyMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~AddMediaResponseBodyMediaFile() = default;
};
class AddMediaResponseBodyMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  AddMediaResponseBodyMediaRunIdList() {}

  explicit AddMediaResponseBodyMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddMediaResponseBodyMediaRunIdList() = default;
};
class AddMediaResponseBodyMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  AddMediaResponseBodyMediaTags() {}

  explicit AddMediaResponseBodyMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddMediaResponseBodyMediaTags() = default;
};
class AddMediaResponseBodyMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<AddMediaResponseBodyMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> publishState{};
  shared_ptr<AddMediaResponseBodyMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<AddMediaResponseBodyMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  AddMediaResponseBodyMedia() {}

  explicit AddMediaResponseBodyMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        AddMediaResponseBodyMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<AddMediaResponseBodyMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        AddMediaResponseBodyMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<AddMediaResponseBodyMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        AddMediaResponseBodyMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<AddMediaResponseBodyMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddMediaResponseBodyMedia() = default;
};
class AddMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddMediaResponseBodyMedia> media{};
  shared_ptr<string> requestId{};

  AddMediaResponseBody() {}

  explicit AddMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = media ? boost::any(media->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(map<string, boost::any>) == m["Media"].type()) {
        AddMediaResponseBodyMedia model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Media"]));
        media = make_shared<AddMediaResponseBodyMedia>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMediaResponseBody() = default;
};
class AddMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaResponseBody> body{};

  AddMediaResponse() {}

  explicit AddMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaResponse() = default;
};
class AddMediaTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tag{};

  AddMediaTagRequest() {}

  explicit AddMediaTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~AddMediaTagRequest() = default;
};
class AddMediaTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddMediaTagResponseBody() {}

  explicit AddMediaTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMediaTagResponseBody() = default;
};
class AddMediaTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaTagResponseBody> body{};

  AddMediaTagResponse() {}

  explicit AddMediaTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaTagResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaTagResponse() = default;
};
class AddMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  AddMediaWorkflowRequest() {}

  explicit AddMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~AddMediaWorkflowRequest() = default;
};
class AddMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  AddMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit AddMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~AddMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class AddMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  AddMediaWorkflowResponseBody() {}

  explicit AddMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        AddMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<AddMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMediaWorkflowResponseBody() = default;
};
class AddMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaWorkflowResponseBody> body{};

  AddMediaWorkflowResponse() {}

  explicit AddMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaWorkflowResponse() = default;
};
class AddPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};

  AddPipelineRequest() {}

  explicit AddPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
  }


  virtual ~AddPipelineRequest() = default;
};
class AddPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> mqTag{};
  shared_ptr<string> mqTopic{};
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  AddPipelineResponseBodyPipelineNotifyConfig() {}

  explicit AddPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mqTag) {
      res["MqTag"] = boost::any(*mqTag);
    }
    if (mqTopic) {
      res["MqTopic"] = boost::any(*mqTopic);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MqTag") != m.end() && !m["MqTag"].empty()) {
      mqTag = make_shared<string>(boost::any_cast<string>(m["MqTag"]));
    }
    if (m.find("MqTopic") != m.end() && !m["MqTopic"].empty()) {
      mqTopic = make_shared<string>(boost::any_cast<string>(m["MqTopic"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~AddPipelineResponseBodyPipelineNotifyConfig() = default;
};
class AddPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<AddPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> quotaAllocate{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};
  shared_ptr<string> state{};

  AddPipelineResponseBodyPipeline() {}

  explicit AddPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (quotaAllocate) {
      res["QuotaAllocate"] = boost::any(*quotaAllocate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        AddPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<AddPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("QuotaAllocate") != m.end() && !m["QuotaAllocate"].empty()) {
      quotaAllocate = make_shared<long>(boost::any_cast<long>(m["QuotaAllocate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~AddPipelineResponseBodyPipeline() = default;
};
class AddPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddPipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  AddPipelineResponseBody() {}

  explicit AddPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        AddPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<AddPipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPipelineResponseBody() = default;
};
class AddPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPipelineResponseBody> body{};

  AddPipelineResponse() {}

  explicit AddPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~AddPipelineResponse() = default;
};
class AddSmarttagTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> analyseTypes{};
  shared_ptr<string> faceCategoryIds{};
  shared_ptr<string> faceCustomParamsConfig{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> keywordConfig{};
  shared_ptr<string> knowledgeConfig{};
  shared_ptr<string> labelType{};
  shared_ptr<string> labelVersion{};
  shared_ptr<string> landmarkGroupIds{};
  shared_ptr<string> objectGroupIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scene{};
  shared_ptr<string> templateName{};

  AddSmarttagTemplateRequest() {}

  explicit AddSmarttagTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analyseTypes) {
      res["AnalyseTypes"] = boost::any(*analyseTypes);
    }
    if (faceCategoryIds) {
      res["FaceCategoryIds"] = boost::any(*faceCategoryIds);
    }
    if (faceCustomParamsConfig) {
      res["FaceCustomParamsConfig"] = boost::any(*faceCustomParamsConfig);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (keywordConfig) {
      res["KeywordConfig"] = boost::any(*keywordConfig);
    }
    if (knowledgeConfig) {
      res["KnowledgeConfig"] = boost::any(*knowledgeConfig);
    }
    if (labelType) {
      res["LabelType"] = boost::any(*labelType);
    }
    if (labelVersion) {
      res["LabelVersion"] = boost::any(*labelVersion);
    }
    if (landmarkGroupIds) {
      res["LandmarkGroupIds"] = boost::any(*landmarkGroupIds);
    }
    if (objectGroupIds) {
      res["ObjectGroupIds"] = boost::any(*objectGroupIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalyseTypes") != m.end() && !m["AnalyseTypes"].empty()) {
      analyseTypes = make_shared<string>(boost::any_cast<string>(m["AnalyseTypes"]));
    }
    if (m.find("FaceCategoryIds") != m.end() && !m["FaceCategoryIds"].empty()) {
      faceCategoryIds = make_shared<string>(boost::any_cast<string>(m["FaceCategoryIds"]));
    }
    if (m.find("FaceCustomParamsConfig") != m.end() && !m["FaceCustomParamsConfig"].empty()) {
      faceCustomParamsConfig = make_shared<string>(boost::any_cast<string>(m["FaceCustomParamsConfig"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("KeywordConfig") != m.end() && !m["KeywordConfig"].empty()) {
      keywordConfig = make_shared<string>(boost::any_cast<string>(m["KeywordConfig"]));
    }
    if (m.find("KnowledgeConfig") != m.end() && !m["KnowledgeConfig"].empty()) {
      knowledgeConfig = make_shared<string>(boost::any_cast<string>(m["KnowledgeConfig"]));
    }
    if (m.find("LabelType") != m.end() && !m["LabelType"].empty()) {
      labelType = make_shared<string>(boost::any_cast<string>(m["LabelType"]));
    }
    if (m.find("LabelVersion") != m.end() && !m["LabelVersion"].empty()) {
      labelVersion = make_shared<string>(boost::any_cast<string>(m["LabelVersion"]));
    }
    if (m.find("LandmarkGroupIds") != m.end() && !m["LandmarkGroupIds"].empty()) {
      landmarkGroupIds = make_shared<string>(boost::any_cast<string>(m["LandmarkGroupIds"]));
    }
    if (m.find("ObjectGroupIds") != m.end() && !m["ObjectGroupIds"].empty()) {
      objectGroupIds = make_shared<string>(boost::any_cast<string>(m["ObjectGroupIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~AddSmarttagTemplateRequest() = default;
};
class AddSmarttagTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  AddSmarttagTemplateResponseBody() {}

  explicit AddSmarttagTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~AddSmarttagTemplateResponseBody() = default;
};
class AddSmarttagTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSmarttagTemplateResponseBody> body{};

  AddSmarttagTemplateResponse() {}

  explicit AddSmarttagTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSmarttagTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSmarttagTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddSmarttagTemplateResponse() = default;
};
class AddTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> audio{};
  shared_ptr<string> container{};
  shared_ptr<string> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> transConfig{};
  shared_ptr<string> video{};

  AddTemplateRequest() {}

  explicit AddTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = boost::any(*audio);
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (muxConfig) {
      res["MuxConfig"] = boost::any(*muxConfig);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (transConfig) {
      res["TransConfig"] = boost::any(*transConfig);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      audio = make_shared<string>(boost::any_cast<string>(m["Audio"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      muxConfig = make_shared<string>(boost::any_cast<string>(m["MuxConfig"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      transConfig = make_shared<string>(boost::any_cast<string>(m["TransConfig"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
  }


  virtual ~AddTemplateRequest() = default;
};
class AddTemplateResponseBodyTemplateAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> level{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> peakLevel{};
  shared_ptr<string> truePeak{};

  AddTemplateResponseBodyTemplateAudioVolume() {}

  explicit AddTemplateResponseBodyTemplateAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (peakLevel) {
      res["PeakLevel"] = boost::any(*peakLevel);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("PeakLevel") != m.end() && !m["PeakLevel"].empty()) {
      peakLevel = make_shared<string>(boost::any_cast<string>(m["PeakLevel"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateAudioVolume() = default;
};
class AddTemplateResponseBodyTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<AddTemplateResponseBodyTemplateAudioVolume> volume{};

  AddTemplateResponseBodyTemplateAudio() {}

  explicit AddTemplateResponseBodyTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        AddTemplateResponseBodyTemplateAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<AddTemplateResponseBodyTemplateAudioVolume>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBodyTemplateAudio() = default;
};
class AddTemplateResponseBodyTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  AddTemplateResponseBodyTemplateContainer() {}

  explicit AddTemplateResponseBodyTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateContainer() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  AddTemplateResponseBodyTemplateMuxConfigGif() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigGif() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  AddTemplateResponseBodyTemplateMuxConfigSegment() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigSegment() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  AddTemplateResponseBodyTemplateMuxConfigWebp() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigWebp() = default;
};
class AddTemplateResponseBodyTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigGif> gif{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigSegment> segment{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigWebp> webp{};

  AddTemplateResponseBodyTemplateMuxConfig() {}

  explicit AddTemplateResponseBodyTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<AddTemplateResponseBodyTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<AddTemplateResponseBodyTemplateMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<AddTemplateResponseBodyTemplateMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfig() = default;
};
class AddTemplateResponseBodyTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  AddTemplateResponseBodyTemplateTransConfig() {}

  explicit AddTemplateResponseBodyTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateTransConfig() = default;
};
class AddTemplateResponseBodyTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  AddTemplateResponseBodyTemplateVideoBitrateBnd() {}

  explicit AddTemplateResponseBodyTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateVideoBitrateBnd() = default;
};
class AddTemplateResponseBodyTemplateVideoNarrowBand : public Darabonba::Model {
public:
  shared_ptr<double> abrmax{};
  shared_ptr<double> maxAbrRatio{};
  shared_ptr<string> version{};

  AddTemplateResponseBodyTemplateVideoNarrowBand() {}

  explicit AddTemplateResponseBodyTemplateVideoNarrowBand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrmax) {
      res["Abrmax"] = boost::any(*abrmax);
    }
    if (maxAbrRatio) {
      res["MaxAbrRatio"] = boost::any(*maxAbrRatio);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abrmax") != m.end() && !m["Abrmax"].empty()) {
      abrmax = make_shared<double>(boost::any_cast<double>(m["Abrmax"]));
    }
    if (m.find("MaxAbrRatio") != m.end() && !m["MaxAbrRatio"].empty()) {
      maxAbrRatio = make_shared<double>(boost::any_cast<double>(m["MaxAbrRatio"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateVideoNarrowBand() = default;
};
class AddTemplateResponseBodyTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<AddTemplateResponseBodyTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> hdr2sdr{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<AddTemplateResponseBodyTemplateVideoNarrowBand> narrowBand{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  AddTemplateResponseBodyTemplateVideo() {}

  explicit AddTemplateResponseBodyTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (hdr2sdr) {
      res["Hdr2sdr"] = boost::any(*hdr2sdr);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (narrowBand) {
      res["NarrowBand"] = narrowBand ? boost::any(narrowBand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        AddTemplateResponseBodyTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<AddTemplateResponseBodyTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Hdr2sdr") != m.end() && !m["Hdr2sdr"].empty()) {
      hdr2sdr = make_shared<string>(boost::any_cast<string>(m["Hdr2sdr"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("NarrowBand") != m.end() && !m["NarrowBand"].empty()) {
      if (typeid(map<string, boost::any>) == m["NarrowBand"].type()) {
        AddTemplateResponseBodyTemplateVideoNarrowBand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NarrowBand"]));
        narrowBand = make_shared<AddTemplateResponseBodyTemplateVideoNarrowBand>(model1);
      }
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateVideo() = default;
};
class AddTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<AddTemplateResponseBodyTemplateAudio> audio{};
  shared_ptr<AddTemplateResponseBodyTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<AddTemplateResponseBodyTemplateTransConfig> transConfig{};
  shared_ptr<AddTemplateResponseBodyTemplateVideo> video{};

  AddTemplateResponseBodyTemplate() {}

  explicit AddTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        AddTemplateResponseBodyTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<AddTemplateResponseBodyTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        AddTemplateResponseBodyTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<AddTemplateResponseBodyTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        AddTemplateResponseBodyTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<AddTemplateResponseBodyTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        AddTemplateResponseBodyTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<AddTemplateResponseBodyTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        AddTemplateResponseBodyTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<AddTemplateResponseBodyTemplateVideo>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBodyTemplate() = default;
};
class AddTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddTemplateResponseBodyTemplate> template_{};

  AddTemplateResponseBody() {}

  explicit AddTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        AddTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<AddTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBody() = default;
};
class AddTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTemplateResponseBody> body{};

  AddTemplateResponse() {}

  explicit AddTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddTemplateResponse() = default;
};
class AddWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddWaterMarkTemplateRequest() {}

  explicit AddWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddWaterMarkTemplateRequest() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> width{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> type{};
  shared_ptr<string> width{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplate() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplate() = default;
};
class AddWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplate> waterMarkTemplate{};

  AddWaterMarkTemplateResponseBody() {}

  explicit AddWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplate) {
      res["WaterMarkTemplate"] = waterMarkTemplate ? boost::any(waterMarkTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplate"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplate"]));
        waterMarkTemplate = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplate>(model1);
      }
    }
  }


  virtual ~AddWaterMarkTemplateResponseBody() = default;
};
class AddWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWaterMarkTemplateResponseBody> body{};

  AddWaterMarkTemplateResponse() {}

  explicit AddWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddWaterMarkTemplateResponse() = default;
};
class BindInputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> referer{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  BindInputBucketRequest() {}

  explicit BindInputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (referer) {
      res["Referer"] = boost::any(*referer);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Referer") != m.end() && !m["Referer"].empty()) {
      referer = make_shared<string>(boost::any_cast<string>(m["Referer"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~BindInputBucketRequest() = default;
};
class BindInputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindInputBucketResponseBody() {}

  explicit BindInputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindInputBucketResponseBody() = default;
};
class BindInputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindInputBucketResponseBody> body{};

  BindInputBucketResponse() {}

  explicit BindInputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindInputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindInputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~BindInputBucketResponse() = default;
};
class BindOutputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  BindOutputBucketRequest() {}

  explicit BindOutputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~BindOutputBucketRequest() = default;
};
class BindOutputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindOutputBucketResponseBody() {}

  explicit BindOutputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindOutputBucketResponseBody() = default;
};
class BindOutputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindOutputBucketResponseBody> body{};

  BindOutputBucketResponse() {}

  explicit BindOutputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindOutputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindOutputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~BindOutputBucketResponse() = default;
};
class CancelJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CancelJobRequest() {}

  explicit CancelJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CancelJobRequest() = default;
};
class CancelJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  CancelJobResponseBody() {}

  explicit CancelJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelJobResponseBody() = default;
};
class CancelJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelJobResponseBody> body{};

  CancelJobResponse() {}

  explicit CancelJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelJobResponse() = default;
};
class CreateCustomEntityRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> customEntityInfo{};
  shared_ptr<string> customEntityName{};
  shared_ptr<string> customGroupId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateCustomEntityRequest() {}

  explicit CreateCustomEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (customEntityInfo) {
      res["CustomEntityInfo"] = boost::any(*customEntityInfo);
    }
    if (customEntityName) {
      res["CustomEntityName"] = boost::any(*customEntityName);
    }
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("CustomEntityInfo") != m.end() && !m["CustomEntityInfo"].empty()) {
      customEntityInfo = make_shared<string>(boost::any_cast<string>(m["CustomEntityInfo"]));
    }
    if (m.find("CustomEntityName") != m.end() && !m["CustomEntityName"].empty()) {
      customEntityName = make_shared<string>(boost::any_cast<string>(m["CustomEntityName"]));
    }
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateCustomEntityRequest() = default;
};
class CreateCustomEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customEntityId{};
  shared_ptr<string> requestId{};

  CreateCustomEntityResponseBody() {}

  explicit CreateCustomEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customEntityId) {
      res["CustomEntityId"] = boost::any(*customEntityId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomEntityId") != m.end() && !m["CustomEntityId"].empty()) {
      customEntityId = make_shared<string>(boost::any_cast<string>(m["CustomEntityId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomEntityResponseBody() = default;
};
class CreateCustomEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomEntityResponseBody> body{};

  CreateCustomEntityResponse() {}

  explicit CreateCustomEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomEntityResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomEntityResponse() = default;
};
class CreateCustomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> customGroupDescription{};
  shared_ptr<string> customGroupName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateCustomGroupRequest() {}

  explicit CreateCustomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (customGroupDescription) {
      res["CustomGroupDescription"] = boost::any(*customGroupDescription);
    }
    if (customGroupName) {
      res["CustomGroupName"] = boost::any(*customGroupName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("CustomGroupDescription") != m.end() && !m["CustomGroupDescription"].empty()) {
      customGroupDescription = make_shared<string>(boost::any_cast<string>(m["CustomGroupDescription"]));
    }
    if (m.find("CustomGroupName") != m.end() && !m["CustomGroupName"].empty()) {
      customGroupName = make_shared<string>(boost::any_cast<string>(m["CustomGroupName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateCustomGroupRequest() = default;
};
class CreateCustomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customGroupId{};
  shared_ptr<string> requestId{};

  CreateCustomGroupResponseBody() {}

  explicit CreateCustomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomGroupResponseBody() = default;
};
class CreateCustomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomGroupResponseBody> body{};

  CreateCustomGroupResponse() {}

  explicit CreateCustomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomGroupResponse() = default;
};
class CreateFpShotDBRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> description{};
  shared_ptr<long> modelId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateFpShotDBRequest() {}

  explicit CreateFpShotDBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<long>(boost::any_cast<long>(m["ModelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateFpShotDBRequest() = default;
};
class CreateFpShotDBResponseBodyFpShotDB : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> description{};
  shared_ptr<string> fpDBId{};
  shared_ptr<long> modelId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};

  CreateFpShotDBResponseBodyFpShotDB() {}

  explicit CreateFpShotDBResponseBodyFpShotDB(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<long>(boost::any_cast<long>(m["ModelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~CreateFpShotDBResponseBodyFpShotDB() = default;
};
class CreateFpShotDBResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateFpShotDBResponseBodyFpShotDB> fpShotDB{};
  shared_ptr<string> requestId{};

  CreateFpShotDBResponseBody() {}

  explicit CreateFpShotDBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotDB) {
      res["FpShotDB"] = fpShotDB ? boost::any(fpShotDB->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotDB") != m.end() && !m["FpShotDB"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotDB"].type()) {
        CreateFpShotDBResponseBodyFpShotDB model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotDB"]));
        fpShotDB = make_shared<CreateFpShotDBResponseBodyFpShotDB>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFpShotDBResponseBody() = default;
};
class CreateFpShotDBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFpShotDBResponseBody> body{};

  CreateFpShotDBResponse() {}

  explicit CreateFpShotDBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFpShotDBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFpShotDBResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFpShotDBResponse() = default;
};
class DeactivateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeactivateMediaWorkflowRequest() {}

  explicit DeactivateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeactivateMediaWorkflowRequest() = default;
};
class DeactivateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};

  DeactivateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit DeactivateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~DeactivateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class DeactivateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeactivateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  DeactivateMediaWorkflowResponseBody() {}

  explicit DeactivateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        DeactivateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<DeactivateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeactivateMediaWorkflowResponseBody() = default;
};
class DeactivateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeactivateMediaWorkflowResponseBody> body{};

  DeactivateMediaWorkflowResponse() {}

  explicit DeactivateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactivateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactivateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~DeactivateMediaWorkflowResponse() = default;
};
class DeleteCustomEntityRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> customEntityId{};
  shared_ptr<string> customGroupId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCustomEntityRequest() {}

  explicit DeleteCustomEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (customEntityId) {
      res["CustomEntityId"] = boost::any(*customEntityId);
    }
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("CustomEntityId") != m.end() && !m["CustomEntityId"].empty()) {
      customEntityId = make_shared<string>(boost::any_cast<string>(m["CustomEntityId"]));
    }
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCustomEntityRequest() = default;
};
class DeleteCustomEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomEntityResponseBody() {}

  explicit DeleteCustomEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomEntityResponseBody() = default;
};
class DeleteCustomEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomEntityResponseBody> body{};

  DeleteCustomEntityResponse() {}

  explicit DeleteCustomEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomEntityResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomEntityResponse() = default;
};
class DeleteCustomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> customGroupId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCustomGroupRequest() {}

  explicit DeleteCustomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCustomGroupRequest() = default;
};
class DeleteCustomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomGroupResponseBody() {}

  explicit DeleteCustomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomGroupResponseBody() = default;
};
class DeleteCustomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomGroupResponseBody> body{};

  DeleteCustomGroupResponse() {}

  explicit DeleteCustomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomGroupResponse() = default;
};
class DeleteCustomViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> customEntityId{};
  shared_ptr<string> customGroupId{};
  shared_ptr<string> customViewId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCustomViewRequest() {}

  explicit DeleteCustomViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (customEntityId) {
      res["CustomEntityId"] = boost::any(*customEntityId);
    }
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (customViewId) {
      res["CustomViewId"] = boost::any(*customViewId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("CustomEntityId") != m.end() && !m["CustomEntityId"].empty()) {
      customEntityId = make_shared<string>(boost::any_cast<string>(m["CustomEntityId"]));
    }
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("CustomViewId") != m.end() && !m["CustomViewId"].empty()) {
      customViewId = make_shared<string>(boost::any_cast<string>(m["CustomViewId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCustomViewRequest() = default;
};
class DeleteCustomViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomViewResponseBody() {}

  explicit DeleteCustomViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomViewResponseBody() = default;
};
class DeleteCustomViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomViewResponseBody> body{};

  DeleteCustomViewResponse() {}

  explicit DeleteCustomViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomViewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomViewResponse() = default;
};
class DeleteMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteMediaRequest() {}

  explicit DeleteMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteMediaRequest() = default;
};
class DeleteMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaResponseBody() {}

  explicit DeleteMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaResponseBody() = default;
};
class DeleteMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaResponseBody> body{};

  DeleteMediaResponse() {}

  explicit DeleteMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaResponse() = default;
};
class DeleteMediaTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tag{};

  DeleteMediaTagRequest() {}

  explicit DeleteMediaTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~DeleteMediaTagRequest() = default;
};
class DeleteMediaTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaTagResponseBody() {}

  explicit DeleteMediaTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaTagResponseBody() = default;
};
class DeleteMediaTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaTagResponseBody> body{};

  DeleteMediaTagResponse() {}

  explicit DeleteMediaTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaTagResponse() = default;
};
class DeleteMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteMediaWorkflowRequest() {}

  explicit DeleteMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteMediaWorkflowRequest() = default;
};
class DeleteMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};

  DeleteMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit DeleteMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~DeleteMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class DeleteMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  DeleteMediaWorkflowResponseBody() {}

  explicit DeleteMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        DeleteMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<DeleteMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaWorkflowResponseBody() = default;
};
class DeleteMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaWorkflowResponseBody> body{};

  DeleteMediaWorkflowResponse() {}

  explicit DeleteMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaWorkflowResponse() = default;
};
class DeletePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeletePipelineRequest() {}

  explicit DeletePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeletePipelineRequest() = default;
};
class DeletePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<string> requestId{};

  DeletePipelineResponseBody() {}

  explicit DeletePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePipelineResponseBody() = default;
};
class DeletePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePipelineResponseBody> body{};

  DeletePipelineResponse() {}

  explicit DeletePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelineResponse() = default;
};
class DeleteSmarttagTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};

  DeleteSmarttagTemplateRequest() {}

  explicit DeleteSmarttagTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteSmarttagTemplateRequest() = default;
};
class DeleteSmarttagTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSmarttagTemplateResponseBody() {}

  explicit DeleteSmarttagTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSmarttagTemplateResponseBody() = default;
};
class DeleteSmarttagTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSmarttagTemplateResponseBody> body{};

  DeleteSmarttagTemplateResponse() {}

  explicit DeleteSmarttagTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSmarttagTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSmarttagTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSmarttagTemplateResponse() = default;
};
class DeleteTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};

  DeleteTemplateRequest() {}

  explicit DeleteTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteTemplateRequest() = default;
};
class DeleteTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  DeleteTemplateResponseBody() {}

  explicit DeleteTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteTemplateResponseBody() = default;
};
class DeleteTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTemplateResponseBody> body{};

  DeleteTemplateResponse() {}

  explicit DeleteTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTemplateResponse() = default;
};
class DeleteWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateId{};

  DeleteWaterMarkTemplateRequest() {}

  explicit DeleteWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
  }


  virtual ~DeleteWaterMarkTemplateRequest() = default;
};
class DeleteWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> waterMarkTemplateId{};

  DeleteWaterMarkTemplateResponseBody() {}

  explicit DeleteWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
  }


  virtual ~DeleteWaterMarkTemplateResponseBody() = default;
};
class DeleteWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWaterMarkTemplateResponseBody> body{};

  DeleteWaterMarkTemplateResponse() {}

  explicit DeleteWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWaterMarkTemplateResponse() = default;
};
class ImAuditRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> contents{};
  shared_ptr<string> images{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scenes{};

  ImAuditRequest() {}

  explicit ImAuditRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (contents) {
      res["Contents"] = boost::any(*contents);
    }
    if (images) {
      res["Images"] = boost::any(*images);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scenes) {
      res["Scenes"] = boost::any(*scenes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      contents = make_shared<string>(boost::any_cast<string>(m["Contents"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      images = make_shared<string>(boost::any_cast<string>(m["Images"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      scenes = make_shared<string>(boost::any_cast<string>(m["Scenes"]));
    }
  }


  virtual ~ImAuditRequest() = default;
};
class ImAuditResponseBodyImageResultsResultResultsFrames : public Darabonba::Model {
public:
  shared_ptr<double> rate{};
  shared_ptr<string> url{};

  ImAuditResponseBodyImageResultsResultResultsFrames() {}

  explicit ImAuditResponseBodyImageResultsResultResultsFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<double>(boost::any_cast<double>(m["rate"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResultResultsFrames() = default;
};
class ImAuditResponseBodyImageResultsResultResultsHintWordsInfo : public Darabonba::Model {
public:
  shared_ptr<string> context{};

  ImAuditResponseBodyImageResultsResultResultsHintWordsInfo() {}

  explicit ImAuditResponseBodyImageResultsResultResultsHintWordsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["context"] = boost::any(*context);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("context") != m.end() && !m["context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["context"]));
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResultResultsHintWordsInfo() = default;
};
class ImAuditResponseBodyImageResultsResultResultsLogoData : public Darabonba::Model {
public:
  shared_ptr<double> h{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<double> w{};
  shared_ptr<double> x{};
  shared_ptr<double> y{};

  ImAuditResponseBodyImageResultsResultResultsLogoData() {}

  explicit ImAuditResponseBodyImageResultsResultResultsLogoData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (h) {
      res["h"] = boost::any(*h);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (w) {
      res["w"] = boost::any(*w);
    }
    if (x) {
      res["x"] = boost::any(*x);
    }
    if (y) {
      res["y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("h") != m.end() && !m["h"].empty()) {
      h = make_shared<double>(boost::any_cast<double>(m["h"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("w") != m.end() && !m["w"].empty()) {
      w = make_shared<double>(boost::any_cast<double>(m["w"]));
    }
    if (m.find("x") != m.end() && !m["x"].empty()) {
      x = make_shared<double>(boost::any_cast<double>(m["x"]));
    }
    if (m.find("y") != m.end() && !m["y"].empty()) {
      y = make_shared<double>(boost::any_cast<double>(m["y"]));
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResultResultsLogoData() = default;
};
class ImAuditResponseBodyImageResultsResultResultsProgramCodeData : public Darabonba::Model {
public:
  shared_ptr<double> h{};
  shared_ptr<double> w{};
  shared_ptr<double> x{};
  shared_ptr<double> y{};

  ImAuditResponseBodyImageResultsResultResultsProgramCodeData() {}

  explicit ImAuditResponseBodyImageResultsResultResultsProgramCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (h) {
      res["h"] = boost::any(*h);
    }
    if (w) {
      res["w"] = boost::any(*w);
    }
    if (x) {
      res["x"] = boost::any(*x);
    }
    if (y) {
      res["y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("h") != m.end() && !m["h"].empty()) {
      h = make_shared<double>(boost::any_cast<double>(m["h"]));
    }
    if (m.find("w") != m.end() && !m["w"].empty()) {
      w = make_shared<double>(boost::any_cast<double>(m["w"]));
    }
    if (m.find("x") != m.end() && !m["x"].empty()) {
      x = make_shared<double>(boost::any_cast<double>(m["x"]));
    }
    if (m.find("y") != m.end() && !m["y"].empty()) {
      y = make_shared<double>(boost::any_cast<double>(m["y"]));
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResultResultsProgramCodeData() = default;
};
class ImAuditResponseBodyImageResultsResultResultsQrcodeLocations : public Darabonba::Model {
public:
  shared_ptr<double> h{};
  shared_ptr<string> qrcode{};
  shared_ptr<double> w{};
  shared_ptr<double> x{};
  shared_ptr<double> y{};

  ImAuditResponseBodyImageResultsResultResultsQrcodeLocations() {}

  explicit ImAuditResponseBodyImageResultsResultResultsQrcodeLocations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (h) {
      res["h"] = boost::any(*h);
    }
    if (qrcode) {
      res["qrcode"] = boost::any(*qrcode);
    }
    if (w) {
      res["w"] = boost::any(*w);
    }
    if (x) {
      res["x"] = boost::any(*x);
    }
    if (y) {
      res["y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("h") != m.end() && !m["h"].empty()) {
      h = make_shared<double>(boost::any_cast<double>(m["h"]));
    }
    if (m.find("qrcode") != m.end() && !m["qrcode"].empty()) {
      qrcode = make_shared<string>(boost::any_cast<string>(m["qrcode"]));
    }
    if (m.find("w") != m.end() && !m["w"].empty()) {
      w = make_shared<double>(boost::any_cast<double>(m["w"]));
    }
    if (m.find("x") != m.end() && !m["x"].empty()) {
      x = make_shared<double>(boost::any_cast<double>(m["x"]));
    }
    if (m.find("y") != m.end() && !m["y"].empty()) {
      y = make_shared<double>(boost::any_cast<double>(m["y"]));
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResultResultsQrcodeLocations() = default;
};
class ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces : public Darabonba::Model {
public:
  shared_ptr<string> idid{};
  shared_ptr<string> name{};
  shared_ptr<double> re{};

  ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces() {}

  explicit ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idid) {
      res["idid"] = boost::any(*idid);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (re) {
      res["re"] = boost::any(*re);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("idid") != m.end() && !m["idid"].empty()) {
      idid = make_shared<string>(boost::any_cast<string>(m["idid"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("re") != m.end() && !m["re"].empty()) {
      re = make_shared<double>(boost::any_cast<double>(m["re"]));
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces() = default;
};
class ImAuditResponseBodyImageResultsResultResultsSfaceData : public Darabonba::Model {
public:
  shared_ptr<vector<ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces>> faces{};
  shared_ptr<double> h{};
  shared_ptr<double> w{};
  shared_ptr<double> x{};
  shared_ptr<double> y{};

  ImAuditResponseBodyImageResultsResultResultsSfaceData() {}

  explicit ImAuditResponseBodyImageResultsResultResultsSfaceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faces) {
      vector<boost::any> temp1;
      for(auto item1:*faces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["faces"] = boost::any(temp1);
    }
    if (h) {
      res["h"] = boost::any(*h);
    }
    if (w) {
      res["w"] = boost::any(*w);
    }
    if (x) {
      res["x"] = boost::any(*x);
    }
    if (y) {
      res["y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("faces") != m.end() && !m["faces"].empty()) {
      if (typeid(vector<boost::any>) == m["faces"].type()) {
        vector<ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["faces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        faces = make_shared<vector<ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces>>(expect1);
      }
    }
    if (m.find("h") != m.end() && !m["h"].empty()) {
      h = make_shared<double>(boost::any_cast<double>(m["h"]));
    }
    if (m.find("w") != m.end() && !m["w"].empty()) {
      w = make_shared<double>(boost::any_cast<double>(m["w"]));
    }
    if (m.find("x") != m.end() && !m["x"].empty()) {
      x = make_shared<double>(boost::any_cast<double>(m["x"]));
    }
    if (m.find("y") != m.end() && !m["y"].empty()) {
      y = make_shared<double>(boost::any_cast<double>(m["y"]));
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResultResultsSfaceData() = default;
};
class ImAuditResponseBodyImageResultsResultResults : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<double> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<ImAuditResponseBodyImageResultsResultResultsFrames>> frames{};
  shared_ptr<vector<ImAuditResponseBodyImageResultsResultResultsHintWordsInfo>> hintWordsInfo{};
  shared_ptr<vector<ImAuditResponseBodyImageResultsResultResultsLogoData>> logoData{};
  shared_ptr<vector<string>> ocrData{};
  shared_ptr<vector<ImAuditResponseBodyImageResultsResultResultsProgramCodeData>> programCodeData{};
  shared_ptr<vector<string>> qrcodeData{};
  shared_ptr<vector<ImAuditResponseBodyImageResultsResultResultsQrcodeLocations>> qrcodeLocations{};
  shared_ptr<vector<ImAuditResponseBodyImageResultsResultResultsSfaceData>> sfaceData{};

  ImAuditResponseBodyImageResultsResultResults() {}

  explicit ImAuditResponseBodyImageResultsResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (frames) {
      vector<boost::any> temp1;
      for(auto item1:*frames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["frames"] = boost::any(temp1);
    }
    if (hintWordsInfo) {
      vector<boost::any> temp1;
      for(auto item1:*hintWordsInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hintWordsInfo"] = boost::any(temp1);
    }
    if (logoData) {
      vector<boost::any> temp1;
      for(auto item1:*logoData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["logoData"] = boost::any(temp1);
    }
    if (ocrData) {
      res["ocrData"] = boost::any(*ocrData);
    }
    if (programCodeData) {
      vector<boost::any> temp1;
      for(auto item1:*programCodeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["programCodeData"] = boost::any(temp1);
    }
    if (qrcodeData) {
      res["qrcodeData"] = boost::any(*qrcodeData);
    }
    if (qrcodeLocations) {
      vector<boost::any> temp1;
      for(auto item1:*qrcodeLocations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["qrcodeLocations"] = boost::any(temp1);
    }
    if (sfaceData) {
      vector<boost::any> temp1;
      for(auto item1:*sfaceData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sfaceData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<double>(boost::any_cast<double>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("frames") != m.end() && !m["frames"].empty()) {
      if (typeid(vector<boost::any>) == m["frames"].type()) {
        vector<ImAuditResponseBodyImageResultsResultResultsFrames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["frames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResultResultsFrames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frames = make_shared<vector<ImAuditResponseBodyImageResultsResultResultsFrames>>(expect1);
      }
    }
    if (m.find("hintWordsInfo") != m.end() && !m["hintWordsInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["hintWordsInfo"].type()) {
        vector<ImAuditResponseBodyImageResultsResultResultsHintWordsInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hintWordsInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResultResultsHintWordsInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hintWordsInfo = make_shared<vector<ImAuditResponseBodyImageResultsResultResultsHintWordsInfo>>(expect1);
      }
    }
    if (m.find("logoData") != m.end() && !m["logoData"].empty()) {
      if (typeid(vector<boost::any>) == m["logoData"].type()) {
        vector<ImAuditResponseBodyImageResultsResultResultsLogoData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["logoData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResultResultsLogoData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logoData = make_shared<vector<ImAuditResponseBodyImageResultsResultResultsLogoData>>(expect1);
      }
    }
    if (m.find("ocrData") != m.end() && !m["ocrData"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ocrData"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ocrData"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ocrData = make_shared<vector<string>>(toVec1);
    }
    if (m.find("programCodeData") != m.end() && !m["programCodeData"].empty()) {
      if (typeid(vector<boost::any>) == m["programCodeData"].type()) {
        vector<ImAuditResponseBodyImageResultsResultResultsProgramCodeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["programCodeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResultResultsProgramCodeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programCodeData = make_shared<vector<ImAuditResponseBodyImageResultsResultResultsProgramCodeData>>(expect1);
      }
    }
    if (m.find("qrcodeData") != m.end() && !m["qrcodeData"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["qrcodeData"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["qrcodeData"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      qrcodeData = make_shared<vector<string>>(toVec1);
    }
    if (m.find("qrcodeLocations") != m.end() && !m["qrcodeLocations"].empty()) {
      if (typeid(vector<boost::any>) == m["qrcodeLocations"].type()) {
        vector<ImAuditResponseBodyImageResultsResultResultsQrcodeLocations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["qrcodeLocations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResultResultsQrcodeLocations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qrcodeLocations = make_shared<vector<ImAuditResponseBodyImageResultsResultResultsQrcodeLocations>>(expect1);
      }
    }
    if (m.find("sfaceData") != m.end() && !m["sfaceData"].empty()) {
      if (typeid(vector<boost::any>) == m["sfaceData"].type()) {
        vector<ImAuditResponseBodyImageResultsResultResultsSfaceData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sfaceData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResultResultsSfaceData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sfaceData = make_shared<vector<ImAuditResponseBodyImageResultsResultResultsSfaceData>>(expect1);
      }
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResultResults() = default;
};
class ImAuditResponseBodyImageResultsResult : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> dataId{};
  shared_ptr<map<string, boost::any>> extras{};
  shared_ptr<string> msg{};
  shared_ptr<vector<ImAuditResponseBodyImageResultsResultResults>> results{};
  shared_ptr<string> taskId{};
  shared_ptr<string> url{};

  ImAuditResponseBodyImageResultsResult() {}

  explicit ImAuditResponseBodyImageResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataId) {
      res["dataId"] = boost::any(*dataId);
    }
    if (extras) {
      res["extras"] = boost::any(*extras);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["results"] = boost::any(temp1);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("dataId") != m.end() && !m["dataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["dataId"]));
    }
    if (m.find("extras") != m.end() && !m["extras"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["extras"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extras = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("results") != m.end() && !m["results"].empty()) {
      if (typeid(vector<boost::any>) == m["results"].type()) {
        vector<ImAuditResponseBodyImageResultsResultResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResultResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<ImAuditResponseBodyImageResultsResultResults>>(expect1);
      }
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~ImAuditResponseBodyImageResultsResult() = default;
};
class ImAuditResponseBodyImageResults : public Darabonba::Model {
public:
  shared_ptr<vector<ImAuditResponseBodyImageResultsResult>> result{};

  ImAuditResponseBodyImageResults() {}

  explicit ImAuditResponseBodyImageResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ImAuditResponseBodyImageResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyImageResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ImAuditResponseBodyImageResultsResult>>(expect1);
      }
    }
  }


  virtual ~ImAuditResponseBodyImageResults() = default;
};
class ImAuditResponseBodyTextResultsResultResultsDetailsContexts : public Darabonba::Model {
public:
  shared_ptr<string> context{};
  shared_ptr<string> libCode{};
  shared_ptr<string> libName{};
  shared_ptr<vector<string>> positions{};
  shared_ptr<string> ruleType{};

  ImAuditResponseBodyTextResultsResultResultsDetailsContexts() {}

  explicit ImAuditResponseBodyTextResultsResultResultsDetailsContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["context"] = boost::any(*context);
    }
    if (libCode) {
      res["libCode"] = boost::any(*libCode);
    }
    if (libName) {
      res["libName"] = boost::any(*libName);
    }
    if (positions) {
      res["positions"] = boost::any(*positions);
    }
    if (ruleType) {
      res["ruleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("context") != m.end() && !m["context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["context"]));
    }
    if (m.find("libCode") != m.end() && !m["libCode"].empty()) {
      libCode = make_shared<string>(boost::any_cast<string>(m["libCode"]));
    }
    if (m.find("libName") != m.end() && !m["libName"].empty()) {
      libName = make_shared<string>(boost::any_cast<string>(m["libName"]));
    }
    if (m.find("positions") != m.end() && !m["positions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["positions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["positions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      positions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ruleType") != m.end() && !m["ruleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["ruleType"]));
    }
  }


  virtual ~ImAuditResponseBodyTextResultsResultResultsDetailsContexts() = default;
};
class ImAuditResponseBodyTextResultsResultResultsDetails : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<vector<ImAuditResponseBodyTextResultsResultResultsDetailsContexts>> contexts{};

  ImAuditResponseBodyTextResultsResultResultsDetails() {}

  explicit ImAuditResponseBodyTextResultsResultResultsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (contexts) {
      vector<boost::any> temp1;
      for(auto item1:*contexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["contexts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("contexts") != m.end() && !m["contexts"].empty()) {
      if (typeid(vector<boost::any>) == m["contexts"].type()) {
        vector<ImAuditResponseBodyTextResultsResultResultsDetailsContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["contexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyTextResultsResultResultsDetailsContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contexts = make_shared<vector<ImAuditResponseBodyTextResultsResultResultsDetailsContexts>>(expect1);
      }
    }
  }


  virtual ~ImAuditResponseBodyTextResultsResultResultsDetails() = default;
};
class ImAuditResponseBodyTextResultsResultResults : public Darabonba::Model {
public:
  shared_ptr<vector<ImAuditResponseBodyTextResultsResultResultsDetails>> details{};
  shared_ptr<string> label{};
  shared_ptr<double> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  ImAuditResponseBodyTextResultsResultResults() {}

  explicit ImAuditResponseBodyTextResultsResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["details"] = boost::any(temp1);
    }
    if (label) {
      res["label"] = boost::any(*label);
    }
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("details") != m.end() && !m["details"].empty()) {
      if (typeid(vector<boost::any>) == m["details"].type()) {
        vector<ImAuditResponseBodyTextResultsResultResultsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyTextResultsResultResultsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<ImAuditResponseBodyTextResultsResultResultsDetails>>(expect1);
      }
    }
    if (m.find("label") != m.end() && !m["label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["label"]));
    }
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<double>(boost::any_cast<double>(m["rate"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
    if (m.find("suggestion") != m.end() && !m["suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["suggestion"]));
    }
  }


  virtual ~ImAuditResponseBodyTextResultsResultResults() = default;
};
class ImAuditResponseBodyTextResultsResult : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> content{};
  shared_ptr<string> dataId{};
  shared_ptr<string> msg{};
  shared_ptr<vector<ImAuditResponseBodyTextResultsResultResults>> results{};
  shared_ptr<string> taskId{};

  ImAuditResponseBodyTextResultsResult() {}

  explicit ImAuditResponseBodyTextResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (dataId) {
      res["dataId"] = boost::any(*dataId);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["results"] = boost::any(temp1);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("dataId") != m.end() && !m["dataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["dataId"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("results") != m.end() && !m["results"].empty()) {
      if (typeid(vector<boost::any>) == m["results"].type()) {
        vector<ImAuditResponseBodyTextResultsResultResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyTextResultsResultResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<ImAuditResponseBodyTextResultsResultResults>>(expect1);
      }
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~ImAuditResponseBodyTextResultsResult() = default;
};
class ImAuditResponseBodyTextResults : public Darabonba::Model {
public:
  shared_ptr<vector<ImAuditResponseBodyTextResultsResult>> result{};

  ImAuditResponseBodyTextResults() {}

  explicit ImAuditResponseBodyTextResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ImAuditResponseBodyTextResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImAuditResponseBodyTextResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ImAuditResponseBodyTextResultsResult>>(expect1);
      }
    }
  }


  virtual ~ImAuditResponseBodyTextResults() = default;
};
class ImAuditResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> imageQuotaExceed{};
  shared_ptr<ImAuditResponseBodyImageResults> imageResults{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> textQuotaExceed{};
  shared_ptr<ImAuditResponseBodyTextResults> textResults{};

  ImAuditResponseBody() {}

  explicit ImAuditResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageQuotaExceed) {
      res["ImageQuotaExceed"] = boost::any(*imageQuotaExceed);
    }
    if (imageResults) {
      res["ImageResults"] = imageResults ? boost::any(imageResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (textQuotaExceed) {
      res["TextQuotaExceed"] = boost::any(*textQuotaExceed);
    }
    if (textResults) {
      res["TextResults"] = textResults ? boost::any(textResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageQuotaExceed") != m.end() && !m["ImageQuotaExceed"].empty()) {
      imageQuotaExceed = make_shared<bool>(boost::any_cast<bool>(m["ImageQuotaExceed"]));
    }
    if (m.find("ImageResults") != m.end() && !m["ImageResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageResults"].type()) {
        ImAuditResponseBodyImageResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageResults"]));
        imageResults = make_shared<ImAuditResponseBodyImageResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TextQuotaExceed") != m.end() && !m["TextQuotaExceed"].empty()) {
      textQuotaExceed = make_shared<bool>(boost::any_cast<bool>(m["TextQuotaExceed"]));
    }
    if (m.find("TextResults") != m.end() && !m["TextResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextResults"].type()) {
        ImAuditResponseBodyTextResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextResults"]));
        textResults = make_shared<ImAuditResponseBodyTextResults>(model1);
      }
    }
  }


  virtual ~ImAuditResponseBody() = default;
};
class ImAuditResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImAuditResponseBody> body{};

  ImAuditResponse() {}

  explicit ImAuditResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImAuditResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImAuditResponseBody>(model1);
      }
    }
  }


  virtual ~ImAuditResponse() = default;
};
class ImportFpShotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> fpDBId{};
  shared_ptr<string> fpImportConfig{};
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userData{};

  ImportFpShotJobRequest() {}

  explicit ImportFpShotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (fpImportConfig) {
      res["FpImportConfig"] = boost::any(*fpImportConfig);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("FpImportConfig") != m.end() && !m["FpImportConfig"].empty()) {
      fpImportConfig = make_shared<string>(boost::any_cast<string>(m["FpImportConfig"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ImportFpShotJobRequest() = default;
};
class ImportFpShotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  ImportFpShotJobResponseBody() {}

  explicit ImportFpShotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportFpShotJobResponseBody() = default;
};
class ImportFpShotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportFpShotJobResponseBody> body{};

  ImportFpShotJobResponse() {}

  explicit ImportFpShotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportFpShotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportFpShotJobResponseBody>(model1);
      }
    }
  }


  virtual ~ImportFpShotJobResponse() = default;
};
class ListAllMediaBucketRequest : public Darabonba::Model {
public:
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListAllMediaBucketRequest() {}

  explicit ListAllMediaBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListAllMediaBucketRequest() = default;
};
class ListAllMediaBucketResponseBodyMediaBucketListMediaBucket : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> referer{};
  shared_ptr<string> type{};

  ListAllMediaBucketResponseBodyMediaBucketListMediaBucket() {}

  explicit ListAllMediaBucketResponseBodyMediaBucketListMediaBucket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (referer) {
      res["Referer"] = boost::any(*referer);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Referer") != m.end() && !m["Referer"].empty()) {
      referer = make_shared<string>(boost::any_cast<string>(m["Referer"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAllMediaBucketResponseBodyMediaBucketListMediaBucket() = default;
};
class ListAllMediaBucketResponseBodyMediaBucketList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket>> mediaBucket{};

  ListAllMediaBucketResponseBodyMediaBucketList() {}

  explicit ListAllMediaBucketResponseBodyMediaBucketList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaBucket) {
      vector<boost::any> temp1;
      for(auto item1:*mediaBucket){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaBucket"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaBucket") != m.end() && !m["MediaBucket"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaBucket"].type()) {
        vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaBucket"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllMediaBucketResponseBodyMediaBucketListMediaBucket model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaBucket = make_shared<vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket>>(expect1);
      }
    }
  }


  virtual ~ListAllMediaBucketResponseBodyMediaBucketList() = default;
};
class ListAllMediaBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAllMediaBucketResponseBodyMediaBucketList> mediaBucketList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListAllMediaBucketResponseBody() {}

  explicit ListAllMediaBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaBucketList) {
      res["MediaBucketList"] = mediaBucketList ? boost::any(mediaBucketList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaBucketList") != m.end() && !m["MediaBucketList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBucketList"].type()) {
        ListAllMediaBucketResponseBodyMediaBucketList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBucketList"]));
        mediaBucketList = make_shared<ListAllMediaBucketResponseBodyMediaBucketList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAllMediaBucketResponseBody() = default;
};
class ListAllMediaBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllMediaBucketResponseBody> body{};

  ListAllMediaBucketResponse() {}

  explicit ListAllMediaBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllMediaBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllMediaBucketResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllMediaBucketResponse() = default;
};
class ListCustomEntitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> customGroupId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListCustomEntitiesRequest() {}

  explicit ListCustomEntitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListCustomEntitiesRequest() = default;
};
class ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity : public Darabonba::Model {
public:
  shared_ptr<string> customEntityId{};
  shared_ptr<string> customEntityInfo{};
  shared_ptr<string> customEntityName{};

  ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity() {}

  explicit ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customEntityId) {
      res["CustomEntityId"] = boost::any(*customEntityId);
    }
    if (customEntityInfo) {
      res["CustomEntityInfo"] = boost::any(*customEntityInfo);
    }
    if (customEntityName) {
      res["CustomEntityName"] = boost::any(*customEntityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomEntityId") != m.end() && !m["CustomEntityId"].empty()) {
      customEntityId = make_shared<string>(boost::any_cast<string>(m["CustomEntityId"]));
    }
    if (m.find("CustomEntityInfo") != m.end() && !m["CustomEntityInfo"].empty()) {
      customEntityInfo = make_shared<string>(boost::any_cast<string>(m["CustomEntityInfo"]));
    }
    if (m.find("CustomEntityName") != m.end() && !m["CustomEntityName"].empty()) {
      customEntityName = make_shared<string>(boost::any_cast<string>(m["CustomEntityName"]));
    }
  }


  virtual ~ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity() = default;
};
class ListCustomEntitiesResponseBodyCustomEntities : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity>> customEntity{};

  ListCustomEntitiesResponseBodyCustomEntities() {}

  explicit ListCustomEntitiesResponseBodyCustomEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customEntity) {
      vector<boost::any> temp1;
      for(auto item1:*customEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomEntity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomEntity") != m.end() && !m["CustomEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomEntity"].type()) {
        vector<ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customEntity = make_shared<vector<ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity>>(expect1);
      }
    }
  }


  virtual ~ListCustomEntitiesResponseBodyCustomEntities() = default;
};
class ListCustomEntitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCustomEntitiesResponseBodyCustomEntities> customEntities{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomEntitiesResponseBody() {}

  explicit ListCustomEntitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customEntities) {
      res["CustomEntities"] = customEntities ? boost::any(customEntities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomEntities") != m.end() && !m["CustomEntities"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomEntities"].type()) {
        ListCustomEntitiesResponseBodyCustomEntities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomEntities"]));
        customEntities = make_shared<ListCustomEntitiesResponseBodyCustomEntities>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomEntitiesResponseBody() = default;
};
class ListCustomEntitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomEntitiesResponseBody> body{};

  ListCustomEntitiesResponse() {}

  explicit ListCustomEntitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomEntitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomEntitiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomEntitiesResponse() = default;
};
class ListCustomGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListCustomGroupsRequest() {}

  explicit ListCustomGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListCustomGroupsRequest() = default;
};
class ListCustomGroupsResponseBodyCustomGroupsCustomGroup : public Darabonba::Model {
public:
  shared_ptr<string> customGroupDescription{};
  shared_ptr<string> customGroupId{};
  shared_ptr<string> customGroupName{};

  ListCustomGroupsResponseBodyCustomGroupsCustomGroup() {}

  explicit ListCustomGroupsResponseBodyCustomGroupsCustomGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customGroupDescription) {
      res["CustomGroupDescription"] = boost::any(*customGroupDescription);
    }
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (customGroupName) {
      res["CustomGroupName"] = boost::any(*customGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomGroupDescription") != m.end() && !m["CustomGroupDescription"].empty()) {
      customGroupDescription = make_shared<string>(boost::any_cast<string>(m["CustomGroupDescription"]));
    }
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("CustomGroupName") != m.end() && !m["CustomGroupName"].empty()) {
      customGroupName = make_shared<string>(boost::any_cast<string>(m["CustomGroupName"]));
    }
  }


  virtual ~ListCustomGroupsResponseBodyCustomGroupsCustomGroup() = default;
};
class ListCustomGroupsResponseBodyCustomGroups : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomGroupsResponseBodyCustomGroupsCustomGroup>> customGroup{};

  ListCustomGroupsResponseBodyCustomGroups() {}

  explicit ListCustomGroupsResponseBodyCustomGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customGroup) {
      vector<boost::any> temp1;
      for(auto item1:*customGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomGroup") != m.end() && !m["CustomGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomGroup"].type()) {
        vector<ListCustomGroupsResponseBodyCustomGroupsCustomGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomGroupsResponseBodyCustomGroupsCustomGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customGroup = make_shared<vector<ListCustomGroupsResponseBodyCustomGroupsCustomGroup>>(expect1);
      }
    }
  }


  virtual ~ListCustomGroupsResponseBodyCustomGroups() = default;
};
class ListCustomGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCustomGroupsResponseBodyCustomGroups> customGroups{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomGroupsResponseBody() {}

  explicit ListCustomGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customGroups) {
      res["CustomGroups"] = customGroups ? boost::any(customGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomGroups") != m.end() && !m["CustomGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomGroups"].type()) {
        ListCustomGroupsResponseBodyCustomGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomGroups"]));
        customGroups = make_shared<ListCustomGroupsResponseBodyCustomGroups>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomGroupsResponseBody() = default;
};
class ListCustomGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomGroupsResponseBody> body{};

  ListCustomGroupsResponse() {}

  explicit ListCustomGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomGroupsResponse() = default;
};
class ListCustomPersonsRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> personId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListCustomPersonsRequest() {}

  explicit ListCustomPersonsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListCustomPersonsRequest() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace : public Darabonba::Model {
public:
  shared_ptr<string> faceId{};
  shared_ptr<string> imageUrl{};

  ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace>> face{};

  ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (face) {
      vector<boost::any> temp1;
      for(auto item1:*face){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Face"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Face") != m.end() && !m["Face"].empty()) {
      if (typeid(vector<boost::any>) == m["Face"].type()) {
        vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Face"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        face = make_shared<vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace>>(expect1);
      }
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson : public Darabonba::Model {
public:
  shared_ptr<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces> faces{};
  shared_ptr<string> personDescription{};
  shared_ptr<string> personId{};
  shared_ptr<string> personName{};

  ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faces) {
      res["Faces"] = faces ? boost::any(faces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (personDescription) {
      res["PersonDescription"] = boost::any(*personDescription);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    if (personName) {
      res["PersonName"] = boost::any(*personName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Faces") != m.end() && !m["Faces"].empty()) {
      if (typeid(map<string, boost::any>) == m["Faces"].type()) {
        ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Faces"]));
        faces = make_shared<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces>(model1);
      }
    }
    if (m.find("PersonDescription") != m.end() && !m["PersonDescription"].empty()) {
      personDescription = make_shared<string>(boost::any_cast<string>(m["PersonDescription"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
    if (m.find("PersonName") != m.end() && !m["PersonName"].empty()) {
      personName = make_shared<string>(boost::any_cast<string>(m["PersonName"]));
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategoryPersons : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson>> person{};

  ListCustomPersonsResponseBodyCategoriesCategoryPersons() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategoryPersons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (person) {
      vector<boost::any> temp1;
      for(auto item1:*person){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Person"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Person") != m.end() && !m["Person"].empty()) {
      if (typeid(vector<boost::any>) == m["Person"].type()) {
        vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Person"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        person = make_shared<vector<ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson>>(expect1);
      }
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategoryPersons() = default;
};
class ListCustomPersonsResponseBodyCategoriesCategory : public Darabonba::Model {
public:
  shared_ptr<string> categoryDescription{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> categoryName{};
  shared_ptr<ListCustomPersonsResponseBodyCategoriesCategoryPersons> persons{};

  ListCustomPersonsResponseBodyCategoriesCategory() {}

  explicit ListCustomPersonsResponseBodyCategoriesCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryDescription) {
      res["CategoryDescription"] = boost::any(*categoryDescription);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (persons) {
      res["Persons"] = persons ? boost::any(persons->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryDescription") != m.end() && !m["CategoryDescription"].empty()) {
      categoryDescription = make_shared<string>(boost::any_cast<string>(m["CategoryDescription"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Persons") != m.end() && !m["Persons"].empty()) {
      if (typeid(map<string, boost::any>) == m["Persons"].type()) {
        ListCustomPersonsResponseBodyCategoriesCategoryPersons model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Persons"]));
        persons = make_shared<ListCustomPersonsResponseBodyCategoriesCategoryPersons>(model1);
      }
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategoriesCategory() = default;
};
class ListCustomPersonsResponseBodyCategories : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomPersonsResponseBodyCategoriesCategory>> category{};

  ListCustomPersonsResponseBodyCategories() {}

  explicit ListCustomPersonsResponseBodyCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<ListCustomPersonsResponseBodyCategoriesCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomPersonsResponseBodyCategoriesCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<ListCustomPersonsResponseBodyCategoriesCategory>>(expect1);
      }
    }
  }


  virtual ~ListCustomPersonsResponseBodyCategories() = default;
};
class ListCustomPersonsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCustomPersonsResponseBodyCategories> categories{};
  shared_ptr<string> requestId{};

  ListCustomPersonsResponseBody() {}

  explicit ListCustomPersonsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = categories ? boost::any(categories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(map<string, boost::any>) == m["Categories"].type()) {
        ListCustomPersonsResponseBodyCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Categories"]));
        categories = make_shared<ListCustomPersonsResponseBodyCategories>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCustomPersonsResponseBody() = default;
};
class ListCustomPersonsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomPersonsResponseBody> body{};

  ListCustomPersonsResponse() {}

  explicit ListCustomPersonsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomPersonsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomPersonsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomPersonsResponse() = default;
};
class ListCustomViewsRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> customEntityId{};
  shared_ptr<string> customGroupId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListCustomViewsRequest() {}

  explicit ListCustomViewsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (customEntityId) {
      res["CustomEntityId"] = boost::any(*customEntityId);
    }
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("CustomEntityId") != m.end() && !m["CustomEntityId"].empty()) {
      customEntityId = make_shared<string>(boost::any_cast<string>(m["CustomEntityId"]));
    }
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListCustomViewsRequest() = default;
};
class ListCustomViewsResponseBodyCustomViewsCustomView : public Darabonba::Model {
public:
  shared_ptr<string> customViewId{};
  shared_ptr<string> imageUrl{};

  ListCustomViewsResponseBodyCustomViewsCustomView() {}

  explicit ListCustomViewsResponseBodyCustomViewsCustomView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customViewId) {
      res["CustomViewId"] = boost::any(*customViewId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomViewId") != m.end() && !m["CustomViewId"].empty()) {
      customViewId = make_shared<string>(boost::any_cast<string>(m["CustomViewId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
  }


  virtual ~ListCustomViewsResponseBodyCustomViewsCustomView() = default;
};
class ListCustomViewsResponseBodyCustomViews : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomViewsResponseBodyCustomViewsCustomView>> customView{};

  ListCustomViewsResponseBodyCustomViews() {}

  explicit ListCustomViewsResponseBodyCustomViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customView) {
      vector<boost::any> temp1;
      for(auto item1:*customView){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomView"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomView") != m.end() && !m["CustomView"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomView"].type()) {
        vector<ListCustomViewsResponseBodyCustomViewsCustomView> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomView"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomViewsResponseBodyCustomViewsCustomView model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customView = make_shared<vector<ListCustomViewsResponseBodyCustomViewsCustomView>>(expect1);
      }
    }
  }


  virtual ~ListCustomViewsResponseBodyCustomViews() = default;
};
class ListCustomViewsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCustomViewsResponseBodyCustomViews> customViews{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomViewsResponseBody() {}

  explicit ListCustomViewsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customViews) {
      res["CustomViews"] = customViews ? boost::any(customViews->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomViews") != m.end() && !m["CustomViews"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomViews"].type()) {
        ListCustomViewsResponseBodyCustomViews model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomViews"]));
        customViews = make_shared<ListCustomViewsResponseBodyCustomViews>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomViewsResponseBody() = default;
};
class ListCustomViewsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomViewsResponseBody> body{};

  ListCustomViewsResponse() {}

  explicit ListCustomViewsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomViewsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomViewsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomViewsResponse() = default;
};
class ListFpShotDBRequest : public Darabonba::Model {
public:
  shared_ptr<string> fpDBIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListFpShotDBRequest() {}

  explicit ListFpShotDBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpDBIds) {
      res["FpDBIds"] = boost::any(*fpDBIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpDBIds") != m.end() && !m["FpDBIds"].empty()) {
      fpDBIds = make_shared<string>(boost::any_cast<string>(m["FpDBIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListFpShotDBRequest() = default;
};
class ListFpShotDBResponseBodyFpShotDBListFpShotDB : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fpDBId{};
  shared_ptr<long> modelId{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};

  ListFpShotDBResponseBodyFpShotDBListFpShotDB() {}

  explicit ListFpShotDBResponseBodyFpShotDBListFpShotDB(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<long>(boost::any_cast<long>(m["ModelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListFpShotDBResponseBodyFpShotDBListFpShotDB() = default;
};
class ListFpShotDBResponseBodyFpShotDBList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFpShotDBResponseBodyFpShotDBListFpShotDB>> fpShotDB{};

  ListFpShotDBResponseBodyFpShotDBList() {}

  explicit ListFpShotDBResponseBodyFpShotDBList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotDB) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotDB){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotDB"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotDB") != m.end() && !m["FpShotDB"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotDB"].type()) {
        vector<ListFpShotDBResponseBodyFpShotDBListFpShotDB> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotDB"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFpShotDBResponseBodyFpShotDBListFpShotDB model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotDB = make_shared<vector<ListFpShotDBResponseBodyFpShotDBListFpShotDB>>(expect1);
      }
    }
  }


  virtual ~ListFpShotDBResponseBodyFpShotDBList() = default;
};
class ListFpShotDBResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  ListFpShotDBResponseBodyNonExistIds() {}

  explicit ListFpShotDBResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFpShotDBResponseBodyNonExistIds() = default;
};
class ListFpShotDBResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFpShotDBResponseBodyFpShotDBList> fpShotDBList{};
  shared_ptr<ListFpShotDBResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<string> requestId{};

  ListFpShotDBResponseBody() {}

  explicit ListFpShotDBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotDBList) {
      res["FpShotDBList"] = fpShotDBList ? boost::any(fpShotDBList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotDBList") != m.end() && !m["FpShotDBList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotDBList"].type()) {
        ListFpShotDBResponseBodyFpShotDBList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotDBList"]));
        fpShotDBList = make_shared<ListFpShotDBResponseBodyFpShotDBList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        ListFpShotDBResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<ListFpShotDBResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFpShotDBResponseBody() = default;
};
class ListFpShotDBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFpShotDBResponseBody> body{};

  ListFpShotDBResponse() {}

  explicit ListFpShotDBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFpShotDBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFpShotDBResponseBody>(model1);
      }
    }
  }


  virtual ~ListFpShotDBResponse() = default;
};
class ListFpShotFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startTime{};

  ListFpShotFilesRequest() {}

  explicit ListFpShotFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListFpShotFilesRequest() = default;
};
class ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile() {}

  explicit ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile() = default;
};
class ListFpShotFilesResponseBodyFpShotFileListFpShotFile : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile> inputFile{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> storeTime{};

  ListFpShotFilesResponseBodyFpShotFileListFpShotFile() {}

  explicit ListFpShotFilesResponseBodyFpShotFileListFpShotFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (storeTime) {
      res["StoreTime"] = boost::any(*storeTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile>(model1);
      }
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("StoreTime") != m.end() && !m["StoreTime"].empty()) {
      storeTime = make_shared<string>(boost::any_cast<string>(m["StoreTime"]));
    }
  }


  virtual ~ListFpShotFilesResponseBodyFpShotFileListFpShotFile() = default;
};
class ListFpShotFilesResponseBodyFpShotFileList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFpShotFilesResponseBodyFpShotFileListFpShotFile>> fpShotFile{};

  ListFpShotFilesResponseBodyFpShotFileList() {}

  explicit ListFpShotFilesResponseBodyFpShotFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotFile) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotFile){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotFile"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotFile") != m.end() && !m["FpShotFile"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotFile"].type()) {
        vector<ListFpShotFilesResponseBodyFpShotFileListFpShotFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotFile"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFpShotFilesResponseBodyFpShotFileListFpShotFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotFile = make_shared<vector<ListFpShotFilesResponseBodyFpShotFileListFpShotFile>>(expect1);
      }
    }
  }


  virtual ~ListFpShotFilesResponseBodyFpShotFileList() = default;
};
class ListFpShotFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFpShotFilesResponseBodyFpShotFileList> fpShotFileList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListFpShotFilesResponseBody() {}

  explicit ListFpShotFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotFileList) {
      res["FpShotFileList"] = fpShotFileList ? boost::any(fpShotFileList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotFileList") != m.end() && !m["FpShotFileList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotFileList"].type()) {
        ListFpShotFilesResponseBodyFpShotFileList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotFileList"]));
        fpShotFileList = make_shared<ListFpShotFilesResponseBodyFpShotFileList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFpShotFilesResponseBody() = default;
};
class ListFpShotFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFpShotFilesResponseBody> body{};

  ListFpShotFilesResponse() {}

  explicit ListFpShotFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFpShotFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFpShotFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFpShotFilesResponse() = default;
};
class ListFpShotImportJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListFpShotImportJobRequest() {}

  explicit ListFpShotImportJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListFpShotImportJobRequest() = default;
};
class ListFpShotImportJobResponseBodyFpShotImportJobList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> fpImportConfig{};
  shared_ptr<string> id{};
  shared_ptr<string> input{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> processMessage{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};

  ListFpShotImportJobResponseBodyFpShotImportJobList() {}

  explicit ListFpShotImportJobResponseBodyFpShotImportJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (fpImportConfig) {
      res["FpImportConfig"] = boost::any(*fpImportConfig);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (processMessage) {
      res["ProcessMessage"] = boost::any(*processMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("FpImportConfig") != m.end() && !m["FpImportConfig"].empty()) {
      fpImportConfig = make_shared<string>(boost::any_cast<string>(m["FpImportConfig"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ProcessMessage") != m.end() && !m["ProcessMessage"].empty()) {
      processMessage = make_shared<string>(boost::any_cast<string>(m["ProcessMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListFpShotImportJobResponseBodyFpShotImportJobList() = default;
};
class ListFpShotImportJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListFpShotImportJobResponseBodyFpShotImportJobList>> fpShotImportJobList{};
  shared_ptr<vector<string>> nonExistIds{};
  shared_ptr<string> requestId{};

  ListFpShotImportJobResponseBody() {}

  explicit ListFpShotImportJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotImportJobList) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotImportJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotImportJobList"] = boost::any(temp1);
    }
    if (nonExistIds) {
      res["NonExistIds"] = boost::any(*nonExistIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotImportJobList") != m.end() && !m["FpShotImportJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotImportJobList"].type()) {
        vector<ListFpShotImportJobResponseBodyFpShotImportJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotImportJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFpShotImportJobResponseBodyFpShotImportJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotImportJobList = make_shared<vector<ListFpShotImportJobResponseBodyFpShotImportJobList>>(expect1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFpShotImportJobResponseBody() = default;
};
class ListFpShotImportJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFpShotImportJobResponseBody> body{};

  ListFpShotImportJobResponse() {}

  explicit ListFpShotImportJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFpShotImportJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFpShotImportJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListFpShotImportJobResponse() = default;
};
class ListJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> state{};

  ListJobRequest() {}

  explicit ListJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListJobRequest() = default;
};
class ListJobResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListJobResponseBodyJobListJobInput() {}

  explicit ListJobResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobInput() = default;
};
class ListJobResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  ListJobResponseBodyJobListJobMNSMessageResult() {}

  explicit ListJobResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobMNSMessageResult() = default;
};
class ListJobResponseBodyJobListJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  ListJobResponseBodyJobListJobOutputAudioVolume() {}

  explicit ListJobResponseBodyJobListJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputAudioVolume() = default;
};
class ListJobResponseBodyJobListJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};
  shared_ptr<ListJobResponseBodyJobListJobOutputAudioVolume> volume{};

  ListJobResponseBodyJobListJobOutputAudio() {}

  explicit ListJobResponseBodyJobListJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        ListJobResponseBodyJobListJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<ListJobResponseBodyJobListJobOutputAudioVolume>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputAudio() = default;
};
class ListJobResponseBodyJobListJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> seek{};

  ListJobResponseBodyJobListJobOutputClipTimeSpan() {}

  explicit ListJobResponseBodyJobListJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputClipTimeSpan() = default;
};
class ListJobResponseBodyJobListJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputClipTimeSpan> timeSpan{};

  ListJobResponseBodyJobListJobOutputClip() {}

  explicit ListJobResponseBodyJobListJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        ListJobResponseBodyJobListJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<ListJobResponseBodyJobListJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputClip() = default;
};
class ListJobResponseBodyJobListJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  ListJobResponseBodyJobListJobOutputContainer() {}

  explicit ListJobResponseBodyJobListJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputContainer() = default;
};
class ListJobResponseBodyJobListJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};
  shared_ptr<string> type{};

  ListJobResponseBodyJobListJobOutputEncryption() {}

  explicit ListJobResponseBodyJobListJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputEncryption() = default;
};
class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> md5Support{};
  shared_ptr<bool> sizeSupport{};

  ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS() {}

  explicit ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS() = default;
};
class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS> TS{};

  ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport() {}

  explicit ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport() = default;
};
class ListJobResponseBodyJobListJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> start{};

  ListJobResponseBodyJobListJobOutputMergeListMerge() {}

  explicit ListJobResponseBodyJobListJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMergeListMerge() = default;
};
class ListJobResponseBodyJobListJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputMergeListMerge>> merge{};

  ListJobResponseBodyJobListJobOutputMergeList() {}

  explicit ListJobResponseBodyJobListJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<ListJobResponseBodyJobListJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<ListJobResponseBodyJobListJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMergeList() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  ListJobResponseBodyJobListJobOutputMuxConfigGif() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigGif() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  ListJobResponseBodyJobListJobOutputMuxConfigSegment() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigSegment() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  ListJobResponseBodyJobListJobOutputMuxConfigWebp() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigWebp() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigGif> gif{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigSegment> segment{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigWebp> webp{};

  ListJobResponseBodyJobListJobOutputMuxConfig() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfig() = default;
};
class ListJobResponseBodyJobListJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> openUrl{};

  ListJobResponseBodyJobListJobOutputOpeningListOpening() {}

  explicit ListJobResponseBodyJobListJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOpeningListOpening() = default;
};
class ListJobResponseBodyJobListJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputOpeningListOpening>> opening{};

  ListJobResponseBodyJobListJobOutputOpeningList() {}

  explicit ListJobResponseBodyJobListJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<ListJobResponseBodyJobListJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<ListJobResponseBodyJobListJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOpeningList() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<string> message{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};

  ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  ListJobResponseBodyJobListJobOutputOutSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  ListJobResponseBodyJobListJobOutputOutputFile() {}

  explicit ListJobResponseBodyJobListJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutputFile() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  ListJobResponseBodyJobListJobOutputPropertiesFormat() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesFormat() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};

  ListJobResponseBodyJobListJobOutputPropertiesStreams() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreams() = default;
};
class ListJobResponseBodyJobListJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreams> streams{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputProperties() {}

  explicit ListJobResponseBodyJobListJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<ListJobResponseBodyJobListJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputProperties() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList> subtitleList{};

  ListJobResponseBodyJobListJobOutputSubtitleConfig() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfig() = default;
};
class ListJobResponseBodyJobListJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  ListJobResponseBodyJobListJobOutputSuperReso() {}

  explicit ListJobResponseBodyJobListJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSuperReso() = default;
};
class ListJobResponseBodyJobListJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> height{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> start{};
  shared_ptr<string> tailUrl{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputTailSlateListTailSlate() {}

  explicit ListJobResponseBodyJobListJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTailSlateListTailSlate() = default;
};
class ListJobResponseBodyJobListJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate>> tailSlate{};

  ListJobResponseBodyJobListJobOutputTailSlateList() {}

  explicit ListJobResponseBodyJobListJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTailSlateList() = default;
};
class ListJobResponseBodyJobListJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  ListJobResponseBodyJobListJobOutputTransConfig() {}

  explicit ListJobResponseBodyJobListJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTransConfig() = default;
};
class ListJobResponseBodyJobListJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  ListJobResponseBodyJobListJobOutputVideoBitrateBnd() {}

  explicit ListJobResponseBodyJobListJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputVideoBitrateBnd() = default;
};
class ListJobResponseBodyJobListJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<ListJobResponseBodyJobListJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputVideo() {}

  explicit ListJobResponseBodyJobListJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        ListJobResponseBodyJobListJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<ListJobResponseBodyJobListJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputVideo() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> referPos{};
  shared_ptr<string> type{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark>> waterMark{};

  ListJobResponseBodyJobListJobOutputWaterMarkList() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkList() = default;
};
class ListJobResponseBodyJobListJobOutput : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<ListJobResponseBodyJobListJobOutputClip> clip{};
  shared_ptr<ListJobResponseBodyJobListJobOutputContainer> container{};
  shared_ptr<string> deWatermark{};
  shared_ptr<ListJobResponseBodyJobListJobOutputEncryption> encryption{};
  shared_ptr<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMergeList> mergeList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfig> muxConfig{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOpeningList> openingList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<ListJobResponseBodyJobListJobOutputProperties> properties{};
  shared_ptr<string> rotate{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSuperReso> superReso{};
  shared_ptr<ListJobResponseBodyJobListJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<ListJobResponseBodyJobListJobOutputTransConfig> transConfig{};
  shared_ptr<string> userData{};
  shared_ptr<ListJobResponseBodyJobListJobOutputVideo> video{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<ListJobResponseBodyJobListJobOutputWaterMarkList> waterMarkList{};

  ListJobResponseBodyJobListJobOutput() {}

  explicit ListJobResponseBodyJobListJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        ListJobResponseBodyJobListJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<ListJobResponseBodyJobListJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        ListJobResponseBodyJobListJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<ListJobResponseBodyJobListJobOutputClip>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        ListJobResponseBodyJobListJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<ListJobResponseBodyJobListJobOutputContainer>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        ListJobResponseBodyJobListJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<ListJobResponseBodyJobListJobOutputEncryption>(model1);
      }
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        ListJobResponseBodyJobListJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<ListJobResponseBodyJobListJobOutputMergeList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<ListJobResponseBodyJobListJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        ListJobResponseBodyJobListJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<ListJobResponseBodyJobListJobOutputOpeningList>(model1);
      }
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<ListJobResponseBodyJobListJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        ListJobResponseBodyJobListJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<ListJobResponseBodyJobListJobOutputOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        ListJobResponseBodyJobListJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<ListJobResponseBodyJobListJobOutputProperties>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        ListJobResponseBodyJobListJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<ListJobResponseBodyJobListJobOutputSuperReso>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        ListJobResponseBodyJobListJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<ListJobResponseBodyJobListJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        ListJobResponseBodyJobListJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<ListJobResponseBodyJobListJobOutputTransConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        ListJobResponseBodyJobListJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<ListJobResponseBodyJobListJobOutputVideo>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        ListJobResponseBodyJobListJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<ListJobResponseBodyJobListJobOutputWaterMarkList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutput() = default;
};
class ListJobResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<ListJobResponseBodyJobListJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<ListJobResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<ListJobResponseBodyJobListJobOutput> output{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};

  ListJobResponseBodyJobListJob() {}

  explicit ListJobResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListJobResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListJobResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        ListJobResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<ListJobResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListJobResponseBodyJobListJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListJobResponseBodyJobListJobOutput>(model1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJob() = default;
};
class ListJobResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJob>> job{};

  ListJobResponseBodyJobList() {}

  explicit ListJobResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<ListJobResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<ListJobResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobList() = default;
};
class ListJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobList> jobList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListJobResponseBody() {}

  explicit ListJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        ListJobResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<ListJobResponseBodyJobList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListJobResponseBody() = default;
};
class ListJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJobResponseBody> body{};

  ListJobResponse() {}

  explicit ListJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobResponse() = default;
};
class ListMediaWorkflowExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputFileURL{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListMediaWorkflowExecutionsRequest() {}

  explicit ListMediaWorkflowExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFileURL) {
      res["InputFileURL"] = boost::any(*inputFileURL);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFileURL") != m.end() && !m["InputFileURL"].empty()) {
      inputFileURL = make_shared<string>(boost::any_cast<string>(m["InputFileURL"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsRequest() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> jobId{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>> activity{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activity) {
      vector<boost::any> temp1;
      for(auto item1:*activity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activity") != m.end() && !m["Activity"].empty()) {
      if (typeid(vector<boost::any>) == m["Activity"].type()) {
        vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activity = make_shared<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>>(expect1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput : public Darabonba::Model {
public:
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile> inputFile{};
  shared_ptr<string> userData{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution : public Darabonba::Model {
public:
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList> activityList{};
  shared_ptr<string> creationTime{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput> input{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> runId{};
  shared_ptr<string> state{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityList) {
      res["ActivityList"] = activityList ? boost::any(activityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityList") != m.end() && !m["ActivityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityList"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityList"]));
        activityList = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["RunId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>> mediaWorkflowExecution{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecution) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflowExecution){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflowExecution"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecution") != m.end() && !m["MediaWorkflowExecution"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflowExecution"].type()) {
        vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflowExecution"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflowExecution = make_shared<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>>(expect1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList() = default;
};
class ListMediaWorkflowExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList> mediaWorkflowExecutionList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListMediaWorkflowExecutionsResponseBody() {}

  explicit ListMediaWorkflowExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecutionList) {
      res["MediaWorkflowExecutionList"] = mediaWorkflowExecutionList ? boost::any(mediaWorkflowExecutionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecutionList") != m.end() && !m["MediaWorkflowExecutionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowExecutionList"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowExecutionList"]));
        mediaWorkflowExecutionList = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBody() = default;
};
class ListMediaWorkflowExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBody> body{};

  ListMediaWorkflowExecutionsResponse() {}

  explicit ListMediaWorkflowExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaWorkflowExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaWorkflowExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponse() = default;
};
class QueryAnalysisJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> analysisJobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryAnalysisJobListRequest() {}

  explicit QueryAnalysisJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJobIds) {
      res["AnalysisJobIds"] = boost::any(*analysisJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJobIds") != m.end() && !m["AnalysisJobIds"].empty()) {
      analysisJobIds = make_shared<string>(boost::any_cast<string>(m["AnalysisJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryAnalysisJobListRequest() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> left{};
  shared_ptr<string> mode{};
  shared_ptr<string> top{};
  shared_ptr<string> width{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop> crop{};
  shared_ptr<string> deinterlace{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (crop) {
      res["Crop"] = crop ? boost::any(crop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deinterlace) {
      res["Deinterlace"] = boost::any(*deinterlace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Crop"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Crop"]));
        crop = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop>(model1);
      }
    }
    if (m.find("Deinterlace") != m.end() && !m["Deinterlace"].empty()) {
      deinterlace = make_shared<string>(boost::any_cast<string>(m["Deinterlace"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl : public Darabonba::Model {
public:
  shared_ptr<string> methodStreaming{};
  shared_ptr<string> rateQuality{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodStreaming) {
      res["MethodStreaming"] = boost::any(*methodStreaming);
    }
    if (rateQuality) {
      res["RateQuality"] = boost::any(*rateQuality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodStreaming") != m.end() && !m["MethodStreaming"].empty()) {
      methodStreaming = make_shared<string>(boost::any_cast<string>(m["MethodStreaming"]));
    }
    if (m.find("RateQuality") != m.end() && !m["RateQuality"].empty()) {
      rateQuality = make_shared<string>(boost::any_cast<string>(m["RateQuality"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl> propertiesControl{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl> qualityControl{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertiesControl) {
      res["PropertiesControl"] = propertiesControl ? boost::any(propertiesControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (qualityControl) {
      res["QualityControl"] = qualityControl ? boost::any(qualityControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertiesControl") != m.end() && !m["PropertiesControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertiesControl"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertiesControl"]));
        propertiesControl = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl>(model1);
      }
    }
    if (m.find("QualityControl") != m.end() && !m["QualityControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["QualityControl"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QualityControl"]));
        qualityControl = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> loop{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment> segment{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> transMode{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio> audio{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo> video{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate>> template_{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig> analysisConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile> inputFile{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> state{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList> templateList{};
  shared_ptr<string> userData{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisConfig) {
      res["AnalysisConfig"] = analysisConfig ? boost::any(analysisConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisConfig"]));
        analysisConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob>> analysisJob{};

  QueryAnalysisJobListResponseBodyAnalysisJobList() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJob) {
      vector<boost::any> temp1;
      for(auto item1:*analysisJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnalysisJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJob") != m.end() && !m["AnalysisJob"].empty()) {
      if (typeid(vector<boost::any>) == m["AnalysisJob"].type()) {
        vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnalysisJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        analysisJob = make_shared<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob>>(expect1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobList() = default;
};
class QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds() {}

  explicit QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds() = default;
};
class QueryAnalysisJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobList> analysisJobList{};
  shared_ptr<QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds> nonExistAnalysisJobIds{};
  shared_ptr<string> requestId{};

  QueryAnalysisJobListResponseBody() {}

  explicit QueryAnalysisJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJobList) {
      res["AnalysisJobList"] = analysisJobList ? boost::any(analysisJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistAnalysisJobIds) {
      res["NonExistAnalysisJobIds"] = nonExistAnalysisJobIds ? boost::any(nonExistAnalysisJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJobList") != m.end() && !m["AnalysisJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisJobList"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisJobList"]));
        analysisJobList = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobList>(model1);
      }
    }
    if (m.find("NonExistAnalysisJobIds") != m.end() && !m["NonExistAnalysisJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistAnalysisJobIds"].type()) {
        QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistAnalysisJobIds"]));
        nonExistAnalysisJobIds = make_shared<QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBody() = default;
};
class QueryAnalysisJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAnalysisJobListResponseBody> body{};

  QueryAnalysisJobListResponse() {}

  explicit QueryAnalysisJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAnalysisJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAnalysisJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponse() = default;
};
class QueryFpDBDeleteJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryFpDBDeleteJobListRequest() {}

  explicit QueryFpDBDeleteJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryFpDBDeleteJobListRequest() = default;
};
class QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> delType{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};

  QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob() {}

  explicit QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (delType) {
      res["DelType"] = boost::any(*delType);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DelType") != m.end() && !m["DelType"].empty()) {
      delType = make_shared<string>(boost::any_cast<string>(m["DelType"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob() = default;
};
class QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob>> fpDBDeleteJob{};

  QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList() {}

  explicit QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpDBDeleteJob) {
      vector<boost::any> temp1;
      for(auto item1:*fpDBDeleteJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpDBDeleteJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpDBDeleteJob") != m.end() && !m["FpDBDeleteJob"].empty()) {
      if (typeid(vector<boost::any>) == m["FpDBDeleteJob"].type()) {
        vector<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpDBDeleteJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpDBDeleteJob = make_shared<vector<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob>>(expect1);
      }
    }
  }


  virtual ~QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList() = default;
};
class QueryFpDBDeleteJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFpDBDeleteJobListResponseBodyNonExistIds() {}

  explicit QueryFpDBDeleteJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFpDBDeleteJobListResponseBodyNonExistIds() = default;
};
class QueryFpDBDeleteJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList> fpDBDeleteJobList{};
  shared_ptr<QueryFpDBDeleteJobListResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<string> requestId{};

  QueryFpDBDeleteJobListResponseBody() {}

  explicit QueryFpDBDeleteJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpDBDeleteJobList) {
      res["FpDBDeleteJobList"] = fpDBDeleteJobList ? boost::any(fpDBDeleteJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpDBDeleteJobList") != m.end() && !m["FpDBDeleteJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpDBDeleteJobList"].type()) {
        QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpDBDeleteJobList"]));
        fpDBDeleteJobList = make_shared<QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryFpDBDeleteJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryFpDBDeleteJobListResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryFpDBDeleteJobListResponseBody() = default;
};
class QueryFpDBDeleteJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryFpDBDeleteJobListResponseBody> body{};

  QueryFpDBDeleteJobListResponse() {}

  explicit QueryFpDBDeleteJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFpDBDeleteJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFpDBDeleteJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFpDBDeleteJobListResponse() = default;
};
class QueryFpFileDeleteJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryFpFileDeleteJobListRequest() {}

  explicit QueryFpFileDeleteJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryFpFileDeleteJobListRequest() = default;
};
class QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> fileIds{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};

  QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob() {}

  explicit QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob() = default;
};
class QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob>> fpFileDeleteJob{};

  QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList() {}

  explicit QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpFileDeleteJob) {
      vector<boost::any> temp1;
      for(auto item1:*fpFileDeleteJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpFileDeleteJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpFileDeleteJob") != m.end() && !m["FpFileDeleteJob"].empty()) {
      if (typeid(vector<boost::any>) == m["FpFileDeleteJob"].type()) {
        vector<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpFileDeleteJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpFileDeleteJob = make_shared<vector<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob>>(expect1);
      }
    }
  }


  virtual ~QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList() = default;
};
class QueryFpFileDeleteJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFpFileDeleteJobListResponseBodyNonExistIds() {}

  explicit QueryFpFileDeleteJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFpFileDeleteJobListResponseBodyNonExistIds() = default;
};
class QueryFpFileDeleteJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList> fpFileDeleteJobList{};
  shared_ptr<QueryFpFileDeleteJobListResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<string> requestId{};

  QueryFpFileDeleteJobListResponseBody() {}

  explicit QueryFpFileDeleteJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpFileDeleteJobList) {
      res["FpFileDeleteJobList"] = fpFileDeleteJobList ? boost::any(fpFileDeleteJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpFileDeleteJobList") != m.end() && !m["FpFileDeleteJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpFileDeleteJobList"].type()) {
        QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpFileDeleteJobList"]));
        fpFileDeleteJobList = make_shared<QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryFpFileDeleteJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryFpFileDeleteJobListResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryFpFileDeleteJobListResponseBody() = default;
};
class QueryFpFileDeleteJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryFpFileDeleteJobListResponseBody> body{};

  QueryFpFileDeleteJobListResponse() {}

  explicit QueryFpFileDeleteJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFpFileDeleteJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFpFileDeleteJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFpFileDeleteJobListResponse() = default;
};
class QueryFpShotJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> jobIds{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> state{};

  QueryFpShotJobListRequest() {}

  explicit QueryFpShotJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryFpShotJobListRequest() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig : public Darabonba::Model {
public:
  shared_ptr<string> fpDBId{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> saveType{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication> duplication{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput> input{};
  shared_ptr<string> similarity{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duplication) {
      res["Duplication"] = duplication ? boost::any(duplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duplication") != m.end() && !m["Duplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["Duplication"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Duplication"]));
        duplication = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication>(model1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput>(model1);
      }
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice>> fpShotSlice{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotSlice) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotSlice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotSlice"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotSlice") != m.end() && !m["FpShotSlice"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotSlice"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotSlice"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotSlice = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices> fpShotSlices{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> similarity{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotSlices) {
      res["FpShotSlices"] = fpShotSlices ? boost::any(fpShotSlices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotSlices") != m.end() && !m["FpShotSlices"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotSlices"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotSlices"]));
        fpShotSlices = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices>(model1);
      }
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot>> fpShot{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShot) {
      vector<boost::any> temp1;
      for(auto item1:*fpShot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShot") != m.end() && !m["FpShot"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShot"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShot = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication> duplication{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput> input{};
  shared_ptr<string> similarity{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duplication) {
      res["Duplication"] = duplication ? boost::any(duplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duplication") != m.end() && !m["Duplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["Duplication"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Duplication"]));
        duplication = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication>(model1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput>(model1);
      }
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice>> fpShotSlice{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotSlice) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotSlice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotSlice"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotSlice") != m.end() && !m["FpShotSlice"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotSlice"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotSlice"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotSlice = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices> fpShotSlices{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> similarity{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotSlices) {
      res["FpShotSlices"] = fpShotSlices ? boost::any(fpShotSlices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotSlices") != m.end() && !m["FpShotSlices"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotSlices"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotSlices"]));
        fpShotSlices = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices>(model1);
      }
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot>> fpShot{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShot) {
      vector<boost::any> temp1;
      for(auto item1:*fpShot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShot") != m.end() && !m["FpShot"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShot"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShot = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice : public Darabonba::Model {
public:
  shared_ptr<string> duplicationText{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment> inputFragment{};
  shared_ptr<string> inputText{};
  shared_ptr<string> similarity{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duplicationText) {
      res["DuplicationText"] = boost::any(*duplicationText);
    }
    if (inputFragment) {
      res["InputFragment"] = inputFragment ? boost::any(inputFragment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputText) {
      res["InputText"] = boost::any(*inputText);
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DuplicationText") != m.end() && !m["DuplicationText"].empty()) {
      duplicationText = make_shared<string>(boost::any_cast<string>(m["DuplicationText"]));
    }
    if (m.find("InputFragment") != m.end() && !m["InputFragment"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFragment"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFragment"]));
        inputFragment = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment>(model1);
      }
    }
    if (m.find("InputText") != m.end() && !m["InputText"].empty()) {
      inputText = make_shared<string>(boost::any_cast<string>(m["InputText"]));
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice>> textFpShotSlice{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (textFpShotSlice) {
      vector<boost::any> temp1;
      for(auto item1:*textFpShotSlice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextFpShotSlice"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TextFpShotSlice") != m.end() && !m["TextFpShotSlice"].empty()) {
      if (typeid(vector<boost::any>) == m["TextFpShotSlice"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextFpShotSlice"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textFpShotSlice = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot : public Darabonba::Model {
public:
  shared_ptr<string> primaryKey{};
  shared_ptr<string> similarity{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices> textFpShotSlices{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    if (textFpShotSlices) {
      res["TextFpShotSlices"] = textFpShotSlices ? boost::any(textFpShotSlices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
    if (m.find("TextFpShotSlices") != m.end() && !m["TextFpShotSlices"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextFpShotSlices"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextFpShotSlices"]));
        textFpShotSlices = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices>(model1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot>> textFpShot{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (textFpShot) {
      vector<boost::any> temp1;
      for(auto item1:*textFpShot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextFpShot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TextFpShot") != m.end() && !m["TextFpShot"].empty()) {
      if (typeid(vector<boost::any>) == m["TextFpShot"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextFpShot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textFpShot = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots> audioFpShots{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots> fpShots{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots> textFpShots{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFpShots) {
      res["AudioFpShots"] = audioFpShots ? boost::any(audioFpShots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fpShots) {
      res["FpShots"] = fpShots ? boost::any(fpShots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textFpShots) {
      res["TextFpShots"] = textFpShots ? boost::any(textFpShots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFpShots") != m.end() && !m["AudioFpShots"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioFpShots"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioFpShots"]));
        audioFpShots = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots>(model1);
      }
    }
    if (m.find("FpShots") != m.end() && !m["FpShots"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShots"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShots"]));
        fpShots = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots>(model1);
      }
    }
    if (m.find("TextFpShots") != m.end() && !m["TextFpShots"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextFpShots"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextFpShots"]));
        textFpShots = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots>(model1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobListFpShotJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<long> duration{};
  shared_ptr<string> fileId{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig> fpShotConfig{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult> fpShotResult{};
  shared_ptr<string> id{};
  shared_ptr<string> input{};
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile> inputFile{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  QueryFpShotJobListResponseBodyFpShotJobListFpShotJob() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobListFpShotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (fpShotConfig) {
      res["FpShotConfig"] = fpShotConfig ? boost::any(fpShotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fpShotResult) {
      res["FpShotResult"] = fpShotResult ? boost::any(fpShotResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("FpShotConfig") != m.end() && !m["FpShotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotConfig"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotConfig"]));
        fpShotConfig = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig>(model1);
      }
    }
    if (m.find("FpShotResult") != m.end() && !m["FpShotResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotResult"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotResult"]));
        fpShotResult = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobListFpShotJob() = default;
};
class QueryFpShotJobListResponseBodyFpShotJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJob>> fpShotJob{};

  QueryFpShotJobListResponseBodyFpShotJobList() {}

  explicit QueryFpShotJobListResponseBodyFpShotJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotJob) {
      vector<boost::any> temp1;
      for(auto item1:*fpShotJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FpShotJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotJob") != m.end() && !m["FpShotJob"].empty()) {
      if (typeid(vector<boost::any>) == m["FpShotJob"].type()) {
        vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FpShotJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryFpShotJobListResponseBodyFpShotJobListFpShotJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fpShotJob = make_shared<vector<QueryFpShotJobListResponseBodyFpShotJobListFpShotJob>>(expect1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponseBodyFpShotJobList() = default;
};
class QueryFpShotJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryFpShotJobListResponseBodyNonExistIds() {}

  explicit QueryFpShotJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryFpShotJobListResponseBodyNonExistIds() = default;
};
class QueryFpShotJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryFpShotJobListResponseBodyFpShotJobList> fpShotJobList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryFpShotJobListResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<string> requestId{};

  QueryFpShotJobListResponseBody() {}

  explicit QueryFpShotJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotJobList) {
      res["FpShotJobList"] = fpShotJobList ? boost::any(fpShotJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotJobList") != m.end() && !m["FpShotJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FpShotJobList"].type()) {
        QueryFpShotJobListResponseBodyFpShotJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FpShotJobList"]));
        fpShotJobList = make_shared<QueryFpShotJobListResponseBodyFpShotJobList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryFpShotJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryFpShotJobListResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryFpShotJobListResponseBody() = default;
};
class QueryFpShotJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryFpShotJobListResponseBody> body{};

  QueryFpShotJobListResponse() {}

  explicit QueryFpShotJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFpShotJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFpShotJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFpShotJobListResponse() = default;
};
class QueryIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryIProductionJobRequest() {}

  explicit QueryIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryIProductionJobRequest() = default;
};
class QueryIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<string> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  QueryIProductionJobResponseBody() {}

  explicit QueryIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryIProductionJobResponseBody() = default;
};
class QueryIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryIProductionJobResponseBody> body{};

  QueryIProductionJobResponse() {}

  explicit QueryIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIProductionJobResponse() = default;
};
class QueryJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryJobListRequest() {}

  explicit QueryJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryJobListRequest() = default;
};
class QueryJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryJobListResponseBodyJobListJobInput() {}

  explicit QueryJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobInput() = default;
};
class QueryJobListResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryJobListResponseBodyJobListJobMNSMessageResult() {}

  explicit QueryJobListResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobMNSMessageResult() = default;
};
class QueryJobListResponseBodyJobListJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  QueryJobListResponseBodyJobListJobOutputAudioVolume() {}

  explicit QueryJobListResponseBodyJobListJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputAudioVolume() = default;
};
class QueryJobListResponseBodyJobListJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputAudioVolume> volume{};

  QueryJobListResponseBodyJobListJobOutputAudio() {}

  explicit QueryJobListResponseBodyJobListJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        QueryJobListResponseBodyJobListJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<QueryJobListResponseBodyJobListJobOutputAudioVolume>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputAudio() = default;
};
class QueryJobListResponseBodyJobListJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> seek{};

  QueryJobListResponseBodyJobListJobOutputClipTimeSpan() {}

  explicit QueryJobListResponseBodyJobListJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputClipTimeSpan() = default;
};
class QueryJobListResponseBodyJobListJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputClipTimeSpan> timeSpan{};

  QueryJobListResponseBodyJobListJobOutputClip() {}

  explicit QueryJobListResponseBodyJobListJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        QueryJobListResponseBodyJobListJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<QueryJobListResponseBodyJobListJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputClip() = default;
};
class QueryJobListResponseBodyJobListJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryJobListResponseBodyJobListJobOutputContainer() {}

  explicit QueryJobListResponseBodyJobListJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputContainer() = default;
};
class QueryJobListResponseBodyJobListJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};
  shared_ptr<string> type{};

  QueryJobListResponseBodyJobListJobOutputEncryption() {}

  explicit QueryJobListResponseBodyJobListJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputEncryption() = default;
};
class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> md5Support{};
  shared_ptr<bool> sizeSupport{};

  QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS() {}

  explicit QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS() = default;
};
class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS> TS{};

  QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport() {}

  explicit QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport() = default;
};
class QueryJobListResponseBodyJobListJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> start{};

  QueryJobListResponseBodyJobListJobOutputMergeListMerge() {}

  explicit QueryJobListResponseBodyJobListJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMergeListMerge() = default;
};
class QueryJobListResponseBodyJobListJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge>> merge{};

  QueryJobListResponseBodyJobListJobOutputMergeList() {}

  explicit QueryJobListResponseBodyJobListJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMergeList() = default;
};
class QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> downgradePolicy{};
  shared_ptr<double> duration{};
  shared_ptr<string> enable{};
  shared_ptr<string> message{};
  shared_ptr<double> realSpeed{};
  shared_ptr<long> settingSpeed{};
  shared_ptr<double> timeCost{};

  QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo() {}

  explicit QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (downgradePolicy) {
      res["DowngradePolicy"] = boost::any(*downgradePolicy);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (realSpeed) {
      res["RealSpeed"] = boost::any(*realSpeed);
    }
    if (settingSpeed) {
      res["SettingSpeed"] = boost::any(*settingSpeed);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DowngradePolicy") != m.end() && !m["DowngradePolicy"].empty()) {
      downgradePolicy = make_shared<string>(boost::any_cast<string>(m["DowngradePolicy"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RealSpeed") != m.end() && !m["RealSpeed"].empty()) {
      realSpeed = make_shared<double>(boost::any_cast<double>(m["RealSpeed"]));
    }
    if (m.find("SettingSpeed") != m.end() && !m["SettingSpeed"].empty()) {
      settingSpeed = make_shared<long>(boost::any_cast<long>(m["SettingSpeed"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<double>(boost::any_cast<double>(m["TimeCost"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigGif() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigGif() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigSegment() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigSegment() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigWebp() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigWebp() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigGif> gif{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigSegment> segment{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigWebp> webp{};

  QueryJobListResponseBodyJobListJobOutputMuxConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> openUrl{};

  QueryJobListResponseBodyJobListJobOutputOpeningListOpening() {}

  explicit QueryJobListResponseBodyJobListJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOpeningListOpening() = default;
};
class QueryJobListResponseBodyJobListJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening>> opening{};

  QueryJobListResponseBodyJobListJobOutputOpeningList() {}

  explicit QueryJobListResponseBodyJobListJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOpeningList() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<string> message{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QueryJobListResponseBodyJobListJobOutputOutputFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutputFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryJobListResponseBodyJobListJobOutputPropertiesFormat() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesFormat() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo : public Darabonba::Model {
public:
  shared_ptr<string> source{};

  QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo>> sourceLogo{};

  QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceLogo) {
      vector<boost::any> temp1;
      for(auto item1:*sourceLogo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceLogo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceLogo") != m.end() && !m["SourceLogo"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceLogo"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceLogo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceLogo = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};
  shared_ptr<string> bitsPerRawSample{};
  shared_ptr<string> colorPrimaries{};
  shared_ptr<string> colorTransfer{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (bitsPerRawSample) {
      res["bitsPerRawSample"] = boost::any(*bitsPerRawSample);
    }
    if (colorPrimaries) {
      res["colorPrimaries"] = boost::any(*colorPrimaries);
    }
    if (colorTransfer) {
      res["colorTransfer"] = boost::any(*colorTransfer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("bitsPerRawSample") != m.end() && !m["bitsPerRawSample"].empty()) {
      bitsPerRawSample = make_shared<string>(boost::any_cast<string>(m["bitsPerRawSample"]));
    }
    if (m.find("colorPrimaries") != m.end() && !m["colorPrimaries"].empty()) {
      colorPrimaries = make_shared<string>(boost::any_cast<string>(m["colorPrimaries"]));
    }
    if (m.find("colorTransfer") != m.end() && !m["colorTransfer"].empty()) {
      colorTransfer = make_shared<string>(boost::any_cast<string>(m["colorTransfer"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreams() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreams() = default;
};
class QueryJobListResponseBodyJobListJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos> sourceLogos{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreams> streams{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputProperties() {}

  explicit QueryJobListResponseBodyJobListJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (sourceLogos) {
      res["SourceLogos"] = sourceLogos ? boost::any(sourceLogos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("SourceLogos") != m.end() && !m["SourceLogos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceLogos"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceLogos"]));
        sourceLogos = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos>(model1);
      }
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputProperties() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList> subtitleList{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  QueryJobListResponseBodyJobListJobOutputSuperReso() {}

  explicit QueryJobListResponseBodyJobListJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSuperReso() = default;
};
class QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> height{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> start{};
  shared_ptr<string> tailUrl{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate() {}

  explicit QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate() = default;
};
class QueryJobListResponseBodyJobListJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate>> tailSlate{};

  QueryJobListResponseBodyJobListJobOutputTailSlateList() {}

  explicit QueryJobListResponseBodyJobListJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTailSlateList() = default;
};
class QueryJobListResponseBodyJobListJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  QueryJobListResponseBodyJobListJobOutputTransConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTransConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd() {}

  explicit QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd() = default;
};
class QueryJobListResponseBodyJobListJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputVideo() {}

  explicit QueryJobListResponseBodyJobListJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputVideo() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> referPos{};
  shared_ptr<string> type{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark>> waterMark{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkList() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkList() = default;
};
class QueryJobListResponseBodyJobListJobOutput : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputClip> clip{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputContainer> container{};
  shared_ptr<string> deWatermark{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputEncryption> encryption{};
  shared_ptr<string> extendData{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMergeList> mergeList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo> multiSpeedInfo{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfig> muxConfig{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOpeningList> openingList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputProperties> properties{};
  shared_ptr<string> rotate{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSuperReso> superReso{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputTransConfig> transConfig{};
  shared_ptr<string> userData{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputVideo> video{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputWaterMarkList> waterMarkList{};

  QueryJobListResponseBodyJobListJobOutput() {}

  explicit QueryJobListResponseBodyJobListJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendData) {
      res["ExtendData"] = boost::any(*extendData);
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (multiSpeedInfo) {
      res["MultiSpeedInfo"] = multiSpeedInfo ? boost::any(multiSpeedInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryJobListResponseBodyJobListJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryJobListResponseBodyJobListJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        QueryJobListResponseBodyJobListJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<QueryJobListResponseBodyJobListJobOutputClip>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryJobListResponseBodyJobListJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryJobListResponseBodyJobListJobOutputContainer>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        QueryJobListResponseBodyJobListJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<QueryJobListResponseBodyJobListJobOutputEncryption>(model1);
      }
    }
    if (m.find("ExtendData") != m.end() && !m["ExtendData"].empty()) {
      extendData = make_shared<string>(boost::any_cast<string>(m["ExtendData"]));
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        QueryJobListResponseBodyJobListJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<QueryJobListResponseBodyJobListJobOutputMergeList>(model1);
      }
    }
    if (m.find("MultiSpeedInfo") != m.end() && !m["MultiSpeedInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MultiSpeedInfo"].type()) {
        QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MultiSpeedInfo"]));
        multiSpeedInfo = make_shared<QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        QueryJobListResponseBodyJobListJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<QueryJobListResponseBodyJobListJobOutputOpeningList>(model1);
      }
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryJobListResponseBodyJobListJobOutputOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryJobListResponseBodyJobListJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryJobListResponseBodyJobListJobOutputProperties>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        QueryJobListResponseBodyJobListJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<QueryJobListResponseBodyJobListJobOutputSuperReso>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        QueryJobListResponseBodyJobListJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<QueryJobListResponseBodyJobListJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryJobListResponseBodyJobListJobOutputTransConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryJobListResponseBodyJobListJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryJobListResponseBodyJobListJobOutputVideo>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        QueryJobListResponseBodyJobListJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<QueryJobListResponseBodyJobListJobOutputWaterMarkList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutput() = default;
};
class QueryJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryJobListResponseBodyJobListJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryJobListResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutput> output{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};
  shared_ptr<string> submitTime{};

  QueryJobListResponseBodyJobListJob() {}

  explicit QueryJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryJobListResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryJobListResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        QueryJobListResponseBodyJobListJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<QueryJobListResponseBodyJobListJobOutput>(model1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJob() = default;
};
class QueryJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJob>> job{};

  QueryJobListResponseBodyJobList() {}

  explicit QueryJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobList() = default;
};
class QueryJobListResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryJobListResponseBodyNonExistJobIds() {}

  explicit QueryJobListResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryJobListResponseBodyNonExistJobIds() = default;
};
class QueryJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryJobListResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};

  QueryJobListResponseBody() {}

  explicit QueryJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QueryJobListResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QueryJobListResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryJobListResponseBody() = default;
};
class QueryJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryJobListResponseBody> body{};

  QueryJobListResponse() {}

  explicit QueryJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobListResponse() = default;
};
class QueryMediaCensorJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaCensorJobDetailRequest() {}

  explicit QueryMediaCensorJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailRequest() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> label{};
  shared_ptr<long> startTime{};
  shared_ptr<string> text{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult>> audioDetailResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioDetailResult) {
      vector<boost::any> temp1;
      for(auto item1:*audioDetailResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioDetailResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioDetailResult") != m.end() && !m["AudioDetailResult"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioDetailResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioDetailResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioDetailResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList> audioDetailResultList{};
  shared_ptr<string> label{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioDetailResultList) {
      res["AudioDetailResultList"] = audioDetailResultList ? boost::any(audioDetailResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioDetailResultList") != m.end() && !m["AudioDetailResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioDetailResultList"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioDetailResultList"]));
        audioDetailResultList = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList>(model1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult>> result{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults> results{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult>> coverImageCensorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverImageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*coverImageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverImageCensorResult") != m.end() && !m["CoverImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverImageCensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverImageCensorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults> censorResults{};
  shared_ptr<string> object{};
  shared_ptr<string> timestamp{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults>(model1);
      }
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline>> videoTimeline{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimeline) {
      vector<boost::any> temp1;
      for(auto item1:*videoTimeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoTimeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimeline") != m.end() && !m["VideoTimeline"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoTimeline"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoTimeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoTimeline = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults> censorResults{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines> videoTimelines{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (videoTimelines) {
      res["VideoTimelines"] = videoTimelines ? boost::any(videoTimelines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("VideoTimelines") != m.end() && !m["VideoTimelines"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTimelines"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTimelines"]));
        videoTimelines = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile> outputFile{};
  shared_ptr<string> videoCensor{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensor) {
      res["VideoCensor"] = boost::any(*videoCensor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("VideoCensor") != m.end() && !m["VideoCensor"].empty()) {
      videoCensor = make_shared<string>(boost::any_cast<string>(m["VideoCensor"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult> audioCensorResult{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult> barrageCensorResult{};
  shared_ptr<string> code{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults> coverImageCensorResults{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult> descCensorResult{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};
  shared_ptr<string> suggestion{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult> titleCensorResult{};
  shared_ptr<string> userData{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult> vensorCensorResult{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig> videoCensorConfig{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioCensorResult) {
      res["AudioCensorResult"] = audioCensorResult ? boost::any(audioCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = barrageCensorResult ? boost::any(barrageCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (coverImageCensorResults) {
      res["CoverImageCensorResults"] = coverImageCensorResults ? boost::any(coverImageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (descCensorResult) {
      res["DescCensorResult"] = descCensorResult ? boost::any(descCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = titleCensorResult ? boost::any(titleCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vensorCensorResult) {
      res["VensorCensorResult"] = vensorCensorResult ? boost::any(vensorCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = videoCensorConfig ? boost::any(videoCensorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioCensorResult") != m.end() && !m["AudioCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioCensorResult"]));
        audioCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult>(model1);
      }
    }
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["BarrageCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BarrageCensorResult"]));
        barrageCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CoverImageCensorResults") != m.end() && !m["CoverImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverImageCensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverImageCensorResults"]));
        coverImageCensorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescCensorResult"]));
        descCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TitleCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TitleCensorResult"]));
        titleCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VensorCensorResult") != m.end() && !m["VensorCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VensorCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VensorCensorResult"]));
        vensorCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult>(model1);
      }
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCensorConfig"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCensorConfig"]));
        videoCensorConfig = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail() = default;
};
class QueryMediaCensorJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail> mediaCensorJobDetail{};
  shared_ptr<string> requestId{};

  QueryMediaCensorJobDetailResponseBody() {}

  explicit QueryMediaCensorJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJobDetail) {
      res["MediaCensorJobDetail"] = mediaCensorJobDetail ? boost::any(mediaCensorJobDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJobDetail") != m.end() && !m["MediaCensorJobDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaCensorJobDetail"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaCensorJobDetail"]));
        mediaCensorJobDetail = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBody() = default;
};
class QueryMediaCensorJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaCensorJobDetailResponseBody> body{};

  QueryMediaCensorJobDetailResponse() {}

  explicit QueryMediaCensorJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaCensorJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaCensorJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponse() = default;
};
class QueryMediaCensorJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> jobIds{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> state{};

  QueryMediaCensorJobListRequest() {}

  explicit QueryMediaCensorJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryMediaCensorJobListRequest() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult>> result{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults> results{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult>> coverImageCensorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverImageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*coverImageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverImageCensorResult") != m.end() && !m["CoverImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverImageCensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverImageCensorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults> censorResults{};
  shared_ptr<string> object{};
  shared_ptr<string> timestamp{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults>(model1);
      }
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline>> videoTimeline{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimeline) {
      vector<boost::any> temp1;
      for(auto item1:*videoTimeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoTimeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimeline") != m.end() && !m["VideoTimeline"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoTimeline"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoTimeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoTimeline = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults> censorResults{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines> videoTimelines{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (videoTimelines) {
      res["VideoTimelines"] = videoTimelines ? boost::any(videoTimelines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("VideoTimelines") != m.end() && !m["VideoTimelines"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTimelines"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTimelines"]));
        videoTimelines = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile> outputFile{};
  shared_ptr<string> videoCensor{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensor) {
      res["VideoCensor"] = boost::any(*videoCensor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("VideoCensor") != m.end() && !m["VideoCensor"].empty()) {
      videoCensor = make_shared<string>(boost::any_cast<string>(m["VideoCensor"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult> audioCensorResult{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult> barrageCensorResult{};
  shared_ptr<string> code{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults> coverImageCensorResults{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult> descCensorResult{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};
  shared_ptr<string> suggestion{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult> titleCensorResult{};
  shared_ptr<string> userData{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult> vensorCensorResult{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig> videoCensorConfig{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioCensorResult) {
      res["AudioCensorResult"] = audioCensorResult ? boost::any(audioCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = barrageCensorResult ? boost::any(barrageCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (coverImageCensorResults) {
      res["CoverImageCensorResults"] = coverImageCensorResults ? boost::any(coverImageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (descCensorResult) {
      res["DescCensorResult"] = descCensorResult ? boost::any(descCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = titleCensorResult ? boost::any(titleCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vensorCensorResult) {
      res["VensorCensorResult"] = vensorCensorResult ? boost::any(vensorCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = videoCensorConfig ? boost::any(videoCensorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioCensorResult") != m.end() && !m["AudioCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioCensorResult"]));
        audioCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult>(model1);
      }
    }
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["BarrageCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BarrageCensorResult"]));
        barrageCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CoverImageCensorResults") != m.end() && !m["CoverImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverImageCensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverImageCensorResults"]));
        coverImageCensorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescCensorResult"]));
        descCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TitleCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TitleCensorResult"]));
        titleCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VensorCensorResult") != m.end() && !m["VensorCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VensorCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VensorCensorResult"]));
        vensorCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult>(model1);
      }
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCensorConfig"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCensorConfig"]));
        videoCensorConfig = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob>> mediaCensorJob{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobList() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJob) {
      vector<boost::any> temp1;
      for(auto item1:*mediaCensorJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaCensorJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJob") != m.end() && !m["MediaCensorJob"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaCensorJob"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaCensorJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaCensorJob = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobList() = default;
};
class QueryMediaCensorJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaCensorJobListResponseBodyNonExistIds() {}

  explicit QueryMediaCensorJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyNonExistIds() = default;
};
class QueryMediaCensorJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobList> mediaCensorJobList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobListResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<string> requestId{};

  QueryMediaCensorJobListResponseBody() {}

  explicit QueryMediaCensorJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJobList) {
      res["MediaCensorJobList"] = mediaCensorJobList ? boost::any(mediaCensorJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJobList") != m.end() && !m["MediaCensorJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaCensorJobList"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaCensorJobList"]));
        mediaCensorJobList = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryMediaCensorJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryMediaCensorJobListResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBody() = default;
};
class QueryMediaCensorJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaCensorJobListResponseBody> body{};

  QueryMediaCensorJobListResponse() {}

  explicit QueryMediaCensorJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaCensorJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaCensorJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponse() = default;
};
class QueryMediaInfoJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaInfoJobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaInfoJobListRequest() {}

  explicit QueryMediaInfoJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJobIds) {
      res["MediaInfoJobIds"] = boost::any(*mediaInfoJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJobIds") != m.end() && !m["MediaInfoJobIds"].empty()) {
      mediaInfoJobIds = make_shared<string>(boost::any_cast<string>(m["MediaInfoJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaInfoJobListRequest() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> colorPrimaries{};
  shared_ptr<string> colorRange{};
  shared_ptr<string> colorTransfer{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (colorPrimaries) {
      res["ColorPrimaries"] = boost::any(*colorPrimaries);
    }
    if (colorRange) {
      res["ColorRange"] = boost::any(*colorRange);
    }
    if (colorTransfer) {
      res["ColorTransfer"] = boost::any(*colorTransfer);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("ColorPrimaries") != m.end() && !m["ColorPrimaries"].empty()) {
      colorPrimaries = make_shared<string>(boost::any_cast<string>(m["ColorPrimaries"]));
    }
    if (m.find("ColorRange") != m.end() && !m["ColorRange"].empty()) {
      colorRange = make_shared<string>(boost::any_cast<string>(m["ColorRange"]));
    }
    if (m.find("ColorTransfer") != m.end() && !m["ColorTransfer"].empty()) {
      colorTransfer = make_shared<string>(boost::any_cast<string>(m["ColorTransfer"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList> videoStreamList{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams> streams{};
  shared_ptr<string> width{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties> properties{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob>> mediaInfoJob{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfoJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfoJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfoJob"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfoJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfoJob = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobList() = default;
};
class QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds() {}

  explicit QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds() = default;
};
class QueryMediaInfoJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobList> mediaInfoJobList{};
  shared_ptr<QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds> nonExistMediaInfoJobIds{};
  shared_ptr<string> requestId{};

  QueryMediaInfoJobListResponseBody() {}

  explicit QueryMediaInfoJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJobList) {
      res["MediaInfoJobList"] = mediaInfoJobList ? boost::any(mediaInfoJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistMediaInfoJobIds) {
      res["NonExistMediaInfoJobIds"] = nonExistMediaInfoJobIds ? boost::any(nonExistMediaInfoJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJobList") != m.end() && !m["MediaInfoJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJobList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJobList"]));
        mediaInfoJobList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobList>(model1);
      }
    }
    if (m.find("NonExistMediaInfoJobIds") != m.end() && !m["NonExistMediaInfoJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaInfoJobIds"].type()) {
        QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaInfoJobIds"]));
        nonExistMediaInfoJobIds = make_shared<QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBody() = default;
};
class QueryMediaInfoJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaInfoJobListResponseBody> body{};

  QueryMediaInfoJobListResponse() {}

  explicit QueryMediaInfoJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaInfoJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaInfoJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponse() = default;
};
class QueryMediaListRequest : public Darabonba::Model {
public:
  shared_ptr<bool> includeMediaInfo{};
  shared_ptr<bool> includePlayList{};
  shared_ptr<bool> includeSnapshotList{};
  shared_ptr<bool> includeSummaryList{};
  shared_ptr<string> mediaIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaListRequest() {}

  explicit QueryMediaListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includeMediaInfo) {
      res["IncludeMediaInfo"] = boost::any(*includeMediaInfo);
    }
    if (includePlayList) {
      res["IncludePlayList"] = boost::any(*includePlayList);
    }
    if (includeSnapshotList) {
      res["IncludeSnapshotList"] = boost::any(*includeSnapshotList);
    }
    if (includeSummaryList) {
      res["IncludeSummaryList"] = boost::any(*includeSummaryList);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncludeMediaInfo") != m.end() && !m["IncludeMediaInfo"].empty()) {
      includeMediaInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeMediaInfo"]));
    }
    if (m.find("IncludePlayList") != m.end() && !m["IncludePlayList"].empty()) {
      includePlayList = make_shared<bool>(boost::any_cast<bool>(m["IncludePlayList"]));
    }
    if (m.find("IncludeSnapshotList") != m.end() && !m["IncludeSnapshotList"].empty()) {
      includeSnapshotList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSnapshotList"]));
    }
    if (m.find("IncludeSummaryList") != m.end() && !m["IncludeSummaryList"].empty()) {
      includeSummaryList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSummaryList"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaListRequest() = default;
};
class QueryMediaListResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoFormat() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoFormat() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList> videoStreamList{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreams() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreams() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfo : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoFormat> format{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreams> streams{};

  QueryMediaListResponseBodyMediaListMediaMediaInfo() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoFormat>(model1);
      }
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreams>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfo() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayListPlayFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaPlayListPlayFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayListPlayFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayListPlayFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayListPlay : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> encryption{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaPlayListPlayFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> size{};
  shared_ptr<string> width{};

  QueryMediaListResponseBodyMediaListMediaPlayListPlay() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayListPlay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (encryption) {
      res["Encryption"] = boost::any(*encryption);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["Encryption"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaPlayListPlayFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaPlayListPlayFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayListPlay() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay>> play{};

  QueryMediaListResponseBodyMediaListMediaPlayList() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (play) {
      vector<boost::any> temp1;
      for(auto item1:*play){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Play"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Play") != m.end() && !m["Play"].empty()) {
      if (typeid(vector<boost::any>) == m["Play"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Play"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaPlayListPlay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        play = make_shared<vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayList() = default;
};
class QueryMediaListResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaListResponseBodyMediaListMediaRunIdList() {}

  explicit QueryMediaListResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaRunIdList() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<string> count{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> type{};

  QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot>> snapshot{};

  QueryMediaListResponseBodyMediaListMediaSnapshotList() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotList() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryListSummary : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> type{};

  QueryMediaListResponseBodyMediaListMediaSummaryListSummary() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryListSummary() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary>> summary{};

  QueryMediaListResponseBodyMediaListMediaSummaryList() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaSummaryListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryList() = default;
};
class QueryMediaListResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  QueryMediaListResponseBodyMediaListMediaTags() {}

  explicit QueryMediaListResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaTags() = default;
};
class QueryMediaListResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfo> mediaInfo{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaPlayList> playList{};
  shared_ptr<string> publishState{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSnapshotList> snapshotList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSummaryList> summaryList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  QueryMediaListResponseBodyMediaListMedia() {}

  explicit QueryMediaListResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playList) {
      res["PlayList"] = playList ? boost::any(playList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotList) {
      res["SnapshotList"] = snapshotList ? boost::any(snapshotList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summaryList) {
      res["SummaryList"] = summaryList ? boost::any(summaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfo>(model1);
      }
    }
    if (m.find("PlayList") != m.end() && !m["PlayList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayList"].type()) {
        QueryMediaListResponseBodyMediaListMediaPlayList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayList"]));
        playList = make_shared<QueryMediaListResponseBodyMediaListMediaPlayList>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        QueryMediaListResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<QueryMediaListResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("SnapshotList") != m.end() && !m["SnapshotList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotList"].type()) {
        QueryMediaListResponseBodyMediaListMediaSnapshotList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotList"]));
        snapshotList = make_shared<QueryMediaListResponseBodyMediaListMediaSnapshotList>(model1);
      }
    }
    if (m.find("SummaryList") != m.end() && !m["SummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SummaryList"].type()) {
        QueryMediaListResponseBodyMediaListMediaSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SummaryList"]));
        summaryList = make_shared<QueryMediaListResponseBodyMediaListMediaSummaryList>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryMediaListResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryMediaListResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMedia() = default;
};
class QueryMediaListResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMedia>> media{};

  QueryMediaListResponseBodyMediaList() {}

  explicit QueryMediaListResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<QueryMediaListResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<QueryMediaListResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaList() = default;
};
class QueryMediaListResponseBodyNonExistMediaIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaId{};

  QueryMediaListResponseBodyNonExistMediaIds() {}

  explicit QueryMediaListResponseBodyNonExistMediaIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyNonExistMediaIds() = default;
};
class QueryMediaListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyMediaList> mediaList{};
  shared_ptr<QueryMediaListResponseBodyNonExistMediaIds> nonExistMediaIds{};
  shared_ptr<string> requestId{};

  QueryMediaListResponseBody() {}

  explicit QueryMediaListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistMediaIds) {
      res["NonExistMediaIds"] = nonExistMediaIds ? boost::any(nonExistMediaIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        QueryMediaListResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<QueryMediaListResponseBodyMediaList>(model1);
      }
    }
    if (m.find("NonExistMediaIds") != m.end() && !m["NonExistMediaIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaIds"].type()) {
        QueryMediaListResponseBodyNonExistMediaIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaIds"]));
        nonExistMediaIds = make_shared<QueryMediaListResponseBodyNonExistMediaIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaListResponseBody() = default;
};
class QueryMediaListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaListResponseBody> body{};

  QueryMediaListResponse() {}

  explicit QueryMediaListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponse() = default;
};
class QueryMediaListByURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileURLs{};
  shared_ptr<bool> includeMediaInfo{};
  shared_ptr<bool> includePlayList{};
  shared_ptr<bool> includeSnapshotList{};
  shared_ptr<bool> includeSummaryList{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaListByURLRequest() {}

  explicit QueryMediaListByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURLs) {
      res["FileURLs"] = boost::any(*fileURLs);
    }
    if (includeMediaInfo) {
      res["IncludeMediaInfo"] = boost::any(*includeMediaInfo);
    }
    if (includePlayList) {
      res["IncludePlayList"] = boost::any(*includePlayList);
    }
    if (includeSnapshotList) {
      res["IncludeSnapshotList"] = boost::any(*includeSnapshotList);
    }
    if (includeSummaryList) {
      res["IncludeSummaryList"] = boost::any(*includeSummaryList);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURLs") != m.end() && !m["FileURLs"].empty()) {
      fileURLs = make_shared<string>(boost::any_cast<string>(m["FileURLs"]));
    }
    if (m.find("IncludeMediaInfo") != m.end() && !m["IncludeMediaInfo"].empty()) {
      includeMediaInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeMediaInfo"]));
    }
    if (m.find("IncludePlayList") != m.end() && !m["IncludePlayList"].empty()) {
      includePlayList = make_shared<bool>(boost::any_cast<bool>(m["IncludePlayList"]));
    }
    if (m.find("IncludeSnapshotList") != m.end() && !m["IncludeSnapshotList"].empty()) {
      includeSnapshotList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSnapshotList"]));
    }
    if (m.find("IncludeSummaryList") != m.end() && !m["IncludeSummaryList"].empty()) {
      includeSummaryList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSummaryList"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaListByURLRequest() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList> videoStreamList{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfo : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat> format{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams> streams{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfo() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat>(model1);
      }
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfo() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> encryption{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> size{};
  shared_ptr<string> width{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (encryption) {
      res["Encryption"] = boost::any(*encryption);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["Encryption"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay>> play{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (play) {
      vector<boost::any> temp1;
      for(auto item1:*play){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Play"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Play") != m.end() && !m["Play"].empty()) {
      if (typeid(vector<boost::any>) == m["Play"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Play"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        play = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaListByURLResponseBodyMediaListMediaRunIdList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaRunIdList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<string> count{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> type{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot>> snapshot{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> type{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary>> summary{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  QueryMediaListByURLResponseBodyMediaListMediaTags() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaTags() = default;
};
class QueryMediaListByURLResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfo> mediaInfo{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaPlayList> playList{};
  shared_ptr<string> publishState{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSnapshotList> snapshotList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSummaryList> summaryList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  QueryMediaListByURLResponseBodyMediaListMedia() {}

  explicit QueryMediaListByURLResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playList) {
      res["PlayList"] = playList ? boost::any(playList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotList) {
      res["SnapshotList"] = snapshotList ? boost::any(snapshotList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summaryList) {
      res["SummaryList"] = summaryList ? boost::any(summaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfo>(model1);
      }
    }
    if (m.find("PlayList") != m.end() && !m["PlayList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaPlayList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayList"]));
        playList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaPlayList>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("SnapshotList") != m.end() && !m["SnapshotList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSnapshotList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotList"]));
        snapshotList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSnapshotList>(model1);
      }
    }
    if (m.find("SummaryList") != m.end() && !m["SummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SummaryList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SummaryList"]));
        summaryList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSummaryList>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryMediaListByURLResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMedia() = default;
};
class QueryMediaListByURLResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMedia>> media{};

  QueryMediaListByURLResponseBodyMediaList() {}

  explicit QueryMediaListByURLResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaList() = default;
};
class QueryMediaListByURLResponseBodyNonExistFileURLs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileURL{};

  QueryMediaListByURLResponseBodyNonExistFileURLs() {}

  explicit QueryMediaListByURLResponseBodyNonExistFileURLs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileURL"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileURL"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileURL = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyNonExistFileURLs() = default;
};
class QueryMediaListByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaList> mediaList{};
  shared_ptr<QueryMediaListByURLResponseBodyNonExistFileURLs> nonExistFileURLs{};
  shared_ptr<string> requestId{};

  QueryMediaListByURLResponseBody() {}

  explicit QueryMediaListByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistFileURLs) {
      res["NonExistFileURLs"] = nonExistFileURLs ? boost::any(nonExistFileURLs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        QueryMediaListByURLResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<QueryMediaListByURLResponseBodyMediaList>(model1);
      }
    }
    if (m.find("NonExistFileURLs") != m.end() && !m["NonExistFileURLs"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistFileURLs"].type()) {
        QueryMediaListByURLResponseBodyNonExistFileURLs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistFileURLs"]));
        nonExistFileURLs = make_shared<QueryMediaListByURLResponseBodyNonExistFileURLs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBody() = default;
};
class QueryMediaListByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaListByURLResponseBody> body{};

  QueryMediaListByURLResponse() {}

  explicit QueryMediaListByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaListByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaListByURLResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponse() = default;
};
class QueryMediaWorkflowExecutionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> runIds{};

  QueryMediaWorkflowExecutionListRequest() {}

  explicit QueryMediaWorkflowExecutionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (runIds) {
      res["RunIds"] = boost::any(*runIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RunIds") != m.end() && !m["RunIds"].empty()) {
      runIds = make_shared<string>(boost::any_cast<string>(m["RunIds"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListRequest() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>> activity{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activity) {
      vector<boost::any> temp1;
      for(auto item1:*activity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activity") != m.end() && !m["Activity"].empty()) {
      if (typeid(vector<boost::any>) == m["Activity"].type()) {
        vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activity = make_shared<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile> inputFile{};
  shared_ptr<string> userData{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList> activityList{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput> input{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> runId{};
  shared_ptr<string> state{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityList) {
      res["ActivityList"] = activityList ? boost::any(activityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityList") != m.end() && !m["ActivityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityList"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityList"]));
        activityList = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["RunId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>> mediaWorkflowExecution{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecution) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflowExecution){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflowExecution"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecution") != m.end() && !m["MediaWorkflowExecution"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflowExecution"].type()) {
        vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflowExecution"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflowExecution = make_shared<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds() = default;
};
class QueryMediaWorkflowExecutionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList> mediaWorkflowExecutionList{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds> nonExistRunIds{};
  shared_ptr<string> requestId{};

  QueryMediaWorkflowExecutionListResponseBody() {}

  explicit QueryMediaWorkflowExecutionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecutionList) {
      res["MediaWorkflowExecutionList"] = mediaWorkflowExecutionList ? boost::any(mediaWorkflowExecutionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistRunIds) {
      res["NonExistRunIds"] = nonExistRunIds ? boost::any(nonExistRunIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecutionList") != m.end() && !m["MediaWorkflowExecutionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowExecutionList"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowExecutionList"]));
        mediaWorkflowExecutionList = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList>(model1);
      }
    }
    if (m.find("NonExistRunIds") != m.end() && !m["NonExistRunIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistRunIds"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistRunIds"]));
        nonExistRunIds = make_shared<QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBody() = default;
};
class QueryMediaWorkflowExecutionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBody> body{};

  QueryMediaWorkflowExecutionListResponse() {}

  explicit QueryMediaWorkflowExecutionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaWorkflowExecutionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaWorkflowExecutionListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponse() = default;
};
class QueryMediaWorkflowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaWorkflowListRequest() {}

  explicit QueryMediaWorkflowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowIds) {
      res["MediaWorkflowIds"] = boost::any(*mediaWorkflowIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowIds") != m.end() && !m["MediaWorkflowIds"].empty()) {
      mediaWorkflowIds = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaWorkflowListRequest() = default;
};
class QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow() {}

  explicit QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow() = default;
};
class QueryMediaWorkflowListResponseBodyMediaWorkflowList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow>> mediaWorkflow{};

  QueryMediaWorkflowListResponseBodyMediaWorkflowList() {}

  explicit QueryMediaWorkflowListResponseBodyMediaWorkflowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflow"].type()) {
        vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflow = make_shared<vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyMediaWorkflowList() = default;
};
class QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaWorkflowId{};

  QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds() {}

  explicit QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaWorkflowId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaWorkflowId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaWorkflowId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds() = default;
};
class QueryMediaWorkflowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowListResponseBodyMediaWorkflowList> mediaWorkflowList{};
  shared_ptr<QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds> nonExistMediaWorkflowIds{};
  shared_ptr<string> requestId{};

  QueryMediaWorkflowListResponseBody() {}

  explicit QueryMediaWorkflowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowList) {
      res["MediaWorkflowList"] = mediaWorkflowList ? boost::any(mediaWorkflowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistMediaWorkflowIds) {
      res["NonExistMediaWorkflowIds"] = nonExistMediaWorkflowIds ? boost::any(nonExistMediaWorkflowIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowList") != m.end() && !m["MediaWorkflowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowList"].type()) {
        QueryMediaWorkflowListResponseBodyMediaWorkflowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowList"]));
        mediaWorkflowList = make_shared<QueryMediaWorkflowListResponseBodyMediaWorkflowList>(model1);
      }
    }
    if (m.find("NonExistMediaWorkflowIds") != m.end() && !m["NonExistMediaWorkflowIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaWorkflowIds"].type()) {
        QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaWorkflowIds"]));
        nonExistMediaWorkflowIds = make_shared<QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaWorkflowListResponseBody() = default;
};
class QueryMediaWorkflowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaWorkflowListResponseBody> body{};

  QueryMediaWorkflowListResponse() {}

  explicit QueryMediaWorkflowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaWorkflowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaWorkflowListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaWorkflowListResponse() = default;
};
class QueryPipelineListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineIds{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryPipelineListRequest() {}

  explicit QueryPipelineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineIds) {
      res["PipelineIds"] = boost::any(*pipelineIds);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineIds") != m.end() && !m["PipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["PipelineIds"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryPipelineListRequest() = default;
};
class QueryPipelineListResponseBodyNonExistPids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryPipelineListResponseBodyNonExistPids() {}

  explicit QueryPipelineListResponseBodyNonExistPids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryPipelineListResponseBodyNonExistPids() = default;
};
class QueryPipelineListResponseBodyPipelineListPipelineExtendConfig : public Darabonba::Model {
public:
  shared_ptr<bool> isBoostNew{};
  shared_ptr<long> maxMultiSpeed{};
  shared_ptr<string> multiSpeedDowngradePolicy{};

  QueryPipelineListResponseBodyPipelineListPipelineExtendConfig() {}

  explicit QueryPipelineListResponseBodyPipelineListPipelineExtendConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isBoostNew) {
      res["IsBoostNew"] = boost::any(*isBoostNew);
    }
    if (maxMultiSpeed) {
      res["MaxMultiSpeed"] = boost::any(*maxMultiSpeed);
    }
    if (multiSpeedDowngradePolicy) {
      res["MultiSpeedDowngradePolicy"] = boost::any(*multiSpeedDowngradePolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsBoostNew") != m.end() && !m["IsBoostNew"].empty()) {
      isBoostNew = make_shared<bool>(boost::any_cast<bool>(m["IsBoostNew"]));
    }
    if (m.find("MaxMultiSpeed") != m.end() && !m["MaxMultiSpeed"].empty()) {
      maxMultiSpeed = make_shared<long>(boost::any_cast<long>(m["MaxMultiSpeed"]));
    }
    if (m.find("MultiSpeedDowngradePolicy") != m.end() && !m["MultiSpeedDowngradePolicy"].empty()) {
      multiSpeedDowngradePolicy = make_shared<string>(boost::any_cast<string>(m["MultiSpeedDowngradePolicy"]));
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineListPipelineExtendConfig() = default;
};
class QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> mqTag{};
  shared_ptr<string> mqTopic{};
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mqTag) {
      res["MqTag"] = boost::any(*mqTag);
    }
    if (mqTopic) {
      res["MqTopic"] = boost::any(*mqTopic);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MqTag") != m.end() && !m["MqTag"].empty()) {
      mqTag = make_shared<string>(boost::any_cast<string>(m["MqTag"]));
    }
    if (m.find("MqTopic") != m.end() && !m["MqTopic"].empty()) {
      mqTopic = make_shared<string>(boost::any_cast<string>(m["MqTopic"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class QueryPipelineListResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<QueryPipelineListResponseBodyPipelineListPipelineExtendConfig> extendConfig{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> quotaAllocate{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};
  shared_ptr<string> state{};

  QueryPipelineListResponseBodyPipelineListPipeline() {}

  explicit QueryPipelineListResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendConfig) {
      res["ExtendConfig"] = extendConfig ? boost::any(extendConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (quotaAllocate) {
      res["QuotaAllocate"] = boost::any(*quotaAllocate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendConfig") != m.end() && !m["ExtendConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendConfig"].type()) {
        QueryPipelineListResponseBodyPipelineListPipelineExtendConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendConfig"]));
        extendConfig = make_shared<QueryPipelineListResponseBodyPipelineListPipelineExtendConfig>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("QuotaAllocate") != m.end() && !m["QuotaAllocate"].empty()) {
      quotaAllocate = make_shared<long>(boost::any_cast<long>(m["QuotaAllocate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineListPipeline() = default;
};
class QueryPipelineListResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPipelineListResponseBodyPipelineListPipeline>> pipeline{};

  QueryPipelineListResponseBodyPipelineList() {}

  explicit QueryPipelineListResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<QueryPipelineListResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPipelineListResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<QueryPipelineListResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineList() = default;
};
class QueryPipelineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryPipelineListResponseBodyNonExistPids> nonExistPids{};
  shared_ptr<QueryPipelineListResponseBodyPipelineList> pipelineList{};
  shared_ptr<string> requestId{};

  QueryPipelineListResponseBody() {}

  explicit QueryPipelineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistPids) {
      res["NonExistPids"] = nonExistPids ? boost::any(nonExistPids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistPids") != m.end() && !m["NonExistPids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistPids"].type()) {
        QueryPipelineListResponseBodyNonExistPids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistPids"]));
        nonExistPids = make_shared<QueryPipelineListResponseBodyNonExistPids>(model1);
      }
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        QueryPipelineListResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<QueryPipelineListResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryPipelineListResponseBody() = default;
};
class QueryPipelineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPipelineListResponseBody> body{};

  QueryPipelineListResponse() {}

  explicit QueryPipelineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPipelineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPipelineListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPipelineListResponse() = default;
};
class QuerySmarttagJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> params{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmarttagJobRequest() {}

  explicit QuerySmarttagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmarttagJobRequest() = default;
};
class QuerySmarttagJobResponseBodyResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> type{};

  QuerySmarttagJobResponseBodyResultsResult() {}

  explicit QuerySmarttagJobResponseBodyResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QuerySmarttagJobResponseBodyResultsResult() = default;
};
class QuerySmarttagJobResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmarttagJobResponseBodyResultsResult>> result{};

  QuerySmarttagJobResponseBodyResults() {}

  explicit QuerySmarttagJobResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QuerySmarttagJobResponseBodyResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmarttagJobResponseBodyResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QuerySmarttagJobResponseBodyResultsResult>>(expect1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponseBodyResults() = default;
};
class QuerySmarttagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySmarttagJobResponseBodyResults> results{};
  shared_ptr<string> userData{};

  QuerySmarttagJobResponseBody() {}

  explicit QuerySmarttagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QuerySmarttagJobResponseBodyResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QuerySmarttagJobResponseBodyResults>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QuerySmarttagJobResponseBody() = default;
};
class QuerySmarttagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmarttagJobResponseBody> body{};

  QuerySmarttagJobResponse() {}

  explicit QuerySmarttagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmarttagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmarttagJobResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponse() = default;
};
class QuerySmarttagTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};

  QuerySmarttagTemplateListRequest() {}

  explicit QuerySmarttagTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~QuerySmarttagTemplateListRequest() = default;
};
class QuerySmarttagTemplateListResponseBodyTemplatesTemplate : public Darabonba::Model {
public:
  shared_ptr<string> analyseTypes{};
  shared_ptr<string> faceCategoryIds{};
  shared_ptr<string> faceCustomParamsConfig{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> keywordConfig{};
  shared_ptr<string> knowledgeConfig{};
  shared_ptr<string> labelType{};
  shared_ptr<string> labelVersion{};
  shared_ptr<string> landmarkGroupIds{};
  shared_ptr<string> objectGroupIds{};
  shared_ptr<string> scene{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  QuerySmarttagTemplateListResponseBodyTemplatesTemplate() {}

  explicit QuerySmarttagTemplateListResponseBodyTemplatesTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analyseTypes) {
      res["AnalyseTypes"] = boost::any(*analyseTypes);
    }
    if (faceCategoryIds) {
      res["FaceCategoryIds"] = boost::any(*faceCategoryIds);
    }
    if (faceCustomParamsConfig) {
      res["FaceCustomParamsConfig"] = boost::any(*faceCustomParamsConfig);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (keywordConfig) {
      res["KeywordConfig"] = boost::any(*keywordConfig);
    }
    if (knowledgeConfig) {
      res["KnowledgeConfig"] = boost::any(*knowledgeConfig);
    }
    if (labelType) {
      res["LabelType"] = boost::any(*labelType);
    }
    if (labelVersion) {
      res["LabelVersion"] = boost::any(*labelVersion);
    }
    if (landmarkGroupIds) {
      res["LandmarkGroupIds"] = boost::any(*landmarkGroupIds);
    }
    if (objectGroupIds) {
      res["ObjectGroupIds"] = boost::any(*objectGroupIds);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalyseTypes") != m.end() && !m["AnalyseTypes"].empty()) {
      analyseTypes = make_shared<string>(boost::any_cast<string>(m["AnalyseTypes"]));
    }
    if (m.find("FaceCategoryIds") != m.end() && !m["FaceCategoryIds"].empty()) {
      faceCategoryIds = make_shared<string>(boost::any_cast<string>(m["FaceCategoryIds"]));
    }
    if (m.find("FaceCustomParamsConfig") != m.end() && !m["FaceCustomParamsConfig"].empty()) {
      faceCustomParamsConfig = make_shared<string>(boost::any_cast<string>(m["FaceCustomParamsConfig"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("KeywordConfig") != m.end() && !m["KeywordConfig"].empty()) {
      keywordConfig = make_shared<string>(boost::any_cast<string>(m["KeywordConfig"]));
    }
    if (m.find("KnowledgeConfig") != m.end() && !m["KnowledgeConfig"].empty()) {
      knowledgeConfig = make_shared<string>(boost::any_cast<string>(m["KnowledgeConfig"]));
    }
    if (m.find("LabelType") != m.end() && !m["LabelType"].empty()) {
      labelType = make_shared<string>(boost::any_cast<string>(m["LabelType"]));
    }
    if (m.find("LabelVersion") != m.end() && !m["LabelVersion"].empty()) {
      labelVersion = make_shared<string>(boost::any_cast<string>(m["LabelVersion"]));
    }
    if (m.find("LandmarkGroupIds") != m.end() && !m["LandmarkGroupIds"].empty()) {
      landmarkGroupIds = make_shared<string>(boost::any_cast<string>(m["LandmarkGroupIds"]));
    }
    if (m.find("ObjectGroupIds") != m.end() && !m["ObjectGroupIds"].empty()) {
      objectGroupIds = make_shared<string>(boost::any_cast<string>(m["ObjectGroupIds"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QuerySmarttagTemplateListResponseBodyTemplatesTemplate() = default;
};
class QuerySmarttagTemplateListResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmarttagTemplateListResponseBodyTemplatesTemplate>> template_{};

  QuerySmarttagTemplateListResponseBodyTemplates() {}

  explicit QuerySmarttagTemplateListResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QuerySmarttagTemplateListResponseBodyTemplatesTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmarttagTemplateListResponseBodyTemplatesTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QuerySmarttagTemplateListResponseBodyTemplatesTemplate>>(expect1);
      }
    }
  }


  virtual ~QuerySmarttagTemplateListResponseBodyTemplates() = default;
};
class QuerySmarttagTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QuerySmarttagTemplateListResponseBodyTemplates> templates{};

  QuerySmarttagTemplateListResponseBody() {}

  explicit QuerySmarttagTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      res["Templates"] = templates ? boost::any(templates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Templates"].type()) {
        QuerySmarttagTemplateListResponseBodyTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Templates"]));
        templates = make_shared<QuerySmarttagTemplateListResponseBodyTemplates>(model1);
      }
    }
  }


  virtual ~QuerySmarttagTemplateListResponseBody() = default;
};
class QuerySmarttagTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmarttagTemplateListResponseBody> body{};

  QuerySmarttagTemplateListResponse() {}

  explicit QuerySmarttagTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmarttagTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmarttagTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmarttagTemplateListResponse() = default;
};
class QuerySnapshotJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snapshotJobIds{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> state{};

  QuerySnapshotJobListRequest() {}

  explicit QuerySnapshotJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snapshotJobIds) {
      res["SnapshotJobIds"] = boost::any(*snapshotJobIds);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnapshotJobIds") != m.end() && !m["SnapshotJobIds"].empty()) {
      snapshotJobIds = make_shared<string>(boost::any_cast<string>(m["SnapshotJobIds"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QuerySnapshotJobListRequest() = default;
};
class QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds() {}

  explicit QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut : public Darabonba::Model {
public:
  shared_ptr<string> cellHeight{};
  shared_ptr<string> cellSelStep{};
  shared_ptr<string> cellWidth{};
  shared_ptr<string> color{};
  shared_ptr<string> columns{};
  shared_ptr<string> isKeepCellPic{};
  shared_ptr<string> lines{};
  shared_ptr<string> margin{};
  shared_ptr<string> padding{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cellHeight) {
      res["CellHeight"] = boost::any(*cellHeight);
    }
    if (cellSelStep) {
      res["CellSelStep"] = boost::any(*cellSelStep);
    }
    if (cellWidth) {
      res["CellWidth"] = boost::any(*cellWidth);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (isKeepCellPic) {
      res["IsKeepCellPic"] = boost::any(*isKeepCellPic);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CellHeight") != m.end() && !m["CellHeight"].empty()) {
      cellHeight = make_shared<string>(boost::any_cast<string>(m["CellHeight"]));
    }
    if (m.find("CellSelStep") != m.end() && !m["CellSelStep"].empty()) {
      cellSelStep = make_shared<string>(boost::any_cast<string>(m["CellSelStep"]));
    }
    if (m.find("CellWidth") != m.end() && !m["CellWidth"].empty()) {
      cellWidth = make_shared<string>(boost::any_cast<string>(m["CellWidth"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["Columns"]));
    }
    if (m.find("IsKeepCellPic") != m.end() && !m["IsKeepCellPic"].empty()) {
      isKeepCellPic = make_shared<string>(boost::any_cast<string>(m["IsKeepCellPic"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<string>(boost::any_cast<string>(m["Margin"]));
    }
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<string>(boost::any_cast<string>(m["Padding"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray : public Darabonba::Model {
public:
  shared_ptr<vector<long>> timePointList{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePointList) {
      res["TimePointList"] = boost::any(*timePointList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePointList") != m.end() && !m["TimePointList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TimePointList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimePointList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      timePointList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<string> frameType{};
  shared_ptr<string> height{};
  shared_ptr<string> interval{};
  shared_ptr<string> num{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile> outputFile{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut> tileOut{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile> tileOutputFile{};
  shared_ptr<string> time{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray> timeArray{};
  shared_ptr<string> width{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameType) {
      res["FrameType"] = boost::any(*frameType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tileOut) {
      res["TileOut"] = tileOut ? boost::any(tileOut->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tileOutputFile) {
      res["TileOutputFile"] = tileOutputFile ? boost::any(tileOutputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (timeArray) {
      res["TimeArray"] = timeArray ? boost::any(timeArray->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameType") != m.end() && !m["FrameType"].empty()) {
      frameType = make_shared<string>(boost::any_cast<string>(m["FrameType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<string>(boost::any_cast<string>(m["Num"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile>(model1);
      }
    }
    if (m.find("TileOut") != m.end() && !m["TileOut"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOut"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOut"]));
        tileOut = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut>(model1);
      }
    }
    if (m.find("TileOutputFile") != m.end() && !m["TileOutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOutputFile"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOutputFile"]));
        tileOutputFile = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile>(model1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("TimeArray") != m.end() && !m["TimeArray"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeArray"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeArray"]));
        timeArray = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput> input{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig> snapshotConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> tileCount{};
  shared_ptr<string> userData{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = snapshotConfig ? boost::any(snapshotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tileCount) {
      res["TileCount"] = boost::any(*tileCount);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotConfig"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotConfig"]));
        snapshotConfig = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TileCount") != m.end() && !m["TileCount"].empty()) {
      tileCount = make_shared<string>(boost::any_cast<string>(m["TileCount"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob>> snapshotJob{};

  QuerySnapshotJobListResponseBodySnapshotJobList() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotJob) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotJob"].type()) {
        vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotJob = make_shared<vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob>>(expect1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobList() = default;
};
class QuerySnapshotJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextPageToken{};
  shared_ptr<QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds> nonExistSnapshotJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobList> snapshotJobList{};

  QuerySnapshotJobListResponseBody() {}

  explicit QuerySnapshotJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistSnapshotJobIds) {
      res["NonExistSnapshotJobIds"] = nonExistSnapshotJobIds ? boost::any(nonExistSnapshotJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotJobList) {
      res["SnapshotJobList"] = snapshotJobList ? boost::any(snapshotJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistSnapshotJobIds") != m.end() && !m["NonExistSnapshotJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistSnapshotJobIds"].type()) {
        QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistSnapshotJobIds"]));
        nonExistSnapshotJobIds = make_shared<QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotJobList") != m.end() && !m["SnapshotJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJobList"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJobList"]));
        snapshotJobList = make_shared<QuerySnapshotJobListResponseBodySnapshotJobList>(model1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponseBody() = default;
};
class QuerySnapshotJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySnapshotJobListResponseBody> body{};

  QuerySnapshotJobListResponse() {}

  explicit QuerySnapshotJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySnapshotJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySnapshotJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponse() = default;
};
class QueryTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateIds{};

  QueryTemplateListRequest() {}

  explicit QueryTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
  }


  virtual ~QueryTemplateListRequest() = default;
};
class QueryTemplateListResponseBodyNonExistTids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryTemplateListResponseBodyNonExistTids() {}

  explicit QueryTemplateListResponseBodyNonExistTids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTemplateListResponseBodyNonExistTids() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> level{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> peakLevel{};
  shared_ptr<string> truePeak{};

  QueryTemplateListResponseBodyTemplateListTemplateAudioVolume() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (peakLevel) {
      res["PeakLevel"] = boost::any(*peakLevel);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("PeakLevel") != m.end() && !m["PeakLevel"].empty()) {
      peakLevel = make_shared<string>(boost::any_cast<string>(m["PeakLevel"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateAudioVolume() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateAudioVolume> volume{};

  QueryTemplateListResponseBodyTemplateListTemplateAudio() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<QueryTemplateListResponseBodyTemplateListTemplateAudioVolume>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateAudio() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryTemplateListResponseBodyTemplateListTemplateContainer() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateContainer() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment> segment{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp> webp{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfig() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfig() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  QueryTemplateListResponseBodyTemplateListTemplateTransConfig() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateTransConfig() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand : public Darabonba::Model {
public:
  shared_ptr<double> abrmax{};
  shared_ptr<double> maxAbrRatio{};
  shared_ptr<string> version{};

  QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrmax) {
      res["Abrmax"] = boost::any(*abrmax);
    }
    if (maxAbrRatio) {
      res["MaxAbrRatio"] = boost::any(*maxAbrRatio);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abrmax") != m.end() && !m["Abrmax"].empty()) {
      abrmax = make_shared<double>(boost::any_cast<double>(m["Abrmax"]));
    }
    if (m.find("MaxAbrRatio") != m.end() && !m["MaxAbrRatio"].empty()) {
      maxAbrRatio = make_shared<double>(boost::any_cast<double>(m["MaxAbrRatio"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> hdr2sdr{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand> narrowBand{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  QueryTemplateListResponseBodyTemplateListTemplateVideo() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (hdr2sdr) {
      res["Hdr2sdr"] = boost::any(*hdr2sdr);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (narrowBand) {
      res["NarrowBand"] = narrowBand ? boost::any(narrowBand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Hdr2sdr") != m.end() && !m["Hdr2sdr"].empty()) {
      hdr2sdr = make_shared<string>(boost::any_cast<string>(m["Hdr2sdr"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("NarrowBand") != m.end() && !m["NarrowBand"].empty()) {
      if (typeid(map<string, boost::any>) == m["NarrowBand"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NarrowBand"]));
        narrowBand = make_shared<QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand>(model1);
      }
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateVideo() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateAudio> audio{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateContainer> container{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateVideo> video{};

  QueryTemplateListResponseBodyTemplateListTemplate() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryTemplateListResponseBodyTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryTemplateListResponseBodyTemplateListTemplateContainer>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryTemplateListResponseBodyTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryTemplateListResponseBodyTemplateListTemplateVideo>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplate() = default;
};
class QueryTemplateListResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTemplateListResponseBodyTemplateListTemplate>> template_{};

  QueryTemplateListResponseBodyTemplateList() {}

  explicit QueryTemplateListResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QueryTemplateListResponseBodyTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTemplateListResponseBodyTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QueryTemplateListResponseBodyTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateList() = default;
};
class QueryTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyNonExistTids> nonExistTids{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryTemplateListResponseBodyTemplateList> templateList{};

  QueryTemplateListResponseBody() {}

  explicit QueryTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistTids) {
      res["NonExistTids"] = nonExistTids ? boost::any(nonExistTids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistTids") != m.end() && !m["NonExistTids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistTids"].type()) {
        QueryTemplateListResponseBodyNonExistTids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistTids"]));
        nonExistTids = make_shared<QueryTemplateListResponseBodyNonExistTids>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        QueryTemplateListResponseBodyTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<QueryTemplateListResponseBodyTemplateList>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBody() = default;
};
class QueryTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTemplateListResponseBody> body{};

  QueryTemplateListResponse() {}

  explicit QueryTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponse() = default;
};
class QueryWaterMarkTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateIds{};

  QueryWaterMarkTemplateListRequest() {}

  explicit QueryWaterMarkTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateIds) {
      res["WaterMarkTemplateIds"] = boost::any(*waterMarkTemplateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateIds") != m.end() && !m["WaterMarkTemplateIds"].empty()) {
      waterMarkTemplateIds = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateIds"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListRequest() = default;
};
class QueryWaterMarkTemplateListResponseBodyNonExistWids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryWaterMarkTemplateListResponseBodyNonExistWids() {}

  explicit QueryWaterMarkTemplateListResponseBodyNonExistWids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyNonExistWids() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> width{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> type{};
  shared_ptr<string> width{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate>> waterMarkTemplate{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMarkTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*waterMarkTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMarkTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMarkTemplate"].type()) {
        vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMarkTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMarkTemplate = make_shared<vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList() = default;
};
class QueryWaterMarkTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryWaterMarkTemplateListResponseBodyNonExistWids> nonExistWids{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList> waterMarkTemplateList{};

  QueryWaterMarkTemplateListResponseBody() {}

  explicit QueryWaterMarkTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistWids) {
      res["NonExistWids"] = nonExistWids ? boost::any(nonExistWids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplateList) {
      res["WaterMarkTemplateList"] = waterMarkTemplateList ? boost::any(waterMarkTemplateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistWids") != m.end() && !m["NonExistWids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistWids"].type()) {
        QueryWaterMarkTemplateListResponseBodyNonExistWids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistWids"]));
        nonExistWids = make_shared<QueryWaterMarkTemplateListResponseBodyNonExistWids>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplateList") != m.end() && !m["WaterMarkTemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplateList"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplateList"]));
        waterMarkTemplateList = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList>(model1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBody() = default;
};
class QueryWaterMarkTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryWaterMarkTemplateListResponseBody> body{};

  QueryWaterMarkTemplateListResponse() {}

  explicit QueryWaterMarkTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryWaterMarkTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryWaterMarkTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponse() = default;
};
class RegisterCustomFaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> personId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  RegisterCustomFaceRequest() {}

  explicit RegisterCustomFaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~RegisterCustomFaceRequest() = default;
};
class RegisterCustomFaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> faceId{};
  shared_ptr<string> requestId{};

  RegisterCustomFaceResponseBody() {}

  explicit RegisterCustomFaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterCustomFaceResponseBody() = default;
};
class RegisterCustomFaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterCustomFaceResponseBody> body{};

  RegisterCustomFaceResponse() {}

  explicit RegisterCustomFaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterCustomFaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterCustomFaceResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterCustomFaceResponse() = default;
};
class RegisterCustomViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> customEntityId{};
  shared_ptr<string> customGroupId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  RegisterCustomViewRequest() {}

  explicit RegisterCustomViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (customEntityId) {
      res["CustomEntityId"] = boost::any(*customEntityId);
    }
    if (customGroupId) {
      res["CustomGroupId"] = boost::any(*customGroupId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("CustomEntityId") != m.end() && !m["CustomEntityId"].empty()) {
      customEntityId = make_shared<string>(boost::any_cast<string>(m["CustomEntityId"]));
    }
    if (m.find("CustomGroupId") != m.end() && !m["CustomGroupId"].empty()) {
      customGroupId = make_shared<string>(boost::any_cast<string>(m["CustomGroupId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~RegisterCustomViewRequest() = default;
};
class RegisterCustomViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customViewId{};
  shared_ptr<string> requestId{};

  RegisterCustomViewResponseBody() {}

  explicit RegisterCustomViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customViewId) {
      res["CustomViewId"] = boost::any(*customViewId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomViewId") != m.end() && !m["CustomViewId"].empty()) {
      customViewId = make_shared<string>(boost::any_cast<string>(m["CustomViewId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterCustomViewResponseBody() = default;
};
class RegisterCustomViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterCustomViewResponseBody> body{};

  RegisterCustomViewResponse() {}

  explicit RegisterCustomViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterCustomViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterCustomViewResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterCustomViewResponse() = default;
};
class SearchMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> stateList{};

  SearchMediaWorkflowRequest() {}

  explicit SearchMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (stateList) {
      res["StateList"] = boost::any(*stateList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StateList") != m.end() && !m["StateList"].empty()) {
      stateList = make_shared<string>(boost::any_cast<string>(m["StateList"]));
    }
  }


  virtual ~SearchMediaWorkflowRequest() = default;
};
class SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow() {}

  explicit SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow() = default;
};
class SearchMediaWorkflowResponseBodyMediaWorkflowList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow>> mediaWorkflow{};

  SearchMediaWorkflowResponseBodyMediaWorkflowList() {}

  explicit SearchMediaWorkflowResponseBodyMediaWorkflowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflow"].type()) {
        vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflow = make_shared<vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow>>(expect1);
      }
    }
  }


  virtual ~SearchMediaWorkflowResponseBodyMediaWorkflowList() = default;
};
class SearchMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchMediaWorkflowResponseBodyMediaWorkflowList> mediaWorkflowList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  SearchMediaWorkflowResponseBody() {}

  explicit SearchMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowList) {
      res["MediaWorkflowList"] = mediaWorkflowList ? boost::any(mediaWorkflowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowList") != m.end() && !m["MediaWorkflowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowList"].type()) {
        SearchMediaWorkflowResponseBodyMediaWorkflowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowList"]));
        mediaWorkflowList = make_shared<SearchMediaWorkflowResponseBodyMediaWorkflowList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchMediaWorkflowResponseBody() = default;
};
class SearchMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaWorkflowResponseBody> body{};

  SearchMediaWorkflowResponse() {}

  explicit SearchMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaWorkflowResponse() = default;
};
class SearchPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> state{};

  SearchPipelineRequest() {}

  explicit SearchPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SearchPipelineRequest() = default;
};
class SearchPipelineResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> mqTag{};
  shared_ptr<string> mqTopic{};
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  SearchPipelineResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit SearchPipelineResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mqTag) {
      res["MqTag"] = boost::any(*mqTag);
    }
    if (mqTopic) {
      res["MqTopic"] = boost::any(*mqTopic);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MqTag") != m.end() && !m["MqTag"].empty()) {
      mqTag = make_shared<string>(boost::any_cast<string>(m["MqTag"]));
    }
    if (m.find("MqTopic") != m.end() && !m["MqTopic"].empty()) {
      mqTopic = make_shared<string>(boost::any_cast<string>(m["MqTopic"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class SearchPipelineResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<SearchPipelineResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> quotaAllocate{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};
  shared_ptr<string> state{};

  SearchPipelineResponseBodyPipelineListPipeline() {}

  explicit SearchPipelineResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (quotaAllocate) {
      res["QuotaAllocate"] = boost::any(*quotaAllocate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        SearchPipelineResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<SearchPipelineResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("QuotaAllocate") != m.end() && !m["QuotaAllocate"].empty()) {
      quotaAllocate = make_shared<long>(boost::any_cast<long>(m["QuotaAllocate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineListPipeline() = default;
};
class SearchPipelineResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchPipelineResponseBodyPipelineListPipeline>> pipeline{};

  SearchPipelineResponseBodyPipelineList() {}

  explicit SearchPipelineResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<SearchPipelineResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchPipelineResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<SearchPipelineResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineList() = default;
};
class SearchPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<SearchPipelineResponseBodyPipelineList> pipelineList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  SearchPipelineResponseBody() {}

  explicit SearchPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        SearchPipelineResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<SearchPipelineResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchPipelineResponseBody() = default;
};
class SearchPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchPipelineResponseBody> body{};

  SearchPipelineResponse() {}

  explicit SearchPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~SearchPipelineResponse() = default;
};
class SearchTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> namePrefix{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> state{};

  SearchTemplateRequest() {}

  explicit SearchTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namePrefix) {
      res["NamePrefix"] = boost::any(*namePrefix);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamePrefix") != m.end() && !m["NamePrefix"].empty()) {
      namePrefix = make_shared<string>(boost::any_cast<string>(m["NamePrefix"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SearchTemplateRequest() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};

  SearchTemplateResponseBodyTemplateListTemplateAudio() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateAudio() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SearchTemplateResponseBodyTemplateListTemplateContainer() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateContainer() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment> segment{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfig() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfig() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  SearchTemplateResponseBodyTemplateListTemplateTransConfig() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateTransConfig() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand : public Darabonba::Model {
public:
  shared_ptr<double> abrmax{};
  shared_ptr<double> maxAbrRatio{};
  shared_ptr<string> version{};

  SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrmax) {
      res["Abrmax"] = boost::any(*abrmax);
    }
    if (maxAbrRatio) {
      res["MaxAbrRatio"] = boost::any(*maxAbrRatio);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abrmax") != m.end() && !m["Abrmax"].empty()) {
      abrmax = make_shared<double>(boost::any_cast<double>(m["Abrmax"]));
    }
    if (m.find("MaxAbrRatio") != m.end() && !m["MaxAbrRatio"].empty()) {
      maxAbrRatio = make_shared<double>(boost::any_cast<double>(m["MaxAbrRatio"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> hdr2sdr{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand> narrowBand{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SearchTemplateResponseBodyTemplateListTemplateVideo() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (hdr2sdr) {
      res["Hdr2sdr"] = boost::any(*hdr2sdr);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (narrowBand) {
      res["NarrowBand"] = narrowBand ? boost::any(narrowBand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Hdr2sdr") != m.end() && !m["Hdr2sdr"].empty()) {
      hdr2sdr = make_shared<string>(boost::any_cast<string>(m["Hdr2sdr"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("NarrowBand") != m.end() && !m["NarrowBand"].empty()) {
      if (typeid(map<string, boost::any>) == m["NarrowBand"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NarrowBand"]));
        narrowBand = make_shared<SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand>(model1);
      }
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateVideo() = default;
};
class SearchTemplateResponseBodyTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateAudio> audio{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateContainer> container{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateVideo> video{};

  SearchTemplateResponseBodyTemplateListTemplate() {}

  explicit SearchTemplateResponseBodyTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SearchTemplateResponseBodyTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SearchTemplateResponseBodyTemplateListTemplateContainer>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SearchTemplateResponseBodyTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SearchTemplateResponseBodyTemplateListTemplateVideo>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplate() = default;
};
class SearchTemplateResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchTemplateResponseBodyTemplateListTemplate>> template_{};

  SearchTemplateResponseBodyTemplateList() {}

  explicit SearchTemplateResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<SearchTemplateResponseBodyTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTemplateResponseBodyTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<SearchTemplateResponseBodyTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateList() = default;
};
class SearchTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<SearchTemplateResponseBodyTemplateList> templateList{};
  shared_ptr<long> totalCount{};

  SearchTemplateResponseBody() {}

  explicit SearchTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        SearchTemplateResponseBodyTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<SearchTemplateResponseBodyTemplateList>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchTemplateResponseBody() = default;
};
class SearchTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTemplateResponseBody> body{};

  SearchTemplateResponse() {}

  explicit SearchTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponse() = default;
};
class SearchWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> state{};

  SearchWaterMarkTemplateRequest() {}

  explicit SearchWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SearchWaterMarkTemplateRequest() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> width{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> type{};
  shared_ptr<string> width{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate>> waterMarkTemplate{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMarkTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*waterMarkTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMarkTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMarkTemplate"].type()) {
        vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMarkTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMarkTemplate = make_shared<vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate>>(expect1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList() = default;
};
class SearchWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList> waterMarkTemplateList{};

  SearchWaterMarkTemplateResponseBody() {}

  explicit SearchWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (waterMarkTemplateList) {
      res["WaterMarkTemplateList"] = waterMarkTemplateList ? boost::any(waterMarkTemplateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WaterMarkTemplateList") != m.end() && !m["WaterMarkTemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplateList"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplateList"]));
        waterMarkTemplateList = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList>(model1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBody() = default;
};
class SearchWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchWaterMarkTemplateResponseBody> body{};

  SearchWaterMarkTemplateResponse() {}

  explicit SearchWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponse() = default;
};
class SubmitAnalysisJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> analysisConfig{};
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userData{};

  SubmitAnalysisJobRequest() {}

  explicit SubmitAnalysisJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisConfig) {
      res["AnalysisConfig"] = boost::any(*analysisConfig);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      analysisConfig = make_shared<string>(boost::any_cast<string>(m["AnalysisConfig"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAnalysisJobRequest() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> left{};
  shared_ptr<string> mode{};
  shared_ptr<string> top{};
  shared_ptr<string> width{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop> crop{};
  shared_ptr<string> deinterlace{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (crop) {
      res["Crop"] = crop ? boost::any(crop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deinterlace) {
      res["Deinterlace"] = boost::any(*deinterlace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Crop"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Crop"]));
        crop = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop>(model1);
      }
    }
    if (m.find("Deinterlace") != m.end() && !m["Deinterlace"].empty()) {
      deinterlace = make_shared<string>(boost::any_cast<string>(m["Deinterlace"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl : public Darabonba::Model {
public:
  shared_ptr<string> methodStreaming{};
  shared_ptr<string> rateQuality{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodStreaming) {
      res["MethodStreaming"] = boost::any(*methodStreaming);
    }
    if (rateQuality) {
      res["RateQuality"] = boost::any(*rateQuality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodStreaming") != m.end() && !m["MethodStreaming"].empty()) {
      methodStreaming = make_shared<string>(boost::any_cast<string>(m["MethodStreaming"]));
    }
    if (m.find("RateQuality") != m.end() && !m["RateQuality"].empty()) {
      rateQuality = make_shared<string>(boost::any_cast<string>(m["RateQuality"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl> propertiesControl{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl> qualityControl{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertiesControl) {
      res["PropertiesControl"] = propertiesControl ? boost::any(propertiesControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (qualityControl) {
      res["QualityControl"] = qualityControl ? boost::any(qualityControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertiesControl") != m.end() && !m["PropertiesControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertiesControl"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertiesControl"]));
        propertiesControl = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl>(model1);
      }
    }
    if (m.find("QualityControl") != m.end() && !m["QualityControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["QualityControl"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QualityControl"]));
        qualityControl = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitAnalysisJobResponseBodyAnalysisJobInputFile() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobInputFile() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> loop{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment> segment{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> transMode{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio> audio{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo> video{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate>> template_{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateList() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateList() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJob : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig> analysisConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobInputFile> inputFile{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> state{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateList> templateList{};
  shared_ptr<string> userData{};

  SubmitAnalysisJobResponseBodyAnalysisJob() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisConfig) {
      res["AnalysisConfig"] = analysisConfig ? boost::any(analysisConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisConfig"]));
        analysisConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobInputFile>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateList>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJob() = default;
};
class SubmitAnalysisJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJob> analysisJob{};
  shared_ptr<string> requestId{};

  SubmitAnalysisJobResponseBody() {}

  explicit SubmitAnalysisJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJob) {
      res["AnalysisJob"] = analysisJob ? boost::any(analysisJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJob") != m.end() && !m["AnalysisJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisJob"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisJob"]));
        analysisJob = make_shared<SubmitAnalysisJobResponseBodyAnalysisJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBody() = default;
};
class SubmitAnalysisJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAnalysisJobResponseBody> body{};

  SubmitAnalysisJobResponse() {}

  explicit SubmitAnalysisJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAnalysisJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAnalysisJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponse() = default;
};
class SubmitFpDBDeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> delType{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userData{};

  SubmitFpDBDeleteJobRequest() {}

  explicit SubmitFpDBDeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delType) {
      res["DelType"] = boost::any(*delType);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelType") != m.end() && !m["DelType"].empty()) {
      delType = make_shared<string>(boost::any_cast<string>(m["DelType"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitFpDBDeleteJobRequest() = default;
};
class SubmitFpDBDeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitFpDBDeleteJobResponseBody() {}

  explicit SubmitFpDBDeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitFpDBDeleteJobResponseBody() = default;
};
class SubmitFpDBDeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitFpDBDeleteJobResponseBody> body{};

  SubmitFpDBDeleteJobResponse() {}

  explicit SubmitFpDBDeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFpDBDeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFpDBDeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFpDBDeleteJobResponse() = default;
};
class SubmitFpFileDeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileIds{};
  shared_ptr<string> fpDBId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> primaryKeys{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userData{};

  SubmitFpFileDeleteJobRequest() {}

  explicit SubmitFpFileDeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (fpDBId) {
      res["FpDBId"] = boost::any(*fpDBId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("FpDBId") != m.end() && !m["FpDBId"].empty()) {
      fpDBId = make_shared<string>(boost::any_cast<string>(m["FpDBId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      primaryKeys = make_shared<string>(boost::any_cast<string>(m["PrimaryKeys"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitFpFileDeleteJobRequest() = default;
};
class SubmitFpFileDeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitFpFileDeleteJobResponseBody() {}

  explicit SubmitFpFileDeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitFpFileDeleteJobResponseBody() = default;
};
class SubmitFpFileDeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitFpFileDeleteJobResponseBody> body{};

  SubmitFpFileDeleteJobResponse() {}

  explicit SubmitFpFileDeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFpFileDeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFpFileDeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFpFileDeleteJobResponse() = default;
};
class SubmitFpShotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> fpShotConfig{};
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userData{};

  SubmitFpShotJobRequest() {}

  explicit SubmitFpShotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fpShotConfig) {
      res["FpShotConfig"] = boost::any(*fpShotConfig);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FpShotConfig") != m.end() && !m["FpShotConfig"].empty()) {
      fpShotConfig = make_shared<string>(boost::any_cast<string>(m["FpShotConfig"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitFpShotJobRequest() = default;
};
class SubmitFpShotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitFpShotJobResponseBody() {}

  explicit SubmitFpShotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitFpShotJobResponseBody() = default;
};
class SubmitFpShotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitFpShotJobResponseBody> body{};

  SubmitFpShotJobResponse() {}

  explicit SubmitFpShotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFpShotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFpShotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFpShotJobResponse() = default;
};
class SubmitIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<string> input{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> modelId{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> output{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scheduleParams{};
  shared_ptr<string> userData{};

  SubmitIProductionJobRequest() {}

  explicit SubmitIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scheduleParams) {
      res["ScheduleParams"] = boost::any(*scheduleParams);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScheduleParams") != m.end() && !m["ScheduleParams"].empty()) {
      scheduleParams = make_shared<string>(boost::any_cast<string>(m["ScheduleParams"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitIProductionJobRequest() = default;
};
class SubmitIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  SubmitIProductionJobResponseBody() {}

  explicit SubmitIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~SubmitIProductionJobResponseBody() = default;
};
class SubmitIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitIProductionJobResponseBody> body{};

  SubmitIProductionJobResponse() {}

  explicit SubmitIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitIProductionJobResponse() = default;
};
class SubmitJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> outputBucket{};
  shared_ptr<string> outputLocation{};
  shared_ptr<string> outputs{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  SubmitJobsRequest() {}

  explicit SubmitJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (outputBucket) {
      res["OutputBucket"] = boost::any(*outputBucket);
    }
    if (outputLocation) {
      res["OutputLocation"] = boost::any(*outputLocation);
    }
    if (outputs) {
      res["Outputs"] = boost::any(*outputs);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OutputBucket") != m.end() && !m["OutputBucket"].empty()) {
      outputBucket = make_shared<string>(boost::any_cast<string>(m["OutputBucket"]));
    }
    if (m.find("OutputLocation") != m.end() && !m["OutputLocation"].empty()) {
      outputLocation = make_shared<string>(boost::any_cast<string>(m["OutputLocation"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~SubmitJobsRequest() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitJobsResponseBodyJobResultListJobResultJobInput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobInput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix : public Darabonba::Model {
public:
  shared_ptr<string> amixURL{};
  shared_ptr<string> duration{};
  shared_ptr<string> map{};
  shared_ptr<string> mixDurMode{};
  shared_ptr<string> start{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amixURL) {
      res["AmixURL"] = boost::any(*amixURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (mixDurMode) {
      res["MixDurMode"] = boost::any(*mixDurMode);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmixURL") != m.end() && !m["AmixURL"].empty()) {
      amixURL = make_shared<string>(boost::any_cast<string>(m["AmixURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("MixDurMode") != m.end() && !m["MixDurMode"].empty()) {
      mixDurMode = make_shared<string>(boost::any_cast<string>(m["MixDurMode"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix>> amix{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amix) {
      vector<boost::any> temp1;
      for(auto item1:*amix){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Amix"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amix") != m.end() && !m["Amix"].empty()) {
      if (typeid(vector<boost::any>) == m["Amix"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Amix"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        amix = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume> volume{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> seek{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan> timeSpan{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputClip() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputClip() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> alpha{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile> inputFile{};
  shared_ptr<string> type{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};
  shared_ptr<string> type{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> md5Support{};
  shared_ptr<bool> sizeSupport{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS> TS{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> start{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge>> merge{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif> gif{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment> segment{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp> webp{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> openUrl{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening>> opening{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<string> message{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams> streams{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList> subtitleList{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> height{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> start{};
  shared_ptr<string> tailUrl{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate>> tailSlate{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> referPos{};
  shared_ptr<string> type{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark>> waterMark{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutput : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList> amixList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputClip> clip{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer> container{};
  shared_ptr<string> deWatermark{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark> digiWaterMark{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption> encryption{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList> mergeList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig> muxConfig{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList> openingList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties> properties{};
  shared_ptr<string> rotate{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso> superReso{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig> transConfig{};
  shared_ptr<string> userData{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo> video{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList> waterMarkList{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amixList) {
      res["AmixList"] = amixList ? boost::any(amixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmixList") != m.end() && !m["AmixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AmixList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AmixList"]));
        amixList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList>(model1);
      }
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputClip>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption>(model1);
      }
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList>(model1);
      }
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutput> output{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};

  SubmitJobsResponseBodyJobResultListJobResultJob() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutput>(model1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJob() = default;
};
class SubmitJobsResponseBodyJobResultListJobResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJob> job{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  SubmitJobsResponseBodyJobResultListJobResult() {}

  explicit SubmitJobsResponseBodyJobResultListJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<SubmitJobsResponseBodyJobResultListJobResultJob>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResult() = default;
};
class SubmitJobsResponseBodyJobResultList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResult>> jobResult{};

  SubmitJobsResponseBodyJobResultList() {}

  explicit SubmitJobsResponseBodyJobResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResult) {
      vector<boost::any> temp1;
      for(auto item1:*jobResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResult") != m.end() && !m["JobResult"].empty()) {
      if (typeid(vector<boost::any>) == m["JobResult"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobResult = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResult>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultList() = default;
};
class SubmitJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultList> jobResultList{};
  shared_ptr<string> requestId{};

  SubmitJobsResponseBody() {}

  explicit SubmitJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResultList) {
      res["JobResultList"] = jobResultList ? boost::any(jobResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResultList") != m.end() && !m["JobResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobResultList"].type()) {
        SubmitJobsResponseBodyJobResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobResultList"]));
        jobResultList = make_shared<SubmitJobsResponseBodyJobResultList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitJobsResponseBody() = default;
};
class SubmitJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitJobsResponseBody> body{};

  SubmitJobsResponse() {}

  explicit SubmitJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponse() = default;
};
class SubmitMediaCensorJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> barrages{};
  shared_ptr<string> coverImages{};
  shared_ptr<string> description{};
  shared_ptr<string> externalUrl{};
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};
  shared_ptr<string> videoCensorConfig{};

  SubmitMediaCensorJobRequest() {}

  explicit SubmitMediaCensorJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrages) {
      res["Barrages"] = boost::any(*barrages);
    }
    if (coverImages) {
      res["CoverImages"] = boost::any(*coverImages);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (externalUrl) {
      res["ExternalUrl"] = boost::any(*externalUrl);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = boost::any(*videoCensorConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Barrages") != m.end() && !m["Barrages"].empty()) {
      barrages = make_shared<string>(boost::any_cast<string>(m["Barrages"]));
    }
    if (m.find("CoverImages") != m.end() && !m["CoverImages"].empty()) {
      coverImages = make_shared<string>(boost::any_cast<string>(m["CoverImages"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExternalUrl") != m.end() && !m["ExternalUrl"].empty()) {
      externalUrl = make_shared<string>(boost::any_cast<string>(m["ExternalUrl"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      videoCensorConfig = make_shared<string>(boost::any_cast<string>(m["VideoCensorConfig"]));
    }
  }


  virtual ~SubmitMediaCensorJobRequest() = default;
};
class SubmitMediaCensorJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitMediaCensorJobResponseBody() {}

  explicit SubmitMediaCensorJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaCensorJobResponseBody() = default;
};
class SubmitMediaCensorJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaCensorJobResponseBody> body{};

  SubmitMediaCensorJobResponse() {}

  explicit SubmitMediaCensorJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaCensorJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaCensorJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaCensorJobResponse() = default;
};
class SubmitMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobRequest() {}

  explicit SubmitMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequest() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> colorPrimaries{};
  shared_ptr<string> colorRange{};
  shared_ptr<string> colorTransfer{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (colorPrimaries) {
      res["ColorPrimaries"] = boost::any(*colorPrimaries);
    }
    if (colorRange) {
      res["ColorRange"] = boost::any(*colorRange);
    }
    if (colorTransfer) {
      res["ColorTransfer"] = boost::any(*colorTransfer);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("ColorPrimaries") != m.end() && !m["ColorPrimaries"].empty()) {
      colorPrimaries = make_shared<string>(boost::any_cast<string>(m["ColorPrimaries"]));
    }
    if (m.find("ColorRange") != m.end() && !m["ColorRange"].empty()) {
      colorRange = make_shared<string>(boost::any_cast<string>(m["ColorRange"]));
    }
    if (m.find("ColorTransfer") != m.end() && !m["ColorTransfer"].empty()) {
      colorTransfer = make_shared<string>(boost::any_cast<string>(m["ColorTransfer"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList> videoStreamList{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams> streams{};
  shared_ptr<string> width{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobProperties() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobProperties() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobProperties> properties{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobProperties>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class SubmitMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  SubmitMediaInfoJobResponseBody() {}

  explicit SubmitMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBody() = default;
};
class SubmitMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaInfoJobResponseBody> body{};

  SubmitMediaInfoJobResponse() {}

  explicit SubmitMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponse() = default;
};
class SubmitSmarttagJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentAddr{};
  shared_ptr<string> contentType{};
  shared_ptr<string> input{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> params{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitSmarttagJobRequest() {}

  explicit SubmitSmarttagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentAddr) {
      res["ContentAddr"] = boost::any(*contentAddr);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentAddr") != m.end() && !m["ContentAddr"].empty()) {
      contentAddr = make_shared<string>(boost::any_cast<string>(m["ContentAddr"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSmarttagJobRequest() = default;
};
class SubmitSmarttagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitSmarttagJobResponseBody() {}

  explicit SubmitSmarttagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSmarttagJobResponseBody() = default;
};
class SubmitSmarttagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSmarttagJobResponseBody> body{};

  SubmitSmarttagJobResponse() {}

  explicit SubmitSmarttagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSmarttagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSmarttagJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSmarttagJobResponse() = default;
};
class SubmitSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snapshotConfig{};
  shared_ptr<string> userData{};

  SubmitSnapshotJobRequest() {}

  explicit SubmitSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = boost::any(*snapshotConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      snapshotConfig = make_shared<string>(boost::any_cast<string>(m["SnapshotConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSnapshotJobRequest() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitSnapshotJobResponseBodySnapshotJobInput() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobInput() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut : public Darabonba::Model {
public:
  shared_ptr<string> cellHeight{};
  shared_ptr<string> cellSelStep{};
  shared_ptr<string> cellWidth{};
  shared_ptr<string> color{};
  shared_ptr<string> columns{};
  shared_ptr<string> isKeepCellPic{};
  shared_ptr<string> lines{};
  shared_ptr<string> margin{};
  shared_ptr<string> padding{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cellHeight) {
      res["CellHeight"] = boost::any(*cellHeight);
    }
    if (cellSelStep) {
      res["CellSelStep"] = boost::any(*cellSelStep);
    }
    if (cellWidth) {
      res["CellWidth"] = boost::any(*cellWidth);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (isKeepCellPic) {
      res["IsKeepCellPic"] = boost::any(*isKeepCellPic);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CellHeight") != m.end() && !m["CellHeight"].empty()) {
      cellHeight = make_shared<string>(boost::any_cast<string>(m["CellHeight"]));
    }
    if (m.find("CellSelStep") != m.end() && !m["CellSelStep"].empty()) {
      cellSelStep = make_shared<string>(boost::any_cast<string>(m["CellSelStep"]));
    }
    if (m.find("CellWidth") != m.end() && !m["CellWidth"].empty()) {
      cellWidth = make_shared<string>(boost::any_cast<string>(m["CellWidth"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["Columns"]));
    }
    if (m.find("IsKeepCellPic") != m.end() && !m["IsKeepCellPic"].empty()) {
      isKeepCellPic = make_shared<string>(boost::any_cast<string>(m["IsKeepCellPic"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<string>(boost::any_cast<string>(m["Margin"]));
    }
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<string>(boost::any_cast<string>(m["Padding"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray : public Darabonba::Model {
public:
  shared_ptr<vector<long>> timePointList{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePointList) {
      res["TimePointList"] = boost::any(*timePointList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePointList") != m.end() && !m["TimePointList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TimePointList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimePointList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      timePointList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<string> frameType{};
  shared_ptr<string> height{};
  shared_ptr<string> interval{};
  shared_ptr<string> num{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile> outputFile{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut> tileOut{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile> tileOutputFile{};
  shared_ptr<string> time{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray> timeArray{};
  shared_ptr<string> width{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameType) {
      res["FrameType"] = boost::any(*frameType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tileOut) {
      res["TileOut"] = tileOut ? boost::any(tileOut->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tileOutputFile) {
      res["TileOutputFile"] = tileOutputFile ? boost::any(tileOutputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (timeArray) {
      res["TimeArray"] = timeArray ? boost::any(timeArray->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameType") != m.end() && !m["FrameType"].empty()) {
      frameType = make_shared<string>(boost::any_cast<string>(m["FrameType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<string>(boost::any_cast<string>(m["Num"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile>(model1);
      }
    }
    if (m.find("TileOut") != m.end() && !m["TileOut"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOut"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOut"]));
        tileOut = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut>(model1);
      }
    }
    if (m.find("TileOutputFile") != m.end() && !m["TileOutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOutputFile"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOutputFile"]));
        tileOutputFile = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile>(model1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("TimeArray") != m.end() && !m["TimeArray"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeArray"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeArray"]));
        timeArray = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobInput> input{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig> snapshotConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> tileCount{};
  shared_ptr<string> userData{};

  SubmitSnapshotJobResponseBodySnapshotJob() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = snapshotConfig ? boost::any(snapshotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tileCount) {
      res["TileCount"] = boost::any(*tileCount);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSnapshotJobResponseBodySnapshotJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotConfig"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotConfig"]));
        snapshotConfig = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TileCount") != m.end() && !m["TileCount"].empty()) {
      tileCount = make_shared<string>(boost::any_cast<string>(m["TileCount"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJob() = default;
};
class SubmitSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJob> snapshotJob{};

  SubmitSnapshotJobResponseBody() {}

  explicit SubmitSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotJob) {
      res["SnapshotJob"] = snapshotJob ? boost::any(snapshotJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJob"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJob"]));
        snapshotJob = make_shared<SubmitSnapshotJobResponseBodySnapshotJob>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponseBody() = default;
};
class SubmitSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSnapshotJobResponseBody> body{};

  SubmitSnapshotJobResponse() {}

  explicit SubmitSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponse() = default;
};
class TagCustomPersonRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryDescription{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> personDescription{};
  shared_ptr<string> personId{};
  shared_ptr<string> personName{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  TagCustomPersonRequest() {}

  explicit TagCustomPersonRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryDescription) {
      res["CategoryDescription"] = boost::any(*categoryDescription);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (personDescription) {
      res["PersonDescription"] = boost::any(*personDescription);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    if (personName) {
      res["PersonName"] = boost::any(*personName);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryDescription") != m.end() && !m["CategoryDescription"].empty()) {
      categoryDescription = make_shared<string>(boost::any_cast<string>(m["CategoryDescription"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PersonDescription") != m.end() && !m["PersonDescription"].empty()) {
      personDescription = make_shared<string>(boost::any_cast<string>(m["PersonDescription"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
    if (m.find("PersonName") != m.end() && !m["PersonName"].empty()) {
      personName = make_shared<string>(boost::any_cast<string>(m["PersonName"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~TagCustomPersonRequest() = default;
};
class TagCustomPersonResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagCustomPersonResponseBody() {}

  explicit TagCustomPersonResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagCustomPersonResponseBody() = default;
};
class TagCustomPersonResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagCustomPersonResponseBody> body{};

  TagCustomPersonResponse() {}

  explicit TagCustomPersonResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagCustomPersonResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagCustomPersonResponseBody>(model1);
      }
    }
  }


  virtual ~TagCustomPersonResponse() = default;
};
class UnbindInputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> roleArn{};

  UnbindInputBucketRequest() {}

  explicit UnbindInputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~UnbindInputBucketRequest() = default;
};
class UnbindInputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindInputBucketResponseBody() {}

  explicit UnbindInputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindInputBucketResponseBody() = default;
};
class UnbindInputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindInputBucketResponseBody> body{};

  UnbindInputBucketResponse() {}

  explicit UnbindInputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindInputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindInputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindInputBucketResponse() = default;
};
class UnbindOutputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UnbindOutputBucketRequest() {}

  explicit UnbindOutputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UnbindOutputBucketRequest() = default;
};
class UnbindOutputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindOutputBucketResponseBody() {}

  explicit UnbindOutputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindOutputBucketResponseBody() = default;
};
class UnbindOutputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindOutputBucketResponseBody> body{};

  UnbindOutputBucketResponse() {}

  explicit UnbindOutputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindOutputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindOutputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindOutputBucketResponse() = default;
};
class UnregisterCustomFaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> faceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> personId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UnregisterCustomFaceRequest() {}

  explicit UnregisterCustomFaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (personId) {
      res["PersonId"] = boost::any(*personId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PersonId") != m.end() && !m["PersonId"].empty()) {
      personId = make_shared<string>(boost::any_cast<string>(m["PersonId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UnregisterCustomFaceRequest() = default;
};
class UnregisterCustomFaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnregisterCustomFaceResponseBody() {}

  explicit UnregisterCustomFaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnregisterCustomFaceResponseBody() = default;
};
class UnregisterCustomFaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnregisterCustomFaceResponseBody> body{};

  UnregisterCustomFaceResponse() {}

  explicit UnregisterCustomFaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnregisterCustomFaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnregisterCustomFaceResponseBody>(model1);
      }
    }
  }


  virtual ~UnregisterCustomFaceResponse() = default;
};
class UpdateMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};

  UpdateMediaRequest() {}

  explicit UpdateMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateMediaRequest() = default;
};
class UpdateMediaResponseBodyMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  UpdateMediaResponseBodyMediaFile() {}

  explicit UpdateMediaResponseBodyMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~UpdateMediaResponseBodyMediaFile() = default;
};
class UpdateMediaResponseBodyMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  UpdateMediaResponseBodyMediaRunIdList() {}

  explicit UpdateMediaResponseBodyMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaResponseBodyMediaRunIdList() = default;
};
class UpdateMediaResponseBodyMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  UpdateMediaResponseBodyMediaTags() {}

  explicit UpdateMediaResponseBodyMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaResponseBodyMediaTags() = default;
};
class UpdateMediaResponseBodyMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<UpdateMediaResponseBodyMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> publishState{};
  shared_ptr<UpdateMediaResponseBodyMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<UpdateMediaResponseBodyMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  UpdateMediaResponseBodyMedia() {}

  explicit UpdateMediaResponseBodyMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        UpdateMediaResponseBodyMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<UpdateMediaResponseBodyMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        UpdateMediaResponseBodyMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<UpdateMediaResponseBodyMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        UpdateMediaResponseBodyMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<UpdateMediaResponseBodyMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateMediaResponseBodyMedia() = default;
};
class UpdateMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaResponseBodyMedia> media{};
  shared_ptr<string> requestId{};

  UpdateMediaResponseBody() {}

  explicit UpdateMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = media ? boost::any(media->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(map<string, boost::any>) == m["Media"].type()) {
        UpdateMediaResponseBodyMedia model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Media"]));
        media = make_shared<UpdateMediaResponseBodyMedia>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaResponseBody() = default;
};
class UpdateMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaResponseBody> body{};

  UpdateMediaResponse() {}

  explicit UpdateMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaResponse() = default;
};
class UpdateMediaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateMediaCategoryRequest() {}

  explicit UpdateMediaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateMediaCategoryRequest() = default;
};
class UpdateMediaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaCategoryResponseBody() {}

  explicit UpdateMediaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaCategoryResponseBody() = default;
};
class UpdateMediaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaCategoryResponseBody> body{};

  UpdateMediaCategoryResponse() {}

  explicit UpdateMediaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaCategoryResponse() = default;
};
class UpdateMediaCoverRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateMediaCoverRequest() {}

  explicit UpdateMediaCoverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateMediaCoverRequest() = default;
};
class UpdateMediaCoverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaCoverResponseBody() {}

  explicit UpdateMediaCoverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaCoverResponseBody() = default;
};
class UpdateMediaCoverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaCoverResponseBody> body{};

  UpdateMediaCoverResponse() {}

  explicit UpdateMediaCoverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaCoverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaCoverResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaCoverResponse() = default;
};
class UpdateMediaPublishStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> publish{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateMediaPublishStateRequest() {}

  explicit UpdateMediaPublishStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publish) {
      res["Publish"] = boost::any(*publish);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Publish") != m.end() && !m["Publish"].empty()) {
      publish = make_shared<bool>(boost::any_cast<bool>(m["Publish"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateMediaPublishStateRequest() = default;
};
class UpdateMediaPublishStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaPublishStateResponseBody() {}

  explicit UpdateMediaPublishStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaPublishStateResponseBody() = default;
};
class UpdateMediaPublishStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaPublishStateResponseBody> body{};

  UpdateMediaPublishStateResponse() {}

  explicit UpdateMediaPublishStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaPublishStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaPublishStateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaPublishStateResponse() = default;
};
class UpdateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  UpdateMediaWorkflowRequest() {}

  explicit UpdateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~UpdateMediaWorkflowRequest() = default;
};
class UpdateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  UpdateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit UpdateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~UpdateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class UpdateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  UpdateMediaWorkflowResponseBody() {}

  explicit UpdateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        UpdateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<UpdateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaWorkflowResponseBody() = default;
};
class UpdateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaWorkflowResponseBody> body{};

  UpdateMediaWorkflowResponse() {}

  explicit UpdateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaWorkflowResponse() = default;
};
class UpdateMediaWorkflowTriggerModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> triggerMode{};

  UpdateMediaWorkflowTriggerModeRequest() {}

  explicit UpdateMediaWorkflowTriggerModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeRequest() = default;
};
class UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow() {}

  explicit UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow() = default;
};
class UpdateMediaWorkflowTriggerModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  UpdateMediaWorkflowTriggerModeResponseBody() {}

  explicit UpdateMediaWorkflowTriggerModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponseBody() = default;
};
class UpdateMediaWorkflowTriggerModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaWorkflowTriggerModeResponseBody> body{};

  UpdateMediaWorkflowTriggerModeResponse() {}

  explicit UpdateMediaWorkflowTriggerModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaWorkflowTriggerModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaWorkflowTriggerModeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponse() = default;
};
class UpdatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> extendConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  UpdatePipelineRequest() {}

  explicit UpdatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendConfig) {
      res["ExtendConfig"] = boost::any(*extendConfig);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendConfig") != m.end() && !m["ExtendConfig"].empty()) {
      extendConfig = make_shared<string>(boost::any_cast<string>(m["ExtendConfig"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~UpdatePipelineRequest() = default;
};
class UpdatePipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> mqTag{};
  shared_ptr<string> mqTopic{};
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  UpdatePipelineResponseBodyPipelineNotifyConfig() {}

  explicit UpdatePipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mqTag) {
      res["MqTag"] = boost::any(*mqTag);
    }
    if (mqTopic) {
      res["MqTopic"] = boost::any(*mqTopic);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MqTag") != m.end() && !m["MqTag"].empty()) {
      mqTag = make_shared<string>(boost::any_cast<string>(m["MqTag"]));
    }
    if (m.find("MqTopic") != m.end() && !m["MqTopic"].empty()) {
      mqTopic = make_shared<string>(boost::any_cast<string>(m["MqTopic"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~UpdatePipelineResponseBodyPipelineNotifyConfig() = default;
};
class UpdatePipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdatePipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<long> quotaAllocate{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<string> state{};

  UpdatePipelineResponseBodyPipeline() {}

  explicit UpdatePipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (quotaAllocate) {
      res["QuotaAllocate"] = boost::any(*quotaAllocate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        UpdatePipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<UpdatePipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("QuotaAllocate") != m.end() && !m["QuotaAllocate"].empty()) {
      quotaAllocate = make_shared<long>(boost::any_cast<long>(m["QuotaAllocate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~UpdatePipelineResponseBodyPipeline() = default;
};
class UpdatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdatePipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  UpdatePipelineResponseBody() {}

  explicit UpdatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        UpdatePipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<UpdatePipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePipelineResponseBody() = default;
};
class UpdatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelineResponseBody> body{};

  UpdatePipelineResponse() {}

  explicit UpdatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineResponse() = default;
};
class UpdateSmarttagTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> analyseTypes{};
  shared_ptr<string> faceCategoryIds{};
  shared_ptr<string> faceCustomParamsConfig{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> keywordConfig{};
  shared_ptr<string> knowledgeConfig{};
  shared_ptr<string> labelType{};
  shared_ptr<string> labelVersion{};
  shared_ptr<string> landmarkGroupIds{};
  shared_ptr<string> objectGroupIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scene{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  UpdateSmarttagTemplateRequest() {}

  explicit UpdateSmarttagTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analyseTypes) {
      res["AnalyseTypes"] = boost::any(*analyseTypes);
    }
    if (faceCategoryIds) {
      res["FaceCategoryIds"] = boost::any(*faceCategoryIds);
    }
    if (faceCustomParamsConfig) {
      res["FaceCustomParamsConfig"] = boost::any(*faceCustomParamsConfig);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (keywordConfig) {
      res["KeywordConfig"] = boost::any(*keywordConfig);
    }
    if (knowledgeConfig) {
      res["KnowledgeConfig"] = boost::any(*knowledgeConfig);
    }
    if (labelType) {
      res["LabelType"] = boost::any(*labelType);
    }
    if (labelVersion) {
      res["LabelVersion"] = boost::any(*labelVersion);
    }
    if (landmarkGroupIds) {
      res["LandmarkGroupIds"] = boost::any(*landmarkGroupIds);
    }
    if (objectGroupIds) {
      res["ObjectGroupIds"] = boost::any(*objectGroupIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalyseTypes") != m.end() && !m["AnalyseTypes"].empty()) {
      analyseTypes = make_shared<string>(boost::any_cast<string>(m["AnalyseTypes"]));
    }
    if (m.find("FaceCategoryIds") != m.end() && !m["FaceCategoryIds"].empty()) {
      faceCategoryIds = make_shared<string>(boost::any_cast<string>(m["FaceCategoryIds"]));
    }
    if (m.find("FaceCustomParamsConfig") != m.end() && !m["FaceCustomParamsConfig"].empty()) {
      faceCustomParamsConfig = make_shared<string>(boost::any_cast<string>(m["FaceCustomParamsConfig"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("KeywordConfig") != m.end() && !m["KeywordConfig"].empty()) {
      keywordConfig = make_shared<string>(boost::any_cast<string>(m["KeywordConfig"]));
    }
    if (m.find("KnowledgeConfig") != m.end() && !m["KnowledgeConfig"].empty()) {
      knowledgeConfig = make_shared<string>(boost::any_cast<string>(m["KnowledgeConfig"]));
    }
    if (m.find("LabelType") != m.end() && !m["LabelType"].empty()) {
      labelType = make_shared<string>(boost::any_cast<string>(m["LabelType"]));
    }
    if (m.find("LabelVersion") != m.end() && !m["LabelVersion"].empty()) {
      labelVersion = make_shared<string>(boost::any_cast<string>(m["LabelVersion"]));
    }
    if (m.find("LandmarkGroupIds") != m.end() && !m["LandmarkGroupIds"].empty()) {
      landmarkGroupIds = make_shared<string>(boost::any_cast<string>(m["LandmarkGroupIds"]));
    }
    if (m.find("ObjectGroupIds") != m.end() && !m["ObjectGroupIds"].empty()) {
      objectGroupIds = make_shared<string>(boost::any_cast<string>(m["ObjectGroupIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~UpdateSmarttagTemplateRequest() = default;
};
class UpdateSmarttagTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSmarttagTemplateResponseBody() {}

  explicit UpdateSmarttagTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSmarttagTemplateResponseBody() = default;
};
class UpdateSmarttagTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSmarttagTemplateResponseBody> body{};

  UpdateSmarttagTemplateResponse() {}

  explicit UpdateSmarttagTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSmarttagTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSmarttagTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSmarttagTemplateResponse() = default;
};
class UpdateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> audio{};
  shared_ptr<string> container{};
  shared_ptr<string> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> transConfig{};
  shared_ptr<string> video{};

  UpdateTemplateRequest() {}

  explicit UpdateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = boost::any(*audio);
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (muxConfig) {
      res["MuxConfig"] = boost::any(*muxConfig);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = boost::any(*transConfig);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      audio = make_shared<string>(boost::any_cast<string>(m["Audio"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      muxConfig = make_shared<string>(boost::any_cast<string>(m["MuxConfig"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      transConfig = make_shared<string>(boost::any_cast<string>(m["TransConfig"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
  }


  virtual ~UpdateTemplateRequest() = default;
};
class UpdateTemplateResponseBodyTemplateAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> level{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> peakLevel{};
  shared_ptr<string> truePeak{};

  UpdateTemplateResponseBodyTemplateAudioVolume() {}

  explicit UpdateTemplateResponseBodyTemplateAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (peakLevel) {
      res["PeakLevel"] = boost::any(*peakLevel);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("PeakLevel") != m.end() && !m["PeakLevel"].empty()) {
      peakLevel = make_shared<string>(boost::any_cast<string>(m["PeakLevel"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateAudioVolume() = default;
};
class UpdateTemplateResponseBodyTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<UpdateTemplateResponseBodyTemplateAudioVolume> volume{};

  UpdateTemplateResponseBodyTemplateAudio() {}

  explicit UpdateTemplateResponseBodyTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        UpdateTemplateResponseBodyTemplateAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<UpdateTemplateResponseBodyTemplateAudioVolume>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateAudio() = default;
};
class UpdateTemplateResponseBodyTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  UpdateTemplateResponseBodyTemplateContainer() {}

  explicit UpdateTemplateResponseBodyTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateContainer() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  UpdateTemplateResponseBodyTemplateMuxConfigGif() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigGif() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  UpdateTemplateResponseBodyTemplateMuxConfigSegment() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigSegment() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  UpdateTemplateResponseBodyTemplateMuxConfigWebp() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigWebp() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigGif> gif{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigSegment> segment{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigWebp> webp{};

  UpdateTemplateResponseBodyTemplateMuxConfig() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfig() = default;
};
class UpdateTemplateResponseBodyTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  UpdateTemplateResponseBodyTemplateTransConfig() {}

  explicit UpdateTemplateResponseBodyTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateTransConfig() = default;
};
class UpdateTemplateResponseBodyTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  UpdateTemplateResponseBodyTemplateVideoBitrateBnd() {}

  explicit UpdateTemplateResponseBodyTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateVideoBitrateBnd() = default;
};
class UpdateTemplateResponseBodyTemplateVideoNarrowBand : public Darabonba::Model {
public:
  shared_ptr<double> abrmax{};
  shared_ptr<double> maxAbrRatio{};
  shared_ptr<string> version{};

  UpdateTemplateResponseBodyTemplateVideoNarrowBand() {}

  explicit UpdateTemplateResponseBodyTemplateVideoNarrowBand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrmax) {
      res["Abrmax"] = boost::any(*abrmax);
    }
    if (maxAbrRatio) {
      res["MaxAbrRatio"] = boost::any(*maxAbrRatio);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abrmax") != m.end() && !m["Abrmax"].empty()) {
      abrmax = make_shared<double>(boost::any_cast<double>(m["Abrmax"]));
    }
    if (m.find("MaxAbrRatio") != m.end() && !m["MaxAbrRatio"].empty()) {
      maxAbrRatio = make_shared<double>(boost::any_cast<double>(m["MaxAbrRatio"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateVideoNarrowBand() = default;
};
class UpdateTemplateResponseBodyTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<UpdateTemplateResponseBodyTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> hdr2sdr{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<UpdateTemplateResponseBodyTemplateVideoNarrowBand> narrowBand{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  UpdateTemplateResponseBodyTemplateVideo() {}

  explicit UpdateTemplateResponseBodyTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (hdr2sdr) {
      res["Hdr2sdr"] = boost::any(*hdr2sdr);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (narrowBand) {
      res["NarrowBand"] = narrowBand ? boost::any(narrowBand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        UpdateTemplateResponseBodyTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<UpdateTemplateResponseBodyTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Hdr2sdr") != m.end() && !m["Hdr2sdr"].empty()) {
      hdr2sdr = make_shared<string>(boost::any_cast<string>(m["Hdr2sdr"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("NarrowBand") != m.end() && !m["NarrowBand"].empty()) {
      if (typeid(map<string, boost::any>) == m["NarrowBand"].type()) {
        UpdateTemplateResponseBodyTemplateVideoNarrowBand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NarrowBand"]));
        narrowBand = make_shared<UpdateTemplateResponseBodyTemplateVideoNarrowBand>(model1);
      }
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateVideo() = default;
};
class UpdateTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<UpdateTemplateResponseBodyTemplateAudio> audio{};
  shared_ptr<UpdateTemplateResponseBodyTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<UpdateTemplateResponseBodyTemplateTransConfig> transConfig{};
  shared_ptr<UpdateTemplateResponseBodyTemplateVideo> video{};

  UpdateTemplateResponseBodyTemplate() {}

  explicit UpdateTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        UpdateTemplateResponseBodyTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<UpdateTemplateResponseBodyTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        UpdateTemplateResponseBodyTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<UpdateTemplateResponseBodyTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<UpdateTemplateResponseBodyTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        UpdateTemplateResponseBodyTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<UpdateTemplateResponseBodyTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        UpdateTemplateResponseBodyTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<UpdateTemplateResponseBodyTemplateVideo>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplate() = default;
};
class UpdateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateTemplateResponseBodyTemplate> template_{};

  UpdateTemplateResponseBody() {}

  explicit UpdateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        UpdateTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<UpdateTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBody() = default;
};
class UpdateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTemplateResponseBody> body{};

  UpdateTemplateResponse() {}

  explicit UpdateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponse() = default;
};
class UpdateWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateId{};

  UpdateWaterMarkTemplateRequest() {}

  explicit UpdateWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateRequest() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> width{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> type{};
  shared_ptr<string> width{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate() = default;
};
class UpdateWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate> waterMarkTemplate{};

  UpdateWaterMarkTemplateResponseBody() {}

  explicit UpdateWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplate) {
      res["WaterMarkTemplate"] = waterMarkTemplate ? boost::any(waterMarkTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplate"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplate"]));
        waterMarkTemplate = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate>(model1);
      }
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBody() = default;
};
class UpdateWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWaterMarkTemplateResponseBody> body{};

  UpdateWaterMarkTemplateResponse() {}

  explicit UpdateWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWaterMarkTemplateResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ActivateMediaWorkflowResponse activateMediaWorkflowWithOptions(shared_ptr<ActivateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActivateMediaWorkflowResponse activateMediaWorkflow(shared_ptr<ActivateMediaWorkflowRequest> request);
  AddMediaResponse addMediaWithOptions(shared_ptr<AddMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaResponse addMedia(shared_ptr<AddMediaRequest> request);
  AddMediaTagResponse addMediaTagWithOptions(shared_ptr<AddMediaTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaTagResponse addMediaTag(shared_ptr<AddMediaTagRequest> request);
  AddMediaWorkflowResponse addMediaWorkflowWithOptions(shared_ptr<AddMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaWorkflowResponse addMediaWorkflow(shared_ptr<AddMediaWorkflowRequest> request);
  AddPipelineResponse addPipelineWithOptions(shared_ptr<AddPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPipelineResponse addPipeline(shared_ptr<AddPipelineRequest> request);
  AddSmarttagTemplateResponse addSmarttagTemplateWithOptions(shared_ptr<AddSmarttagTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSmarttagTemplateResponse addSmarttagTemplate(shared_ptr<AddSmarttagTemplateRequest> request);
  AddTemplateResponse addTemplateWithOptions(shared_ptr<AddTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTemplateResponse addTemplate(shared_ptr<AddTemplateRequest> request);
  AddWaterMarkTemplateResponse addWaterMarkTemplateWithOptions(shared_ptr<AddWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWaterMarkTemplateResponse addWaterMarkTemplate(shared_ptr<AddWaterMarkTemplateRequest> request);
  BindInputBucketResponse bindInputBucketWithOptions(shared_ptr<BindInputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindInputBucketResponse bindInputBucket(shared_ptr<BindInputBucketRequest> request);
  BindOutputBucketResponse bindOutputBucketWithOptions(shared_ptr<BindOutputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindOutputBucketResponse bindOutputBucket(shared_ptr<BindOutputBucketRequest> request);
  CancelJobResponse cancelJobWithOptions(shared_ptr<CancelJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelJobResponse cancelJob(shared_ptr<CancelJobRequest> request);
  CreateCustomEntityResponse createCustomEntityWithOptions(shared_ptr<CreateCustomEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomEntityResponse createCustomEntity(shared_ptr<CreateCustomEntityRequest> request);
  CreateCustomGroupResponse createCustomGroupWithOptions(shared_ptr<CreateCustomGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomGroupResponse createCustomGroup(shared_ptr<CreateCustomGroupRequest> request);
  CreateFpShotDBResponse createFpShotDBWithOptions(shared_ptr<CreateFpShotDBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFpShotDBResponse createFpShotDB(shared_ptr<CreateFpShotDBRequest> request);
  DeactivateMediaWorkflowResponse deactivateMediaWorkflowWithOptions(shared_ptr<DeactivateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactivateMediaWorkflowResponse deactivateMediaWorkflow(shared_ptr<DeactivateMediaWorkflowRequest> request);
  DeleteCustomEntityResponse deleteCustomEntityWithOptions(shared_ptr<DeleteCustomEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomEntityResponse deleteCustomEntity(shared_ptr<DeleteCustomEntityRequest> request);
  DeleteCustomGroupResponse deleteCustomGroupWithOptions(shared_ptr<DeleteCustomGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomGroupResponse deleteCustomGroup(shared_ptr<DeleteCustomGroupRequest> request);
  DeleteCustomViewResponse deleteCustomViewWithOptions(shared_ptr<DeleteCustomViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomViewResponse deleteCustomView(shared_ptr<DeleteCustomViewRequest> request);
  DeleteMediaResponse deleteMediaWithOptions(shared_ptr<DeleteMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaResponse deleteMedia(shared_ptr<DeleteMediaRequest> request);
  DeleteMediaTagResponse deleteMediaTagWithOptions(shared_ptr<DeleteMediaTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaTagResponse deleteMediaTag(shared_ptr<DeleteMediaTagRequest> request);
  DeleteMediaWorkflowResponse deleteMediaWorkflowWithOptions(shared_ptr<DeleteMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaWorkflowResponse deleteMediaWorkflow(shared_ptr<DeleteMediaWorkflowRequest> request);
  DeletePipelineResponse deletePipelineWithOptions(shared_ptr<DeletePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelineResponse deletePipeline(shared_ptr<DeletePipelineRequest> request);
  DeleteSmarttagTemplateResponse deleteSmarttagTemplateWithOptions(shared_ptr<DeleteSmarttagTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSmarttagTemplateResponse deleteSmarttagTemplate(shared_ptr<DeleteSmarttagTemplateRequest> request);
  DeleteTemplateResponse deleteTemplateWithOptions(shared_ptr<DeleteTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTemplateResponse deleteTemplate(shared_ptr<DeleteTemplateRequest> request);
  DeleteWaterMarkTemplateResponse deleteWaterMarkTemplateWithOptions(shared_ptr<DeleteWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWaterMarkTemplateResponse deleteWaterMarkTemplate(shared_ptr<DeleteWaterMarkTemplateRequest> request);
  ImAuditResponse imAuditWithOptions(shared_ptr<ImAuditRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImAuditResponse imAudit(shared_ptr<ImAuditRequest> request);
  ImportFpShotJobResponse importFpShotJobWithOptions(shared_ptr<ImportFpShotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportFpShotJobResponse importFpShotJob(shared_ptr<ImportFpShotJobRequest> request);
  ListAllMediaBucketResponse listAllMediaBucketWithOptions(shared_ptr<ListAllMediaBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllMediaBucketResponse listAllMediaBucket(shared_ptr<ListAllMediaBucketRequest> request);
  ListCustomEntitiesResponse listCustomEntitiesWithOptions(shared_ptr<ListCustomEntitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomEntitiesResponse listCustomEntities(shared_ptr<ListCustomEntitiesRequest> request);
  ListCustomGroupsResponse listCustomGroupsWithOptions(shared_ptr<ListCustomGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomGroupsResponse listCustomGroups(shared_ptr<ListCustomGroupsRequest> request);
  ListCustomPersonsResponse listCustomPersonsWithOptions(shared_ptr<ListCustomPersonsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomPersonsResponse listCustomPersons(shared_ptr<ListCustomPersonsRequest> request);
  ListCustomViewsResponse listCustomViewsWithOptions(shared_ptr<ListCustomViewsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomViewsResponse listCustomViews(shared_ptr<ListCustomViewsRequest> request);
  ListFpShotDBResponse listFpShotDBWithOptions(shared_ptr<ListFpShotDBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFpShotDBResponse listFpShotDB(shared_ptr<ListFpShotDBRequest> request);
  ListFpShotFilesResponse listFpShotFilesWithOptions(shared_ptr<ListFpShotFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFpShotFilesResponse listFpShotFiles(shared_ptr<ListFpShotFilesRequest> request);
  ListFpShotImportJobResponse listFpShotImportJobWithOptions(shared_ptr<ListFpShotImportJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFpShotImportJobResponse listFpShotImportJob(shared_ptr<ListFpShotImportJobRequest> request);
  ListJobResponse listJobWithOptions(shared_ptr<ListJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobResponse listJob(shared_ptr<ListJobRequest> request);
  ListMediaWorkflowExecutionsResponse listMediaWorkflowExecutionsWithOptions(shared_ptr<ListMediaWorkflowExecutionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaWorkflowExecutionsResponse listMediaWorkflowExecutions(shared_ptr<ListMediaWorkflowExecutionsRequest> request);
  QueryAnalysisJobListResponse queryAnalysisJobListWithOptions(shared_ptr<QueryAnalysisJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAnalysisJobListResponse queryAnalysisJobList(shared_ptr<QueryAnalysisJobListRequest> request);
  QueryFpDBDeleteJobListResponse queryFpDBDeleteJobListWithOptions(shared_ptr<QueryFpDBDeleteJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFpDBDeleteJobListResponse queryFpDBDeleteJobList(shared_ptr<QueryFpDBDeleteJobListRequest> request);
  QueryFpFileDeleteJobListResponse queryFpFileDeleteJobListWithOptions(shared_ptr<QueryFpFileDeleteJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFpFileDeleteJobListResponse queryFpFileDeleteJobList(shared_ptr<QueryFpFileDeleteJobListRequest> request);
  QueryFpShotJobListResponse queryFpShotJobListWithOptions(shared_ptr<QueryFpShotJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFpShotJobListResponse queryFpShotJobList(shared_ptr<QueryFpShotJobListRequest> request);
  QueryIProductionJobResponse queryIProductionJobWithOptions(shared_ptr<QueryIProductionJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIProductionJobResponse queryIProductionJob(shared_ptr<QueryIProductionJobRequest> request);
  QueryJobListResponse queryJobListWithOptions(shared_ptr<QueryJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobListResponse queryJobList(shared_ptr<QueryJobListRequest> request);
  QueryMediaCensorJobDetailResponse queryMediaCensorJobDetailWithOptions(shared_ptr<QueryMediaCensorJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaCensorJobDetailResponse queryMediaCensorJobDetail(shared_ptr<QueryMediaCensorJobDetailRequest> request);
  QueryMediaCensorJobListResponse queryMediaCensorJobListWithOptions(shared_ptr<QueryMediaCensorJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaCensorJobListResponse queryMediaCensorJobList(shared_ptr<QueryMediaCensorJobListRequest> request);
  QueryMediaInfoJobListResponse queryMediaInfoJobListWithOptions(shared_ptr<QueryMediaInfoJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaInfoJobListResponse queryMediaInfoJobList(shared_ptr<QueryMediaInfoJobListRequest> request);
  QueryMediaListResponse queryMediaListWithOptions(shared_ptr<QueryMediaListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaListResponse queryMediaList(shared_ptr<QueryMediaListRequest> request);
  QueryMediaListByURLResponse queryMediaListByURLWithOptions(shared_ptr<QueryMediaListByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaListByURLResponse queryMediaListByURL(shared_ptr<QueryMediaListByURLRequest> request);
  QueryMediaWorkflowExecutionListResponse queryMediaWorkflowExecutionListWithOptions(shared_ptr<QueryMediaWorkflowExecutionListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaWorkflowExecutionListResponse queryMediaWorkflowExecutionList(shared_ptr<QueryMediaWorkflowExecutionListRequest> request);
  QueryMediaWorkflowListResponse queryMediaWorkflowListWithOptions(shared_ptr<QueryMediaWorkflowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaWorkflowListResponse queryMediaWorkflowList(shared_ptr<QueryMediaWorkflowListRequest> request);
  QueryPipelineListResponse queryPipelineListWithOptions(shared_ptr<QueryPipelineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPipelineListResponse queryPipelineList(shared_ptr<QueryPipelineListRequest> request);
  QuerySmarttagJobResponse querySmarttagJobWithOptions(shared_ptr<QuerySmarttagJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmarttagJobResponse querySmarttagJob(shared_ptr<QuerySmarttagJobRequest> request);
  QuerySmarttagTemplateListResponse querySmarttagTemplateListWithOptions(shared_ptr<QuerySmarttagTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmarttagTemplateListResponse querySmarttagTemplateList(shared_ptr<QuerySmarttagTemplateListRequest> request);
  QuerySnapshotJobListResponse querySnapshotJobListWithOptions(shared_ptr<QuerySnapshotJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySnapshotJobListResponse querySnapshotJobList(shared_ptr<QuerySnapshotJobListRequest> request);
  QueryTemplateListResponse queryTemplateListWithOptions(shared_ptr<QueryTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTemplateListResponse queryTemplateList(shared_ptr<QueryTemplateListRequest> request);
  QueryWaterMarkTemplateListResponse queryWaterMarkTemplateListWithOptions(shared_ptr<QueryWaterMarkTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryWaterMarkTemplateListResponse queryWaterMarkTemplateList(shared_ptr<QueryWaterMarkTemplateListRequest> request);
  RegisterCustomFaceResponse registerCustomFaceWithOptions(shared_ptr<RegisterCustomFaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterCustomFaceResponse registerCustomFace(shared_ptr<RegisterCustomFaceRequest> request);
  RegisterCustomViewResponse registerCustomViewWithOptions(shared_ptr<RegisterCustomViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterCustomViewResponse registerCustomView(shared_ptr<RegisterCustomViewRequest> request);
  SearchMediaWorkflowResponse searchMediaWorkflowWithOptions(shared_ptr<SearchMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaWorkflowResponse searchMediaWorkflow(shared_ptr<SearchMediaWorkflowRequest> request);
  SearchPipelineResponse searchPipelineWithOptions(shared_ptr<SearchPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchPipelineResponse searchPipeline(shared_ptr<SearchPipelineRequest> request);
  SearchTemplateResponse searchTemplateWithOptions(shared_ptr<SearchTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTemplateResponse searchTemplate(shared_ptr<SearchTemplateRequest> request);
  SearchWaterMarkTemplateResponse searchWaterMarkTemplateWithOptions(shared_ptr<SearchWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchWaterMarkTemplateResponse searchWaterMarkTemplate(shared_ptr<SearchWaterMarkTemplateRequest> request);
  SubmitAnalysisJobResponse submitAnalysisJobWithOptions(shared_ptr<SubmitAnalysisJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAnalysisJobResponse submitAnalysisJob(shared_ptr<SubmitAnalysisJobRequest> request);
  SubmitFpDBDeleteJobResponse submitFpDBDeleteJobWithOptions(shared_ptr<SubmitFpDBDeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFpDBDeleteJobResponse submitFpDBDeleteJob(shared_ptr<SubmitFpDBDeleteJobRequest> request);
  SubmitFpFileDeleteJobResponse submitFpFileDeleteJobWithOptions(shared_ptr<SubmitFpFileDeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFpFileDeleteJobResponse submitFpFileDeleteJob(shared_ptr<SubmitFpFileDeleteJobRequest> request);
  SubmitFpShotJobResponse submitFpShotJobWithOptions(shared_ptr<SubmitFpShotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFpShotJobResponse submitFpShotJob(shared_ptr<SubmitFpShotJobRequest> request);
  SubmitIProductionJobResponse submitIProductionJobWithOptions(shared_ptr<SubmitIProductionJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitIProductionJobResponse submitIProductionJob(shared_ptr<SubmitIProductionJobRequest> request);
  SubmitJobsResponse submitJobsWithOptions(shared_ptr<SubmitJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitJobsResponse submitJobs(shared_ptr<SubmitJobsRequest> request);
  SubmitMediaCensorJobResponse submitMediaCensorJobWithOptions(shared_ptr<SubmitMediaCensorJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaCensorJobResponse submitMediaCensorJob(shared_ptr<SubmitMediaCensorJobRequest> request);
  SubmitMediaInfoJobResponse submitMediaInfoJobWithOptions(shared_ptr<SubmitMediaInfoJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaInfoJobResponse submitMediaInfoJob(shared_ptr<SubmitMediaInfoJobRequest> request);
  SubmitSmarttagJobResponse submitSmarttagJobWithOptions(shared_ptr<SubmitSmarttagJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSmarttagJobResponse submitSmarttagJob(shared_ptr<SubmitSmarttagJobRequest> request);
  SubmitSnapshotJobResponse submitSnapshotJobWithOptions(shared_ptr<SubmitSnapshotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSnapshotJobResponse submitSnapshotJob(shared_ptr<SubmitSnapshotJobRequest> request);
  TagCustomPersonResponse tagCustomPersonWithOptions(shared_ptr<TagCustomPersonRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagCustomPersonResponse tagCustomPerson(shared_ptr<TagCustomPersonRequest> request);
  UnbindInputBucketResponse unbindInputBucketWithOptions(shared_ptr<UnbindInputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindInputBucketResponse unbindInputBucket(shared_ptr<UnbindInputBucketRequest> request);
  UnbindOutputBucketResponse unbindOutputBucketWithOptions(shared_ptr<UnbindOutputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindOutputBucketResponse unbindOutputBucket(shared_ptr<UnbindOutputBucketRequest> request);
  UnregisterCustomFaceResponse unregisterCustomFaceWithOptions(shared_ptr<UnregisterCustomFaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnregisterCustomFaceResponse unregisterCustomFace(shared_ptr<UnregisterCustomFaceRequest> request);
  UpdateMediaResponse updateMediaWithOptions(shared_ptr<UpdateMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaResponse updateMedia(shared_ptr<UpdateMediaRequest> request);
  UpdateMediaCategoryResponse updateMediaCategoryWithOptions(shared_ptr<UpdateMediaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaCategoryResponse updateMediaCategory(shared_ptr<UpdateMediaCategoryRequest> request);
  UpdateMediaCoverResponse updateMediaCoverWithOptions(shared_ptr<UpdateMediaCoverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaCoverResponse updateMediaCover(shared_ptr<UpdateMediaCoverRequest> request);
  UpdateMediaPublishStateResponse updateMediaPublishStateWithOptions(shared_ptr<UpdateMediaPublishStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaPublishStateResponse updateMediaPublishState(shared_ptr<UpdateMediaPublishStateRequest> request);
  UpdateMediaWorkflowResponse updateMediaWorkflowWithOptions(shared_ptr<UpdateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaWorkflowResponse updateMediaWorkflow(shared_ptr<UpdateMediaWorkflowRequest> request);
  UpdateMediaWorkflowTriggerModeResponse updateMediaWorkflowTriggerModeWithOptions(shared_ptr<UpdateMediaWorkflowTriggerModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaWorkflowTriggerModeResponse updateMediaWorkflowTriggerMode(shared_ptr<UpdateMediaWorkflowTriggerModeRequest> request);
  UpdatePipelineResponse updatePipelineWithOptions(shared_ptr<UpdatePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineResponse updatePipeline(shared_ptr<UpdatePipelineRequest> request);
  UpdateSmarttagTemplateResponse updateSmarttagTemplateWithOptions(shared_ptr<UpdateSmarttagTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSmarttagTemplateResponse updateSmarttagTemplate(shared_ptr<UpdateSmarttagTemplateRequest> request);
  UpdateTemplateResponse updateTemplateWithOptions(shared_ptr<UpdateTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTemplateResponse updateTemplate(shared_ptr<UpdateTemplateRequest> request);
  UpdateWaterMarkTemplateResponse updateWaterMarkTemplateWithOptions(shared_ptr<UpdateWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWaterMarkTemplateResponse updateWaterMarkTemplate(shared_ptr<UpdateWaterMarkTemplateRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Mts20140618

#endif
